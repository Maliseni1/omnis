"use strict";
const electron = require("electron");
const path$1 = require("node:path");
const fs$1 = require("node:fs/promises");
const Stream = require("stream");
const require$$2$3 = require("events");
const require$$0$3 = require("buffer");
const require$$1$3 = require("util");
const fs = require("fs");
const Url = require("url");
const require$$2$4 = require("os");
const path = require("path");
const require$$2$5 = require("string_decoder");
const crypto = require("crypto");
const http = require("http");
const punycode$2 = require("punycode");
const https = require("https");
const zlib = require("zlib");
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lib$h = {};
var underscoreNodeF = {};
var hasRequiredUnderscoreNodeF;
function requireUnderscoreNodeF() {
  if (hasRequiredUnderscoreNodeF) return underscoreNodeF;
  hasRequiredUnderscoreNodeF = 1;
  Object.defineProperty(underscoreNodeF, "__esModule", { value: true });
  var VERSION = "1.13.7";
  var root = typeof self == "object" && self.self === self && self || typeof commonjsGlobal$1 == "object" && commonjsGlobal$1.global === commonjsGlobal$1 && commonjsGlobal$1 || Function("return this")() || {};
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
  var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty2 = ObjProto.hasOwnProperty;
  var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
  var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
  var _isNaN2 = isNaN, _isFinite = isFinite;
  var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
  var nonEnumerableProps = [
    "valueOf",
    "isPrototypeOf",
    "toString",
    "propertyIsEnumerable",
    "hasOwnProperty",
    "toLocaleString"
  ];
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
      for (; index < length; index++) {
        rest2[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0:
          return func.call(this, rest2);
        case 1:
          return func.call(this, arguments[0], rest2);
        case 2:
          return func.call(this, arguments[0], arguments[1], rest2);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest2;
      return func.apply(this, args);
    };
  }
  function isObject(obj) {
    var type2 = typeof obj;
    return type2 === "function" || type2 === "object" && !!obj;
  }
  function isNull(obj) {
    return obj === null;
  }
  function isUndefined(obj) {
    return obj === void 0;
  }
  function isBoolean(obj) {
    return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
  }
  function isElement(obj) {
    return !!(obj && obj.nodeType === 1);
  }
  function tagTester(name) {
    var tag = "[object " + name + "]";
    return function(obj) {
      return toString.call(obj) === tag;
    };
  }
  var isString = tagTester("String");
  var isNumber = tagTester("Number");
  var isDate = tagTester("Date");
  var isRegExp = tagTester("RegExp");
  var isError = tagTester("Error");
  var isSymbol = tagTester("Symbol");
  var isArrayBuffer = tagTester("ArrayBuffer");
  var isFunction = tagTester("Function");
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
    isFunction = function(obj) {
      return typeof obj == "function" || false;
    };
  }
  var isFunction$1 = isFunction;
  var hasObjectTag = tagTester("Object");
  var hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag(new DataView(new ArrayBuffer(8)))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
  var isDataView = tagTester("DataView");
  function alternateIsDataView(obj) {
    return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
  }
  var isDataView$1 = hasDataViewBug ? alternateIsDataView : isDataView;
  var isArray = nativeIsArray || tagTester("Array");
  function has$1(obj, key) {
    return obj != null && hasOwnProperty2.call(obj, key);
  }
  var isArguments = tagTester("Arguments");
  (function() {
    if (!isArguments(arguments)) {
      isArguments = function(obj) {
        return has$1(obj, "callee");
      };
    }
  })();
  var isArguments$1 = isArguments;
  function isFinite$1(obj) {
    return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
  }
  function isNaN$1(obj) {
    return isNumber(obj) && _isNaN2(obj);
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  function createSizePropertyCheck(getSizeProperty) {
    return function(collection) {
      var sizeProperty = getSizeProperty(collection);
      return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
    };
  }
  function shallowProperty(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  }
  var getByteLength = shallowProperty("byteLength");
  var isBufferLike = createSizePropertyCheck(getByteLength);
  var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
  function isTypedArray(obj) {
    return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
  }
  var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
  var getLength = shallowProperty("length");
  function emulatedSet(keys2) {
    var hash = {};
    for (var l = keys2.length, i = 0; i < l; ++i) hash[keys2[i]] = true;
    return {
      contains: function(key) {
        return hash[key] === true;
      },
      push: function(key) {
        hash[key] = true;
        return keys2.push(key);
      }
    };
  }
  function collectNonEnumProps(obj, keys2) {
    keys2 = emulatedSet(keys2);
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;
    var prop2 = "constructor";
    if (has$1(obj, prop2) && !keys2.contains(prop2)) keys2.push(prop2);
    while (nonEnumIdx--) {
      prop2 = nonEnumerableProps[nonEnumIdx];
      if (prop2 in obj && obj[prop2] !== proto[prop2] && !keys2.contains(prop2)) {
        keys2.push(prop2);
      }
    }
  }
  function keys(obj) {
    if (!isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys2 = [];
    for (var key in obj) if (has$1(obj, key)) keys2.push(key);
    if (hasEnumBug) collectNonEnumProps(obj, keys2);
    return keys2;
  }
  function isEmpty(obj) {
    if (obj == null) return true;
    var length = getLength(obj);
    if (typeof length == "number" && (isArray(obj) || isString(obj) || isArguments$1(obj))) return length === 0;
    return getLength(keys(obj)) === 0;
  }
  function isMatch(object3, attrs) {
    var _keys = keys(attrs), length = _keys.length;
    if (object3 == null) return !length;
    var obj = Object(object3);
    for (var i = 0; i < length; i++) {
      var key = _keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  }
  function _$1(obj) {
    if (obj instanceof _$1) return obj;
    if (!(this instanceof _$1)) return new _$1(obj);
    this._wrapped = obj;
  }
  _$1.VERSION = VERSION;
  _$1.prototype.value = function() {
    return this._wrapped;
  };
  _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
  _$1.prototype.toString = function() {
    return String(this._wrapped);
  };
  function toBufferView(bufferSource) {
    return new Uint8Array(
      bufferSource.buffer || bufferSource,
      bufferSource.byteOffset || 0,
      getByteLength(bufferSource)
    );
  }
  var tagDataView = "[object DataView]";
  function eq(a, b, aStack, bStack) {
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    if (a == null || b == null) return false;
    if (a !== a) return b !== b;
    var type2 = typeof a;
    if (type2 !== "function" && type2 !== "object" && typeof b != "object") return false;
    return deepEq(a, b, aStack, bStack);
  }
  function deepEq(a, b, aStack, bStack) {
    if (a instanceof _$1) a = a._wrapped;
    if (b instanceof _$1) b = b._wrapped;
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    if (hasDataViewBug && className == "[object Object]" && isDataView$1(a)) {
      if (!isDataView$1(b)) return false;
      className = tagDataView;
    }
    switch (className) {
      // These types are compared by value.
      case "[object RegExp]":
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case "[object String]":
        return "" + a === "" + b;
      case "[object Number]":
        if (+a !== +a) return +b !== +b;
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case "[object Date]":
      case "[object Boolean]":
        return +a === +b;
      case "[object Symbol]":
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
      case "[object ArrayBuffer]":
      case tagDataView:
        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
    }
    var areArrays = className === "[object Array]";
    if (!areArrays && isTypedArray$1(a)) {
      var byteLength = getByteLength(a);
      if (byteLength !== getByteLength(b)) return false;
      if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
      areArrays = true;
    }
    if (!areArrays) {
      if (typeof a != "object" || typeof b != "object") return false;
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
        return false;
      }
    }
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      if (aStack[length] === a) return bStack[length] === b;
    }
    aStack.push(a);
    bStack.push(b);
    if (areArrays) {
      length = a.length;
      if (length !== b.length) return false;
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      var _keys = keys(a), key;
      length = _keys.length;
      if (keys(b).length !== length) return false;
      while (length--) {
        key = _keys[length];
        if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    aStack.pop();
    bStack.pop();
    return true;
  }
  function isEqual(a, b) {
    return eq(a, b);
  }
  function allKeys(obj) {
    if (!isObject(obj)) return [];
    var keys2 = [];
    for (var key in obj) keys2.push(key);
    if (hasEnumBug) collectNonEnumProps(obj, keys2);
    return keys2;
  }
  function ie11fingerprint(methods) {
    var length = getLength(methods);
    return function(obj) {
      if (obj == null) return false;
      var keys2 = allKeys(obj);
      if (getLength(keys2)) return false;
      for (var i = 0; i < length; i++) {
        if (!isFunction$1(obj[methods[i]])) return false;
      }
      return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
    };
  }
  var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
  var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
  var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  var isWeakSet = tagTester("WeakSet");
  function values(obj) {
    var _keys = keys(obj);
    var length = _keys.length;
    var values2 = Array(length);
    for (var i = 0; i < length; i++) {
      values2[i] = obj[_keys[i]];
    }
    return values2;
  }
  function pairs(obj) {
    var _keys = keys(obj);
    var length = _keys.length;
    var pairs2 = Array(length);
    for (var i = 0; i < length; i++) {
      pairs2[i] = [_keys[i], obj[_keys[i]]];
    }
    return pairs2;
  }
  function invert(obj) {
    var result2 = {};
    var _keys = keys(obj);
    for (var i = 0, length = _keys.length; i < length; i++) {
      result2[obj[_keys[i]]] = _keys[i];
    }
    return result2;
  }
  function functions(obj) {
    var names = [];
    for (var key in obj) {
      if (isFunction$1(obj[key])) names.push(key);
    }
    return names.sort();
  }
  function createAssigner(keysFunc, defaults3) {
    return function(obj) {
      var length = arguments.length;
      if (defaults3) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
        for (var i = 0; i < l; i++) {
          var key = keys2[i];
          if (!defaults3 || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  }
  var extend = createAssigner(allKeys);
  var extendOwn = createAssigner(keys);
  var defaults2 = createAssigner(allKeys, true);
  function ctor() {
    return function() {
    };
  }
  function baseCreate(prototype) {
    if (!isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    var Ctor = ctor();
    Ctor.prototype = prototype;
    var result2 = new Ctor();
    Ctor.prototype = null;
    return result2;
  }
  function create(prototype, props2) {
    var result2 = baseCreate(prototype);
    if (props2) extendOwn(result2, props2);
    return result2;
  }
  function clone2(obj) {
    if (!isObject(obj)) return obj;
    return isArray(obj) ? obj.slice() : extend({}, obj);
  }
  function tap(obj, interceptor) {
    interceptor(obj);
    return obj;
  }
  function toPath$1(path2) {
    return isArray(path2) ? path2 : [path2];
  }
  _$1.toPath = toPath$1;
  function toPath(path2) {
    return _$1.toPath(path2);
  }
  function deepGet(obj, path2) {
    var length = path2.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path2[i]];
    }
    return length ? obj : void 0;
  }
  function get2(object3, path2, defaultValue) {
    var value = deepGet(object3, toPath(path2));
    return isUndefined(value) ? defaultValue : value;
  }
  function has(obj, path2) {
    path2 = toPath(path2);
    var length = path2.length;
    for (var i = 0; i < length; i++) {
      var key = path2[i];
      if (!has$1(obj, key)) return false;
      obj = obj[key];
    }
    return !!length;
  }
  function identity(value) {
    return value;
  }
  function matcher(attrs) {
    attrs = extendOwn({}, attrs);
    return function(obj) {
      return isMatch(obj, attrs);
    };
  }
  function property(path2) {
    path2 = toPath(path2);
    return function(obj) {
      return deepGet(obj, path2);
    };
  }
  function optimizeCb(func, context2, argCount) {
    if (context2 === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1:
        return function(value) {
          return func.call(context2, value);
        };
      // The 2-argument case is omitted because weâ€™re not using it.
      case 3:
        return function(value, index, collection) {
          return func.call(context2, value, index, collection);
        };
      case 4:
        return function(accumulator, value, index, collection) {
          return func.call(context2, accumulator, value, index, collection);
        };
    }
    return function() {
      return func.apply(context2, arguments);
    };
  }
  function baseIteratee(value, context2, argCount) {
    if (value == null) return identity;
    if (isFunction$1(value)) return optimizeCb(value, context2, argCount);
    if (isObject(value) && !isArray(value)) return matcher(value);
    return property(value);
  }
  function iteratee(value, context2) {
    return baseIteratee(value, context2, Infinity);
  }
  _$1.iteratee = iteratee;
  function cb(value, context2, argCount) {
    if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context2);
    return baseIteratee(value, context2, argCount);
  }
  function mapObject(obj, iteratee2, context2) {
    iteratee2 = cb(iteratee2, context2);
    var _keys = keys(obj), length = _keys.length, results2 = {};
    for (var index = 0; index < length; index++) {
      var currentKey = _keys[index];
      results2[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
    }
    return results2;
  }
  function noop() {
  }
  function propertyOf(obj) {
    if (obj == null) return noop;
    return function(path2) {
      return get2(obj, path2);
    };
  }
  function times2(n, iteratee2, context2) {
    var accum = Array(Math.max(0, n));
    iteratee2 = optimizeCb(iteratee2, context2, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee2(i);
    return accum;
  }
  function random(min3, max3) {
    if (max3 == null) {
      max3 = min3;
      min3 = 0;
    }
    return min3 + Math.floor(Math.random() * (max3 - min3 + 1));
  }
  var now = Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
  function createEscaper(map3) {
    var escaper = function(match) {
      return map3[match];
    };
    var source = "(?:" + keys(map3).join("|") + ")";
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, "g");
    return function(string) {
      string = string == null ? "" : "" + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  }
  var escapeMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };
  var _escape = createEscaper(escapeMap);
  var unescapeMap = invert(escapeMap);
  var _unescape = createEscaper(unescapeMap);
  var templateSettings = _$1.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  var noMatch = /(.)^/;
  var escapes = {
    "'": "'",
    "\\": "\\",
    "\r": "r",
    "\n": "n",
    "\u2028": "u2028",
    "\u2029": "u2029"
  };
  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
  function escapeChar(match) {
    return "\\" + escapes[match];
  }
  var bareIdentifier = /^\s*(\w|\$)+\s*$/;
  function template(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = defaults2({}, settings, _$1.templateSettings);
    var matcher2 = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join("|") + "|$", "g");
    var index = 0;
    var source = "__p+='";
    text.replace(matcher2, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;
      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      return match;
    });
    source += "';\n";
    var argument = settings.variable;
    if (argument) {
      if (!bareIdentifier.test(argument)) throw new Error(
        "variable is not a bare identifier: " + argument
      );
    } else {
      source = "with(obj||{}){\n" + source + "}\n";
      argument = "obj";
    }
    source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
    var render;
    try {
      render = new Function(argument, "_", source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    var template2 = function(data) {
      return render.call(this, data, _$1);
    };
    template2.source = "function(" + argument + "){\n" + source + "}";
    return template2;
  }
  function result(obj, path2, fallback) {
    path2 = toPath(path2);
    var length = path2.length;
    if (!length) {
      return isFunction$1(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop2 = obj == null ? void 0 : obj[path2[i]];
      if (prop2 === void 0) {
        prop2 = fallback;
        i = length;
      }
      obj = isFunction$1(prop2) ? prop2.call(obj) : prop2;
    }
    return obj;
  }
  var idCounter = 0;
  function uniqueId(prefix) {
    var id = ++idCounter + "";
    return prefix ? prefix + id : id;
  }
  function chain(obj) {
    var instance = _$1(obj);
    instance._chain = true;
    return instance;
  }
  function executeBound(sourceFunc, boundFunc, context2, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context2, args);
    var self2 = baseCreate(sourceFunc.prototype);
    var result2 = sourceFunc.apply(self2, args);
    if (isObject(result2)) return result2;
    return self2;
  }
  var partial = restArguments(function(func, boundArgs) {
    var placeholder = partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });
  partial.placeholder = _$1;
  var bind2 = restArguments(function(func, context2, args) {
    if (!isFunction$1(func)) throw new TypeError("Bind must be called on a function");
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context2, this, args.concat(callArgs));
    });
    return bound;
  });
  var isArrayLike = createSizePropertyCheck(getLength);
  function flatten$1(input, depth, strict2, output) {
    output = output || [];
    if (!depth && depth !== 0) {
      depth = Infinity;
    } else if (depth <= 0) {
      return output.concat(input);
    }
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
        if (depth > 1) {
          flatten$1(value, depth - 1, strict2, output);
          idx = output.length;
        } else {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        }
      } else if (!strict2) {
        output[idx++] = value;
      }
    }
    return output;
  }
  var bindAll = restArguments(function(obj, keys2) {
    keys2 = flatten$1(keys2, false, false);
    var index = keys2.length;
    if (index < 1) throw new Error("bindAll must be passed function names");
    while (index--) {
      var key = keys2[index];
      obj[key] = bind2(obj[key], obj);
    }
    return obj;
  });
  function memoize(func, hasher) {
    var memoize2 = function(key) {
      var cache = memoize2.cache;
      var address = "" + (hasher ? hasher.apply(this, arguments) : key);
      if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize2.cache = {};
    return memoize2;
  }
  var delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });
  var defer = partial(delay, _$1, 1);
  function throttle(func, wait, options) {
    var timeout, context2, args, result2;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : now();
      timeout = null;
      result2 = func.apply(context2, args);
      if (!timeout) context2 = args = null;
    };
    var throttled = function() {
      var _now = now();
      if (!previous && options.leading === false) previous = _now;
      var remaining = wait - (_now - previous);
      context2 = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = _now;
        result2 = func.apply(context2, args);
        if (!timeout) context2 = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result2;
    };
    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context2 = args = null;
    };
    return throttled;
  }
  function debounce(func, wait, immediate) {
    var timeout, previous, args, result2, context2;
    var later = function() {
      var passed = now() - previous;
      if (wait > passed) {
        timeout = setTimeout(later, wait - passed);
      } else {
        timeout = null;
        if (!immediate) result2 = func.apply(context2, args);
        if (!timeout) args = context2 = null;
      }
    };
    var debounced = restArguments(function(_args) {
      context2 = this;
      args = _args;
      previous = now();
      if (!timeout) {
        timeout = setTimeout(later, wait);
        if (immediate) result2 = func.apply(context2, args);
      }
      return result2;
    });
    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = args = context2 = null;
    };
    return debounced;
  }
  function wrap(func, wrapper) {
    return partial(wrapper, func);
  }
  function negate(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  }
  function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result2 = args[start].apply(this, arguments);
      while (i--) result2 = args[i].call(this, result2);
      return result2;
    };
  }
  function after(times3, func) {
    return function() {
      if (--times3 < 1) {
        return func.apply(this, arguments);
      }
    };
  }
  function before(times3, func) {
    var memo;
    return function() {
      if (--times3 > 0) {
        memo = func.apply(this, arguments);
      }
      if (times3 <= 1) func = null;
      return memo;
    };
  }
  var once = partial(before, 2);
  function findKey(obj, predicate, context2) {
    predicate = cb(predicate, context2);
    var _keys = keys(obj), key;
    for (var i = 0, length = _keys.length; i < length; i++) {
      key = _keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  }
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context2) {
      predicate = cb(predicate, context2);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }
  var findIndex = createPredicateIndexFinder(1);
  var findLastIndex = createPredicateIndexFinder(-1);
  function sortedIndex(array, obj, iteratee2, context2) {
    iteratee2 = cb(iteratee2, context2, 1);
    var value = iteratee2(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid2 = Math.floor((low + high) / 2);
      if (iteratee2(array[mid2]) < value) low = mid2 + 1;
      else high = mid2;
    }
    return low;
  }
  function createIndexFinder(dir, predicateFind, sortedIndex2) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == "number") {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex2 && idx && length) {
        idx = sortedIndex2(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), isNaN$1);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }
  var indexOf = createIndexFinder(1, findIndex, sortedIndex);
  var lastIndexOf = createIndexFinder(-1, findLastIndex);
  function find2(obj, predicate, context2) {
    var keyFinder = isArrayLike(obj) ? findIndex : findKey;
    var key = keyFinder(obj, predicate, context2);
    if (key !== void 0 && key !== -1) return obj[key];
  }
  function findWhere(obj, attrs) {
    return find2(obj, matcher(attrs));
  }
  function each2(obj, iteratee2, context2) {
    iteratee2 = optimizeCb(iteratee2, context2);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee2(obj[i], i, obj);
      }
    } else {
      var _keys = keys(obj);
      for (i = 0, length = _keys.length; i < length; i++) {
        iteratee2(obj[_keys[i]], _keys[i], obj);
      }
    }
    return obj;
  }
  function map2(obj, iteratee2, context2) {
    iteratee2 = cb(iteratee2, context2);
    var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, results2 = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      results2[index] = iteratee2(obj[currentKey], currentKey, obj);
    }
    return results2;
  }
  function createReduce(dir) {
    var reducer = function(obj, iteratee2, memo, initial2) {
      var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
      if (!initial2) {
        memo = obj[_keys ? _keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = _keys ? _keys[index] : index;
        memo = iteratee2(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };
    return function(obj, iteratee2, memo, context2) {
      var initial2 = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee2, context2, 4), memo, initial2);
    };
  }
  var reduce2 = createReduce(1);
  var reduceRight = createReduce(-1);
  function filter2(obj, predicate, context2) {
    var results2 = [];
    predicate = cb(predicate, context2);
    each2(obj, function(value, index, list) {
      if (predicate(value, index, list)) results2.push(value);
    });
    return results2;
  }
  function reject(obj, predicate, context2) {
    return filter2(obj, negate(cb(predicate)), context2);
  }
  function every(obj, predicate, context2) {
    predicate = cb(predicate, context2);
    var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  }
  function some2(obj, predicate, context2) {
    predicate = cb(predicate, context2);
    var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  }
  function contains(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = values(obj);
    if (typeof fromIndex != "number" || guard) fromIndex = 0;
    return indexOf(obj, item, fromIndex) >= 0;
  }
  var invoke = restArguments(function(obj, path2, args) {
    var contextPath, func;
    if (isFunction$1(path2)) {
      func = path2;
    } else {
      path2 = toPath(path2);
      contextPath = path2.slice(0, -1);
      path2 = path2[path2.length - 1];
    }
    return map2(obj, function(context2) {
      var method2 = func;
      if (!method2) {
        if (contextPath && contextPath.length) {
          context2 = deepGet(context2, contextPath);
        }
        if (context2 == null) return void 0;
        method2 = context2[path2];
      }
      return method2 == null ? method2 : method2.apply(context2, args);
    });
  });
  function pluck(obj, key) {
    return map2(obj, property(key));
  }
  function where(obj, attrs) {
    return filter2(obj, matcher(attrs));
  }
  function max2(obj, iteratee2, context2) {
    var result2 = -Infinity, lastComputed = -Infinity, value, computed;
    if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
      obj = isArrayLike(obj) ? obj : values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result2) {
          result2 = value;
        }
      }
    } else {
      iteratee2 = cb(iteratee2, context2);
      each2(obj, function(v, index, list) {
        computed = iteratee2(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
          result2 = v;
          lastComputed = computed;
        }
      });
    }
    return result2;
  }
  function min2(obj, iteratee2, context2) {
    var result2 = Infinity, lastComputed = Infinity, value, computed;
    if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
      obj = isArrayLike(obj) ? obj : values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result2) {
          result2 = value;
        }
      }
    } else {
      iteratee2 = cb(iteratee2, context2);
      each2(obj, function(v, index, list) {
        computed = iteratee2(v, index, list);
        if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
          result2 = v;
          lastComputed = computed;
        }
      });
    }
    return result2;
  }
  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  function toArray(obj) {
    if (!obj) return [];
    if (isArray(obj)) return slice.call(obj);
    if (isString(obj)) {
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return map2(obj, identity);
    return values(obj);
  }
  function sample(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = values(obj);
      return obj[random(obj.length - 1)];
    }
    var sample2 = toArray(obj);
    var length = getLength(sample2);
    n = Math.max(Math.min(n, length), 0);
    var last2 = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = random(index, last2);
      var temp = sample2[index];
      sample2[index] = sample2[rand];
      sample2[rand] = temp;
    }
    return sample2.slice(0, n);
  }
  function shuffle(obj) {
    return sample(obj, Infinity);
  }
  function sortBy(obj, iteratee2, context2) {
    var index = 0;
    iteratee2 = cb(iteratee2, context2);
    return pluck(map2(obj, function(value, key, list) {
      return {
        value,
        index: index++,
        criteria: iteratee2(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), "value");
  }
  function group(behavior, partition2) {
    return function(obj, iteratee2, context2) {
      var result2 = partition2 ? [[], []] : {};
      iteratee2 = cb(iteratee2, context2);
      each2(obj, function(value, index) {
        var key = iteratee2(value, index, obj);
        behavior(result2, value, key);
      });
      return result2;
    };
  }
  var groupBy = group(function(result2, value, key) {
    if (has$1(result2, key)) result2[key].push(value);
    else result2[key] = [value];
  });
  var indexBy = group(function(result2, value, key) {
    result2[key] = value;
  });
  var countBy = group(function(result2, value, key) {
    if (has$1(result2, key)) result2[key]++;
    else result2[key] = 1;
  });
  var partition = group(function(result2, value, pass) {
    result2[pass ? 0 : 1].push(value);
  }, true);
  function size(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : keys(obj).length;
  }
  function keyInObj(value, key, obj) {
    return key in obj;
  }
  var pick = restArguments(function(obj, keys2) {
    var result2 = {}, iteratee2 = keys2[0];
    if (obj == null) return result2;
    if (isFunction$1(iteratee2)) {
      if (keys2.length > 1) iteratee2 = optimizeCb(iteratee2, keys2[1]);
      keys2 = allKeys(obj);
    } else {
      iteratee2 = keyInObj;
      keys2 = flatten$1(keys2, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys2.length; i < length; i++) {
      var key = keys2[i];
      var value = obj[key];
      if (iteratee2(value, key, obj)) result2[key] = value;
    }
    return result2;
  });
  var omit = restArguments(function(obj, keys2) {
    var iteratee2 = keys2[0], context2;
    if (isFunction$1(iteratee2)) {
      iteratee2 = negate(iteratee2);
      if (keys2.length > 1) context2 = keys2[1];
    } else {
      keys2 = map2(flatten$1(keys2, false, false), String);
      iteratee2 = function(value, key) {
        return !contains(keys2, key);
      };
    }
    return pick(obj, iteratee2, context2);
  });
  function initial(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  }
  function first(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[0];
    return initial(array, array.length - n);
  }
  function rest(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  }
  function last(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return rest(array, Math.max(0, array.length - n));
  }
  function compact(array) {
    return filter2(array, Boolean);
  }
  function flatten(array, depth) {
    return flatten$1(array, depth, false);
  }
  var difference = restArguments(function(array, rest2) {
    rest2 = flatten$1(rest2, true, true);
    return filter2(array, function(value) {
      return !contains(rest2, value);
    });
  });
  var without = restArguments(function(array, otherArrays) {
    return difference(array, otherArrays);
  });
  function uniq(array, isSorted, iteratee2, context2) {
    if (!isBoolean(isSorted)) {
      context2 = iteratee2;
      iteratee2 = isSorted;
      isSorted = false;
    }
    if (iteratee2 != null) iteratee2 = cb(iteratee2, context2);
    var result2 = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
      if (isSorted && !iteratee2) {
        if (!i || seen !== computed) result2.push(value);
        seen = computed;
      } else if (iteratee2) {
        if (!contains(seen, computed)) {
          seen.push(computed);
          result2.push(value);
        }
      } else if (!contains(result2, value)) {
        result2.push(value);
      }
    }
    return result2;
  }
  var union = restArguments(function(arrays) {
    return uniq(flatten$1(arrays, true, true));
  });
  function intersection(array) {
    var result2 = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (contains(result2, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!contains(arguments[j], item)) break;
      }
      if (j === argsLength) result2.push(item);
    }
    return result2;
  }
  function unzip2(array) {
    var length = array && max2(array, getLength).length || 0;
    var result2 = Array(length);
    for (var index = 0; index < length; index++) {
      result2[index] = pluck(array, index);
    }
    return result2;
  }
  var zip = restArguments(unzip2);
  function object2(list, values2) {
    var result2 = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values2) {
        result2[list[i]] = values2[i];
      } else {
        result2[list[i][0]] = list[i][1];
      }
    }
    return result2;
  }
  function range2(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range3 = Array(length);
    for (var idx = 0; idx < length; idx++, start += step) {
      range3[idx] = start;
    }
    return range3;
  }
  function chunk(array, count) {
    if (count == null || count < 1) return [];
    var result2 = [];
    var i = 0, length = array.length;
    while (i < length) {
      result2.push(slice.call(array, i, i += count));
    }
    return result2;
  }
  function chainResult(instance, obj) {
    return instance._chain ? _$1(obj).chain() : obj;
  }
  function mixin(obj) {
    each2(functions(obj), function(name) {
      var func = _$1[name] = obj[name];
      _$1.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_$1, args));
      };
    });
    return _$1;
  }
  each2(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
    var method2 = ArrayProto[name];
    _$1.prototype[name] = function() {
      var obj = this._wrapped;
      if (obj != null) {
        method2.apply(obj, arguments);
        if ((name === "shift" || name === "splice") && obj.length === 0) {
          delete obj[0];
        }
      }
      return chainResult(this, obj);
    };
  });
  each2(["concat", "join", "slice"], function(name) {
    var method2 = ArrayProto[name];
    _$1.prototype[name] = function() {
      var obj = this._wrapped;
      if (obj != null) obj = method2.apply(obj, arguments);
      return chainResult(this, obj);
    };
  });
  var allExports = {
    __proto__: null,
    VERSION,
    restArguments,
    isObject,
    isNull,
    isUndefined,
    isBoolean,
    isElement,
    isString,
    isNumber,
    isDate,
    isRegExp,
    isError,
    isSymbol,
    isArrayBuffer,
    isDataView: isDataView$1,
    isArray,
    isFunction: isFunction$1,
    isArguments: isArguments$1,
    isFinite: isFinite$1,
    isNaN: isNaN$1,
    isTypedArray: isTypedArray$1,
    isEmpty,
    isMatch,
    isEqual,
    isMap,
    isWeakMap,
    isSet,
    isWeakSet,
    keys,
    allKeys,
    values,
    pairs,
    invert,
    functions,
    methods: functions,
    extend,
    extendOwn,
    assign: extendOwn,
    defaults: defaults2,
    create,
    clone: clone2,
    tap,
    get: get2,
    has,
    mapObject,
    identity,
    constant,
    noop,
    toPath: toPath$1,
    property,
    propertyOf,
    matcher,
    matches: matcher,
    times: times2,
    random,
    now,
    escape: _escape,
    unescape: _unescape,
    templateSettings,
    template,
    result,
    uniqueId,
    chain,
    iteratee,
    partial,
    bind: bind2,
    bindAll,
    memoize,
    delay,
    defer,
    throttle,
    debounce,
    wrap,
    negate,
    compose,
    after,
    before,
    once,
    findKey,
    findIndex,
    findLastIndex,
    sortedIndex,
    indexOf,
    lastIndexOf,
    find: find2,
    detect: find2,
    findWhere,
    each: each2,
    forEach: each2,
    map: map2,
    collect: map2,
    reduce: reduce2,
    foldl: reduce2,
    inject: reduce2,
    reduceRight,
    foldr: reduceRight,
    filter: filter2,
    select: filter2,
    reject,
    every,
    all: every,
    some: some2,
    any: some2,
    contains,
    includes: contains,
    include: contains,
    invoke,
    pluck,
    where,
    max: max2,
    min: min2,
    shuffle,
    sample,
    sortBy,
    groupBy,
    indexBy,
    countBy,
    partition,
    toArray,
    size,
    pick,
    omit,
    first,
    head: first,
    take: first,
    initial,
    last,
    rest,
    tail: rest,
    drop: rest,
    compact,
    flatten,
    without,
    uniq,
    unique: uniq,
    union,
    intersection,
    difference,
    unzip: unzip2,
    transpose: unzip2,
    zip,
    object: object2,
    range: range2,
    chunk,
    mixin,
    "default": _$1
  };
  var _ = mixin(allExports);
  _._ = _;
  underscoreNodeF.VERSION = VERSION;
  underscoreNodeF._ = _;
  underscoreNodeF._escape = _escape;
  underscoreNodeF._unescape = _unescape;
  underscoreNodeF.after = after;
  underscoreNodeF.allKeys = allKeys;
  underscoreNodeF.before = before;
  underscoreNodeF.bind = bind2;
  underscoreNodeF.bindAll = bindAll;
  underscoreNodeF.chain = chain;
  underscoreNodeF.chunk = chunk;
  underscoreNodeF.clone = clone2;
  underscoreNodeF.compact = compact;
  underscoreNodeF.compose = compose;
  underscoreNodeF.constant = constant;
  underscoreNodeF.contains = contains;
  underscoreNodeF.countBy = countBy;
  underscoreNodeF.create = create;
  underscoreNodeF.debounce = debounce;
  underscoreNodeF.defaults = defaults2;
  underscoreNodeF.defer = defer;
  underscoreNodeF.delay = delay;
  underscoreNodeF.difference = difference;
  underscoreNodeF.each = each2;
  underscoreNodeF.every = every;
  underscoreNodeF.extend = extend;
  underscoreNodeF.extendOwn = extendOwn;
  underscoreNodeF.filter = filter2;
  underscoreNodeF.find = find2;
  underscoreNodeF.findIndex = findIndex;
  underscoreNodeF.findKey = findKey;
  underscoreNodeF.findLastIndex = findLastIndex;
  underscoreNodeF.findWhere = findWhere;
  underscoreNodeF.first = first;
  underscoreNodeF.flatten = flatten;
  underscoreNodeF.functions = functions;
  underscoreNodeF.get = get2;
  underscoreNodeF.groupBy = groupBy;
  underscoreNodeF.has = has;
  underscoreNodeF.identity = identity;
  underscoreNodeF.indexBy = indexBy;
  underscoreNodeF.indexOf = indexOf;
  underscoreNodeF.initial = initial;
  underscoreNodeF.intersection = intersection;
  underscoreNodeF.invert = invert;
  underscoreNodeF.invoke = invoke;
  underscoreNodeF.isArguments = isArguments$1;
  underscoreNodeF.isArray = isArray;
  underscoreNodeF.isArrayBuffer = isArrayBuffer;
  underscoreNodeF.isBoolean = isBoolean;
  underscoreNodeF.isDataView = isDataView$1;
  underscoreNodeF.isDate = isDate;
  underscoreNodeF.isElement = isElement;
  underscoreNodeF.isEmpty = isEmpty;
  underscoreNodeF.isEqual = isEqual;
  underscoreNodeF.isError = isError;
  underscoreNodeF.isFinite = isFinite$1;
  underscoreNodeF.isFunction = isFunction$1;
  underscoreNodeF.isMap = isMap;
  underscoreNodeF.isMatch = isMatch;
  underscoreNodeF.isNaN = isNaN$1;
  underscoreNodeF.isNull = isNull;
  underscoreNodeF.isNumber = isNumber;
  underscoreNodeF.isObject = isObject;
  underscoreNodeF.isRegExp = isRegExp;
  underscoreNodeF.isSet = isSet;
  underscoreNodeF.isString = isString;
  underscoreNodeF.isSymbol = isSymbol;
  underscoreNodeF.isTypedArray = isTypedArray$1;
  underscoreNodeF.isUndefined = isUndefined;
  underscoreNodeF.isWeakMap = isWeakMap;
  underscoreNodeF.isWeakSet = isWeakSet;
  underscoreNodeF.iteratee = iteratee;
  underscoreNodeF.keys = keys;
  underscoreNodeF.last = last;
  underscoreNodeF.lastIndexOf = lastIndexOf;
  underscoreNodeF.map = map2;
  underscoreNodeF.mapObject = mapObject;
  underscoreNodeF.matcher = matcher;
  underscoreNodeF.max = max2;
  underscoreNodeF.memoize = memoize;
  underscoreNodeF.min = min2;
  underscoreNodeF.mixin = mixin;
  underscoreNodeF.negate = negate;
  underscoreNodeF.noop = noop;
  underscoreNodeF.now = now;
  underscoreNodeF.object = object2;
  underscoreNodeF.omit = omit;
  underscoreNodeF.once = once;
  underscoreNodeF.pairs = pairs;
  underscoreNodeF.partial = partial;
  underscoreNodeF.partition = partition;
  underscoreNodeF.pick = pick;
  underscoreNodeF.pluck = pluck;
  underscoreNodeF.property = property;
  underscoreNodeF.propertyOf = propertyOf;
  underscoreNodeF.random = random;
  underscoreNodeF.range = range2;
  underscoreNodeF.reduce = reduce2;
  underscoreNodeF.reduceRight = reduceRight;
  underscoreNodeF.reject = reject;
  underscoreNodeF.rest = rest;
  underscoreNodeF.restArguments = restArguments;
  underscoreNodeF.result = result;
  underscoreNodeF.sample = sample;
  underscoreNodeF.shuffle = shuffle;
  underscoreNodeF.size = size;
  underscoreNodeF.some = some2;
  underscoreNodeF.sortBy = sortBy;
  underscoreNodeF.sortedIndex = sortedIndex;
  underscoreNodeF.tap = tap;
  underscoreNodeF.template = template;
  underscoreNodeF.templateSettings = templateSettings;
  underscoreNodeF.throttle = throttle;
  underscoreNodeF.times = times2;
  underscoreNodeF.toArray = toArray;
  underscoreNodeF.toPath = toPath$1;
  underscoreNodeF.union = union;
  underscoreNodeF.uniq = uniq;
  underscoreNodeF.uniqueId = uniqueId;
  underscoreNodeF.unzip = unzip2;
  underscoreNodeF.values = values;
  underscoreNodeF.where = where;
  underscoreNodeF.without = without;
  underscoreNodeF.wrap = wrap;
  underscoreNodeF.zip = zip;
  return underscoreNodeF;
}
var underscoreNode;
var hasRequiredUnderscoreNode;
function requireUnderscoreNode() {
  if (hasRequiredUnderscoreNode) return underscoreNode;
  hasRequiredUnderscoreNode = 1;
  var underscoreNodeF2 = requireUnderscoreNodeF();
  underscoreNode = underscoreNodeF2._;
  return underscoreNode;
}
var docxReader = {};
var promises = {};
var promise = { exports: {} };
var es5 = { exports: {} };
var hasRequiredEs5;
function requireEs5() {
  if (hasRequiredEs5) return es5.exports;
  hasRequiredEs5 = 1;
  var isES5 = /* @__PURE__ */ (function() {
    return this === void 0;
  })();
  if (isES5) {
    es5.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj, prop2) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop2);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;
    var ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    var ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    var ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    var ObjectFreeze = function(obj) {
      return obj;
    };
    var ObjectGetPrototypeOf = function(obj) {
      try {
        return Object(obj).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    var ArrayIsArray = function(obj) {
      try {
        return str.call(obj) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    es5.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  return es5.exports;
}
var util$3;
var hasRequiredUtil$3;
function requireUtil$3() {
  if (hasRequiredUtil$3) return util$3;
  hasRequiredUtil$3 = 1;
  var es52 = requireEs5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : util$3 !== void 0 ? util$3 : null;
  function tryCatcher() {
    try {
      var target2 = tryCatchTarget;
      tryCatchTarget = null;
      return target2.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits2 = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target2, appendee) {
    var len = target2.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
      ret2[i] = target2[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key, defaultValue) {
    if (es52.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2)) return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es52.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = (function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0; i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es52.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = /* @__PURE__ */ Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys;
          try {
            keys = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key]) continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj2 = es52.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2)) return [];
        var ret2 = [];
        enumeration: for (var key in obj2) {
          if (hasProp.call(obj2, key)) {
            ret2.push(key);
          } else {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (hasProp.call(excludedPrototypes[i], key)) {
                continue enumeration;
              }
            }
            ret2.push(key);
          }
        }
        return ret2;
      };
    }
  })();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es52.names(fn.prototype);
        var hasMethods = es52.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es52.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    return obj;
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str) {
    return rident.test(str);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0; i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError(obj2) {
    return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {
    }
  }
  function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return isError(obj2) && es52.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
      return function(value) {
        if (canAttachTrace(value)) return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value)) return value;
        return new Error(safeToString(value));
      };
    }
  })();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from, to, filter2) {
    var keys = es52.names(from);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (filter2(key)) {
        try {
          es52.defineProperty(to, key, es52.getDescriptor(from, key));
        } catch (ignore) {
        }
      }
    }
  }
  var asArray = function(v) {
    if (es52.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it2 = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it2.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es52.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  function env(key) {
    return hasEnvVariables ? process.env[key] : void 0;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise2 = new Promise(function() {
        });
        if ({}.toString.call(promise2) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {
      }
    }
  }
  function domainBind(self2, cb) {
    return self2.bind(cb);
  }
  var ret = {
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es52.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits: inherits2,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    domainBind
  };
  ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
  })();
  if (ret.isNode) ret.toFastProperties(process);
  try {
    throw new Error();
  } catch (e) {
    ret.lastLineError = e;
  }
  util$3 = ret;
  return util$3;
}
var async = { exports: {} };
var schedule_1;
var hasRequiredSchedule;
function requireSchedule() {
  if (hasRequiredSchedule) return schedule_1;
  hasRequiredSchedule = 1;
  var util2 = requireUtil$3();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
  };
  var NativePromise = util2.getNativePromise();
  if (util2.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = commonjsGlobal$1.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util2.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(commonjsGlobal$1, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
      var div2 = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div22 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div2.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div22, opts);
      var scheduleToggle = function() {
        if (toggleScheduled) return;
        toggleScheduled = true;
        div22.classList.toggle("foo");
      };
      return function schedule2(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div2, opts);
        scheduleToggle();
      };
    })();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  schedule_1 = schedule;
  return schedule_1;
}
var queue$1;
var hasRequiredQueue$2;
function requireQueue$2() {
  if (hasRequiredQueue$2) return queue$1;
  hasRequiredQueue$2 = 1;
  function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
      dst[j + dstIndex] = src[j + srcIndex];
      src[j + srcIndex] = void 0;
    }
  }
  function Queue2(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue2.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue2.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue2.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue2.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = void 0;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue2.prototype.length = function() {
    return this._length;
  };
  Queue2.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue2.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  queue$1 = Queue2;
  return queue$1;
}
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async.exports;
  hasRequiredAsync = 1;
  var firstLineError;
  try {
    throw new Error();
  } catch (e) {
    firstLineError = e;
  }
  var schedule = requireSchedule();
  var Queue2 = requireQueue$2();
  var util2 = requireUtil$3();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue2(16);
    this._normalQueue = new Queue2(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
  };
  Async.prototype.disableTrampolineIfNecessary = function() {
    if (util2.hasDevTools) {
      this._trampolineEnabled = false;
    }
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else try {
      this._schedule(function() {
        fn(arg);
      });
    } catch (e) {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise2) {
    this._normalQueue._pushOne(promise2);
    this._queueTick();
  }
  if (!util2.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
  } else {
    Async.prototype.invokeLater = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvokeLater.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          setTimeout(function() {
            fn.call(receiver, arg);
          }, 100);
        });
      }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvoke.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          fn.call(receiver, arg);
        });
      }
    };
    Async.prototype.settlePromises = function(promise2) {
      if (this._trampolineEnabled) {
        AsyncSettlePromises.call(this, promise2);
      } else {
        this._schedule(function() {
          promise2._settlePromises();
        });
      }
    };
  }
  Async.prototype._drainQueue = function(queue2) {
    while (queue2.length() > 0) {
      var fn = queue2.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
        continue;
      }
      var receiver = queue2.shift();
      var arg = queue2.shift();
      fn.call(receiver, arg);
    }
  };
  Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  async.exports = Async;
  async.exports.firstLineError = firstLineError;
  return async.exports;
}
var errors$2;
var hasRequiredErrors$2;
function requireErrors$2() {
  if (hasRequiredErrors$2) return errors$2;
  hasRequiredErrors$2 = 1;
  var es52 = requireEs5();
  var Objectfreeze = es52.freeze;
  var util2 = requireUtil$3();
  var inherits2 = util2.inherits;
  var notEnumerableProp = util2.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError)) return new SubError(message);
      notEnumerableProp(
        this,
        "message",
        typeof message === "string" ? message : defaultMessage
      );
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits2(SubError, Error);
    return SubError;
  }
  var _TypeError, _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError2 = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
  for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError2.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  es52.defineProperty(AggregateError2.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError2.prototype["isOperational"] = true;
  var level = 0;
  AggregateError2.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0; i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split("\n");
      for (var j = 0; j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join("\n");
      ret += str + "\n";
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits2(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError: AggregateError2
    });
    es52.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  errors$2 = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
  return errors$2;
}
var thenables;
var hasRequiredThenables;
function requireThenables() {
  if (hasRequiredThenables) return thenables;
  hasRequiredThenables = 1;
  thenables = function(Promise2, INTERNAL2) {
    var util2 = requireUtil$3();
    var errorObj = util2.errorObj;
    var isObject = util2.isObject;
    function tryConvertToPromise(obj, context2) {
      if (isObject(obj)) {
        if (obj instanceof Promise2) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
          if (context2) context2._pushContext();
          var ret = Promise2.reject(then.e);
          if (context2) context2._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise2(INTERNAL2);
            obj._then(
              ret._fulfill,
              ret._reject,
              void 0,
              ret,
              null
            );
            return ret;
          }
          return doThenable(obj, then, context2);
        }
      }
      return obj;
    }
    function doGetThen(obj) {
      return obj.then;
    }
    function getThen(obj) {
      try {
        return doGetThen(obj);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
      try {
        return hasProp.call(obj, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context2) {
      var promise2 = new Promise2(INTERNAL2);
      var ret = promise2;
      if (context2) context2._pushContext();
      promise2._captureStackTrace();
      if (context2) context2._popContext();
      var synchronous = true;
      var result = util2.tryCatch(then).call(x, resolve, reject);
      synchronous = false;
      if (promise2 && result === errorObj) {
        promise2._rejectCallback(result.e, true, true);
        promise2 = null;
      }
      function resolve(value) {
        if (!promise2) return;
        promise2._resolveCallback(value);
        promise2 = null;
      }
      function reject(reason) {
        if (!promise2) return;
        promise2._rejectCallback(reason, synchronous, true);
        promise2 = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
  return thenables;
}
var promise_array;
var hasRequiredPromise_array;
function requirePromise_array() {
  if (hasRequiredPromise_array) return promise_array;
  hasRequiredPromise_array = 1;
  promise_array = function(Promise2, INTERNAL2, tryConvertToPromise, apiRejection, Proxyable) {
    var util2 = requireUtil$3();
    util2.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function PromiseArray(values) {
      var promise2 = this._promise = new Promise2(INTERNAL2);
      if (values instanceof Promise2) {
        promise2._propagateFrom(values, 3);
      }
      promise2._setOnCancel(this);
      this._values = values;
      this._length = 0;
      this._totalResolved = 0;
      this._init(void 0, -2);
    }
    util2.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
      var values = tryConvertToPromise(this._values, this._promise);
      if (values instanceof Promise2) {
        values = values._target();
        var bitField = values._bitField;
        this._values = values;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values._then(
            init,
            this._reject,
            void 0,
            this,
            resolveValueIfEmpty
          );
        } else if ((bitField & 33554432) !== 0) {
          values = values._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values._reason());
        } else {
          return this._cancel();
        }
      }
      values = util2.asArray(values);
      if (values === null) {
        var err = apiRejection(
          "expecting an array or an iterable object but got " + util2.classString(values)
        ).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values);
    };
    PromiseArray.prototype._iterate = function(values) {
      var len = this.getActualLength(values.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved) result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable()) return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved()) return;
      var values = this._values;
      this._cancel();
      if (values instanceof Promise2) {
        values.cancel();
      } else {
        for (var i = 0; i < values.length; ++i) {
          if (values[i] instanceof Promise2) {
            values[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
  return promise_array;
}
var context;
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  context = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {
    };
    Promise2.prototype._pushContext = function() {
    };
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {
    };
    function Context() {
      this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (this._trace !== void 0) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces) return new Context();
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return void 0;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function() {
    };
    Context.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context.prototype._pushContext;
      Promise2.prototype._popContext = Context.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
      };
    };
    return Context;
  };
  return context;
}
var debuggability;
var hasRequiredDebuggability;
function requireDebuggability() {
  if (hasRequiredDebuggability) return debuggability;
  hasRequiredDebuggability = 1;
  debuggability = function(Promise2, Context) {
    var getDomain = Promise2._getDomain;
    var async2 = Promise2._async;
    var Warning = requireErrors$2().Warning;
    var util2 = requireUtil$3();
    var canAttachTrace = util2.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util2.env("BLUEBIRD_DEBUG") != 0 && (util2.env("BLUEBIRD_DEBUG") || util2.env("NODE_ENV") === "development"));
    var warnings = !!(util2.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util2.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util2.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util2.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util2.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util2.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target2 = this._target();
      target2._bitField = target2._bitField & -1048577 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0) return;
      this._setRejectionIsUnhandled();
      async2.invokeLater(this._notifyUnhandledRejection, this, void 0);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent(
        "rejectionHandled",
        unhandledRejectionHandled,
        void 0,
        this
      );
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent(
          "unhandledRejection",
          possiblyUnhandledRejection,
          reason,
          this
        );
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise2) {
      return warn(message, shouldUseOwnTrace, promise2 || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var domain = getDomain();
      possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var domain = getDomain();
      unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    var disableLongStackTraces = function() {
    };
    Promise2.longStackTraces = function() {
      if (async2.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async2.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Context.deactivateLongStackTraces();
          async2.enableTrampoline();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async2.disableTrampolineIfNecessary();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var fireDomEvent = (function() {
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new CustomEvent(name.toLowerCase(), {
              detail: event2,
              cancelable: true
            });
            return !util2.global.dispatchEvent(domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new Event(name.toLowerCase(), {
              cancelable: true
            });
            domEvent.detail = event2;
            return !util2.global.dispatchEvent(domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(
              name.toLowerCase(),
              false,
              true,
              event2
            );
            return !util2.global.dispatchEvent(domEvent);
          };
        }
      } catch (e) {
      }
      return function() {
        return false;
      };
    })();
    var fireGlobalEvent = (function() {
      if (util2.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util2.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method2 = util2.global[methodName];
          if (!method2) return false;
          method2.apply(util2.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    })();
    function generatePromiseLifecycleEventObject(name, promise2) {
      return { promise: promise2 };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise2, child) {
        return { promise: promise2, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise2) {
        return { reason, promise: promise2 };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async2.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(
          name,
          eventToObjectGenerator[name].apply(null, arguments)
        );
      } catch (e) {
        async2.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util2.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async2.haveItemsQueued()) {
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve, reject) {
      try {
        executor(resolve, reject);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {
    };
    Promise2.prototype._setOnCancel = function(handler) {
    };
    Promise2.prototype._attachCancellationCallback = function(onCancel) {
    };
    Promise2.prototype._captureStackTrace = function() {
    };
    Promise2.prototype._attachExtraTrace = function() {
    };
    Promise2.prototype._clearCancellationData = function() {
    };
    Promise2.prototype._propagateFrom = function(parent, flags) {
    };
    function cancellationExecute(executor, resolve, reject) {
      var promise2 = this;
      try {
        executor(resolve, reject, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util2.toString(onCancel));
          }
          promise2._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable()) return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== void 0) {
        if (util2.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = void 0;
      this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === void 0) {
          branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    function bindingPropagateFrom(parent, flags) {
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== void 0) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return void 0;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
      if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== void 0) {
          if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== void 0) {
          trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
          var parsed = parseStackAndMessage(error);
          util2.notEnumerableProp(
            error,
            "stack",
            parsed.message + "\n" + parsed.stack.join("\n")
          );
          util2.notEnumerableProp(error, "__stackCleaned__", true);
        }
      }
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise2, parent) {
      if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
        if (parent !== void 0 && parent._returnedNonUndefined()) return;
        if ((promise2._bitField & 65535) === 0) return;
        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split("\n");
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1; i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0; i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = "\n" + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
        promise2._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      if (replacement) message += " Use " + replacement + " instead.";
      return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise2) {
      if (!config.warnings) return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise2._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
      }
      return message + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1; j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint; j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error) {
      var stack = error.stack.replace(/\s+$/g, "").split("\n");
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error) {
      var stack = error.stack;
      var message = error.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
      return {
        message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util2.isObject(error)) {
          var stack = error.stack;
          message = title + formatStack(stack, error);
        } else {
          message = title + String(error);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise2) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise2);
          } else {
            localHandler(reason, promise2);
          }
        }
      } catch (e) {
        async2.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise2) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise2);
      }
    }
    function formatNonError(obj) {
      var str;
      if (typeof obj === "function") {
        str = "[function " + (obj.name || "anonymous") + "]";
      } else {
        str = obj && typeof obj.toString === "function" ? obj.toString() : util2.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj);
            str = newStr;
          } catch (e) {
          }
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported()) return;
      var firstStackLines = firstLineError.stack.split("\n");
      var lastStackLines = lastLineError.stack.split("\n");
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent) {
      this._parent = parent;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32) this.uncycle();
    }
    util2.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2) return;
      var nodes2 = [];
      var stackToIndex = {};
      for (var i = 0, node2 = this; node2 !== void 0; ++i) {
        nodes2.push(node2);
        node2 = node2._parent;
      }
      length = this._length = i;
      for (var i = length - 1; i >= 0; --i) {
        var stack = nodes2[i].stack;
        if (stackToIndex[stack] === void 0) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0; i < length; ++i) {
        var currentStack = nodes2[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== void 0 && index !== i) {
          if (index > 0) {
            nodes2[index - 1]._parent = void 0;
            nodes2[index - 1]._length = 1;
          }
          nodes2[i]._parent = void 0;
          nodes2[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes2[i - 1] : this;
          if (index < length - 1) {
            cycleEdgeNode._parent = nodes2[index + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = void 0;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2; j >= 0; --j) {
            nodes2[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error) {
      if (error.__stackCleaned__) return;
      this.uncycle();
      var parsed = parseStackAndMessage(error);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== void 0) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util2.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
      util2.notEnumerableProp(error, "__stackCleaned__", true);
    };
    var captureStackTrace = (function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;
        if (error.name !== void 0 && error.message !== void 0) {
          return error.toString();
        }
        return formatNonError(error);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error();
      if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace3(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error();
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace3(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error();
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;
        if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
          return error.toString();
        }
        return formatNonError(error);
      };
      return null;
    })();
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util2.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message + "\x1B[0m\n");
        };
      } else if (!util2.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn(
            "%c" + message,
            isSoft ? "color: darkorange" : "color: red"
          );
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false
    };
    if (longStackTraces) Promise2.longStackTraces();
    return {
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
  return debuggability;
}
var _finally;
var hasRequired_finally;
function require_finally() {
  if (hasRequired_finally) return _finally;
  hasRequired_finally = 1;
  _finally = function(Promise2, tryConvertToPromise) {
    var util2 = requireUtil$3();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util2.errorObj;
    function PassThroughHandlerContext(promise2, type2, handler) {
      this.promise = promise2;
      this.type = type2;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason)) return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise2 = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise2._boundValue()) : handler.call(promise2._boundValue(), reasonOrValue);
        if (ret !== void 0) {
          promise2._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise2);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise2._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(
                  new FinallyHandlerCancelReaction(this)
                );
              }
            }
            return maybePromise._then(
              succeed,
              fail,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      if (promise2.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type2, success, fail2) {
      if (typeof handler !== "function") return this.then();
      return this._then(
        success,
        fail2,
        void 0,
        new PassThroughHandlerContext(this, type2, handler),
        void 0
      );
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(
        handler,
        0,
        finallyHandler,
        finallyHandler
      );
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    return PassThroughHandlerContext;
  };
  return _finally;
}
var catch_filter;
var hasRequiredCatch_filter;
function requireCatch_filter() {
  if (hasRequiredCatch_filter) return catch_filter;
  hasRequiredCatch_filter = 1;
  catch_filter = function(NEXT_FILTER) {
    var util2 = requireUtil$3();
    var getKeys = requireEs5().keys;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function catchFilter(instances, cb, promise2) {
      return function(e) {
        var boundTo = promise2._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
          var item = instances[i];
          if (item === Error || item != null && item.prototype instanceof Error) {
            if (e instanceof item) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (typeof item === "function") {
            var matchesPredicate = tryCatch(item).call(boundTo, e);
            if (matchesPredicate === errorObj) {
              return matchesPredicate;
            } else if (matchesPredicate) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (util2.isObject(e)) {
            var keys = getKeys(item);
            for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              if (item[key] != e[key]) {
                continue predicateLoop;
              }
            }
            return tryCatch(cb).call(boundTo, e);
          }
        }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
  return catch_filter;
}
var nodeback;
var hasRequiredNodeback;
function requireNodeback() {
  if (hasRequiredNodeback) return nodeback;
  hasRequiredNodeback = 1;
  var util2 = requireUtil$3();
  var maybeWrapAsError = util2.maybeWrapAsError;
  var errors2 = requireErrors$2();
  var OperationalError = errors2.OperationalError;
  var es52 = requireEs5();
  function isUntypedError(obj) {
    return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
      ret = new OperationalError(obj);
      ret.name = obj.name;
      ret.message = obj.message;
      ret.stack = obj.stack;
      var keys = es52.keys(obj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    util2.markAsOriginatingFromRejection(obj);
    return obj;
  }
  function nodebackForPromise(promise2, multiArgs) {
    return function(err, value) {
      if (promise2 === null) return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise2._attachExtraTrace(wrapped);
        promise2._reject(wrapped);
      } else if (!multiArgs) {
        promise2._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise2._fulfill(args);
      }
      promise2 = null;
    };
  }
  nodeback = nodebackForPromise;
  return nodeback;
}
var method;
var hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  hasRequiredMethod = 1;
  method = function(Promise2, INTERNAL2, tryConvertToPromise, apiRejection, debug) {
    var util2 = requireUtil$3();
    var tryCatch = util2.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util2.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL2);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.method",
          ret
        );
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var ret = new Promise2(INTERNAL2);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util2.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug.checkForgottenReturns(
        value,
        promiseCreated,
        "Promise.try",
        ret
      );
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util2.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
  return method;
}
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = function(Promise2, INTERNAL2, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context2) {
      context2.promiseRejectionQueued = true;
      context2.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context2) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context2.target);
      }
    };
    var bindingRejected = function(e, context2) {
      if (!context2.promiseRejectionQueued) this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug.propagateFromFunction();
        Promise2.prototype._boundValue = debug.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL2);
      ret._propagateFrom(this, 1);
      var target2 = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context2 = {
          promiseRejectionQueued: false,
          promise: ret,
          target: target2,
          bindingPromise: maybePromise
        };
        target2._then(INTERNAL2, targetRejected, void 0, ret, context2);
        maybePromise._then(
          bindingResolved,
          bindingRejected,
          void 0,
          ret,
          context2
        );
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target2);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj) {
      if (obj !== void 0) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
      } else {
        this._bitField = this._bitField & -2097153;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
  return bind;
}
var cancel;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel) return cancel;
  hasRequiredCancel = 1;
  cancel = function(Promise2, PromiseArray, apiRejection, debug) {
    var util2 = requireUtil$3();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug.cancellation()) return this._warn("cancellation is disabled");
      var promise2 = this;
      var child = promise2;
      while (promise2._isCancellable()) {
        if (!promise2._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent = promise2._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
          if (promise2._isFollowing()) {
            promise2._followee().cancel();
          } else {
            promise2._cancelBranched();
          }
          break;
        } else {
          if (promise2._isFollowing()) promise2._followee().cancel();
          promise2._setWillBeCancelled();
          child = promise2;
          promise2 = parent;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable()) return;
      this._setCancelled();
      async2.invoke(this._cancelPromises, this, void 0);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0) this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util2.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== void 0) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async2.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async2.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
  return cancel;
}
var direct_resolve;
var hasRequiredDirect_resolve;
function requireDirect_resolve() {
  if (hasRequiredDirect_resolve) return direct_resolve;
  hasRequiredDirect_resolve = 1;
  direct_resolve = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2) value.suppressUnhandledRejections();
      return this._then(
        returner,
        void 0,
        void 0,
        { value },
        void 0
      );
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(
        thrower,
        void 0,
        void 0,
        { reason },
        void 0
      );
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(
          void 0,
          thrower,
          void 0,
          { reason },
          void 0
        );
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2) value.suppressUnhandledRejections();
        return this._then(
          void 0,
          returner,
          void 0,
          { value },
          void 0
        );
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2) _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
  return direct_resolve;
}
var synchronous_inspection;
var hasRequiredSynchronous_inspection;
function requireSynchronous_inspection() {
  if (hasRequiredSynchronous_inspection) return synchronous_inspection;
  hasRequiredSynchronous_inspection = 1;
  synchronous_inspection = function(Promise2) {
    function PromiseInspection(promise2) {
      if (promise2 !== void 0) {
        promise2 = promise2._target();
        this._bitField = promise2._bitField;
        this._settledValueField = promise2._isFateSealed() ? promise2._settledValue() : void 0;
      } else {
        this._bitField = 0;
        this._settledValueField = void 0;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target2 = this._target();
      target2._unsetRejectionIsUnhandled();
      return reason.call(target2);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
  return synchronous_inspection;
}
var join;
var hasRequiredJoin;
function requireJoin() {
  if (hasRequiredJoin) return join;
  hasRequiredJoin = 1;
  join = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL2, async2, getDomain) {
    var util2 = requireUtil$3();
    var canEvaluate = util2.canEvaluate;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var reject;
    {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", "                             \n	            'use strict';                                                    \n	            holder.pIndex = value;                                           \n	            holder.checkFulfillment(this);                                   \n	            ".replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", "                           \n	            'use strict';                                                    \n	            holder.pIndex = promise;                                         \n	            ".replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props2 = new Array(total);
          for (var i2 = 0; i2 < props2.length; ++i2) {
            props2[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props2.join(" = ") + " = null;";
          var cancellationCode = "var promise;\n" + props2.map(function(prop2) {
            return "                                                         \n	                promise = " + prop2 + ";                                      \n	                if (promise instanceof Promise) {                            \n	                    promise.cancel();                                        \n	                }                                                            \n	            ";
          }).join("\n");
          var passedArguments = props2.join(", ");
          var name = "Holder$" + total;
          var code = "return function(tryCatch, errorObj, Promise, async) {    \n	            'use strict';                                                    \n	            function [TheName](fn) {                                         \n	                [TheProperties]                                              \n	                this.fn = fn;                                                \n	                this.asyncNeeded = true;                                     \n	                this.now = 0;                                                \n	            }                                                                \n	                                                                             \n	            [TheName].prototype._callFunction = function(promise) {          \n	                promise._pushContext();                                      \n	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n	                promise._popContext();                                       \n	                if (ret === errorObj) {                                      \n	                    promise._rejectCallback(ret.e, false);                   \n	                } else {                                                     \n	                    promise._resolveCallback(ret);                           \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype.checkFulfillment = function(promise) {       \n	                var now = ++this.now;                                        \n	                if (now === [TheTotal]) {                                    \n	                    if (this.asyncNeeded) {                                  \n	                        async.invoke(this._callFunction, this, promise);     \n	                    } else {                                                 \n	                        this._callFunction(promise);                         \n	                    }                                                        \n	                                                                             \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype._resultCancelled = function() {              \n	                [CancellationCode]                                           \n	            };                                                               \n	                                                                             \n	            return [TheName];                                                \n	        }(tryCatch, errorObj, Promise, async);                               \n	        ";
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async2);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0; i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        {
          if (last <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL2);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0; i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(
                    callbacks[i2],
                    reject,
                    void 0,
                    ret,
                    holder
                  );
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(
                    ret,
                    maybePromise._value(),
                    holder
                  );
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var domain = getDomain();
                if (domain !== null) {
                  holder.fn = util2.domainBind(domain, holder.fn);
                }
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0; $_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn) args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== void 0 ? ret.spread(fn) : ret;
    };
  };
  return join;
}
var map$2;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map$2;
  hasRequiredMap = 1;
  map$2 = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil$3();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    function MappingPromiseArray(promises2, fn, limit, _filter) {
      this.constructor$(promises2);
      this._promise._captureStackTrace();
      var domain = getDomain();
      this._callback = domain === null ? fn : util2.domainBind(domain, fn);
      this._preservedValues = _filter === INTERNAL2 ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = [];
      async2.invoke(this._asyncInit, this, void 0);
    }
    util2.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    };
    MappingPromiseArray.prototype._init = function() {
    };
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (index < 0) {
        index = index * -1 - 1;
        values[index] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved()) return true;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values[index] = value;
          this._queue.push(index);
          return false;
        }
        if (preservedValues !== null) preservedValues[index] = value;
        var promise2 = this._promise;
        var callback = this._callback;
        var receiver = promise2._boundValue();
        promise2._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise2._popContext();
        debug.checkForgottenReturns(
          ret,
          promiseCreated,
          preservedValues !== null ? "Promise.filter" : "Promise.map",
          promise2
        );
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit >= 1) this._inFlight++;
            values[index] = maybePromise;
            maybePromise._proxy(this, (index + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values[index] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values, preservedValues);
        } else {
          this._resolve(values);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue2 = this._queue;
      var limit = this._limit;
      var values = this._values;
      while (queue2.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue2.pop();
        this._promiseFulfilled(values[index], index);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
      var len = values.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map2(promises2, fn, options, _filter) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var limit = 0;
      if (options !== void 0) {
        if (typeof options === "object" && options !== null) {
          if (typeof options.concurrency !== "number") {
            return Promise2.reject(
              new TypeError("'concurrency' must be a number but it is " + util2.classString(options.concurrency))
            );
          }
          limit = options.concurrency;
        } else {
          return Promise2.reject(new TypeError(
            "options argument must be an object but it is " + util2.classString(options)
          ));
        }
      }
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises2, fn, limit, _filter).promise();
    }
    Promise2.prototype.map = function(fn, options) {
      return map2(this, fn, options, null);
    };
    Promise2.map = function(promises2, fn, options, _filter) {
      return map2(promises2, fn, options, _filter);
    };
  };
  return map$2;
}
var call_get;
var hasRequiredCall_get;
function requireCall_get() {
  if (hasRequiredCall_get) return call_get;
  hasRequiredCall_get = 1;
  var cr = Object.create;
  if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  call_get = function(Promise2) {
    var util2 = requireUtil$3();
    var canEvaluate = util2.canEvaluate;
    var isIdentifier = util2.isIdentifier;
    var getMethodCaller;
    var getGetter;
    {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", "                                    \n	        return function(obj) {                                               \n	            'use strict'                                                     \n	            var len = this.length;                                           \n	            ensureMethod(obj, 'methodName');                                 \n	            switch(len) {                                                    \n	                case 1: return obj.methodName(this[0]);                      \n	                case 2: return obj.methodName(this[0], this[1]);             \n	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n	                case 0: return obj.methodName();                             \n	                default:                                                     \n	                    return obj.methodName.apply(obj, this);                  \n	            }                                                                \n	        };                                                                   \n	        ".replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", "                                             \n	        'use strict';                                                        \n	        return obj.propertyName;                                             \n	        ".replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj, methodName) {
      var fn;
      if (obj != null) fn = obj[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util2.classString(obj) + " has no method '" + util2.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj) {
      var methodName = this.pop();
      var fn = ensureMethod(obj, methodName);
      return fn.apply(obj, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1; $_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(
              maybeCaller,
              void 0,
              void 0,
              args,
              void 0
            );
          }
        }
      }
      args.push(methodName);
      return this._then(caller, void 0, void 0, args, void 0);
    };
    function namedGetter(obj) {
      return obj[this];
    }
    function indexedGetter(obj) {
      var index = +this;
      if (index < 0) index = Math.max(0, index + obj.length);
      return obj[index];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, void 0, void 0, propertyName, void 0);
    };
  };
  return call_get;
}
var using;
var hasRequiredUsing;
function requireUsing() {
  if (hasRequiredUsing) return using;
  hasRequiredUsing = 1;
  using = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL2, debug) {
    var util2 = requireUtil$3();
    var TypeError2 = requireErrors$2().TypeError;
    var inherits2 = requireUtil$3().inherits;
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var NULL = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL2);
      function iterator() {
        if (i >= len) return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(
              maybePromise._getDisposer().tryDispose(inspection),
              resources.promise
            );
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(
              iterator,
              thrower,
              null,
              null,
              null
            );
          }
        }
        iterator();
      }
      iterator();
      return ret;
    }
    function Disposer(data, promise2, context2) {
      this._data = data;
      this._promise = promise2;
      this._context = context2;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context2 = this._context;
      if (context2 !== void 0) context2._pushContext();
      var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
      if (context2 !== void 0) context2._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise2, context2) {
      this.constructor$(fn, promise2, context2);
    }
    inherits2(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2) return apiRejection(
        "you must pass at least 2 arguments to Promise.using"
      );
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0; i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, void 0);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0; i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0; i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise2._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
        var promiseCreated = promise2._popContext();
        debug.checkForgottenReturns(
          ret,
          promiseCreated,
          "Promise.using",
          promise2
        );
        return ret;
      });
      var promise2 = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise2;
      promise2._setOnCancel(resources);
      return promise2;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073;
      this._disposer = void 0;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2();
    };
  };
  return using;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  timers = function(Promise2, INTERNAL2, debug) {
    var util2 = requireUtil$3();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(ms, value) {
      var ret;
      var handle;
      if (value !== void 0) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
        if (debug.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL2);
        handle = setTimeout(function() {
          ret._fulfill();
        }, +ms);
        if (debug.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms) {
      return delay(ms, this);
    };
    var afterTimeout = function(promise2, message, parent) {
      var err;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err = message;
        } else {
          err = new TimeoutError("operation timed out");
        }
      } else {
        err = new TimeoutError(message);
      }
      util2.markAsOriginatingFromRejection(err);
      promise2._attachExtraTrace(err);
      promise2._reject(err);
      if (parent != null) {
        parent.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message) {
      ms = +ms;
      var ret, parent;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message, parent);
        }
      }, ms));
      if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
      }
      return ret;
    };
  };
  return timers;
}
var generators;
var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  generators = function(Promise2, apiRejection, INTERNAL2, tryConvertToPromise, Proxyable, debug) {
    var errors2 = requireErrors$2();
    var TypeError2 = errors2.TypeError;
    var util2 = requireUtil$3();
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0; i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2) return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug.cancellation()) {
        var internal = new Promise2(INTERNAL2);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL2);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise2 = this._promise = new Promise2(INTERNAL2);
        promise2._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = void 0;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util2.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved()) return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError(
          "generator .return() sentinel"
        );
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(
          this._generator,
          reason
        );
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(
          this._generator,
          void 0
        );
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise2 = this._yieldedPromise;
        this._yieldedPromise = null;
        promise2.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = void 0;
      this._promiseFulfilled(void 0);
    };
    PromiseSpawn.prototype._continue = function(result) {
      var promise2 = this._promise;
      if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._rejectCallback(result.e, false);
        }
      }
      var value = result.value;
      if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(
            maybePromise,
            this._yieldHandlers,
            this._promise
          );
          if (maybePromise === null) {
            this._promiseRejected(
              new TypeError2(
                "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
              )
            );
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(
            this._promiseFulfilled,
            this,
            maybePromise._value()
          );
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(
            this._promiseRejected,
            this,
            maybePromise._reason()
          );
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(
          void 0,
          void 0,
          yieldHandler,
          stack
        );
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(void 0);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
  return generators;
}
var nodeify;
var hasRequiredNodeify;
function requireNodeify() {
  if (hasRequiredNodeify) return nodeify;
  hasRequiredNodeify = 1;
  nodeify = function(Promise2) {
    var util2 = requireUtil$3();
    var async2 = Promise2._async;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function spreadAdapter(val, nodeback2) {
      var promise2 = this;
      if (!util2.isArray(val)) return successAdapter.call(promise2, val, nodeback2);
      var ret = tryCatch(nodeback2).apply(promise2._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback2) {
      var promise2 = this;
      var receiver = promise2._boundValue();
      var ret = val === void 0 ? tryCatch(nodeback2).call(receiver, null) : tryCatch(nodeback2).call(receiver, null, val);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback2) {
      var promise2 = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback2).call(promise2._boundValue(), reason);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback2, options) {
      if (typeof nodeback2 == "function") {
        var adapter = successAdapter;
        if (options !== void 0 && Object(options).spread) {
          adapter = spreadAdapter;
        }
        this._then(
          adapter,
          errorAdapter,
          void 0,
          this,
          nodeback2
        );
      }
      return this;
    };
  };
  return nodeify;
}
var promisify;
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify;
  hasRequiredPromisify = 1;
  promisify = function(Promise2, INTERNAL2) {
    var THIS = {};
    var util2 = requireUtil$3();
    var nodebackForPromise = requireNodeback();
    var withAppended = util2.withAppended;
    var maybeWrapAsError = util2.maybeWrapAsError;
    var canEvaluate = util2.canEvaluate;
    var TypeError2 = requireErrors$2().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util2.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj, key, suffix) {
      var val = util2.getDataPropertyOrDefault(
        obj,
        key + suffix,
        defaultPromisified
      );
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0; j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter2) {
      var keys = util2.inheritedDataKeys(obj);
      var ret = [];
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter2(key, value, obj, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1; i >= min2; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util2.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util2.filledRange(
          Math.max(parameterCount2, 3),
          "_arg",
          ""
        );
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma2 = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
          } else {
            ret = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
          }
          return ret.replace("{{args}}", args).replace(", ", comma2);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += "                                                             \n	        default:                                                             \n	            var args = new Array(len + 1);                                   \n	            var i = 0;                                                       \n	            for (var i = 0; i < len; ++i) {                                  \n	               args[i] = arguments[i];                                       \n	            }                                                                \n	            args[i] = nodeback;                                              \n	            [CodeForCall]                                                    \n	            break;                                                           \n	        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = "'use strict';                                                \n	        var ret = function (Parameters) {                                    \n	            'use strict';                                                    \n	            var len = arguments.length;                                      \n	            var promise = new Promise(INTERNAL);                             \n	            promise._captureStackTrace();                                    \n	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n	            var ret;                                                         \n	            var callback = tryCatch([GetFunctionCode]);                      \n	            switch(len) {                                                    \n	                [CodeForSwitchCase]                                          \n	            }                                                                \n	            if (ret === errorObj) {                                          \n	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n	            }                                                                \n	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n	            return promise;                                                  \n	        };                                                                   \n	        notEnumerableProp(ret, '__isPromisified__', true);                   \n	        return ret;                                                          \n	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          body
        )(
          Promise2,
          fn,
          receiver,
          withAppended,
          maybeWrapAsError,
          nodebackForPromise,
          util2.tryCatch,
          util2.errorObj,
          util2.notEnumerableProp,
          INTERNAL2
        );
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
      var defaultThis = /* @__PURE__ */ (function() {
        return this;
      })();
      var method2 = callback;
      if (typeof method2 === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise2 = new Promise2(INTERNAL2);
        promise2._captureStackTrace();
        var cb = typeof method2 === "string" && this !== defaultThis ? this[method2] : callback;
        var fn2 = nodebackForPromise(promise2, multiArgs);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise2._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise2._isFateSealed()) promise2._setAsyncGuaranteed();
        return promise2;
      }
      util2.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter2, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter2);
      for (var i = 0, len = methods.length; i < len; i += 2) {
        var key = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(
              key,
              THIS,
              key,
              fn,
              suffix,
              multiArgs
            );
          });
          util2.notEnumerableProp(promisified, "__isPromisified__", true);
          obj[promisifiedKey] = promisified;
        }
      }
      util2.toFastProperties(obj);
      return obj;
    }
    function promisify2(callback, receiver, multiArgs) {
      return makeNodePromisified(
        callback,
        receiver,
        void 0,
        callback,
        null,
        multiArgs
      );
    }
    Promise2.promisify = function(fn, options) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options = Object(options);
      var receiver = options.context === void 0 ? THIS : options.context;
      var multiArgs = !!options.multiArgs;
      var ret = promisify2(fn, receiver, multiArgs);
      util2.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target2, options) {
      if (typeof target2 !== "function" && typeof target2 !== "object") {
        throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      options = Object(options);
      var multiArgs = !!options.multiArgs;
      var suffix = options.suffix;
      if (typeof suffix !== "string") suffix = defaultSuffix;
      var filter2 = options.filter;
      if (typeof filter2 !== "function") filter2 = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function") promisifier = makeNodePromisified;
      if (!util2.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
      }
      var keys = util2.inheritedDataKeys(target2);
      for (var i = 0; i < keys.length; ++i) {
        var value = target2[keys[i]];
        if (keys[i] !== "constructor" && util2.isClass(value)) {
          promisifyAll(
            value.prototype,
            suffix,
            filter2,
            promisifier,
            multiArgs
          );
          promisifyAll(value, suffix, filter2, promisifier, multiArgs);
        }
      }
      return promisifyAll(target2, suffix, filter2, promisifier, multiArgs);
    };
  };
  return promisify;
}
var props;
var hasRequiredProps;
function requireProps() {
  if (hasRequiredProps) return props;
  hasRequiredProps = 1;
  props = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil$3();
    var isObject = util2.isObject;
    var es52 = requireEs5();
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;
    var mapToEntries = /* @__PURE__ */ (function() {
      var index = 0;
      var size = 0;
      function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
      }
      return function mapToEntries2(map2) {
        size = map2.size;
        index = 0;
        var ret = new Array(map2.size * 2);
        map2.forEach(extractEntry, ret);
        return ret;
      };
    })();
    var entriesToMap = function(entries) {
      var ret = new Es6Map();
      var length = entries.length / 2 | 0;
      for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj) {
      var isMap = false;
      var entries;
      if (Es6Map !== void 0 && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
      } else {
        var keys = es52.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
          var key = keys[i];
          entries[i] = obj[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(void 0, -3);
    }
    util2.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props2(promises2) {
      var ret;
      var castValue = tryConvertToPromise(promises2);
      if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(
          Promise2.props,
          void 0,
          void 0,
          void 0,
          void 0
        );
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props2(this);
    };
    Promise2.props = function(promises2) {
      return props2(promises2);
    };
  };
  return props;
}
var race$2;
var hasRequiredRace;
function requireRace() {
  if (hasRequiredRace) return race$2;
  hasRequiredRace = 1;
  race$2 = function(Promise2, INTERNAL2, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil$3();
    var raceLater = function(promise2) {
      return promise2.then(function(array) {
        return race2(array, promise2);
      });
    };
    function race2(promises2, parent) {
      var maybePromise = tryConvertToPromise(promises2);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises2 = util2.asArray(promises2);
        if (promises2 === null)
          return apiRejection("expecting an array or an iterable object but got " + util2.classString(promises2));
      }
      var ret = new Promise2(INTERNAL2);
      if (parent !== void 0) {
        ret._propagateFrom(parent, 3);
      }
      var fulfill = ret._fulfill;
      var reject = ret._reject;
      for (var i = 0, len = promises2.length; i < len; ++i) {
        var val = promises2[i];
        if (val === void 0 && !(i in promises2)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject, void 0, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises2) {
      return race2(promises2, void 0);
    };
    Promise2.prototype.race = function() {
      return race2(this, void 0);
    };
  };
  return race$2;
}
var reduce;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce;
  hasRequiredReduce = 1;
  reduce = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil$3();
    var tryCatch = util2.tryCatch;
    function ReductionPromiseArray(promises2, fn, initialValue, _each) {
      this.constructor$(promises2);
      var domain = getDomain();
      this._fn = domain === null ? fn : util2.domainBind(domain, fn);
      if (initialValue !== void 0) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL2) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = void 0;
      }
      this._promise._captureStackTrace();
      this._init$(void 0, -5);
    }
    util2.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL2) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {
    };
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue) return this._cancel();
      if (this._isResolved()) return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values) {
      this._values = values;
      var value;
      var i;
      var length = values.length;
      if (this._initialValue !== void 0) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values[0]);
        i = 1;
      }
      this._currentCancellable = value;
      if (!value.isRejected()) {
        for (; i < length; ++i) {
          var ctx = {
            accum: null,
            value: values[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, void 0, void 0, ctx, void 0);
        }
      }
      if (this._eachValues !== void 0) {
        value = value._then(this._eachComplete, void 0, void 0, this, void 0);
      }
      value._then(completed, completed, void 0, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce2(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises2, fn, initialValue, _each) {
      return reduce2(promises2, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce2(promises2, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var array = new ReductionPromiseArray(promises2, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, void 0, void 0, this, void 0);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise2 = array._promise;
      var fn = tryCatch(array._fn);
      promise2._pushContext();
      var ret;
      if (array._eachValues !== void 0) {
        ret = fn.call(promise2._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(
          promise2._boundValue(),
          this.accum,
          value,
          this.index,
          this.length
        );
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise2._popContext();
      debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        promise2
      );
      return ret;
    }
  };
  return reduce;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle) return settle;
  hasRequiredSettle = 1;
  settle = function(Promise2, PromiseArray, debug) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util2 = requireUtil$3();
    function SettledPromiseArray(values) {
      this.constructor$(values);
    }
    util2.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
      this._values[index] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var ret = new PromiseInspection();
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
      var ret = new PromiseInspection();
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index, ret);
    };
    Promise2.settle = function(promises2) {
      debug.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises2).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
  return settle;
}
var some;
var hasRequiredSome;
function requireSome() {
  if (hasRequiredSome) return some;
  hasRequiredSome = 1;
  some = function(Promise2, PromiseArray, apiRejection) {
    var util2 = requireUtil$3();
    var RangeError2 = requireErrors$2().RangeError;
    var AggregateError2 = requireErrors$2().AggregateError;
    var isArray = util2.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values) {
      this.constructor$(values);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util2.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(void 0, -5);
      var isArrayResolved = isArray(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError2();
        for (var i = this.length(); i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some2(promises2, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
      }
      var ret = new SomePromiseArray(promises2);
      var promise2 = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise2;
    }
    Promise2.some = function(promises2, howMany) {
      return some2(promises2, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some2(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
  return some;
}
var filter;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter;
  hasRequiredFilter = 1;
  filter = function(Promise2, INTERNAL2) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL2);
    };
    Promise2.filter = function(promises2, fn, options) {
      return PromiseMap(promises2, fn, options, INTERNAL2);
    };
  };
  return filter;
}
var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach) return each;
  hasRequiredEach = 1;
  each = function(Promise2, INTERNAL2) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises2, fn) {
      return PromiseReduce(promises2, fn, INTERNAL2, INTERNAL2);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL2, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL2, INTERNAL2);
    };
    Promise2.each = function(promises2, fn) {
      return PromiseReduce(promises2, fn, INTERNAL2, 0)._then(promiseAllThis, void 0, void 0, promises2, void 0);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
  return each;
}
var any;
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any;
  hasRequiredAny = 1;
  any = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any2(promises2) {
      var ret = new SomePromiseArray(promises2);
      var promise2 = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise2;
    }
    Promise2.any = function(promises2) {
      return any2(promises2);
    };
    Promise2.prototype.any = function() {
      return any2(this);
    };
  };
  return any;
}
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise.exports;
  hasRequiredPromise = 1;
  (function(module) {
    module.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util2 = requireUtil$3();
      var getDomain;
      if (util2.isNode) {
        getDomain = function() {
          var ret = process.domain;
          if (ret === void 0) ret = null;
          return ret;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util2.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = requireEs5();
      var Async = requireAsync();
      var async2 = new Async();
      es52.defineProperty(Promise2, "_async", { value: async2 });
      var errors2 = requireErrors$2();
      var TypeError2 = Promise2.TypeError = errors2.TypeError;
      Promise2.RangeError = errors2.RangeError;
      var CancellationError = Promise2.CancellationError = errors2.CancellationError;
      Promise2.TimeoutError = errors2.TimeoutError;
      Promise2.OperationalError = errors2.OperationalError;
      Promise2.RejectionError = errors2.OperationalError;
      Promise2.AggregateError = errors2.AggregateError;
      var INTERNAL2 = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = requireThenables()(Promise2, INTERNAL2);
      var PromiseArray = requirePromise_array()(
        Promise2,
        INTERNAL2,
        tryConvertToPromise,
        apiRejection,
        Proxyable
      );
      var Context = requireContext()(Promise2);
      var createContext = Context.create;
      var debug = requireDebuggability()(Promise2, Context);
      debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
      var catchFilter = requireCatch_filter()(NEXT_FILTER);
      var nodebackForPromise = requireNodeback();
      var errorObj = util2.errorObj;
      var tryCatch = util2.tryCatch;
      function check2(self2, executor) {
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(executor));
        }
        if (self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
      }
      function Promise2(executor) {
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        if (executor !== INTERNAL2) {
          check2(this, executor);
          this._resolveFromExecutor(executor);
        }
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util2.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("expecting an object but got A catch statement predicate " + util2.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(
          reflectHandler,
          reflectHandler,
          void 0,
          this,
          void 0
        );
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util2.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util2.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise2 = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise2._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret.fulfillmentValue = this.value();
          ret.isFulfilled = true;
        } else if (this.isRejected()) {
          ret.rejectionReason = this.reason();
          ret.isRejected = true;
        }
        return ret;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util2.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret = new Promise2(INTERNAL2);
        ret._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
        if (result === errorObj) {
          ret._rejectCallback(result.e, true);
        }
        if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
        return ret;
      };
      Promise2.all = function(promises2) {
        return new PromiseArray(promises2).promise();
      };
      Promise2.cast = function(obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise2)) {
          ret = new Promise2(INTERNAL2);
          ret._captureStackTrace();
          ret._setFulfilled();
          ret._rejectionHandler0 = obj;
        }
        return ret;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret = new Promise2(INTERNAL2);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(fn));
        }
        return async2.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise2 = haveInternalData ? internalData : new Promise2(INTERNAL2);
        var target2 = this._target();
        var bitField = target2._bitField;
        if (!haveInternalData) {
          promise2._propagateFrom(this, 3);
          promise2._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target2 === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise2);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target2._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target2._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target2._fulfillmentHandler0;
            handler = didReject;
            target2._unsetRejectionIsUnhandled();
          } else {
            settler = target2._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target2._attachExtraTrace(value);
            handler = didReject;
          }
          async2.invoke(settler, target2, {
            handler: domain === null ? handler : typeof handler === "function" && util2.domainBind(domain, handler),
            promise: promise2,
            receiver,
            value
          });
        } else {
          target2._addCallbacks(didFulfill, didReject, promise2, receiver, domain);
        }
        return promise2;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & -65537;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async2.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise2 = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise2, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise2 = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise2, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise2, receiver, domain) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise2;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = domain === null ? reject : util2.domainBind(domain, reject);
          }
        } else {
          var base = index * 4 - 4;
          this[base + 2] = promise2;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = domain === null ? reject : util2.domainBind(domain, reject);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2)) return this._fulfill(value);
        if (shouldBind) this._propagateFrom(maybePromise, 2);
        var promise2 = maybePromise._target();
        if (promise2 === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise2._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0) promise2._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise2._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise2);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise2._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise2._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise2._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util2.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util2.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        var promise2 = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise2._resolveCallback(value);
        }, function(reason) {
          promise2._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise2._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise2) {
        var bitField = promise2._bitField;
        if ((bitField & 65536) !== 0) return;
        promise2._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError2("cannot .spread() a non-array: " + util2.classString(value));
          } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch(handler).call(receiver, value);
        }
        var promiseCreated = promise2._popContext();
        bitField = promise2._bitField;
        if ((bitField & 65536) !== 0) return;
        if (x === NEXT_FILTER) {
          promise2._reject(value);
        } else if (x === errorObj) {
          promise2._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise2, this);
          promise2._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise2) {
        this._rejectionHandler0 = promise2;
      };
      Promise2.prototype._settlePromise = function(promise2, handler, receiver, value) {
        var isPromise = promise2 instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise) promise2._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise2;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
              promise2._reject(errorObj.e);
            }
          } else if (handler === reflectHandler) {
            promise2._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise2);
          } else if (isPromise || promise2 instanceof PromiseArray) {
            promise2._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise2);
          } else {
            if (asyncGuaranteed) promise2._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise2);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise2);
            } else {
              receiver._promiseRejected(value, promise2);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed) promise2._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise2._fulfill(value);
          } else {
            promise2._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise2 = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise2 instanceof Promise2)) {
            handler.call(receiver, value, promise2);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise2);
          }
        } else if (promise2 instanceof Promise2) {
          promise2._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise2 = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise2, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async2.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async2.fatalError(reason, util2.isNode);
        }
        if ((bitField & 65535) > 0) {
          async2.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise2 = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise2, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise2 = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise2, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise2 = new Promise2(INTERNAL2);
        return {
          promise: promise2,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util2.notEnumerableProp(
        Promise2,
        "_makeSelfResolutionError",
        makeSelfResolutionError
      );
      requireMethod()(
        Promise2,
        INTERNAL2,
        tryConvertToPromise,
        apiRejection,
        debug
      );
      requireBind()(Promise2, INTERNAL2, tryConvertToPromise, debug);
      requireCancel()(Promise2, PromiseArray, apiRejection, debug);
      requireDirect_resolve()(Promise2);
      requireSynchronous_inspection()(Promise2);
      requireJoin()(
        Promise2,
        PromiseArray,
        tryConvertToPromise,
        INTERNAL2,
        async2,
        getDomain
      );
      Promise2.Promise = Promise2;
      Promise2.version = "3.4.7";
      requireMap()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug);
      requireCall_get()(Promise2);
      requireUsing()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL2, debug);
      requireTimers()(Promise2, INTERNAL2, debug);
      requireGenerators()(Promise2, apiRejection, INTERNAL2, tryConvertToPromise, Proxyable, debug);
      requireNodeify()(Promise2);
      requirePromisify()(Promise2, INTERNAL2);
      requireProps()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      requireRace()(Promise2, INTERNAL2, tryConvertToPromise, apiRejection);
      requireReduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug);
      requireSettle()(Promise2, PromiseArray, debug);
      requireSome()(Promise2, PromiseArray, apiRejection);
      requireFilter()(Promise2, INTERNAL2);
      requireEach()(Promise2, INTERNAL2);
      requireAny()(Promise2);
      util2.toFastProperties(Promise2);
      util2.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL2);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL2));
      debug.setBounds(Async.firstLineError, util2.lastLineError);
      return Promise2;
    };
  })(promise);
  return promise.exports;
}
var hasRequiredPromises;
function requirePromises() {
  if (hasRequiredPromises) return promises;
  hasRequiredPromises = 1;
  var _ = requireUnderscoreNode();
  var bluebird = requirePromise()();
  promises.defer = defer;
  promises.when = bluebird.resolve;
  promises.resolve = bluebird.resolve;
  promises.all = bluebird.all;
  promises.props = bluebird.props;
  promises.reject = bluebird.reject;
  promises.promisify = bluebird.promisify;
  promises.mapSeries = bluebird.mapSeries;
  promises.attempt = bluebird.attempt;
  promises.nfcall = function(func) {
    var args = Array.prototype.slice.call(arguments, 1);
    var promisedFunc = bluebird.promisify(func);
    return promisedFunc.apply(null, args);
  };
  bluebird.prototype.fail = bluebird.prototype.caught;
  bluebird.prototype.also = function(func) {
    return this.then(function(value) {
      var returnValue = _.extend({}, value, func(value));
      return bluebird.props(returnValue);
    });
  };
  function defer() {
    var resolve;
    var reject;
    var promise2 = new bluebird.Promise(function(resolveArg, rejectArg) {
      resolve = resolveArg;
      reject = rejectArg;
    });
    return {
      resolve,
      reject,
      promise: promise2
    };
  }
  return promises;
}
var documents = {};
var hasRequiredDocuments;
function requireDocuments() {
  if (hasRequiredDocuments) return documents;
  hasRequiredDocuments = 1;
  var _ = requireUnderscoreNode();
  var types2 = documents.types = {
    document: "document",
    paragraph: "paragraph",
    run: "run",
    text: "text",
    tab: "tab",
    checkbox: "checkbox",
    hyperlink: "hyperlink",
    noteReference: "noteReference",
    image: "image",
    note: "note",
    commentReference: "commentReference",
    comment: "comment",
    table: "table",
    tableRow: "tableRow",
    tableCell: "tableCell",
    "break": "break",
    bookmarkStart: "bookmarkStart"
  };
  function Document(children, options) {
    options = options || {};
    return {
      type: types2.document,
      children,
      notes: options.notes || new Notes({}),
      comments: options.comments || []
    };
  }
  function Paragraph(children, properties) {
    properties = properties || {};
    var indent = properties.indent || {};
    return {
      type: types2.paragraph,
      children,
      styleId: properties.styleId || null,
      styleName: properties.styleName || null,
      numbering: properties.numbering || null,
      alignment: properties.alignment || null,
      indent: {
        start: indent.start || null,
        end: indent.end || null,
        firstLine: indent.firstLine || null,
        hanging: indent.hanging || null
      }
    };
  }
  function Run(children, properties) {
    properties = properties || {};
    return {
      type: types2.run,
      children,
      styleId: properties.styleId || null,
      styleName: properties.styleName || null,
      isBold: !!properties.isBold,
      isUnderline: !!properties.isUnderline,
      isItalic: !!properties.isItalic,
      isStrikethrough: !!properties.isStrikethrough,
      isAllCaps: !!properties.isAllCaps,
      isSmallCaps: !!properties.isSmallCaps,
      verticalAlignment: properties.verticalAlignment || verticalAlignment.baseline,
      font: properties.font || null,
      fontSize: properties.fontSize || null,
      highlight: properties.highlight || null
    };
  }
  var verticalAlignment = {
    baseline: "baseline",
    superscript: "superscript",
    subscript: "subscript"
  };
  function Text(value) {
    return {
      type: types2.text,
      value
    };
  }
  function Tab2() {
    return {
      type: types2.tab
    };
  }
  function Checkbox(options) {
    return {
      type: types2.checkbox,
      checked: options.checked
    };
  }
  function Hyperlink(children, options) {
    return {
      type: types2.hyperlink,
      children,
      href: options.href,
      anchor: options.anchor,
      targetFrame: options.targetFrame
    };
  }
  function NoteReference(options) {
    return {
      type: types2.noteReference,
      noteType: options.noteType,
      noteId: options.noteId
    };
  }
  function Notes(notes) {
    this._notes = _.indexBy(notes, function(note) {
      return noteKey(note.noteType, note.noteId);
    });
  }
  Notes.prototype.resolve = function(reference) {
    return this.findNoteByKey(noteKey(reference.noteType, reference.noteId));
  };
  Notes.prototype.findNoteByKey = function(key) {
    return this._notes[key] || null;
  };
  function Note(options) {
    return {
      type: types2.note,
      noteType: options.noteType,
      noteId: options.noteId,
      body: options.body
    };
  }
  function commentReference(options) {
    return {
      type: types2.commentReference,
      commentId: options.commentId
    };
  }
  function comment(options) {
    return {
      type: types2.comment,
      commentId: options.commentId,
      body: options.body,
      authorName: options.authorName,
      authorInitials: options.authorInitials
    };
  }
  function noteKey(noteType, id) {
    return noteType + "-" + id;
  }
  function Image(options) {
    return {
      type: types2.image,
      // `read` is retained for backwards compatibility, but other read
      // methods should be preferred.
      read: function(encoding) {
        if (encoding) {
          return options.readImage(encoding);
        } else {
          return options.readImage().then(function(arrayBuffer) {
            return Buffer.from(arrayBuffer);
          });
        }
      },
      readAsArrayBuffer: function() {
        return options.readImage();
      },
      readAsBase64String: function() {
        return options.readImage("base64");
      },
      readAsBuffer: function() {
        return options.readImage().then(function(arrayBuffer) {
          return Buffer.from(arrayBuffer);
        });
      },
      altText: options.altText,
      contentType: options.contentType
    };
  }
  function Table(children, properties) {
    properties = properties || {};
    return {
      type: types2.table,
      children,
      styleId: properties.styleId || null,
      styleName: properties.styleName || null
    };
  }
  function TableRow(children, options) {
    options = options || {};
    return {
      type: types2.tableRow,
      children,
      isHeader: options.isHeader || false
    };
  }
  function TableCell(children, options) {
    options = options || {};
    return {
      type: types2.tableCell,
      children,
      colSpan: options.colSpan == null ? 1 : options.colSpan,
      rowSpan: options.rowSpan == null ? 1 : options.rowSpan
    };
  }
  function Break(breakType) {
    return {
      type: types2["break"],
      breakType
    };
  }
  function BookmarkStart(options) {
    return {
      type: types2.bookmarkStart,
      name: options.name
    };
  }
  documents.document = documents.Document = Document;
  documents.paragraph = documents.Paragraph = Paragraph;
  documents.run = documents.Run = Run;
  documents.text = documents.Text = Text;
  documents.tab = documents.Tab = Tab2;
  documents.checkbox = documents.Checkbox = Checkbox;
  documents.Hyperlink = Hyperlink;
  documents.noteReference = documents.NoteReference = NoteReference;
  documents.Notes = Notes;
  documents.Note = Note;
  documents.commentReference = commentReference;
  documents.comment = comment;
  documents.Image = Image;
  documents.Table = Table;
  documents.TableRow = TableRow;
  documents.TableCell = TableCell;
  documents.lineBreak = Break("line");
  documents.pageBreak = Break("page");
  documents.columnBreak = Break("column");
  documents.BookmarkStart = BookmarkStart;
  documents.verticalAlignment = verticalAlignment;
  return documents;
}
var results = {};
var hasRequiredResults;
function requireResults() {
  if (hasRequiredResults) return results;
  hasRequiredResults = 1;
  var _ = requireUnderscoreNode();
  results.Result = Result;
  results.success = success;
  results.warning = warning;
  results.error = error;
  function Result(value, messages2) {
    this.value = value;
    this.messages = messages2 || [];
  }
  Result.prototype.map = function(func) {
    return new Result(func(this.value), this.messages);
  };
  Result.prototype.flatMap = function(func) {
    var funcResult = func(this.value);
    return new Result(funcResult.value, combineMessages([this, funcResult]));
  };
  Result.prototype.flatMapThen = function(func) {
    var that = this;
    return func(this.value).then(function(otherResult) {
      return new Result(otherResult.value, combineMessages([that, otherResult]));
    });
  };
  Result.combine = function(results2) {
    var values = _.flatten(_.pluck(results2, "value"));
    var messages2 = combineMessages(results2);
    return new Result(values, messages2);
  };
  function success(value) {
    return new Result(value, []);
  }
  function warning(message) {
    return {
      type: "warning",
      message
    };
  }
  function error(exception) {
    return {
      type: "error",
      message: exception.message,
      error: exception
    };
  }
  function combineMessages(results2) {
    var messages2 = [];
    _.flatten(_.pluck(results2, "messages"), true).forEach(function(message) {
      if (!containsMessage(messages2, message)) {
        messages2.push(message);
      }
    });
    return messages2;
  }
  function containsMessage(messages2, message) {
    return _.find(messages2, isSameMessage.bind(null, message)) !== void 0;
  }
  function isSameMessage(first, second) {
    return first.type === second.type && first.message === second.message;
  }
  return results;
}
var zipfile = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num2) {
    return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var utf8 = {};
var utils$1 = {};
var support = {};
var readable$1 = { exports: {} };
var processNextickArgs = { exports: {} };
var hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1;
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    processNextickArgs.exports = { nextTick };
  } else {
    processNextickArgs.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var toString = {}.toString;
  isarray = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
  return isarray;
}
var stream$1;
var hasRequiredStream$2;
function requireStream$2() {
  if (hasRequiredStream$2) return stream$1;
  hasRequiredStream$2 = 1;
  stream$1 = Stream;
  return stream$1;
}
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports$1) {
    var buffer = require$$0$3;
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports$1);
      exports$1.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var util$2 = {};
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$2;
  hasRequiredUtil$2 = 1;
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  util$2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  util$2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  util$2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  util$2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  util$2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util$2.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$2.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  util$2.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$2.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  util$2.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$2.isPrimitive = isPrimitive;
  util$2.isBuffer = require$$0$3.Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$2;
}
var inherits$1 = { exports: {} };
var inherits_browser$1 = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser$1.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser$1.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser$1.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser$1.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits$1.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits !== "function") throw "";
    inherits$1.exports = util2.inherits;
  } catch (e) {
    inherits$1.exports = requireInherits_browser();
  }
  return inherits$1.exports;
}
var BufferList = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList) return BufferList.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer().Buffer;
    var util2 = require$$1$3;
    function copyBuffer(src, target2, offset) {
      src.copy(target2, offset);
    }
    module.exports = (function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    })();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList);
  return BufferList.exports;
}
var destroy_1$1;
var hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1$1 = {
    destroy,
    undestroy
  };
  return destroy_1$1;
}
var node$1;
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1;
  hasRequiredNode$1 = 1;
  node$1 = require$$1$3.deprecate;
  return node$1;
}
var _stream_writable$1;
var hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$1 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil$2());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode$1()
  };
  var Stream2 = requireStream$2();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$1();
  util2.inherits(Writable, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$1;
}
var _stream_duplex$1;
var hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$1 = Duplex;
  var util2 = Object.create(requireUtil$2());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$1();
  var Writable = require_stream_writable$1();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex$1;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "ï¿½";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "ï¿½";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "ï¿½";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "ï¿½";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var _stream_readable$1;
var hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$1 = Readable2;
  var isArray = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$3.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream2 = requireStream$2();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$2());
  util2.inherits = requireInherits();
  var debugUtil = require$$1$3;
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = requireDestroy$1();
  var StringDecoder;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ (function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        })(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1;
var hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1;
  _stream_transform$1 = Transform;
  var Duplex = require_stream_duplex$1();
  var util2 = Object.create(requireUtil$2());
  util2.inherits = requireInherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done2(_this, er, data);
      });
    } else {
      done2(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done2(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1;
var hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1;
  _stream_passthrough$1 = PassThrough2;
  var Transform = require_stream_transform$1();
  var util2 = Object.create(requireUtil$2());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$1;
}
var hasRequiredReadable$1;
function requireReadable$1() {
  if (hasRequiredReadable$1) return readable$1.exports;
  hasRequiredReadable$1 = 1;
  (function(module, exports$1) {
    var Stream$1 = Stream;
    if (process.env.READABLE_STREAM === "disable" && Stream$1) {
      module.exports = Stream$1;
      exports$1 = module.exports = Stream$1.Readable;
      exports$1.Readable = Stream$1.Readable;
      exports$1.Writable = Stream$1.Writable;
      exports$1.Duplex = Stream$1.Duplex;
      exports$1.Transform = Stream$1.Transform;
      exports$1.PassThrough = Stream$1.PassThrough;
      exports$1.Stream = Stream$1;
    } else {
      exports$1 = module.exports = require_stream_readable$1();
      exports$1.Stream = Stream$1 || exports$1;
      exports$1.Readable = exports$1;
      exports$1.Writable = require_stream_writable$1();
      exports$1.Duplex = require_stream_duplex$1();
      exports$1.Transform = require_stream_transform$1();
      exports$1.PassThrough = require_stream_passthrough$1();
    }
  })(readable$1, readable$1.exports);
  return readable$1.exports;
}
var hasRequiredSupport;
function requireSupport() {
  if (hasRequiredSupport) return support;
  hasRequiredSupport = 1;
  support.base64 = true;
  support.array = true;
  support.string = true;
  support.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  support.nodebuffer = typeof Buffer !== "undefined";
  support.uint8array = typeof Uint8Array !== "undefined";
  if (typeof ArrayBuffer === "undefined") {
    support.blob = false;
  } else {
    var buffer = new ArrayBuffer(0);
    try {
      support.blob = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      try {
        var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        var builder2 = new Builder();
        builder2.append(buffer);
        support.blob = builder2.getBlob("application/zip").size === 0;
      } catch (e2) {
        support.blob = false;
      }
    }
  }
  try {
    support.nodestream = !!requireReadable$1().Readable;
  } catch (e) {
    support.nodestream = false;
  }
  return support;
}
var base64 = {};
var hasRequiredBase64$2;
function requireBase64$2() {
  if (hasRequiredBase64$2) return base64;
  hasRequiredBase64$2 = 1;
  var utils2 = requireUtils();
  var support2 = requireSupport();
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  base64.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;
    var isArray = utils2.getTypeOf(input) !== "string";
    while (i < input.length) {
      remainingBytes = len - i;
      if (!isArray) {
        chr1 = input.charCodeAt(i++);
        chr2 = i < len ? input.charCodeAt(i++) : 0;
        chr3 = i < len ? input.charCodeAt(i++) : 0;
      } else {
        chr1 = input[i++];
        chr2 = i < len ? input[i++] : 0;
        chr3 = i < len ? input[i++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  base64.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support2.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
  return base64;
}
var nodejsUtils;
var hasRequiredNodejsUtils;
function requireNodejsUtils() {
  if (hasRequiredNodejsUtils) return nodejsUtils;
  hasRequiredNodejsUtils = 1;
  nodejsUtils = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode: typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function(data, encoding) {
      if (Buffer.from && Buffer.from !== Uint8Array.from) {
        return Buffer.from(data, encoding);
      } else {
        if (typeof data === "number") {
          throw new Error('The "data" argument must not be a number');
        }
        return new Buffer(data, encoding);
      }
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function(size) {
      if (Buffer.alloc) {
        return Buffer.alloc(size);
      } else {
        var buf = new Buffer(size);
        buf.fill(0);
        return buf;
      }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer: function(b) {
      return Buffer.isBuffer(b);
    },
    isStream: function(obj) {
      return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
  };
  return nodejsUtils;
}
var lib$g;
var hasRequiredLib$g;
function requireLib$g() {
  if (hasRequiredLib$g) return lib$g;
  hasRequiredLib$g = 1;
  var Mutation = commonjsGlobal$1.MutationObserver || commonjsGlobal$1.WebKitMutationObserver;
  var scheduleDrain;
  if (process.browser) {
    if (Mutation) {
      var called = 0;
      var observer = new Mutation(nextTick);
      var element2 = commonjsGlobal$1.document.createTextNode("");
      observer.observe(element2, {
        characterData: true
      });
      scheduleDrain = function() {
        element2.data = called = ++called % 2;
      };
    } else if (!commonjsGlobal$1.setImmediate && typeof commonjsGlobal$1.MessageChannel !== "undefined") {
      var channel = new commonjsGlobal$1.MessageChannel();
      channel.port1.onmessage = nextTick;
      scheduleDrain = function() {
        channel.port2.postMessage(0);
      };
    } else if ("document" in commonjsGlobal$1 && "onreadystatechange" in commonjsGlobal$1.document.createElement("script")) {
      scheduleDrain = function() {
        var scriptEl = commonjsGlobal$1.document.createElement("script");
        scriptEl.onreadystatechange = function() {
          nextTick();
          scriptEl.onreadystatechange = null;
          scriptEl.parentNode.removeChild(scriptEl);
          scriptEl = null;
        };
        commonjsGlobal$1.document.documentElement.appendChild(scriptEl);
      };
    } else {
      scheduleDrain = function() {
        setTimeout(nextTick, 0);
      };
    }
  } else {
    scheduleDrain = function() {
      process.nextTick(nextTick);
    };
  }
  var draining;
  var queue2 = [];
  function nextTick() {
    draining = true;
    var i, oldQueue;
    var len = queue2.length;
    while (len) {
      oldQueue = queue2;
      queue2 = [];
      i = -1;
      while (++i < len) {
        oldQueue[i]();
      }
      len = queue2.length;
    }
    draining = false;
  }
  lib$g = immediate;
  function immediate(task) {
    if (queue2.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }
  return lib$g;
}
var lib$f;
var hasRequiredLib$f;
function requireLib$f() {
  if (hasRequiredLib$f) return lib$f;
  hasRequiredLib$f = 1;
  var immediate = requireLib$g();
  function INTERNAL2() {
  }
  var handlers = {};
  var REJECTED = ["REJECTED"];
  var FULFILLED = ["FULFILLED"];
  var PENDING = ["PENDING"];
  if (!process.browser) {
    var UNHANDLED = ["UNHANDLED"];
  }
  lib$f = Promise2;
  function Promise2(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function");
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = void 0;
    if (!process.browser) {
      this.handled = UNHANDLED;
    }
    if (resolver !== INTERNAL2) {
      safelyResolveThenable(this, resolver);
    }
  }
  Promise2.prototype.finally = function(callback) {
    if (typeof callback !== "function") {
      return this;
    }
    var p = this.constructor;
    return this.then(resolve2, reject2);
    function resolve2(value) {
      function yes() {
        return value;
      }
      return p.resolve(callback()).then(yes);
    }
    function reject2(reason) {
      function no() {
        throw reason;
      }
      return p.resolve(callback()).then(no);
    }
  };
  Promise2.prototype.catch = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
      return this;
    }
    var promise2 = new this.constructor(INTERNAL2);
    if (!process.browser) {
      if (this.handled === UNHANDLED) {
        this.handled = null;
      }
    }
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise2, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise2, onFulfilled, onRejected));
    }
    return promise2;
  };
  function QueueItem(promise2, onFulfilled, onRejected) {
    this.promise = promise2;
    if (typeof onFulfilled === "function") {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === "function") {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function(value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function(value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function(value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function(value) {
    unwrap(this.promise, this.onRejected, value);
  };
  function unwrap(promise2, func, value) {
    immediate(function() {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e) {
        return handlers.reject(promise2, e);
      }
      if (returnValue === promise2) {
        handlers.reject(promise2, new TypeError("Cannot resolve promise with itself"));
      } else {
        handlers.resolve(promise2, returnValue);
      }
    });
  }
  handlers.resolve = function(self2, value) {
    var result = tryCatch(getThen, value);
    if (result.status === "error") {
      return handlers.reject(self2, result.value);
    }
    var thenable = result.value;
    if (thenable) {
      safelyResolveThenable(self2, thenable);
    } else {
      self2.state = FULFILLED;
      self2.outcome = value;
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callFulfilled(value);
      }
    }
    return self2;
  };
  handlers.reject = function(self2, error) {
    self2.state = REJECTED;
    self2.outcome = error;
    if (!process.browser) {
      if (self2.handled === UNHANDLED) {
        immediate(function() {
          if (self2.handled === UNHANDLED) {
            process.emit("unhandledRejection", error, self2);
          }
        });
      }
    }
    var i = -1;
    var len = self2.queue.length;
    while (++i < len) {
      self2.queue[i].callRejected(error);
    }
    return self2;
  };
  function getThen(obj) {
    var then = obj && obj.then;
    if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }
  function safelyResolveThenable(self2, thenable) {
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self2, value);
    }
    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self2, value);
    }
    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }
    var result = tryCatch(tryToUnwrap);
    if (result.status === "error") {
      onError(result.value);
    }
  }
  function tryCatch(func, value) {
    var out = {};
    try {
      out.value = func(value);
      out.status = "success";
    } catch (e) {
      out.status = "error";
      out.value = e;
    }
    return out;
  }
  Promise2.resolve = resolve;
  function resolve(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL2), value);
  }
  Promise2.reject = reject;
  function reject(reason) {
    var promise2 = new this(INTERNAL2);
    return handlers.reject(promise2, reason);
  }
  Promise2.all = all;
  function all(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var values = new Array(len);
    var resolved = 0;
    var i = -1;
    var promise2 = new this(INTERNAL2);
    while (++i < len) {
      allResolver(iterable[i], i);
    }
    return promise2;
    function allResolver(value, i2) {
      self2.resolve(value).then(resolveFromAll, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error);
        }
      });
      function resolveFromAll(outValue) {
        values[i2] = outValue;
        if (++resolved === len && !called) {
          called = true;
          handlers.resolve(promise2, values);
        }
      }
    }
  }
  Promise2.race = race2;
  function race2(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var i = -1;
    var promise2 = new this(INTERNAL2);
    while (++i < len) {
      resolver(iterable[i]);
    }
    return promise2;
    function resolver(value) {
      self2.resolve(value).then(function(response) {
        if (!called) {
          called = true;
          handlers.resolve(promise2, response);
        }
      }, function(error) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error);
        }
      });
    }
  }
  return lib$f;
}
var external;
var hasRequiredExternal;
function requireExternal() {
  if (hasRequiredExternal) return external;
  hasRequiredExternal = 1;
  var ES6Promise = null;
  if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
  } else {
    ES6Promise = requireLib$f();
  }
  external = {
    Promise: ES6Promise
  };
  return external;
}
var setImmediate$1 = {};
var hasRequiredSetImmediate;
function requireSetImmediate() {
  if (hasRequiredSetImmediate) return setImmediate$1;
  hasRequiredSetImmediate = 1;
  (function(global2, undefined$1) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined$1, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel();
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html2 = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html2.removeChild(script);
          script = null;
        };
        html2.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof commonjsGlobal$1 === "undefined" ? setImmediate$1 : commonjsGlobal$1 : self);
  return setImmediate$1;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  (function(exports$1) {
    var support2 = requireSupport();
    var base642 = requireBase64$2();
    var nodejsUtils2 = requireNodejsUtils();
    var external2 = requireExternal();
    requireSetImmediate();
    function string2binary(str) {
      var result = null;
      if (support2.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports$1.newBlob = function(part2, type2) {
      exports$1.checkSupport("blob");
      try {
        return new Blob([part2], {
          type: type2
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder2 = new Builder();
          builder2.append(part2);
          return builder2.getBlob(type2);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type2, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type2 === "array" || type2 === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: (function() {
          try {
            return support2.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: (function() {
          try {
            return support2.nodebuffer && String.fromCharCode.apply(null, nodejsUtils2.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        })()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type2 = exports$1.getTypeOf(array), canUseApply = true;
      if (type2 === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type2 === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type2, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports$1.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils2.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports$1.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports$1.checkSupport(outputType);
      var inputType = exports$1.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports$1.resolve = function(path2) {
      var parts = path2.split("/");
      var result = [];
      for (var index = 0; index < parts.length; index++) {
        var part2 = parts[index];
        if (part2 === "." || part2 === "" && index !== 0 && index !== parts.length - 1) {
          continue;
        } else if (part2 === "..") {
          result.pop();
        } else {
          result.push(part2);
        }
      }
      return result.join("/");
    };
    exports$1.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support2.nodebuffer && nodejsUtils2.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support2.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support2.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports$1.checkSupport = function(type2) {
      var supported = support2[type2.toLowerCase()];
      if (!supported) {
        throw new Error(type2 + " is not supported by this platform");
      }
    };
    exports$1.MAX_VALUE_16BITS = 65535;
    exports$1.MAX_VALUE_32BITS = -1;
    exports$1.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports$1.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports$1.inherits = function(ctor, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports$1.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports$1.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise2 = external2.Promise.resolve(inputData).then(function(data) {
        var isBlob2 = support2.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob2 && typeof FileReader !== "undefined") {
          return new external2.Promise(function(resolve, reject) {
            var reader2 = new FileReader();
            reader2.onload = function(e) {
              resolve(e.target.result);
            };
            reader2.onerror = function(e) {
              reject(e.target.error);
            };
            reader2.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise2.then(function(data) {
        var dataType = exports$1.getTypeOf(data);
        if (!dataType) {
          return external2.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports$1.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base642.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  })(utils$1);
  return utils$1;
}
var GenericWorker_1;
var hasRequiredGenericWorker;
function requireGenericWorker() {
  if (hasRequiredGenericWorker) return GenericWorker_1;
  hasRequiredGenericWorker = 1;
  function GenericWorker(name) {
    this.name = name || "default";
    this.streamInfo = {};
    this.generatedError = null;
    this.extraStreamInfo = {};
    this.isPaused = true;
    this.isFinished = false;
    this.isLocked = false;
    this._listeners = {
      "data": [],
      "end": [],
      "error": []
    };
    this.previous = null;
  }
  GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push: function(chunk) {
      this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end: function() {
      if (this.isFinished) {
        return false;
      }
      this.flush();
      try {
        this.emit("end");
        this.cleanUp();
        this.isFinished = true;
      } catch (e) {
        this.emit("error", e);
      }
      return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error: function(e) {
      if (this.isFinished) {
        return false;
      }
      if (this.isPaused) {
        this.generatedError = e;
      } else {
        this.isFinished = true;
        this.emit("error", e);
        if (this.previous) {
          this.previous.error(e);
        }
        this.cleanUp();
      }
      return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on: function(name, listener) {
      this._listeners[name].push(listener);
      return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp: function() {
      this.streamInfo = this.generatedError = this.extraStreamInfo = null;
      this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit: function(name, arg) {
      if (this._listeners[name]) {
        for (var i = 0; i < this._listeners[name].length; i++) {
          this._listeners[name][i].call(this, arg);
        }
      }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe: function(next) {
      return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious: function(previous) {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.streamInfo = previous.streamInfo;
      this.mergeStreamInfo();
      this.previous = previous;
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.end();
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause: function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = true;
      if (this.previous) {
        this.previous.pause();
      }
      return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume: function() {
      if (!this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = false;
      var withError = false;
      if (this.generatedError) {
        this.error(this.generatedError);
        withError = true;
      }
      if (this.previous) {
        this.previous.resume();
      }
      return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush: function() {
    },
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk: function(chunk) {
      this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo: function(key, value) {
      this.extraStreamInfo[key] = value;
      this.mergeStreamInfo();
      return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo: function() {
      for (var key in this.extraStreamInfo) {
        if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
          continue;
        }
        this.streamInfo[key] = this.extraStreamInfo[key];
      }
    },
    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function() {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.isLocked = true;
      if (this.previous) {
        this.previous.lock();
      }
    },
    /**
     *
     * Pretty print the workers chain.
     */
    toString: function() {
      var me = "Worker " + this.name;
      if (this.previous) {
        return this.previous + " -> " + me;
      } else {
        return me;
      }
    }
  };
  GenericWorker_1 = GenericWorker;
  return GenericWorker_1;
}
var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  (function(exports$1) {
    var utils2 = requireUtils();
    var support2 = requireSupport();
    var nodejsUtils2 = requireNodejsUtils();
    var GenericWorker = requireGenericWorker();
    var _utf8len = new Array(256);
    for (var i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support2.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
    var buf2string = function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils2.applyFromCharCode(utf16buf);
    };
    exports$1.utf8encode = function utf8encode(str) {
      if (support2.nodebuffer) {
        return nodejsUtils2.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports$1.utf8decode = function utf8decode(buf) {
      if (support2.nodebuffer) {
        return utils2.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils2.transformTo(support2.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils2.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk) {
      var data = utils2.transformTo(support2.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support2.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support2.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports$1.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports$1.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports$1.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils2.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: exports$1.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports$1.Utf8EncodeWorker = Utf8EncodeWorker;
  })(utf8);
  return utf8;
}
var ConvertWorker_1;
var hasRequiredConvertWorker;
function requireConvertWorker() {
  if (hasRequiredConvertWorker) return ConvertWorker_1;
  hasRequiredConvertWorker = 1;
  var GenericWorker = requireGenericWorker();
  var utils2 = requireUtils();
  function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  utils2.inherits(ConvertWorker, GenericWorker);
  ConvertWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: utils2.transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  ConvertWorker_1 = ConvertWorker;
  return ConvertWorker_1;
}
var NodejsStreamOutputAdapter_1;
var hasRequiredNodejsStreamOutputAdapter;
function requireNodejsStreamOutputAdapter() {
  if (hasRequiredNodejsStreamOutputAdapter) return NodejsStreamOutputAdapter_1;
  hasRequiredNodejsStreamOutputAdapter = 1;
  var Readable2 = requireReadable$1().Readable;
  var utils2 = requireUtils();
  utils2.inherits(NodejsStreamOutputAdapter, Readable2);
  function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable2.call(this, options);
    this._helper = helper;
    var self2 = this;
    helper.on("data", function(data, meta) {
      if (!self2.push(data)) {
        self2._helper.pause();
      }
      if (updateCb) {
        updateCb(meta);
      }
    }).on("error", function(e) {
      self2.emit("error", e);
    }).on("end", function() {
      self2.push(null);
    });
  }
  NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
  };
  NodejsStreamOutputAdapter_1 = NodejsStreamOutputAdapter;
  return NodejsStreamOutputAdapter_1;
}
var StreamHelper_1;
var hasRequiredStreamHelper;
function requireStreamHelper() {
  if (hasRequiredStreamHelper) return StreamHelper_1;
  hasRequiredStreamHelper = 1;
  var utils2 = requireUtils();
  var ConvertWorker = requireConvertWorker();
  var GenericWorker = requireGenericWorker();
  var base642 = requireBase64$2();
  var support2 = requireSupport();
  var external2 = requireExternal();
  var NodejsStreamOutputAdapter = null;
  if (support2.nodestream) {
    try {
      NodejsStreamOutputAdapter = requireNodejsStreamOutputAdapter();
    } catch (e) {
    }
  }
  function transformZipOutput(type2, content, mimeType) {
    switch (type2) {
      case "blob":
        return utils2.newBlob(utils2.transformTo("arraybuffer", content), mimeType);
      case "base64":
        return base642.encode(content);
      default:
        return utils2.transformTo(type2, content);
    }
  }
  function concat(type2, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for (i = 0; i < dataArray.length; i++) {
      totalLength += dataArray[i].length;
    }
    switch (type2) {
      case "string":
        return dataArray.join("");
      case "array":
        return Array.prototype.concat.apply([], dataArray);
      case "uint8array":
        res = new Uint8Array(totalLength);
        for (i = 0; i < dataArray.length; i++) {
          res.set(dataArray[i], index);
          index += dataArray[i].length;
        }
        return res;
      case "nodebuffer":
        return Buffer.concat(dataArray);
      default:
        throw new Error("concat : unsupported type '" + type2 + "'");
    }
  }
  function accumulate(helper, updateCallback) {
    return new external2.Promise(function(resolve, reject) {
      var dataArray = [];
      var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
      helper.on("data", function(data, meta) {
        dataArray.push(data);
        if (updateCallback) {
          updateCallback(meta);
        }
      }).on("error", function(err) {
        dataArray = [];
        reject(err);
      }).on("end", function() {
        try {
          var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
          resolve(result);
        } catch (e) {
          reject(e);
        }
        dataArray = [];
      }).resume();
    });
  }
  function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
      case "blob":
      case "arraybuffer":
        internalType = "uint8array";
        break;
      case "base64":
        internalType = "string";
        break;
    }
    try {
      this._internalType = internalType;
      this._outputType = outputType;
      this._mimeType = mimeType;
      utils2.checkSupport(internalType);
      this._worker = worker.pipe(new ConvertWorker(internalType));
      worker.lock();
    } catch (e) {
      this._worker = new GenericWorker("error");
      this._worker.error(e);
    }
  }
  StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate: function(updateCb) {
      return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on: function(evt, fn) {
      var self2 = this;
      if (evt === "data") {
        this._worker.on(evt, function(chunk) {
          fn.call(self2, chunk.data, chunk.meta);
        });
      } else {
        this._worker.on(evt, function() {
          utils2.delay(fn, arguments, self2);
        });
      }
      return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume: function() {
      utils2.delay(this._worker.resume, [], this._worker);
      return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause: function() {
      this._worker.pause();
      return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream: function(updateCb) {
      utils2.checkSupport("nodestream");
      if (this._outputType !== "nodebuffer") {
        throw new Error(this._outputType + " is not supported by this method");
      }
      return new NodejsStreamOutputAdapter(this, {
        objectMode: this._outputType !== "nodebuffer"
      }, updateCb);
    }
  };
  StreamHelper_1 = StreamHelper;
  return StreamHelper_1;
}
var defaults = {};
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults;
  hasRequiredDefaults = 1;
  defaults.base64 = false;
  defaults.binary = false;
  defaults.dir = false;
  defaults.createFolders = true;
  defaults.date = null;
  defaults.compression = null;
  defaults.compressionOptions = null;
  defaults.comment = null;
  defaults.unixPermissions = null;
  defaults.dosPermissions = null;
  return defaults;
}
var DataWorker_1;
var hasRequiredDataWorker;
function requireDataWorker() {
  if (hasRequiredDataWorker) return DataWorker_1;
  hasRequiredDataWorker = 1;
  var utils2 = requireUtils();
  var GenericWorker = requireGenericWorker();
  var DEFAULT_BLOCK_SIZE = 16 * 1024;
  function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self2 = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self2.dataIsReady = true;
      self2.data = data;
      self2.max = data && data.length || 0;
      self2.type = utils2.getTypeOf(data);
      if (!self2.isPaused) {
        self2._tickAndRepeat();
      }
    }, function(e) {
      self2.error(e);
    });
  }
  utils2.inherits(DataWorker, GenericWorker);
  DataWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      utils2.delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      utils2.delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker.prototype._tick = function() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
        case "nodebuffer":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  DataWorker_1 = DataWorker;
  return DataWorker_1;
}
var crc32_1$1;
var hasRequiredCrc32$1;
function requireCrc32$1() {
  if (hasRequiredCrc32$1) return crc32_1$1;
  hasRequiredCrc32$1 = 1;
  var utils2 = requireUtils();
  function makeTable() {
    var c, table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
    }
    return crc ^ -1;
  }
  crc32_1$1 = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
      return 0;
    }
    var isArray = utils2.getTypeOf(input) !== "string";
    if (isArray) {
      return crc32(crc | 0, input, input.length, 0);
    } else {
      return crc32str(crc | 0, input, input.length, 0);
    }
  };
  return crc32_1$1;
}
var Crc32Probe_1;
var hasRequiredCrc32Probe;
function requireCrc32Probe() {
  if (hasRequiredCrc32Probe) return Crc32Probe_1;
  hasRequiredCrc32Probe = 1;
  var GenericWorker = requireGenericWorker();
  var crc32 = requireCrc32$1();
  var utils2 = requireUtils();
  function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  utils2.inherits(Crc32Probe, GenericWorker);
  Crc32Probe.prototype.processChunk = function(chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  Crc32Probe_1 = Crc32Probe;
  return Crc32Probe_1;
}
var DataLengthProbe_1;
var hasRequiredDataLengthProbe;
function requireDataLengthProbe() {
  if (hasRequiredDataLengthProbe) return DataLengthProbe_1;
  hasRequiredDataLengthProbe = 1;
  var utils2 = requireUtils();
  var GenericWorker = requireGenericWorker();
  function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  utils2.inherits(DataLengthProbe, GenericWorker);
  DataLengthProbe.prototype.processChunk = function(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
  };
  DataLengthProbe_1 = DataLengthProbe;
  return DataLengthProbe_1;
}
var compressedObject;
var hasRequiredCompressedObject;
function requireCompressedObject() {
  if (hasRequiredCompressedObject) return compressedObject;
  hasRequiredCompressedObject = 1;
  var external2 = requireExternal();
  var DataWorker = requireDataWorker();
  var Crc32Probe = requireCrc32Probe();
  var DataLengthProbe = requireDataLengthProbe();
  function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
  }
  CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker: function() {
      var worker = new DataWorker(external2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
      var that = this;
      worker.on("end", function() {
        if (this.streamInfo["data_length"] !== that.uncompressedSize) {
          throw new Error("Bug : uncompressed data size mismatch");
        }
      });
      return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker: function() {
      return new DataWorker(external2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
  };
  CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
  };
  compressedObject = CompressedObject;
  return compressedObject;
}
var zipObject;
var hasRequiredZipObject;
function requireZipObject() {
  if (hasRequiredZipObject) return zipObject;
  hasRequiredZipObject = 1;
  var StreamHelper = requireStreamHelper();
  var DataWorker = requireDataWorker();
  var utf82 = requireUtf8();
  var CompressedObject = requireCompressedObject();
  var GenericWorker = requireGenericWorker();
  var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;
    this._data = data;
    this._dataBinary = options.binary;
    this.options = {
      compression: options.compression,
      compressionOptions: options.compressionOptions
    };
  };
  ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function(type2) {
      var result = null, outputType = "string";
      try {
        if (!type2) {
          throw new Error("No output type specified.");
        }
        outputType = type2.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
          outputType = "string";
        }
        result = this._decompressWorker();
        var isUnicodeString = !this._dataBinary;
        if (isUnicodeString && !askUnicodeString) {
          result = result.pipe(new utf82.Utf8EncodeWorker());
        }
        if (!isUnicodeString && askUnicodeString) {
          result = result.pipe(new utf82.Utf8DecodeWorker());
        }
      } catch (e) {
        result = new GenericWorker("error");
        result.error(e);
      }
      return new StreamHelper(result, outputType, "");
    },
    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function(type2, onUpdate) {
      return this.internalStream(type2).accumulate(onUpdate);
    },
    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function(type2, onUpdate) {
      return this.internalStream(type2 || "nodebuffer").toNodejsStream(onUpdate);
    },
    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function(compression, compressionOptions) {
      if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
        return this._data.getCompressedWorker();
      } else {
        var result = this._decompressWorker();
        if (!this._dataBinary) {
          result = result.pipe(new utf82.Utf8EncodeWorker());
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
      }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker: function() {
      if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
      } else if (this._data instanceof GenericWorker) {
        return this._data;
      } else {
        return new DataWorker(this._data);
      }
    }
  };
  var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
  var removedFn = function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  };
  for (var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
  }
  zipObject = ZipObject;
  return zipObject;
}
var generate = {};
var compressions = {};
var flate = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  (function(exports$1) {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports$1.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports$1.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports$1.setTyped = function(on) {
      if (on) {
        exports$1.Buf8 = Uint8Array;
        exports$1.Buf16 = Uint16Array;
        exports$1.Buf32 = Int32Array;
        exports$1.assign(exports$1, fnTyped);
      } else {
        exports$1.Buf8 = Array;
        exports$1.Buf16 = Array;
        exports$1.Buf32 = Array;
        exports$1.assign(exports$1, fnUntyped);
      }
    };
    exports$1.setTyped(TYPED_OK);
  })(common);
  return common;
}
var deflate$1 = {};
var deflate = {};
var trees = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var utils2 = requireCommon();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist2) {
    return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
  }
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  function send_code(s, c, tree) {
    send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist2;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist2 = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist2;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist2++] = code;
      }
    }
    dist2 >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist2 << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist2++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s) {
    var n;
    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils2.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  function compress_block(s, ltree, dtree) {
    var dist2;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist2 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist2 === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist2--;
          code = d_code(dist2);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist2 -= base_dist[code];
            send_bits(s, dist2, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node2;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node2 = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node2 * 2] = 1;
      s.depth[node2] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node2 * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node2 = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node2 * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node2] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node2;
      s.heap[
        1
        /*SMALLEST*/
      ] = node2++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len);
  }
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  function _tr_tally(s, dist2, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist2 >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist2 & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist2 === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist2--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist2) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  trees._tr_init = _tr_init;
  trees._tr_stored_block = _tr_stored_block;
  trees._tr_flush_block = _tr_flush_block;
  trees._tr_tally = _tr_tally;
  trees._tr_align = _tr_align;
  return trees;
}
var adler32_1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  hasRequiredAdler32 = 1;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  adler32_1 = adler32;
  return adler32_1;
}
var crc32_1;
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  function makeTable() {
    var c, table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  crc32_1 = crc32;
  return crc32_1;
}
var messages;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages;
}
var hasRequiredDeflate$1;
function requireDeflate$1() {
  if (hasRequiredDeflate$1) return deflate;
  hasRequiredDeflate$1 = 1;
  var utils2 = requireCommon();
  var trees2 = requireTrees();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var msg = requireMessages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils2.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  function flush_block_only(s, last) {
    trees2._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils2.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils2.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees2._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s, flush) {
    var bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils2.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils2.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils2.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils2.Buf16(MAX_BITS + 1);
    this.heap = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees2._tr_init(s);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method2, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method2 !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils2.Buf8(s.w_size * 2);
    s.head = new utils2.Buf16(s.hash_size);
    s.prev = new utils2.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils2.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method2;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate$12(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees2._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees2._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils2.Buf8(s.w_size);
      utils2.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  deflate.deflateInit = deflateInit;
  deflate.deflateInit2 = deflateInit2;
  deflate.deflateReset = deflateReset;
  deflate.deflateResetKeep = deflateResetKeep;
  deflate.deflateSetHeader = deflateSetHeader;
  deflate.deflate = deflate$12;
  deflate.deflateEnd = deflateEnd;
  deflate.deflateSetDictionary = deflateSetDictionary;
  deflate.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  var utils2 = requireCommon();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils2.Buf8(256);
  for (var q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  strings.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new utils2.Buf8(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils2.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  strings.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  strings.binstring2buf = function(str) {
    var buf = new utils2.Buf8(str.length);
    for (var i = 0, len = buf.length; i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  };
  strings.buf2string = function(buf, max2) {
    var i, out, c, c_len;
    var len = max2 || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  strings.utf8border = function(buf, max2) {
    var pos;
    max2 = max2 || buf.length;
    if (max2 > buf.length) {
      max2 = buf.length;
    }
    pos = max2 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max2;
    }
    if (pos === 0) {
      return max2;
    }
    return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
  };
  return strings;
}
var zstream;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  hasRequiredZstream = 1;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  zstream = ZStream;
  return zstream;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate$1;
  hasRequiredDeflate = 1;
  var zlib_deflate = requireDeflate$1();
  var utils2 = requireCommon();
  var strings2 = requireStrings();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate)) return new Deflate(options);
    this.options = utils2.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings2.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings2.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings2.buf2binstring(utils2.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate2(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate2(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate2(input, options);
  }
  deflate$1.Deflate = Deflate;
  deflate$1.deflate = deflate2;
  deflate$1.deflateRaw = deflateRaw;
  deflate$1.gzip = gzip;
  return deflate$1;
}
var inflate$1 = {};
var inflate = {};
var inffast;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  var BAD = 30;
  var TYPE2 = 12;
  inffast = function inflate_fast(strm, start) {
    var state2;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist2;
    var from;
    var from_source;
    var input, output;
    state2 = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state2.dmax;
    wsize = state2.wsize;
    whave = state2.whave;
    wnext = state2.wnext;
    s_window = state2.window;
    hold = state2.hold;
    bits = state2.bits;
    lcode = state2.lencode;
    dcode = state2.distcode;
    lmask = (1 << state2.lenbits) - 1;
    dmask = (1 << state2.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist2 = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist2 += hold & (1 << op) - 1;
                    if (dist2 > dmax) {
                      strm.msg = "invalid distance too far back";
                      state2.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist2 > op) {
                      op = dist2 - op;
                      if (op > whave) {
                        if (state2.sane) {
                          strm.msg = "invalid distance too far back";
                          state2.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist2;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist2;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state2.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state2.mode = TYPE2;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state2.hold = hold;
    state2.bits = bits;
    return;
  };
  return inffast;
}
var inftrees;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var utils2 = requireCommon();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  inftrees = function inflate_table(type2, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min2 = 0, max2 = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils2.Buf16(MAXBITS + 1);
    var offs = new utils2.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max2 = MAXBITS; max2 >= 1; max2--) {
      if (count[max2] !== 0) {
        break;
      }
    }
    if (root > max2) {
      root = max2;
    }
    if (max2 === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min2 = 1; min2 < max2; min2++) {
      if (count[min2] !== 0) {
        break;
      }
    }
    if (root < min2) {
      root = min2;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max2 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra = work;
      end = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min2;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min2 = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max2) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min2;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max2) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  return inftrees;
}
var hasRequiredInflate$1;
function requireInflate$1() {
  if (hasRequiredInflate$1) return inflate;
  hasRequiredInflate$1 = 1;
  var utils2 = requireCommon();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var inflate_fast = requireInffast();
  var inflate_table = requireInftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE2 = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY2 = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils2.Buf16(320);
    this.work = new utils2.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    strm.total_in = strm.total_out = state2.total = 0;
    strm.msg = "";
    if (state2.wrap) {
      strm.adler = state2.wrap & 1;
    }
    state2.mode = HEAD;
    state2.last = 0;
    state2.havedict = 0;
    state2.dmax = 32768;
    state2.head = null;
    state2.hold = 0;
    state2.bits = 0;
    state2.lencode = state2.lendyn = new utils2.Buf32(ENOUGH_LENS);
    state2.distcode = state2.distdyn = new utils2.Buf32(ENOUGH_DISTS);
    state2.sane = 1;
    state2.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    state2.wsize = 0;
    state2.whave = 0;
    state2.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state2.window !== null && state2.wbits !== windowBits) {
      state2.window = null;
    }
    state2.wrap = wrap;
    state2.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state2;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state2 = new InflateState();
    strm.state = state2;
    state2.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state2) {
    if (virgin) {
      var sym;
      lenfix = new utils2.Buf32(512);
      distfix = new utils2.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state2.lens[sym++] = 8;
      }
      while (sym < 256) {
        state2.lens[sym++] = 9;
      }
      while (sym < 280) {
        state2.lens[sym++] = 7;
      }
      while (sym < 288) {
        state2.lens[sym++] = 8;
      }
      inflate_table(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state2.lens[sym++] = 5;
      }
      inflate_table(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, { bits: 5 });
      virgin = false;
    }
    state2.lencode = lenfix;
    state2.lenbits = 9;
    state2.distcode = distfix;
    state2.distbits = 5;
  }
  function updatewindow(strm, src, end, copy2) {
    var dist2;
    var state2 = strm.state;
    if (state2.window === null) {
      state2.wsize = 1 << state2.wbits;
      state2.wnext = 0;
      state2.whave = 0;
      state2.window = new utils2.Buf8(state2.wsize);
    }
    if (copy2 >= state2.wsize) {
      utils2.arraySet(state2.window, src, end - state2.wsize, state2.wsize, 0);
      state2.wnext = 0;
      state2.whave = state2.wsize;
    } else {
      dist2 = state2.wsize - state2.wnext;
      if (dist2 > copy2) {
        dist2 = copy2;
      }
      utils2.arraySet(state2.window, src, end - copy2, dist2, state2.wnext);
      copy2 -= dist2;
      if (copy2) {
        utils2.arraySet(state2.window, src, end - copy2, copy2, 0);
        state2.wnext = copy2;
        state2.whave = state2.wsize;
      } else {
        state2.wnext += dist2;
        if (state2.wnext === state2.wsize) {
          state2.wnext = 0;
        }
        if (state2.whave < state2.wsize) {
          state2.whave += dist2;
        }
      }
    }
    return 0;
  }
  function inflate$12(strm, flush) {
    var state2;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy2;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils2.Buf8(4);
    var opts;
    var n;
    var order2 = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if (state2.mode === TYPE2) {
      state2.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state2.hold;
    bits = state2.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state2.mode) {
          case HEAD:
            if (state2.wrap === 0) {
              state2.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 2 && hold === 35615) {
              state2.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state2.mode = FLAGS;
              break;
            }
            state2.flags = 0;
            if (state2.head) {
              state2.head.done = false;
            }
            if (!(state2.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state2.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state2.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state2.wbits === 0) {
              state2.wbits = len;
            } else if (len > state2.wbits) {
              strm.msg = "invalid window size";
              state2.mode = BAD;
              break;
            }
            state2.dmax = 1 << len;
            strm.adler = state2.check = 1;
            state2.mode = hold & 512 ? DICTID : TYPE2;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.flags = hold;
            if ((state2.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state2.mode = BAD;
              break;
            }
            if (state2.flags & 57344) {
              strm.msg = "unknown header flags set";
              state2.mode = BAD;
              break;
            }
            if (state2.head) {
              state2.head.text = hold >> 8 & 1;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.time = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state2.check = crc32(state2.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.xflags = hold & 255;
              state2.head.os = hold >> 8;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state2.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length = hold;
              if (state2.head) {
                state2.head.extra_len = hold;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc32(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state2.head) {
              state2.head.extra = null;
            }
            state2.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state2.flags & 1024) {
              copy2 = state2.length;
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2) {
                if (state2.head) {
                  len = state2.head.extra_len - state2.length;
                  if (!state2.head.extra) {
                    state2.head.extra = new Array(state2.head.extra_len);
                  }
                  utils2.arraySet(
                    state2.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy2,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state2.flags & 512) {
                  state2.check = crc32(state2.check, input, copy2, next);
                }
                have -= copy2;
                next += copy2;
                state2.length -= copy2;
              }
              if (state2.length) {
                break inf_leave;
              }
            }
            state2.length = 0;
            state2.mode = NAME;
          /* falls through */
          case NAME:
            if (state2.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next + copy2++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.name += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.name = null;
            }
            state2.length = 0;
            state2.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state2.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy2 = 0;
              do {
                len = input[next + copy2++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.comment += String.fromCharCode(len);
                }
              } while (len && copy2 < have);
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.comment = null;
            }
            state2.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state2.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state2.check & 65535)) {
                strm.msg = "header crc mismatch";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state2.head) {
              state2.head.hcrc = state2.flags >> 9 & 1;
              state2.head.done = true;
            }
            strm.adler = state2.check = 0;
            state2.mode = TYPE2;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state2.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state2.mode = DICT;
          /* falls through */
          case DICT:
            if (state2.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state2.check = 1;
            state2.mode = TYPE2;
          /* falls through */
          case TYPE2:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state2.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state2.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state2.mode = STORED;
                break;
              case 1:
                fixedtables(state2);
                state2.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state2.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state2.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state2.mode = BAD;
              break;
            }
            state2.length = hold & 65535;
            hold = 0;
            bits = 0;
            state2.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state2.mode = COPY2;
          /* falls through */
          case COPY2:
            copy2 = state2.length;
            if (copy2) {
              if (copy2 > have) {
                copy2 = have;
              }
              if (copy2 > left) {
                copy2 = left;
              }
              if (copy2 === 0) {
                break inf_leave;
              }
              utils2.arraySet(output, input, next, copy2, put);
              have -= copy2;
              next += copy2;
              left -= copy2;
              put += copy2;
              state2.length -= copy2;
              break;
            }
            state2.mode = TYPE2;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state2.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state2.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state2.nlen > 286 || state2.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state2.mode = BAD;
              break;
            }
            state2.have = 0;
            state2.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state2.have < state2.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.lens[order2[state2.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state2.have < 19) {
              state2.lens[order2[state2.have++]] = 0;
            }
            state2.lencode = state2.lendyn;
            state2.lenbits = 7;
            opts = { bits: state2.lenbits };
            ret = inflate_table(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
            state2.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state2.mode = BAD;
              break;
            }
            state2.have = 0;
            state2.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state2.have < state2.nlen + state2.ndist) {
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state2.lens[state2.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state2.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD;
                    break;
                  }
                  len = state2.lens[state2.have - 1];
                  copy2 = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy2 = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state2.have + copy2 > state2.nlen + state2.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                while (copy2--) {
                  state2.lens[state2.have++] = len;
                }
              }
            }
            if (state2.mode === BAD) {
              break;
            }
            if (state2.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state2.mode = BAD;
              break;
            }
            state2.lenbits = 9;
            opts = { bits: state2.lenbits };
            ret = inflate_table(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
            state2.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state2.mode = BAD;
              break;
            }
            state2.distbits = 6;
            state2.distcode = state2.distdyn;
            opts = { bits: state2.distbits };
            ret = inflate_table(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
            state2.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state2.mode = BAD;
              break;
            }
            state2.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state2.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state2.hold;
              bits = state2.bits;
              if (state2.mode === TYPE2) {
                state2.back = -1;
              }
              break;
            }
            state2.back = 0;
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            state2.length = here_val;
            if (here_op === 0) {
              state2.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state2.back = -1;
              state2.mode = TYPE2;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD;
              break;
            }
            state2.extra = here_op & 15;
            state2.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state2.extra) {
              n = state2.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            state2.was = state2.length;
            state2.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state2.distcode[hold & (1 << state2.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state2.mode = BAD;
              break;
            }
            state2.offset = here_val;
            state2.extra = here_op & 15;
            state2.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state2.extra) {
              n = state2.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.offset += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            if (state2.offset > state2.dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD;
              break;
            }
            state2.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy2 = _out - left;
            if (state2.offset > copy2) {
              copy2 = state2.offset - copy2;
              if (copy2 > state2.whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD;
                  break;
                }
              }
              if (copy2 > state2.wnext) {
                copy2 -= state2.wnext;
                from = state2.wsize - copy2;
              } else {
                from = state2.wnext - copy2;
              }
              if (copy2 > state2.length) {
                copy2 = state2.length;
              }
              from_source = state2.window;
            } else {
              from_source = output;
              from = put - state2.offset;
              copy2 = state2.length;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            left -= copy2;
            state2.length -= copy2;
            do {
              output[put++] = from_source[from++];
            } while (--copy2);
            if (state2.length === 0) {
              state2.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state2.length;
            left--;
            state2.mode = LEN;
            break;
          case CHECK:
            if (state2.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state2.total += _out;
              if (_out) {
                strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
                state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
              }
              _out = left;
              if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
                strm.msg = "incorrect data check";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state2.wrap && state2.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state2.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state2.hold = hold;
    state2.bits = bits;
    if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state2.total += _out;
    if (state2.wrap && _out) {
      strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE2 ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state2 = strm.state;
    if (state2.window) {
      state2.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if ((state2.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state2.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state2;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if (state2.wrap !== 0 && state2.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state2.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state2.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state2.mode = MEM;
      return Z_MEM_ERROR;
    }
    state2.havedict = 1;
    return Z_OK;
  }
  inflate.inflateReset = inflateReset;
  inflate.inflateReset2 = inflateReset2;
  inflate.inflateResetKeep = inflateResetKeep;
  inflate.inflateInit = inflateInit;
  inflate.inflateInit2 = inflateInit2;
  inflate.inflate = inflate$12;
  inflate.inflateEnd = inflateEnd;
  inflate.inflateGetHeader = inflateGetHeader;
  inflate.inflateSetDictionary = inflateSetDictionary;
  inflate.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  constants = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants;
}
var gzheader;
var hasRequiredGzheader;
function requireGzheader() {
  if (hasRequiredGzheader) return gzheader;
  hasRequiredGzheader = 1;
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  gzheader = GZheader;
  return gzheader;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate$1;
  hasRequiredInflate = 1;
  var zlib_inflate = requireInflate$1();
  var utils2 = requireCommon();
  var strings2 = requireStrings();
  var c = requireConstants();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var GZheader = requireGzheader();
  var toString = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate)) return new Inflate(options);
    this.options = utils2.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== c.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings2.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings2.binstring2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
      if (status === c.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c.Z_BUF_ERROR && allowBufError === true) {
        status = c.Z_OK;
        allowBufError = false;
      }
      if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings2.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
    if (status === c.Z_STREAM_END) {
      _mode = c.Z_FINISH;
    }
    if (_mode === c.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c.Z_OK;
    }
    if (_mode === c.Z_SYNC_FLUSH) {
      this.onEnd(c.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate2(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate2(input, options);
  }
  inflate$1.Inflate = Inflate;
  inflate$1.inflate = inflate2;
  inflate$1.inflateRaw = inflateRaw;
  inflate$1.ungzip = inflate2;
  return inflate$1;
}
var pako_1;
var hasRequiredPako;
function requirePako() {
  if (hasRequiredPako) return pako_1;
  hasRequiredPako = 1;
  var assign = requireCommon().assign;
  var deflate2 = requireDeflate();
  var inflate2 = requireInflate();
  var constants2 = requireConstants();
  var pako = {};
  assign(pako, deflate2, inflate2, constants2);
  pako_1 = pako;
  return pako_1;
}
var hasRequiredFlate;
function requireFlate() {
  if (hasRequiredFlate) return flate;
  hasRequiredFlate = 1;
  var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var pako = requirePako();
  var utils2 = requireUtils();
  var GenericWorker = requireGenericWorker();
  var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
  flate.magic = "\b\0";
  function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  utils2.inherits(FlateWorker, GenericWorker);
  FlateWorker.prototype.processChunk = function(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(utils2.transformTo(ARRAY_TYPE, chunk.data), false);
  };
  FlateWorker.prototype.flush = function() {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker.prototype._createPako = function() {
    this._pako = new pako[this._pakoAction]({
      raw: true,
      level: this._pakoOptions.level || -1
      // default compression
    });
    var self2 = this;
    this._pako.onData = function(data) {
      self2.push({
        data,
        meta: self2.meta
      });
    };
  };
  flate.compressWorker = function(compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
  };
  flate.uncompressWorker = function() {
    return new FlateWorker("Inflate", {});
  };
  return flate;
}
var hasRequiredCompressions;
function requireCompressions() {
  if (hasRequiredCompressions) return compressions;
  hasRequiredCompressions = 1;
  var GenericWorker = requireGenericWorker();
  compressions.STORE = {
    magic: "\0\0",
    compressWorker: function() {
      return new GenericWorker("STORE compression");
    },
    uncompressWorker: function() {
      return new GenericWorker("STORE decompression");
    }
  };
  compressions.DEFLATE = requireFlate();
  return compressions;
}
var signature = {};
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  signature.LOCAL_FILE_HEADER = "PK";
  signature.CENTRAL_FILE_HEADER = "PK";
  signature.CENTRAL_DIRECTORY_END = "PK";
  signature.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
  signature.ZIP64_CENTRAL_DIRECTORY_END = "PK";
  signature.DATA_DESCRIPTOR = "PK\x07\b";
  return signature;
}
var ZipFileWorker_1;
var hasRequiredZipFileWorker;
function requireZipFileWorker() {
  if (hasRequiredZipFileWorker) return ZipFileWorker_1;
  hasRequiredZipFileWorker = 1;
  var utils2 = requireUtils();
  var GenericWorker = requireGenericWorker();
  var utf82 = requireUtf8();
  var crc32 = requireCrc32$1();
  var signature2 = requireSignature();
  var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
      hex += String.fromCharCode(dec & 255);
      dec = dec >>> 8;
    }
    return hex;
  };
  var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
    var result = unixPermissions;
    if (!unixPermissions) {
      result = isDir ? 16893 : 33204;
    }
    return (result & 65535) << 16;
  };
  var generateDosExternalFileAttr = function(dosPermissions) {
    return (dosPermissions || 0) & 63;
  };
  var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf82.utf8encode, encodedFileName = utils2.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils2.transformTo("string", utf82.utf8encode(file.name)), comment = file.comment, encodedComment = utils2.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils2.transformTo("string", utf82.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
    var dataInfo = {
      crc32: 0,
      compressedSize: 0,
      uncompressedSize: 0
    };
    if (!streamedContent || streamingEnded) {
      dataInfo.crc32 = streamInfo["crc32"];
      dataInfo.compressedSize = streamInfo["compressedSize"];
      dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
    }
    var bitflag = 0;
    if (streamedContent) {
      bitflag |= 8;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
      bitflag |= 2048;
    }
    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
      extFileAttr |= 16;
    }
    if (platform === "UNIX") {
      versionMadeBy = 798;
      extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else {
      versionMadeBy = 20;
      extFileAttr |= generateDosExternalFileAttr(file.dosPermissions);
    }
    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;
    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();
    if (useUTF8ForFileName) {
      unicodePathExtraField = // Version
      decToHex(1, 1) + // NameCRC32
      decToHex(crc32(encodedFileName), 4) + // UnicodeName
      utfEncodedFileName;
      extraFields += // Info-ZIP Unicode Path Extra Field
      "up" + // size
      decToHex(unicodePathExtraField.length, 2) + // content
      unicodePathExtraField;
    }
    if (useUTF8ForComment) {
      unicodeCommentExtraField = // Version
      decToHex(1, 1) + // CommentCRC32
      decToHex(crc32(encodedComment), 4) + // UnicodeName
      utfEncodedComment;
      extraFields += // Info-ZIP Unicode Path Extra Field
      "uc" + // size
      decToHex(unicodeCommentExtraField.length, 2) + // content
      unicodeCommentExtraField;
    }
    var header = "";
    header += "\n\0";
    header += decToHex(bitflag, 2);
    header += compression.magic;
    header += decToHex(dosTime, 2);
    header += decToHex(dosDate, 2);
    header += decToHex(dataInfo.crc32, 4);
    header += decToHex(dataInfo.compressedSize, 4);
    header += decToHex(dataInfo.uncompressedSize, 4);
    header += decToHex(encodedFileName.length, 2);
    header += decToHex(extraFields.length, 2);
    var fileRecord = signature2.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
    var dirRecord = signature2.CENTRAL_FILE_HEADER + // version made by (00: DOS)
    decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
    header + // file comment length
    decToHex(encodedComment.length, 2) + // disk number start
    "\0\0\0\0" + // external file attributes
    decToHex(extFileAttr, 4) + // relative offset of local header
    decToHex(offset, 4) + // file name
    encodedFileName + // extra field
    extraFields + // file comment
    encodedComment;
    return {
      fileRecord,
      dirRecord
    };
  };
  var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils2.transformTo("string", encodeFileName(comment));
    dirEnd = signature2.CENTRAL_DIRECTORY_END + // number of this disk
    "\0\0\0\0" + // total number of entries in the central directory on this disk
    decToHex(entriesCount, 2) + // total number of entries in the central directory
    decToHex(entriesCount, 2) + // size of the central directory   4 bytes
    decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
    decToHex(localDirLength, 4) + // .ZIP file comment length
    decToHex(encodedComment.length, 2) + // .ZIP file comment
    encodedComment;
    return dirEnd;
  };
  var generateDataDescriptors = function(streamInfo) {
    var descriptor = "";
    descriptor = signature2.DATA_DESCRIPTOR + // crc-32                          4 bytes
    decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
    decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
    decToHex(streamInfo["uncompressedSize"], 4);
    return descriptor;
  };
  function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  utils2.inherits(ZipFileWorker, GenericWorker);
  ZipFileWorker.prototype.push = function(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker.prototype.openedSource = function(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker.prototype.closedSource = function(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker.prototype.flush = function() {
    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker.prototype.prepareNextSource = function() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker.prototype.registerPrevious = function(previous) {
    this._sources.push(previous);
    var self2 = this;
    previous.on("data", function(chunk) {
      self2.processChunk(chunk);
    });
    previous.on("end", function() {
      self2.closedSource(self2.previous.streamInfo);
      if (self2._sources.length) {
        self2.prepareNextSource();
      } else {
        self2.end();
      }
    });
    previous.on("error", function(e) {
      self2.error(e);
    });
    return this;
  };
  ZipFileWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker.prototype.error = function(e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0; i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e2) {
      }
    }
    return true;
  };
  ZipFileWorker.prototype.lock = function() {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
      sources[i].lock();
    }
  };
  ZipFileWorker_1 = ZipFileWorker;
  return ZipFileWorker_1;
}
var hasRequiredGenerate;
function requireGenerate() {
  if (hasRequiredGenerate) return generate;
  hasRequiredGenerate = 1;
  var compressions2 = requireCompressions();
  var ZipFileWorker = requireZipFileWorker();
  var getCompression = function(fileCompression, zipCompression) {
    var compressionName = fileCompression || zipCompression;
    var compression = compressions2[compressionName];
    if (!compression) {
      throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
  };
  generate.generateWorker = function(zip, options, comment) {
    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {
      zip.forEach(function(relativePath, file) {
        entriesCount++;
        var compression = getCompression(file.options.compression, options.compression);
        var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
        var dir = file.dir, date = file.date;
        file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
          name: relativePath,
          dir,
          date,
          comment: file.comment || "",
          unixPermissions: file.unixPermissions,
          dosPermissions: file.dosPermissions
        }).pipe(zipFileWorker);
      });
      zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
      zipFileWorker.error(e);
    }
    return zipFileWorker;
  };
  return generate;
}
var NodejsStreamInputAdapter_1;
var hasRequiredNodejsStreamInputAdapter;
function requireNodejsStreamInputAdapter() {
  if (hasRequiredNodejsStreamInputAdapter) return NodejsStreamInputAdapter_1;
  hasRequiredNodejsStreamInputAdapter = 1;
  var utils2 = requireUtils();
  var GenericWorker = requireGenericWorker();
  function NodejsStreamInputAdapter(filename, stream2) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream2);
  }
  utils2.inherits(NodejsStreamInputAdapter, GenericWorker);
  NodejsStreamInputAdapter.prototype._bindStream = function(stream2) {
    var self2 = this;
    this._stream = stream2;
    stream2.pause();
    stream2.on("data", function(chunk) {
      self2.push({
        data: chunk,
        meta: {
          percent: 0
        }
      });
    }).on("error", function(e) {
      if (self2.isPaused) {
        this.generatedError = e;
      } else {
        self2.error(e);
      }
    }).on("end", function() {
      if (self2.isPaused) {
        self2._upstreamEnded = true;
      } else {
        self2.end();
      }
    });
  };
  NodejsStreamInputAdapter.prototype.pause = function() {
    if (!GenericWorker.prototype.pause.call(this)) {
      return false;
    }
    this._stream.pause();
    return true;
  };
  NodejsStreamInputAdapter.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (this._upstreamEnded) {
      this.end();
    } else {
      this._stream.resume();
    }
    return true;
  };
  NodejsStreamInputAdapter_1 = NodejsStreamInputAdapter;
  return NodejsStreamInputAdapter_1;
}
var object;
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  var utf82 = requireUtf8();
  var utils2 = requireUtils();
  var GenericWorker = requireGenericWorker();
  var StreamHelper = requireStreamHelper();
  var defaults2 = requireDefaults();
  var CompressedObject = requireCompressedObject();
  var ZipObject = requireZipObject();
  var generate2 = requireGenerate();
  var nodejsUtils2 = requireNodejsUtils();
  var NodejsStreamInputAdapter = requireNodejsStreamInputAdapter();
  var fileAdd = function(name, data, originalOptions) {
    var dataType = utils2.getTypeOf(data), parent;
    var o = utils2.extend(originalOptions || {}, defaults2);
    o.date = o.date || /* @__PURE__ */ new Date();
    if (o.compression !== null) {
      o.compression = o.compression.toUpperCase();
    }
    if (typeof o.unixPermissions === "string") {
      o.unixPermissions = parseInt(o.unixPermissions, 8);
    }
    if (o.unixPermissions && o.unixPermissions & 16384) {
      o.dir = true;
    }
    if (o.dosPermissions && o.dosPermissions & 16) {
      o.dir = true;
    }
    if (o.dir) {
      name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
      folderAdd.call(this, parent, true);
    }
    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
      o.binary = !isUnicodeString;
    }
    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
      o.base64 = false;
      o.binary = true;
      data = "";
      o.compression = "STORE";
      dataType = "string";
    }
    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
      zipObjectContent = data;
    } else if (nodejsUtils2.isNode && nodejsUtils2.isStream(data)) {
      zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
      zipObjectContent = utils2.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }
    var object2 = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object2;
  };
  var parentFolder = function(path2) {
    if (path2.slice(-1) === "/") {
      path2 = path2.substring(0, path2.length - 1);
    }
    var lastSlash = path2.lastIndexOf("/");
    return lastSlash > 0 ? path2.substring(0, lastSlash) : "";
  };
  var forceTrailingSlash = function(path2) {
    if (path2.slice(-1) !== "/") {
      path2 += "/";
    }
    return path2;
  };
  var folderAdd = function(name, createFolders) {
    createFolders = typeof createFolders !== "undefined" ? createFolders : defaults2.createFolders;
    name = forceTrailingSlash(name);
    if (!this.files[name]) {
      fileAdd.call(this, name, null, {
        dir: true,
        createFolders
      });
    }
    return this.files[name];
  };
  function isRegExp(object2) {
    return Object.prototype.toString.call(object2) === "[object RegExp]";
  }
  var out = {
    /**
     * @see loadAsync
     */
    load: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
      var filename, relativePath, file;
      for (filename in this.files) {
        file = this.files[filename];
        relativePath = filename.slice(this.root.length, filename.length);
        if (relativePath && filename.slice(0, this.root.length) === this.root) {
          cb(relativePath, file);
        }
      }
    },
    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
      var result = [];
      this.forEach(function(relativePath, entry) {
        if (search(relativePath, entry)) {
          result.push(entry);
        }
      });
      return result;
    },
    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
      if (arguments.length === 1) {
        if (isRegExp(name)) {
          var regexp = name;
          return this.filter(function(relativePath, file) {
            return !file.dir && regexp.test(relativePath);
          });
        } else {
          var obj = this.files[this.root + name];
          if (obj && !obj.dir) {
            return obj;
          } else {
            return null;
          }
        }
      } else {
        name = this.root + name;
        fileAdd.call(this, name, data, o);
      }
      return this;
    },
    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
      if (!arg) {
        return this;
      }
      if (isRegExp(arg)) {
        return this.filter(function(relativePath, file) {
          return file.dir && arg.test(relativePath);
        });
      }
      var name = this.root + arg;
      var newFolder = folderAdd.call(this, name);
      var ret = this.clone();
      ret.root = newFolder.name;
      return ret;
    },
    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
      name = this.root + name;
      var file = this.files[name];
      if (!file) {
        if (name.slice(-1) !== "/") {
          name += "/";
        }
        file = this.files[name];
      }
      if (file && !file.dir) {
        delete this.files[name];
      } else {
        var kids = this.filter(function(relativePath, file2) {
          return file2.name.slice(0, name.length) === name;
        });
        for (var i = 0; i < kids.length; i++) {
          delete this.files[kids[i].name];
        }
      }
      return this;
    },
    /**
     * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
     */
    generate: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
        opts = utils2.extend(options || {}, {
          streamFiles: false,
          compression: "STORE",
          compressionOptions: null,
          type: "",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf82.utf8encode
        });
        opts.type = opts.type.toLowerCase();
        opts.compression = opts.compression.toUpperCase();
        if (opts.type === "binarystring") {
          opts.type = "string";
        }
        if (!opts.type) {
          throw new Error("No output type specified.");
        }
        utils2.checkSupport(opts.type);
        if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
          opts.platform = "UNIX";
        }
        if (opts.platform === "win32") {
          opts.platform = "DOS";
        }
        var comment = opts.comment || this.comment || "";
        worker = generate2.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
      return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
      options = options || {};
      if (!options.type) {
        options.type = "nodebuffer";
      }
      return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
  };
  object = out;
  return object;
}
var DataReader_1;
var hasRequiredDataReader;
function requireDataReader() {
  if (hasRequiredDataReader) return DataReader_1;
  hasRequiredDataReader = 1;
  var utils2 = requireUtils();
  function DataReader(data) {
    this.data = data;
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
  }
  DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
      this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
      if (this.length < this.zero + newIndex || newIndex < 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
      }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
      this.checkIndex(newIndex);
      this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
      this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function() {
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
      var result = 0, i;
      this.checkOffset(size);
      for (i = this.index + size - 1; i >= this.index; i--) {
        result = (result << 8) + this.byteAt(i);
      }
      this.index += size;
      return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
      return utils2.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function() {
    },
    /**
     * Find the last occurrence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurrence, -1 if not found.
     */
    lastIndexOfSignature: function() {
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function() {
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
      var dostime = this.readInt(4);
      return new Date(Date.UTC(
        (dostime >> 25 & 127) + 1980,
        // year
        (dostime >> 21 & 15) - 1,
        // month
        dostime >> 16 & 31,
        // day
        dostime >> 11 & 31,
        // hour
        dostime >> 5 & 63,
        // minute
        (dostime & 31) << 1
      ));
    }
  };
  DataReader_1 = DataReader;
  return DataReader_1;
}
var ArrayReader_1;
var hasRequiredArrayReader;
function requireArrayReader() {
  if (hasRequiredArrayReader) return ArrayReader_1;
  hasRequiredArrayReader = 1;
  var DataReader = requireDataReader();
  var utils2 = requireUtils();
  function ArrayReader(data) {
    DataReader.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
      data[i] = data[i] & 255;
    }
  }
  utils2.inherits(ArrayReader, DataReader);
  ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
  };
  ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader.prototype.readAndCheckSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  ArrayReader_1 = ArrayReader;
  return ArrayReader_1;
}
var StringReader_1;
var hasRequiredStringReader;
function requireStringReader() {
  if (hasRequiredStringReader) return StringReader_1;
  hasRequiredStringReader = 1;
  var DataReader = requireDataReader();
  var utils2 = requireUtils();
  function StringReader(data) {
    DataReader.call(this, data);
  }
  utils2.inherits(StringReader, DataReader);
  StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader.prototype.readAndCheckSignature = function(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  StringReader_1 = StringReader;
  return StringReader_1;
}
var Uint8ArrayReader_1;
var hasRequiredUint8ArrayReader;
function requireUint8ArrayReader() {
  if (hasRequiredUint8ArrayReader) return Uint8ArrayReader_1;
  hasRequiredUint8ArrayReader = 1;
  var ArrayReader = requireArrayReader();
  var utils2 = requireUtils();
  function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
  }
  utils2.inherits(Uint8ArrayReader, ArrayReader);
  Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  Uint8ArrayReader_1 = Uint8ArrayReader;
  return Uint8ArrayReader_1;
}
var NodeBufferReader_1;
var hasRequiredNodeBufferReader;
function requireNodeBufferReader() {
  if (hasRequiredNodeBufferReader) return NodeBufferReader_1;
  hasRequiredNodeBufferReader = 1;
  var Uint8ArrayReader = requireUint8ArrayReader();
  var utils2 = requireUtils();
  function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
  }
  utils2.inherits(NodeBufferReader, Uint8ArrayReader);
  NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  NodeBufferReader_1 = NodeBufferReader;
  return NodeBufferReader_1;
}
var readerFor;
var hasRequiredReaderFor;
function requireReaderFor() {
  if (hasRequiredReaderFor) return readerFor;
  hasRequiredReaderFor = 1;
  var utils2 = requireUtils();
  var support2 = requireSupport();
  var ArrayReader = requireArrayReader();
  var StringReader = requireStringReader();
  var NodeBufferReader = requireNodeBufferReader();
  var Uint8ArrayReader = requireUint8ArrayReader();
  readerFor = function(data) {
    var type2 = utils2.getTypeOf(data);
    utils2.checkSupport(type2);
    if (type2 === "string" && !support2.uint8array) {
      return new StringReader(data);
    }
    if (type2 === "nodebuffer") {
      return new NodeBufferReader(data);
    }
    if (support2.uint8array) {
      return new Uint8ArrayReader(utils2.transformTo("uint8array", data));
    }
    return new ArrayReader(utils2.transformTo("array", data));
  };
  return readerFor;
}
var zipEntry;
var hasRequiredZipEntry;
function requireZipEntry() {
  if (hasRequiredZipEntry) return zipEntry;
  hasRequiredZipEntry = 1;
  var readerFor2 = requireReaderFor();
  var utils2 = requireUtils();
  var CompressedObject = requireCompressedObject();
  var crc32fn = requireCrc32$1();
  var utf82 = requireUtf8();
  var compressions2 = requireCompressions();
  var support2 = requireSupport();
  var MADE_BY_DOS = 0;
  var MADE_BY_UNIX = 3;
  var findCompression = function(compressionMethod) {
    for (var method2 in compressions2) {
      if (!Object.prototype.hasOwnProperty.call(compressions2, method2)) {
        continue;
      }
      if (compressions2[method2].magic === compressionMethod) {
        return compressions2[method2];
      }
    }
    return null;
  };
  function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
  }
  ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
      return (this.bitFlag & 1) === 1;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
      return (this.bitFlag & 2048) === 2048;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader2) {
      var compression, localExtraFieldsLength;
      reader2.skip(22);
      this.fileNameLength = reader2.readInt(2);
      localExtraFieldsLength = reader2.readInt(2);
      this.fileName = reader2.readData(this.fileNameLength);
      reader2.skip(localExtraFieldsLength);
      if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
      }
      compression = findCompression(this.compressionMethod);
      if (compression === null) {
        throw new Error("Corrupted zip : compression " + utils2.pretty(this.compressionMethod) + " unknown (inner file : " + utils2.transformTo("string", this.fileName) + ")");
      }
      this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader2.readData(this.compressedSize));
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader2) {
      this.versionMadeBy = reader2.readInt(2);
      reader2.skip(2);
      this.bitFlag = reader2.readInt(2);
      this.compressionMethod = reader2.readString(2);
      this.date = reader2.readDate();
      this.crc32 = reader2.readInt(4);
      this.compressedSize = reader2.readInt(4);
      this.uncompressedSize = reader2.readInt(4);
      var fileNameLength = reader2.readInt(2);
      this.extraFieldsLength = reader2.readInt(2);
      this.fileCommentLength = reader2.readInt(2);
      this.diskNumberStart = reader2.readInt(2);
      this.internalFileAttributes = reader2.readInt(2);
      this.externalFileAttributes = reader2.readInt(4);
      this.localHeaderOffset = reader2.readInt(4);
      if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
      }
      reader2.skip(fileNameLength);
      this.readExtraFields(reader2);
      this.parseZIP64ExtraField(reader2);
      this.fileComment = reader2.readData(this.fileCommentLength);
    },
    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function() {
      this.unixPermissions = null;
      this.dosPermissions = null;
      var madeBy = this.versionMadeBy >> 8;
      this.dir = this.externalFileAttributes & 16 ? true : false;
      if (madeBy === MADE_BY_DOS) {
        this.dosPermissions = this.externalFileAttributes & 63;
      }
      if (madeBy === MADE_BY_UNIX) {
        this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
      }
      if (!this.dir && this.fileNameStr.slice(-1) === "/") {
        this.dir = true;
      }
    },
    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function() {
      if (!this.extraFields[1]) {
        return;
      }
      var extraReader = readerFor2(this.extraFields[1].value);
      if (this.uncompressedSize === utils2.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
      }
      if (this.compressedSize === utils2.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
      }
      if (this.localHeaderOffset === utils2.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
      }
      if (this.diskNumberStart === utils2.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
      }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader2) {
      var end = reader2.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
      if (!this.extraFields) {
        this.extraFields = {};
      }
      while (reader2.index + 4 < end) {
        extraFieldId = reader2.readInt(2);
        extraFieldLength = reader2.readInt(2);
        extraFieldValue = reader2.readData(extraFieldLength);
        this.extraFields[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
      reader2.setIndex(end);
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
      var decodeParamType = support2.uint8array ? "uint8array" : "array";
      if (this.useUTF8()) {
        this.fileNameStr = utf82.utf8decode(this.fileName);
        this.fileCommentStr = utf82.utf8decode(this.fileComment);
      } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
          this.fileNameStr = upath;
        } else {
          var fileNameByteArray = utils2.transformTo(decodeParamType, this.fileName);
          this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
          this.fileCommentStr = ucomment;
        } else {
          var commentByteArray = utils2.transformTo(decodeParamType, this.fileComment);
          this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
      }
    },
    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
      var upathField = this.extraFields[28789];
      if (upathField) {
        var extraReader = readerFor2(upathField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
          return null;
        }
        return utf82.utf8decode(extraReader.readData(upathField.length - 5));
      }
      return null;
    },
    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
      var ucommentField = this.extraFields[25461];
      if (ucommentField) {
        var extraReader = readerFor2(ucommentField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
          return null;
        }
        return utf82.utf8decode(extraReader.readData(ucommentField.length - 5));
      }
      return null;
    }
  };
  zipEntry = ZipEntry;
  return zipEntry;
}
var zipEntries;
var hasRequiredZipEntries;
function requireZipEntries() {
  if (hasRequiredZipEntries) return zipEntries;
  hasRequiredZipEntries = 1;
  var readerFor2 = requireReaderFor();
  var utils2 = requireUtils();
  var sig = requireSignature();
  var ZipEntry = requireZipEntry();
  var support2 = requireSupport();
  function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
  }
  ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
      if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature2 = this.reader.readString(4);
        throw new Error("Corrupted zip or bug: unexpected signature (" + utils2.pretty(signature2) + ", expected " + utils2.pretty(expectedSignature) + ")");
      }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
      var currentIndex = this.reader.index;
      this.reader.setIndex(askedIndex);
      var signature2 = this.reader.readString(4);
      var result = signature2 === expectedSignature;
      this.reader.setIndex(currentIndex);
      return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
      this.diskNumber = this.reader.readInt(2);
      this.diskWithCentralDirStart = this.reader.readInt(2);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
      this.centralDirRecords = this.reader.readInt(2);
      this.centralDirSize = this.reader.readInt(4);
      this.centralDirOffset = this.reader.readInt(4);
      this.zipCommentLength = this.reader.readInt(2);
      var zipComment = this.reader.readData(this.zipCommentLength);
      var decodeParamType = support2.uint8array ? "uint8array" : "array";
      var decodeContent = utils2.transformTo(decodeParamType, zipComment);
      this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
      this.zip64EndOfCentralSize = this.reader.readInt(8);
      this.reader.skip(4);
      this.diskNumber = this.reader.readInt(4);
      this.diskWithCentralDirStart = this.reader.readInt(4);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
      this.centralDirRecords = this.reader.readInt(8);
      this.centralDirSize = this.reader.readInt(8);
      this.centralDirOffset = this.reader.readInt(8);
      this.zip64ExtensibleData = {};
      var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
      while (index < extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
      this.diskWithZip64CentralDirStart = this.reader.readInt(4);
      this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
      this.disksCount = this.reader.readInt(4);
      if (this.disksCount > 1) {
        throw new Error("Multi-volumes zip are not supported");
      }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
      var i, file;
      for (i = 0; i < this.files.length; i++) {
        file = this.files[i];
        this.reader.setIndex(file.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file.readLocalPart(this.reader);
        file.handleUTF8();
        file.processAttributes();
      }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
      var file;
      this.reader.setIndex(this.centralDirOffset);
      while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file = new ZipEntry({
          zip64: this.zip64
        }, this.loadOptions);
        file.readCentralPart(this.reader);
        this.files.push(file);
      }
      if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 && this.files.length === 0) {
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }
      }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
      var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
      if (offset < 0) {
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
        if (isGarbage) {
          throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
          throw new Error("Corrupted zip: can't find end of central directory");
        }
      }
      this.reader.setIndex(offset);
      var endOfCentralDirOffset = offset;
      this.checkSignature(sig.CENTRAL_DIRECTORY_END);
      this.readBlockEndOfCentral();
      if (this.diskNumber === utils2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils2.MAX_VALUE_16BITS || this.centralDirRecords === utils2.MAX_VALUE_16BITS || this.centralDirSize === utils2.MAX_VALUE_32BITS || this.centralDirOffset === utils2.MAX_VALUE_32BITS) {
        this.zip64 = true;
        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
          this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          if (this.relativeOffsetEndOfZip64CentralDir < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
      }
      var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
      if (this.zip64) {
        expectedEndOfCentralDirOffset += 20;
        expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
      }
      var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
      if (extraBytes > 0) {
        if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) ;
        else {
          this.reader.zero = extraBytes;
        }
      } else if (extraBytes < 0) {
        throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
      }
    },
    prepareReader: function(data) {
      this.reader = readerFor2(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
      this.prepareReader(data);
      this.readEndOfCentral();
      this.readCentralDir();
      this.readLocalFiles();
    }
  };
  zipEntries = ZipEntries;
  return zipEntries;
}
var load;
var hasRequiredLoad;
function requireLoad() {
  if (hasRequiredLoad) return load;
  hasRequiredLoad = 1;
  var utils2 = requireUtils();
  var external2 = requireExternal();
  var utf82 = requireUtf8();
  var ZipEntries = requireZipEntries();
  var Crc32Probe = requireCrc32Probe();
  var nodejsUtils2 = requireNodejsUtils();
  function checkEntryCRC32(zipEntry2) {
    return new external2.Promise(function(resolve, reject) {
      var worker = zipEntry2.decompressed.getContentWorker().pipe(new Crc32Probe());
      worker.on("error", function(e) {
        reject(e);
      }).on("end", function() {
        if (worker.streamInfo.crc32 !== zipEntry2.decompressed.crc32) {
          reject(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
          resolve();
        }
      }).resume();
    });
  }
  load = function(data, options) {
    var zip = this;
    options = utils2.extend(options || {}, {
      base64: false,
      checkCRC32: false,
      optimizedBinaryString: false,
      createFolders: false,
      decodeFileName: utf82.utf8decode
    });
    if (nodejsUtils2.isNode && nodejsUtils2.isStream(data)) {
      return external2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }
    return utils2.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
      var zipEntries2 = new ZipEntries(options);
      zipEntries2.load(data2);
      return zipEntries2;
    }).then(function checkCRC32(zipEntries2) {
      var promises2 = [external2.Promise.resolve(zipEntries2)];
      var files2 = zipEntries2.files;
      if (options.checkCRC32) {
        for (var i = 0; i < files2.length; i++) {
          promises2.push(checkEntryCRC32(files2[i]));
        }
      }
      return external2.Promise.all(promises2);
    }).then(function addFiles(results2) {
      var zipEntries2 = results2.shift();
      var files2 = zipEntries2.files;
      for (var i = 0; i < files2.length; i++) {
        var input = files2[i];
        var unsafeName = input.fileNameStr;
        var safeName = utils2.resolve(input.fileNameStr);
        zip.file(safeName, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
        if (!input.dir) {
          zip.file(safeName).unsafeOriginalName = unsafeName;
        }
      }
      if (zipEntries2.zipComment.length) {
        zip.comment = zipEntries2.zipComment;
      }
      return zip;
    });
  };
  return load;
}
var lib$e;
var hasRequiredLib$e;
function requireLib$e() {
  if (hasRequiredLib$e) return lib$e;
  hasRequiredLib$e = 1;
  function JSZip2() {
    if (!(this instanceof JSZip2)) {
      return new JSZip2();
    }
    if (arguments.length) {
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }
    this.files = /* @__PURE__ */ Object.create(null);
    this.comment = null;
    this.root = "";
    this.clone = function() {
      var newObj = new JSZip2();
      for (var i in this) {
        if (typeof this[i] !== "function") {
          newObj[i] = this[i];
        }
      }
      return newObj;
    };
  }
  JSZip2.prototype = requireObject();
  JSZip2.prototype.loadAsync = requireLoad();
  JSZip2.support = requireSupport();
  JSZip2.defaults = requireDefaults();
  JSZip2.version = "3.10.1";
  JSZip2.loadAsync = function(content, options) {
    return new JSZip2().loadAsync(content, options);
  };
  JSZip2.external = requireExternal();
  lib$e = JSZip2;
  return lib$e;
}
var hasRequiredZipfile;
function requireZipfile() {
  if (hasRequiredZipfile) return zipfile;
  hasRequiredZipfile = 1;
  var base64js = requireBase64Js();
  var JSZip2 = requireLib$e();
  zipfile.openArrayBuffer = openArrayBuffer;
  zipfile.splitPath = splitPath;
  zipfile.joinPath = joinPath;
  function openArrayBuffer(arrayBuffer) {
    return JSZip2.loadAsync(arrayBuffer).then(function(zipFile) {
      function exists(name) {
        return zipFile.file(name) !== null;
      }
      function read(name, encoding) {
        return zipFile.file(name).async("uint8array").then(function(array) {
          if (encoding === "base64") {
            return base64js.fromByteArray(array);
          } else if (encoding) {
            var decoder = new TextDecoder(encoding);
            return decoder.decode(array);
          } else {
            return array;
          }
        });
      }
      function write(name, contents) {
        zipFile.file(name, contents);
      }
      function toArrayBuffer() {
        return zipFile.generateAsync({ type: "arraybuffer" });
      }
      return {
        exists,
        read,
        write,
        toArrayBuffer
      };
    });
  }
  function splitPath(path2) {
    var lastIndex = path2.lastIndexOf("/");
    if (lastIndex === -1) {
      return { dirname: "", basename: path2 };
    } else {
      return {
        dirname: path2.substring(0, lastIndex),
        basename: path2.substring(lastIndex + 1)
      };
    }
  }
  function joinPath() {
    var nonEmptyPaths = Array.prototype.filter.call(arguments, function(path2) {
      return path2;
    });
    var relevantPaths = [];
    nonEmptyPaths.forEach(function(path2) {
      if (/^\//.test(path2)) {
        relevantPaths = [path2];
      } else {
        relevantPaths.push(path2);
      }
    });
    return relevantPaths.join("/");
  }
  return zipfile;
}
var officeXmlReader = {};
var xml = {};
var nodes = {};
var hasRequiredNodes;
function requireNodes() {
  if (hasRequiredNodes) return nodes;
  hasRequiredNodes = 1;
  var _ = requireUnderscoreNode();
  nodes.Element = Element2;
  nodes.element = function(name, attributes, children) {
    return new Element2(name, attributes, children);
  };
  nodes.text = function(value) {
    return {
      type: "text",
      value
    };
  };
  var emptyElement = nodes.emptyElement = {
    first: function() {
      return null;
    },
    firstOrEmpty: function() {
      return emptyElement;
    },
    attributes: {},
    children: []
  };
  function Element2(name, attributes, children) {
    this.type = "element";
    this.name = name;
    this.attributes = attributes || {};
    this.children = children || [];
  }
  Element2.prototype.first = function(name) {
    return _.find(this.children, function(child) {
      return child.name === name;
    });
  };
  Element2.prototype.firstOrEmpty = function(name) {
    return this.first(name) || emptyElement;
  };
  Element2.prototype.getElementsByTagName = function(name) {
    var elements = _.filter(this.children, function(child) {
      return child.name === name;
    });
    return toElementList(elements);
  };
  Element2.prototype.text = function() {
    if (this.children.length === 0) {
      return "";
    } else if (this.children.length !== 1 || this.children[0].type !== "text") {
      throw new Error("Not implemented");
    }
    return this.children[0].value;
  };
  var elementListPrototype = {
    getElementsByTagName: function(name) {
      return toElementList(_.flatten(this.map(function(element2) {
        return element2.getElementsByTagName(name);
      }, true)));
    }
  };
  function toElementList(array) {
    return _.extend(array, elementListPrototype);
  }
  return nodes;
}
var reader = {};
var xmldom = {};
var lib$d = {};
var dom$2 = {};
var conventions = {};
var hasRequiredConventions;
function requireConventions() {
  if (hasRequiredConventions) return conventions;
  hasRequiredConventions = 1;
  function find2(list, predicate, ac2) {
    if (ac2 === void 0) {
      ac2 = Array.prototype;
    }
    if (list && typeof ac2.find === "function") {
      return ac2.find.call(list, predicate);
    }
    for (var i = 0; i < list.length; i++) {
      if (Object.prototype.hasOwnProperty.call(list, i)) {
        var item = list[i];
        if (predicate.call(void 0, item, i, list)) {
          return item;
        }
      }
    }
  }
  function freeze(object2, oc) {
    if (oc === void 0) {
      oc = Object;
    }
    return oc && typeof oc.freeze === "function" ? oc.freeze(object2) : object2;
  }
  function assign(target2, source) {
    if (target2 === null || typeof target2 !== "object") {
      throw new TypeError("target is not an object");
    }
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target2[key] = source[key];
      }
    }
    return target2;
  }
  var MIME_TYPE = freeze({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(value) {
      return value === MIME_TYPE.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  });
  var NAMESPACE = freeze({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(uri2) {
      return uri2 === NAMESPACE.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  conventions.assign = assign;
  conventions.find = find2;
  conventions.freeze = freeze;
  conventions.MIME_TYPE = MIME_TYPE;
  conventions.NAMESPACE = NAMESPACE;
  return conventions;
}
var hasRequiredDom$2;
function requireDom$2() {
  if (hasRequiredDom$2) return dom$2;
  hasRequiredDom$2 = 1;
  var conventions2 = requireConventions();
  var find2 = conventions2.find;
  var NAMESPACE = conventions2.NAMESPACE;
  function notEmptyString(input) {
    return input !== "";
  }
  function splitOnASCIIWhitespace(input) {
    return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
  }
  function orderedSetReducer(current, element2) {
    if (!current.hasOwnProperty(element2)) {
      current[element2] = true;
    }
    return current;
  }
  function toOrderedSet(input) {
    if (!input) return [];
    var list = splitOnASCIIWhitespace(input);
    return Object.keys(list.reduce(orderedSetReducer, {}));
  }
  function arrayIncludes(list) {
    return function(element2) {
      return list && list.indexOf(element2) !== -1;
    };
  }
  function copy2(src, dest) {
    for (var p in src) {
      if (Object.prototype.hasOwnProperty.call(src, p)) {
        dest[p] = src[p];
      }
    }
  }
  function _extends(Class, Super) {
    var pt = Class.prototype;
    if (!(pt instanceof Super)) {
      let t = function() {
      };
      t.prototype = Super.prototype;
      t = new t();
      copy2(pt, t);
      Class.prototype = pt = t;
    }
    if (pt.constructor != Class) {
      if (typeof Class != "function") {
        console.error("unknown Class:" + Class);
      }
      pt.constructor = Class;
    }
  }
  var NodeType = {};
  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = NodeType.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
  var ExceptionCode = {};
  var ExceptionMessage = {};
  ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
  function DOMException2(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this;
      Error.call(this, ExceptionMessage[code]);
      this.message = ExceptionMessage[code];
      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException2);
    }
    error.code = code;
    if (message) this.message = this.message + ": " + message;
    return error;
  }
  DOMException2.prototype = Error.prototype;
  copy2(ExceptionCode, DOMException2);
  function NodeList() {
  }
  NodeList.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(index) {
      return index >= 0 && index < this.length ? this[index] : null;
    },
    toString: function(isHTML, nodeFilter) {
      for (var buf = [], i = 0; i < this.length; i++) {
        serializeToString(this[i], buf, isHTML, nodeFilter);
      }
      return buf.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(predicate) {
      return Array.prototype.filter.call(this, predicate);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(item) {
      return Array.prototype.indexOf.call(this, item);
    }
  };
  function LiveNodeList(node2, refresh) {
    this._node = node2;
    this._refresh = refresh;
    _updateLiveList(this);
  }
  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;
    if (list._inc !== inc) {
      var ls = list._refresh(list._node);
      __set__(list, "length", ls.length);
      if (!list.$$length || ls.length < list.$$length) {
        for (var i = ls.length; i in list; i++) {
          if (Object.prototype.hasOwnProperty.call(list, i)) {
            delete list[i];
          }
        }
      }
      copy2(ls, list);
      list._inc = inc;
    }
  }
  LiveNodeList.prototype.item = function(i) {
    _updateLiveList(this);
    return this[i] || null;
  };
  _extends(LiveNodeList, NodeList);
  function NamedNodeMap() {
  }
  function _findNodeIndex(list, node2) {
    var i = list.length;
    while (i--) {
      if (list[i] === node2) {
        return i;
      }
    }
  }
  function _addNamedNode(el2, list, newAttr, oldAttr) {
    if (oldAttr) {
      list[_findNodeIndex(list, oldAttr)] = newAttr;
    } else {
      list[list.length++] = newAttr;
    }
    if (el2) {
      newAttr.ownerElement = el2;
      var doc = el2.ownerDocument;
      if (doc) {
        oldAttr && _onRemoveAttribute(doc, el2, oldAttr);
        _onAddAttribute(doc, el2, newAttr);
      }
    }
  }
  function _removeNamedNode(el2, list, attr) {
    var i = _findNodeIndex(list, attr);
    if (i >= 0) {
      var lastIndex = list.length - 1;
      while (i < lastIndex) {
        list[i] = list[++i];
      }
      list.length = lastIndex;
      if (el2) {
        var doc = el2.ownerDocument;
        if (doc) {
          _onRemoveAttribute(doc, el2, attr);
          attr.ownerElement = null;
        }
      }
    } else {
      throw new DOMException2(NOT_FOUND_ERR, new Error(el2.tagName + "@" + attr));
    }
  }
  NamedNodeMap.prototype = {
    length: 0,
    item: NodeList.prototype.item,
    getNamedItem: function(key) {
      var i = this.length;
      while (i--) {
        var attr = this[i];
        if (attr.nodeName == key) {
          return attr;
        }
      }
    },
    setNamedItem: function(attr) {
      var el2 = attr.ownerElement;
      if (el2 && el2 != this._ownerElement) {
        throw new DOMException2(INUSE_ATTRIBUTE_ERR);
      }
      var oldAttr = this.getNamedItem(attr.nodeName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    setNamedItemNS: function(attr) {
      var el2 = attr.ownerElement, oldAttr;
      if (el2 && el2 != this._ownerElement) {
        throw new DOMException2(INUSE_ATTRIBUTE_ERR);
      }
      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    removeNamedItem: function(key) {
      var attr = this.getNamedItem(key);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(namespaceURI, localName) {
      var attr = this.getNamedItemNS(namespaceURI, localName);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    getNamedItemNS: function(namespaceURI, localName) {
      var i = this.length;
      while (i--) {
        var node2 = this[i];
        if (node2.localName == localName && node2.namespaceURI == namespaceURI) {
          return node2;
        }
      }
      return null;
    }
  };
  function DOMImplementation() {
  }
  DOMImplementation.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(feature, version) {
      return true;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(namespaceURI, qualifiedName, doctype) {
      var doc = new Document();
      doc.implementation = this;
      doc.childNodes = new NodeList();
      doc.doctype = doctype || null;
      if (doctype) {
        doc.appendChild(doctype);
      }
      if (qualifiedName) {
        var root = doc.createElementNS(namespaceURI, qualifiedName);
        doc.appendChild(root);
      }
      return doc;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(qualifiedName, publicId, systemId) {
      var node2 = new DocumentType();
      node2.name = qualifiedName;
      node2.nodeName = qualifiedName;
      node2.publicId = publicId || "";
      node2.systemId = systemId || "";
      return node2;
    }
  };
  function Node() {
  }
  Node.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(newChild, refChild) {
      return _insertBefore(this, newChild, refChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      if (oldChild) {
        this.removeChild(oldChild);
      }
    },
    removeChild: function(oldChild) {
      return _removeChild(this, oldChild);
    },
    appendChild: function(newChild) {
      return this.insertBefore(newChild, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(deep) {
      return cloneNode(this.ownerDocument || this, this, deep);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      var child = this.firstChild;
      while (child) {
        var next = child.nextSibling;
        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
          this.removeChild(next);
          child.appendData(next.data);
        } else {
          child.normalize();
          child = next;
        }
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(feature, version) {
      return this.ownerDocument.implementation.hasFeature(feature, version);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(namespaceURI) {
      var el2 = this;
      while (el2) {
        var map2 = el2._nsMap;
        if (map2) {
          for (var n in map2) {
            if (Object.prototype.hasOwnProperty.call(map2, n) && map2[n] === namespaceURI) {
              return n;
            }
          }
        }
        el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(prefix) {
      var el2 = this;
      while (el2) {
        var map2 = el2._nsMap;
        if (map2) {
          if (Object.prototype.hasOwnProperty.call(map2, prefix)) {
            return map2[prefix];
          }
        }
        el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(namespaceURI) {
      var prefix = this.lookupPrefix(namespaceURI);
      return prefix == null;
    }
  };
  function _xmlEncoder(c) {
    return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
  }
  copy2(NodeType, Node);
  copy2(NodeType, Node.prototype);
  function _visitNode(node2, callback) {
    if (callback(node2)) {
      return true;
    }
    if (node2 = node2.firstChild) {
      do {
        if (_visitNode(node2, callback)) {
          return true;
        }
      } while (node2 = node2.nextSibling);
    }
  }
  function Document() {
    this.ownerDocument = this;
  }
  function _onAddAttribute(doc, el2, newAttr) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE.XMLNS) {
      el2._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
    }
  }
  function _onRemoveAttribute(doc, el2, newAttr, remove) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE.XMLNS) {
      delete el2._nsMap[newAttr.prefix ? newAttr.localName : ""];
    }
  }
  function _onUpdateChild(doc, el2, newChild) {
    if (doc && doc._inc) {
      doc._inc++;
      var cs = el2.childNodes;
      if (newChild) {
        cs[cs.length++] = newChild;
      } else {
        var child = el2.firstChild;
        var i = 0;
        while (child) {
          cs[i++] = child;
          child = child.nextSibling;
        }
        cs.length = i;
        delete cs[cs.length];
      }
    }
  }
  function _removeChild(parentNode, child) {
    var previous = child.previousSibling;
    var next = child.nextSibling;
    if (previous) {
      previous.nextSibling = next;
    } else {
      parentNode.firstChild = next;
    }
    if (next) {
      next.previousSibling = previous;
    } else {
      parentNode.lastChild = previous;
    }
    child.parentNode = null;
    child.previousSibling = null;
    child.nextSibling = null;
    _onUpdateChild(parentNode.ownerDocument, parentNode);
    return child;
  }
  function hasValidParentNodeType(node2) {
    return node2 && (node2.nodeType === Node.DOCUMENT_NODE || node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node2.nodeType === Node.ELEMENT_NODE);
  }
  function hasInsertableNodeType(node2) {
    return node2 && (isElementNode(node2) || isTextNode(node2) || isDocTypeNode(node2) || node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node2.nodeType === Node.COMMENT_NODE || node2.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
  }
  function isDocTypeNode(node2) {
    return node2 && node2.nodeType === Node.DOCUMENT_TYPE_NODE;
  }
  function isElementNode(node2) {
    return node2 && node2.nodeType === Node.ELEMENT_NODE;
  }
  function isTextNode(node2) {
    return node2 && node2.nodeType === Node.TEXT_NODE;
  }
  function isElementInsertionPossible(doc, child) {
    var parentChildNodes = doc.childNodes || [];
    if (find2(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
      return false;
    }
    var docTypeNode = find2(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function isElementReplacementPossible(doc, child) {
    var parentChildNodes = doc.childNodes || [];
    function hasElementChildThatIsNotChild(node2) {
      return isElementNode(node2) && node2 !== child;
    }
    if (find2(parentChildNodes, hasElementChildThatIsNotChild)) {
      return false;
    }
    var docTypeNode = find2(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function assertPreInsertionValidity1to5(parent, node2, child) {
    if (!hasValidParentNodeType(parent)) {
      throw new DOMException2(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
    }
    if (child && child.parentNode !== parent) {
      throw new DOMException2(NOT_FOUND_ERR, "child not in parent");
    }
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !hasInsertableNodeType(node2) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      isDocTypeNode(node2) && parent.nodeType !== Node.DOCUMENT_NODE
    ) {
      throw new DOMException2(
        HIERARCHY_REQUEST_ERR,
        "Unexpected node type " + node2.nodeType + " for parent node type " + parent.nodeType
      );
    }
  }
  function assertPreInsertionValidityInDocument(parent, node2, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node2.childNodes || [];
    if (node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node2)) {
      if (!isElementInsertionPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node2)) {
      if (find2(parentChildNodes, isDocTypeNode)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find2(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
      if (!child && parentElementChild) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
      }
    }
  }
  function assertPreReplacementValidityInDocument(parent, node2, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node2.childNodes || [];
    if (node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node2)) {
      if (!isElementReplacementPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node2)) {
      let hasDoctypeChildThatIsNotChild = function(node3) {
        return isDocTypeNode(node3) && node3 !== child;
      };
      if (find2(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find2(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
    }
  }
  function _insertBefore(parent, node2, child, _inDocumentAssertion) {
    assertPreInsertionValidity1to5(parent, node2, child);
    if (parent.nodeType === Node.DOCUMENT_NODE) {
      (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node2, child);
    }
    var cp = node2.parentNode;
    if (cp) {
      cp.removeChild(node2);
    }
    if (node2.nodeType === DOCUMENT_FRAGMENT_NODE) {
      var newFirst = node2.firstChild;
      if (newFirst == null) {
        return node2;
      }
      var newLast = node2.lastChild;
    } else {
      newFirst = newLast = node2;
    }
    var pre2 = child ? child.previousSibling : parent.lastChild;
    newFirst.previousSibling = pre2;
    newLast.nextSibling = child;
    if (pre2) {
      pre2.nextSibling = newFirst;
    } else {
      parent.firstChild = newFirst;
    }
    if (child == null) {
      parent.lastChild = newLast;
    } else {
      child.previousSibling = newLast;
    }
    do {
      newFirst.parentNode = parent;
      var targetDoc = parent.ownerDocument || parent;
      _updateOwnerDocument(newFirst, targetDoc);
    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
    _onUpdateChild(parent.ownerDocument || parent, parent);
    if (node2.nodeType == DOCUMENT_FRAGMENT_NODE) {
      node2.firstChild = node2.lastChild = null;
    }
    return node2;
  }
  function _updateOwnerDocument(node2, newOwnerDocument) {
    if (node2.ownerDocument === newOwnerDocument) {
      return;
    }
    node2.ownerDocument = newOwnerDocument;
    if (node2.nodeType === ELEMENT_NODE && node2.attributes) {
      for (var i = 0; i < node2.attributes.length; i++) {
        var attr = node2.attributes.item(i);
        if (attr) {
          attr.ownerDocument = newOwnerDocument;
        }
      }
    }
    var child = node2.firstChild;
    while (child) {
      _updateOwnerDocument(child, newOwnerDocument);
      child = child.nextSibling;
    }
  }
  function _appendSingleChild(parentNode, newChild) {
    if (newChild.parentNode) {
      newChild.parentNode.removeChild(newChild);
    }
    newChild.parentNode = parentNode;
    newChild.previousSibling = parentNode.lastChild;
    newChild.nextSibling = null;
    if (newChild.previousSibling) {
      newChild.previousSibling.nextSibling = newChild;
    } else {
      parentNode.firstChild = newChild;
    }
    parentNode.lastChild = newChild;
    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
    var targetDoc = parentNode.ownerDocument || parentNode;
    _updateOwnerDocument(newChild, targetDoc);
    return newChild;
  }
  Document.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: DOCUMENT_NODE,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(newChild, refChild) {
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        var child = newChild.firstChild;
        while (child) {
          var next = child.nextSibling;
          this.insertBefore(child, refChild);
          child = next;
        }
        return newChild;
      }
      _insertBefore(this, newChild, refChild);
      _updateOwnerDocument(newChild, this);
      if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
        this.documentElement = newChild;
      }
      return newChild;
    },
    removeChild: function(oldChild) {
      if (this.documentElement == oldChild) {
        this.documentElement = null;
      }
      return _removeChild(this, oldChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      _updateOwnerDocument(newChild, this);
      if (oldChild) {
        this.removeChild(oldChild);
      }
      if (isElementNode(newChild)) {
        this.documentElement = newChild;
      }
    },
    // Introduced in DOM Level 2:
    importNode: function(importedNode, deep) {
      return importNode(this, importedNode, deep);
    },
    // Introduced in DOM Level 2:
    getElementById: function(id) {
      var rtv = null;
      _visitNode(this.documentElement, function(node2) {
        if (node2.nodeType == ELEMENT_NODE) {
          if (node2.getAttribute("id") == id) {
            rtv = node2;
            return true;
          }
        }
      });
      return rtv;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(classNames) {
      var classNamesSet = toOrderedSet(classNames);
      return new LiveNodeList(this, function(base) {
        var ls = [];
        if (classNamesSet.length > 0) {
          _visitNode(base.documentElement, function(node2) {
            if (node2 !== base && node2.nodeType === ELEMENT_NODE) {
              var nodeClassNames = node2.getAttribute("class");
              if (nodeClassNames) {
                var matches = classNames === nodeClassNames;
                if (!matches) {
                  var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                  matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                }
                if (matches) {
                  ls.push(node2);
                }
              }
            }
          });
        }
        return ls;
      });
    },
    //document factory method:
    createElement: function(tagName) {
      var node2 = new Element2();
      node2.ownerDocument = this;
      node2.nodeName = tagName;
      node2.tagName = tagName;
      node2.localName = tagName;
      node2.childNodes = new NodeList();
      var attrs = node2.attributes = new NamedNodeMap();
      attrs._ownerElement = node2;
      return node2;
    },
    createDocumentFragment: function() {
      var node2 = new DocumentFragment();
      node2.ownerDocument = this;
      node2.childNodes = new NodeList();
      return node2;
    },
    createTextNode: function(data) {
      var node2 = new Text();
      node2.ownerDocument = this;
      node2.appendData(data);
      return node2;
    },
    createComment: function(data) {
      var node2 = new Comment();
      node2.ownerDocument = this;
      node2.appendData(data);
      return node2;
    },
    createCDATASection: function(data) {
      var node2 = new CDATASection();
      node2.ownerDocument = this;
      node2.appendData(data);
      return node2;
    },
    createProcessingInstruction: function(target2, data) {
      var node2 = new ProcessingInstruction();
      node2.ownerDocument = this;
      node2.tagName = node2.nodeName = node2.target = target2;
      node2.nodeValue = node2.data = data;
      return node2;
    },
    createAttribute: function(name) {
      var node2 = new Attr();
      node2.ownerDocument = this;
      node2.name = name;
      node2.nodeName = name;
      node2.localName = name;
      node2.specified = true;
      return node2;
    },
    createEntityReference: function(name) {
      var node2 = new EntityReference();
      node2.ownerDocument = this;
      node2.nodeName = name;
      return node2;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(namespaceURI, qualifiedName) {
      var node2 = new Element2();
      var pl = qualifiedName.split(":");
      var attrs = node2.attributes = new NamedNodeMap();
      node2.childNodes = new NodeList();
      node2.ownerDocument = this;
      node2.nodeName = qualifiedName;
      node2.tagName = qualifiedName;
      node2.namespaceURI = namespaceURI;
      if (pl.length == 2) {
        node2.prefix = pl[0];
        node2.localName = pl[1];
      } else {
        node2.localName = qualifiedName;
      }
      attrs._ownerElement = node2;
      return node2;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(namespaceURI, qualifiedName) {
      var node2 = new Attr();
      var pl = qualifiedName.split(":");
      node2.ownerDocument = this;
      node2.nodeName = qualifiedName;
      node2.name = qualifiedName;
      node2.namespaceURI = namespaceURI;
      node2.specified = true;
      if (pl.length == 2) {
        node2.prefix = pl[0];
        node2.localName = pl[1];
      } else {
        node2.localName = qualifiedName;
      }
      return node2;
    }
  };
  _extends(Document, Node);
  function Element2() {
    this._nsMap = {};
  }
  Element2.prototype = {
    nodeType: ELEMENT_NODE,
    hasAttribute: function(name) {
      return this.getAttributeNode(name) != null;
    },
    getAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      return attr && attr.value || "";
    },
    getAttributeNode: function(name) {
      return this.attributes.getNamedItem(name);
    },
    setAttribute: function(name, value) {
      var attr = this.ownerDocument.createAttribute(name);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    removeAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      attr && this.removeAttributeNode(attr);
    },
    //four real opeartion method
    appendChild: function(newChild) {
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        return this.insertBefore(newChild, null);
      } else {
        return _appendSingleChild(this, newChild);
      }
    },
    setAttributeNode: function(newAttr) {
      return this.attributes.setNamedItem(newAttr);
    },
    setAttributeNodeNS: function(newAttr) {
      return this.attributes.setNamedItemNS(newAttr);
    },
    removeAttributeNode: function(oldAttr) {
      return this.attributes.removeNamedItem(oldAttr.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(namespaceURI, localName) {
      var old = this.getAttributeNodeNS(namespaceURI, localName);
      old && this.removeAttributeNode(old);
    },
    hasAttributeNS: function(namespaceURI, localName) {
      return this.getAttributeNodeNS(namespaceURI, localName) != null;
    },
    getAttributeNS: function(namespaceURI, localName) {
      var attr = this.getAttributeNodeNS(namespaceURI, localName);
      return attr && attr.value || "";
    },
    setAttributeNS: function(namespaceURI, qualifiedName, value) {
      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    getAttributeNodeNS: function(namespaceURI, localName) {
      return this.attributes.getNamedItemNS(namespaceURI, localName);
    },
    getElementsByTagName: function(tagName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node2) {
          if (node2 !== base && node2.nodeType == ELEMENT_NODE && (tagName === "*" || node2.tagName == tagName)) {
            ls.push(node2);
          }
        });
        return ls;
      });
    },
    getElementsByTagNameNS: function(namespaceURI, localName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node2) {
          if (node2 !== base && node2.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node2.namespaceURI === namespaceURI) && (localName === "*" || node2.localName == localName)) {
            ls.push(node2);
          }
        });
        return ls;
      });
    }
  };
  Document.prototype.getElementsByTagName = Element2.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element2.prototype.getElementsByTagNameNS;
  _extends(Element2, Node);
  function Attr() {
  }
  Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr, Node);
  function CharacterData() {
  }
  CharacterData.prototype = {
    data: "",
    substringData: function(offset, count) {
      return this.data.substring(offset, offset + count);
    },
    appendData: function(text) {
      text = this.data + text;
      this.nodeValue = this.data = text;
      this.length = text.length;
    },
    insertData: function(offset, text) {
      this.replaceData(offset, 0, text);
    },
    appendChild: function(newChild) {
      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
    },
    deleteData: function(offset, count) {
      this.replaceData(offset, count, "");
    },
    replaceData: function(offset, count, text) {
      var start = this.data.substring(0, offset);
      var end = this.data.substring(offset + count);
      text = start + text + end;
      this.nodeValue = this.data = text;
      this.length = text.length;
    }
  };
  _extends(CharacterData, Node);
  function Text() {
  }
  Text.prototype = {
    nodeName: "#text",
    nodeType: TEXT_NODE,
    splitText: function(offset) {
      var text = this.data;
      var newText = text.substring(offset);
      text = text.substring(0, offset);
      this.data = this.nodeValue = text;
      this.length = text.length;
      var newNode = this.ownerDocument.createTextNode(newText);
      if (this.parentNode) {
        this.parentNode.insertBefore(newNode, this.nextSibling);
      }
      return newNode;
    }
  };
  _extends(Text, CharacterData);
  function Comment() {
  }
  Comment.prototype = {
    nodeName: "#comment",
    nodeType: COMMENT_NODE
  };
  _extends(Comment, CharacterData);
  function CDATASection() {
  }
  CDATASection.prototype = {
    nodeName: "#cdata-section",
    nodeType: CDATA_SECTION_NODE
  };
  _extends(CDATASection, CharacterData);
  function DocumentType() {
  }
  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType, Node);
  function Notation() {
  }
  Notation.prototype.nodeType = NOTATION_NODE;
  _extends(Notation, Node);
  function Entity() {
  }
  Entity.prototype.nodeType = ENTITY_NODE;
  _extends(Entity, Node);
  function EntityReference() {
  }
  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference, Node);
  function DocumentFragment() {
  }
  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment, Node);
  function ProcessingInstruction() {
  }
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction, Node);
  function XMLSerializer() {
  }
  XMLSerializer.prototype.serializeToString = function(node2, isHtml, nodeFilter) {
    return nodeSerializeToString.call(node2, isHtml, nodeFilter);
  };
  Node.prototype.toString = nodeSerializeToString;
  function nodeSerializeToString(isHtml, nodeFilter) {
    var buf = [];
    var refNode = this.nodeType == 9 && this.documentElement || this;
    var prefix = refNode.prefix;
    var uri2 = refNode.namespaceURI;
    if (uri2 && prefix == null) {
      var prefix = refNode.lookupPrefix(uri2);
      if (prefix == null) {
        var visibleNamespaces = [
          { namespace: uri2, prefix: null }
          //{namespace:uri,prefix:''}
        ];
      }
    }
    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
    return buf.join("");
  }
  function needNamespaceDefine(node2, isHTML, visibleNamespaces) {
    var prefix = node2.prefix || "";
    var uri2 = node2.namespaceURI;
    if (!uri2) {
      return false;
    }
    if (prefix === "xml" && uri2 === NAMESPACE.XML || uri2 === NAMESPACE.XMLNS) {
      return false;
    }
    var i = visibleNamespaces.length;
    while (i--) {
      var ns = visibleNamespaces[i];
      if (ns.prefix === prefix) {
        return ns.namespace !== uri2;
      }
    }
    return true;
  }
  function addSerializedAttribute(buf, qualifiedName, value) {
    buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
  }
  function serializeToString(node2, buf, isHTML, nodeFilter, visibleNamespaces) {
    if (!visibleNamespaces) {
      visibleNamespaces = [];
    }
    if (nodeFilter) {
      node2 = nodeFilter(node2);
      if (node2) {
        if (typeof node2 == "string") {
          buf.push(node2);
          return;
        }
      } else {
        return;
      }
    }
    switch (node2.nodeType) {
      case ELEMENT_NODE:
        var attrs = node2.attributes;
        var len = attrs.length;
        var child = node2.firstChild;
        var nodeName = node2.tagName;
        isHTML = NAMESPACE.isHTML(node2.namespaceURI) || isHTML;
        var prefixedNodeName = nodeName;
        if (!isHTML && !node2.prefix && node2.namespaceURI) {
          var defaultNS;
          for (var ai = 0; ai < attrs.length; ai++) {
            if (attrs.item(ai).name === "xmlns") {
              defaultNS = attrs.item(ai).value;
              break;
            }
          }
          if (!defaultNS) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.prefix === "" && namespace.namespace === node2.namespaceURI) {
                defaultNS = namespace.namespace;
                break;
              }
            }
          }
          if (defaultNS !== node2.namespaceURI) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.namespace === node2.namespaceURI) {
                if (namespace.prefix) {
                  prefixedNodeName = namespace.prefix + ":" + nodeName;
                }
                break;
              }
            }
          }
        }
        buf.push("<", prefixedNodeName);
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (attr.prefix == "xmlns") {
            visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
          } else if (attr.nodeName == "xmlns") {
            visibleNamespaces.push({ prefix: "", namespace: attr.value });
          }
        }
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
            var prefix = attr.prefix || "";
            var uri2 = attr.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri2);
            visibleNamespaces.push({ prefix, namespace: uri2 });
          }
          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        if (nodeName === prefixedNodeName && needNamespaceDefine(node2, isHTML, visibleNamespaces)) {
          var prefix = node2.prefix || "";
          var uri2 = node2.namespaceURI;
          addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri2);
          visibleNamespaces.push({ prefix, namespace: uri2 });
        }
        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
          buf.push(">");
          if (isHTML && /^script$/i.test(nodeName)) {
            while (child) {
              if (child.data) {
                buf.push(child.data);
              } else {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              }
              child = child.nextSibling;
            }
          } else {
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
          }
          buf.push("</", prefixedNodeName, ">");
        } else {
          buf.push("/>");
        }
        return;
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        var child = node2.firstChild;
        while (child) {
          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
          child = child.nextSibling;
        }
        return;
      case ATTRIBUTE_NODE:
        return addSerializedAttribute(buf, node2.name, node2.value);
      case TEXT_NODE:
        return buf.push(
          node2.data.replace(/[<&>]/g, _xmlEncoder)
        );
      case CDATA_SECTION_NODE:
        return buf.push("<![CDATA[", node2.data, "]]>");
      case COMMENT_NODE:
        return buf.push("<!--", node2.data, "-->");
      case DOCUMENT_TYPE_NODE:
        var pubid = node2.publicId;
        var sysid = node2.systemId;
        buf.push("<!DOCTYPE ", node2.name);
        if (pubid) {
          buf.push(" PUBLIC ", pubid);
          if (sysid && sysid != ".") {
            buf.push(" ", sysid);
          }
          buf.push(">");
        } else if (sysid && sysid != ".") {
          buf.push(" SYSTEM ", sysid, ">");
        } else {
          var sub2 = node2.internalSubset;
          if (sub2) {
            buf.push(" [", sub2, "]");
          }
          buf.push(">");
        }
        return;
      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("<?", node2.target, " ", node2.data, "?>");
      case ENTITY_REFERENCE_NODE:
        return buf.push("&", node2.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        buf.push("??", node2.nodeName);
    }
  }
  function importNode(doc, node2, deep) {
    var node22;
    switch (node2.nodeType) {
      case ELEMENT_NODE:
        node22 = node2.cloneNode(false);
        node22.ownerDocument = doc;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case DOCUMENT_FRAGMENT_NODE:
        break;
      case ATTRIBUTE_NODE:
        deep = true;
        break;
    }
    if (!node22) {
      node22 = node2.cloneNode(false);
    }
    node22.ownerDocument = doc;
    node22.parentNode = null;
    if (deep) {
      var child = node2.firstChild;
      while (child) {
        node22.appendChild(importNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node22;
  }
  function cloneNode(doc, node2, deep) {
    var node22 = new node2.constructor();
    for (var n in node2) {
      if (Object.prototype.hasOwnProperty.call(node2, n)) {
        var v = node2[n];
        if (typeof v != "object") {
          if (v != node22[n]) {
            node22[n] = v;
          }
        }
      }
    }
    if (node2.childNodes) {
      node22.childNodes = new NodeList();
    }
    node22.ownerDocument = doc;
    switch (node22.nodeType) {
      case ELEMENT_NODE:
        var attrs = node2.attributes;
        var attrs2 = node22.attributes = new NamedNodeMap();
        var len = attrs.length;
        attrs2._ownerElement = node22;
        for (var i = 0; i < len; i++) {
          node22.setAttributeNode(cloneNode(doc, attrs.item(i), true));
        }
        break;
      case ATTRIBUTE_NODE:
        deep = true;
    }
    if (deep) {
      var child = node2.firstChild;
      while (child) {
        node22.appendChild(cloneNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node22;
  }
  function __set__(object2, key, value) {
    object2[key] = value;
  }
  try {
    if (Object.defineProperty) {
      let getTextContent = function(node2) {
        switch (node2.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var buf = [];
            node2 = node2.firstChild;
            while (node2) {
              if (node2.nodeType !== 7 && node2.nodeType !== 8) {
                buf.push(getTextContent(node2));
              }
              node2 = node2.nextSibling;
            }
            return buf.join("");
          default:
            return node2.nodeValue;
        }
      };
      Object.defineProperty(LiveNodeList.prototype, "length", {
        get: function() {
          _updateLiveList(this);
          return this.$$length;
        }
      });
      Object.defineProperty(Node.prototype, "textContent", {
        get: function() {
          return getTextContent(this);
        },
        set: function(data) {
          switch (this.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              while (this.firstChild) {
                this.removeChild(this.firstChild);
              }
              if (data || String(data)) {
                this.appendChild(this.ownerDocument.createTextNode(data));
              }
              break;
            default:
              this.data = data;
              this.value = data;
              this.nodeValue = data;
          }
        }
      });
      __set__ = function(object2, key, value) {
        object2["$$" + key] = value;
      };
    }
  } catch (e) {
  }
  dom$2.DocumentType = DocumentType;
  dom$2.DOMException = DOMException2;
  dom$2.DOMImplementation = DOMImplementation;
  dom$2.Element = Element2;
  dom$2.Node = Node;
  dom$2.NodeList = NodeList;
  dom$2.XMLSerializer = XMLSerializer;
  return dom$2;
}
var domParser = {};
var entities = {};
var hasRequiredEntities;
function requireEntities() {
  if (hasRequiredEntities) return entities;
  hasRequiredEntities = 1;
  (function(exports$1) {
    var freeze = requireConventions().freeze;
    exports$1.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports$1.HTML_ENTITIES = freeze({
      Aacute: "Ã",
      aacute: "Ã¡",
      Abreve: "Ä‚",
      abreve: "Äƒ",
      ac: "âˆ¾",
      acd: "âˆ¿",
      acE: "âˆ¾Ì³",
      Acirc: "Ã‚",
      acirc: "Ã¢",
      acute: "Â´",
      Acy: "Ð",
      acy: "Ð°",
      AElig: "Ã†",
      aelig: "Ã¦",
      af: "â¡",
      Afr: "ð”„",
      afr: "ð”ž",
      Agrave: "Ã€",
      agrave: "Ã ",
      alefsym: "â„µ",
      aleph: "â„µ",
      Alpha: "Î‘",
      alpha: "Î±",
      Amacr: "Ä€",
      amacr: "Ä",
      amalg: "â¨¿",
      AMP: "&",
      amp: "&",
      And: "â©“",
      and: "âˆ§",
      andand: "â©•",
      andd: "â©œ",
      andslope: "â©˜",
      andv: "â©š",
      ang: "âˆ ",
      ange: "â¦¤",
      angle: "âˆ ",
      angmsd: "âˆ¡",
      angmsdaa: "â¦¨",
      angmsdab: "â¦©",
      angmsdac: "â¦ª",
      angmsdad: "â¦«",
      angmsdae: "â¦¬",
      angmsdaf: "â¦­",
      angmsdag: "â¦®",
      angmsdah: "â¦¯",
      angrt: "âˆŸ",
      angrtvb: "âŠ¾",
      angrtvbd: "â¦",
      angsph: "âˆ¢",
      angst: "Ã…",
      angzarr: "â¼",
      Aogon: "Ä„",
      aogon: "Ä…",
      Aopf: "ð”¸",
      aopf: "ð•’",
      ap: "â‰ˆ",
      apacir: "â©¯",
      apE: "â©°",
      ape: "â‰Š",
      apid: "â‰‹",
      apos: "'",
      ApplyFunction: "â¡",
      approx: "â‰ˆ",
      approxeq: "â‰Š",
      Aring: "Ã…",
      aring: "Ã¥",
      Ascr: "ð’œ",
      ascr: "ð’¶",
      Assign: "â‰”",
      ast: "*",
      asymp: "â‰ˆ",
      asympeq: "â‰",
      Atilde: "Ãƒ",
      atilde: "Ã£",
      Auml: "Ã„",
      auml: "Ã¤",
      awconint: "âˆ³",
      awint: "â¨‘",
      backcong: "â‰Œ",
      backepsilon: "Ï¶",
      backprime: "â€µ",
      backsim: "âˆ½",
      backsimeq: "â‹",
      Backslash: "âˆ–",
      Barv: "â«§",
      barvee: "âŠ½",
      Barwed: "âŒ†",
      barwed: "âŒ…",
      barwedge: "âŒ…",
      bbrk: "âŽµ",
      bbrktbrk: "âŽ¶",
      bcong: "â‰Œ",
      Bcy: "Ð‘",
      bcy: "Ð±",
      bdquo: "â€ž",
      becaus: "âˆµ",
      Because: "âˆµ",
      because: "âˆµ",
      bemptyv: "â¦°",
      bepsi: "Ï¶",
      bernou: "â„¬",
      Bernoullis: "â„¬",
      Beta: "Î’",
      beta: "Î²",
      beth: "â„¶",
      between: "â‰¬",
      Bfr: "ð”…",
      bfr: "ð”Ÿ",
      bigcap: "â‹‚",
      bigcirc: "â—¯",
      bigcup: "â‹ƒ",
      bigodot: "â¨€",
      bigoplus: "â¨",
      bigotimes: "â¨‚",
      bigsqcup: "â¨†",
      bigstar: "â˜…",
      bigtriangledown: "â–½",
      bigtriangleup: "â–³",
      biguplus: "â¨„",
      bigvee: "â‹",
      bigwedge: "â‹€",
      bkarow: "â¤",
      blacklozenge: "â§«",
      blacksquare: "â–ª",
      blacktriangle: "â–´",
      blacktriangledown: "â–¾",
      blacktriangleleft: "â—‚",
      blacktriangleright: "â–¸",
      blank: "â£",
      blk12: "â–’",
      blk14: "â–‘",
      blk34: "â–“",
      block: "â–ˆ",
      bne: "=âƒ¥",
      bnequiv: "â‰¡âƒ¥",
      bNot: "â«­",
      bnot: "âŒ",
      Bopf: "ð”¹",
      bopf: "ð•“",
      bot: "âŠ¥",
      bottom: "âŠ¥",
      bowtie: "â‹ˆ",
      boxbox: "â§‰",
      boxDL: "â•—",
      boxDl: "â•–",
      boxdL: "â••",
      boxdl: "â”",
      boxDR: "â•”",
      boxDr: "â•“",
      boxdR: "â•’",
      boxdr: "â”Œ",
      boxH: "â•",
      boxh: "â”€",
      boxHD: "â•¦",
      boxHd: "â•¤",
      boxhD: "â•¥",
      boxhd: "â”¬",
      boxHU: "â•©",
      boxHu: "â•§",
      boxhU: "â•¨",
      boxhu: "â”´",
      boxminus: "âŠŸ",
      boxplus: "âŠž",
      boxtimes: "âŠ ",
      boxUL: "â•",
      boxUl: "â•œ",
      boxuL: "â•›",
      boxul: "â”˜",
      boxUR: "â•š",
      boxUr: "â•™",
      boxuR: "â•˜",
      boxur: "â””",
      boxV: "â•‘",
      boxv: "â”‚",
      boxVH: "â•¬",
      boxVh: "â•«",
      boxvH: "â•ª",
      boxvh: "â”¼",
      boxVL: "â•£",
      boxVl: "â•¢",
      boxvL: "â•¡",
      boxvl: "â”¤",
      boxVR: "â• ",
      boxVr: "â•Ÿ",
      boxvR: "â•ž",
      boxvr: "â”œ",
      bprime: "â€µ",
      Breve: "Ë˜",
      breve: "Ë˜",
      brvbar: "Â¦",
      Bscr: "â„¬",
      bscr: "ð’·",
      bsemi: "â",
      bsim: "âˆ½",
      bsime: "â‹",
      bsol: "\\",
      bsolb: "â§…",
      bsolhsub: "âŸˆ",
      bull: "â€¢",
      bullet: "â€¢",
      bump: "â‰Ž",
      bumpE: "âª®",
      bumpe: "â‰",
      Bumpeq: "â‰Ž",
      bumpeq: "â‰",
      Cacute: "Ä†",
      cacute: "Ä‡",
      Cap: "â‹’",
      cap: "âˆ©",
      capand: "â©„",
      capbrcup: "â©‰",
      capcap: "â©‹",
      capcup: "â©‡",
      capdot: "â©€",
      CapitalDifferentialD: "â……",
      caps: "âˆ©ï¸€",
      caret: "â",
      caron: "Ë‡",
      Cayleys: "â„­",
      ccaps: "â©",
      Ccaron: "ÄŒ",
      ccaron: "Ä",
      Ccedil: "Ã‡",
      ccedil: "Ã§",
      Ccirc: "Äˆ",
      ccirc: "Ä‰",
      Cconint: "âˆ°",
      ccups: "â©Œ",
      ccupssm: "â©",
      Cdot: "ÄŠ",
      cdot: "Ä‹",
      cedil: "Â¸",
      Cedilla: "Â¸",
      cemptyv: "â¦²",
      cent: "Â¢",
      CenterDot: "Â·",
      centerdot: "Â·",
      Cfr: "â„­",
      cfr: "ð” ",
      CHcy: "Ð§",
      chcy: "Ñ‡",
      check: "âœ“",
      checkmark: "âœ“",
      Chi: "Î§",
      chi: "Ï‡",
      cir: "â—‹",
      circ: "Ë†",
      circeq: "â‰—",
      circlearrowleft: "â†º",
      circlearrowright: "â†»",
      circledast: "âŠ›",
      circledcirc: "âŠš",
      circleddash: "âŠ",
      CircleDot: "âŠ™",
      circledR: "Â®",
      circledS: "â“ˆ",
      CircleMinus: "âŠ–",
      CirclePlus: "âŠ•",
      CircleTimes: "âŠ—",
      cirE: "â§ƒ",
      cire: "â‰—",
      cirfnint: "â¨",
      cirmid: "â«¯",
      cirscir: "â§‚",
      ClockwiseContourIntegral: "âˆ²",
      CloseCurlyDoubleQuote: "â€",
      CloseCurlyQuote: "â€™",
      clubs: "â™£",
      clubsuit: "â™£",
      Colon: "âˆ·",
      colon: ":",
      Colone: "â©´",
      colone: "â‰”",
      coloneq: "â‰”",
      comma: ",",
      commat: "@",
      comp: "âˆ",
      compfn: "âˆ˜",
      complement: "âˆ",
      complexes: "â„‚",
      cong: "â‰…",
      congdot: "â©­",
      Congruent: "â‰¡",
      Conint: "âˆ¯",
      conint: "âˆ®",
      ContourIntegral: "âˆ®",
      Copf: "â„‚",
      copf: "ð•”",
      coprod: "âˆ",
      Coproduct: "âˆ",
      COPY: "Â©",
      copy: "Â©",
      copysr: "â„—",
      CounterClockwiseContourIntegral: "âˆ³",
      crarr: "â†µ",
      Cross: "â¨¯",
      cross: "âœ—",
      Cscr: "ð’ž",
      cscr: "ð’¸",
      csub: "â«",
      csube: "â«‘",
      csup: "â«",
      csupe: "â«’",
      ctdot: "â‹¯",
      cudarrl: "â¤¸",
      cudarrr: "â¤µ",
      cuepr: "â‹ž",
      cuesc: "â‹Ÿ",
      cularr: "â†¶",
      cularrp: "â¤½",
      Cup: "â‹“",
      cup: "âˆª",
      cupbrcap: "â©ˆ",
      CupCap: "â‰",
      cupcap: "â©†",
      cupcup: "â©Š",
      cupdot: "âŠ",
      cupor: "â©…",
      cups: "âˆªï¸€",
      curarr: "â†·",
      curarrm: "â¤¼",
      curlyeqprec: "â‹ž",
      curlyeqsucc: "â‹Ÿ",
      curlyvee: "â‹Ž",
      curlywedge: "â‹",
      curren: "Â¤",
      curvearrowleft: "â†¶",
      curvearrowright: "â†·",
      cuvee: "â‹Ž",
      cuwed: "â‹",
      cwconint: "âˆ²",
      cwint: "âˆ±",
      cylcty: "âŒ­",
      Dagger: "â€¡",
      dagger: "â€ ",
      daleth: "â„¸",
      Darr: "â†¡",
      dArr: "â‡“",
      darr: "â†“",
      dash: "â€",
      Dashv: "â«¤",
      dashv: "âŠ£",
      dbkarow: "â¤",
      dblac: "Ë",
      Dcaron: "ÄŽ",
      dcaron: "Ä",
      Dcy: "Ð”",
      dcy: "Ð´",
      DD: "â……",
      dd: "â…†",
      ddagger: "â€¡",
      ddarr: "â‡Š",
      DDotrahd: "â¤‘",
      ddotseq: "â©·",
      deg: "Â°",
      Del: "âˆ‡",
      Delta: "Î”",
      delta: "Î´",
      demptyv: "â¦±",
      dfisht: "â¥¿",
      Dfr: "ð”‡",
      dfr: "ð”¡",
      dHar: "â¥¥",
      dharl: "â‡ƒ",
      dharr: "â‡‚",
      DiacriticalAcute: "Â´",
      DiacriticalDot: "Ë™",
      DiacriticalDoubleAcute: "Ë",
      DiacriticalGrave: "`",
      DiacriticalTilde: "Ëœ",
      diam: "â‹„",
      Diamond: "â‹„",
      diamond: "â‹„",
      diamondsuit: "â™¦",
      diams: "â™¦",
      die: "Â¨",
      DifferentialD: "â…†",
      digamma: "Ï",
      disin: "â‹²",
      div: "Ã·",
      divide: "Ã·",
      divideontimes: "â‹‡",
      divonx: "â‹‡",
      DJcy: "Ð‚",
      djcy: "Ñ’",
      dlcorn: "âŒž",
      dlcrop: "âŒ",
      dollar: "$",
      Dopf: "ð”»",
      dopf: "ð••",
      Dot: "Â¨",
      dot: "Ë™",
      DotDot: "âƒœ",
      doteq: "â‰",
      doteqdot: "â‰‘",
      DotEqual: "â‰",
      dotminus: "âˆ¸",
      dotplus: "âˆ”",
      dotsquare: "âŠ¡",
      doublebarwedge: "âŒ†",
      DoubleContourIntegral: "âˆ¯",
      DoubleDot: "Â¨",
      DoubleDownArrow: "â‡“",
      DoubleLeftArrow: "â‡",
      DoubleLeftRightArrow: "â‡”",
      DoubleLeftTee: "â«¤",
      DoubleLongLeftArrow: "âŸ¸",
      DoubleLongLeftRightArrow: "âŸº",
      DoubleLongRightArrow: "âŸ¹",
      DoubleRightArrow: "â‡’",
      DoubleRightTee: "âŠ¨",
      DoubleUpArrow: "â‡‘",
      DoubleUpDownArrow: "â‡•",
      DoubleVerticalBar: "âˆ¥",
      DownArrow: "â†“",
      Downarrow: "â‡“",
      downarrow: "â†“",
      DownArrowBar: "â¤“",
      DownArrowUpArrow: "â‡µ",
      DownBreve: "Ì‘",
      downdownarrows: "â‡Š",
      downharpoonleft: "â‡ƒ",
      downharpoonright: "â‡‚",
      DownLeftRightVector: "â¥",
      DownLeftTeeVector: "â¥ž",
      DownLeftVector: "â†½",
      DownLeftVectorBar: "â¥–",
      DownRightTeeVector: "â¥Ÿ",
      DownRightVector: "â‡",
      DownRightVectorBar: "â¥—",
      DownTee: "âŠ¤",
      DownTeeArrow: "â†§",
      drbkarow: "â¤",
      drcorn: "âŒŸ",
      drcrop: "âŒŒ",
      Dscr: "ð’Ÿ",
      dscr: "ð’¹",
      DScy: "Ð…",
      dscy: "Ñ•",
      dsol: "â§¶",
      Dstrok: "Ä",
      dstrok: "Ä‘",
      dtdot: "â‹±",
      dtri: "â–¿",
      dtrif: "â–¾",
      duarr: "â‡µ",
      duhar: "â¥¯",
      dwangle: "â¦¦",
      DZcy: "Ð",
      dzcy: "ÑŸ",
      dzigrarr: "âŸ¿",
      Eacute: "Ã‰",
      eacute: "Ã©",
      easter: "â©®",
      Ecaron: "Äš",
      ecaron: "Ä›",
      ecir: "â‰–",
      Ecirc: "ÃŠ",
      ecirc: "Ãª",
      ecolon: "â‰•",
      Ecy: "Ð­",
      ecy: "Ñ",
      eDDot: "â©·",
      Edot: "Ä–",
      eDot: "â‰‘",
      edot: "Ä—",
      ee: "â…‡",
      efDot: "â‰’",
      Efr: "ð”ˆ",
      efr: "ð”¢",
      eg: "âªš",
      Egrave: "Ãˆ",
      egrave: "Ã¨",
      egs: "âª–",
      egsdot: "âª˜",
      el: "âª™",
      Element: "âˆˆ",
      elinters: "â§",
      ell: "â„“",
      els: "âª•",
      elsdot: "âª—",
      Emacr: "Ä’",
      emacr: "Ä“",
      empty: "âˆ…",
      emptyset: "âˆ…",
      EmptySmallSquare: "â—»",
      emptyv: "âˆ…",
      EmptyVerySmallSquare: "â–«",
      emsp: "â€ƒ",
      emsp13: "â€„",
      emsp14: "â€…",
      ENG: "ÅŠ",
      eng: "Å‹",
      ensp: "â€‚",
      Eogon: "Ä˜",
      eogon: "Ä™",
      Eopf: "ð”¼",
      eopf: "ð•–",
      epar: "â‹•",
      eparsl: "â§£",
      eplus: "â©±",
      epsi: "Îµ",
      Epsilon: "Î•",
      epsilon: "Îµ",
      epsiv: "Ïµ",
      eqcirc: "â‰–",
      eqcolon: "â‰•",
      eqsim: "â‰‚",
      eqslantgtr: "âª–",
      eqslantless: "âª•",
      Equal: "â©µ",
      equals: "=",
      EqualTilde: "â‰‚",
      equest: "â‰Ÿ",
      Equilibrium: "â‡Œ",
      equiv: "â‰¡",
      equivDD: "â©¸",
      eqvparsl: "â§¥",
      erarr: "â¥±",
      erDot: "â‰“",
      Escr: "â„°",
      escr: "â„¯",
      esdot: "â‰",
      Esim: "â©³",
      esim: "â‰‚",
      Eta: "Î—",
      eta: "Î·",
      ETH: "Ã",
      eth: "Ã°",
      Euml: "Ã‹",
      euml: "Ã«",
      euro: "â‚¬",
      excl: "!",
      exist: "âˆƒ",
      Exists: "âˆƒ",
      expectation: "â„°",
      ExponentialE: "â…‡",
      exponentiale: "â…‡",
      fallingdotseq: "â‰’",
      Fcy: "Ð¤",
      fcy: "Ñ„",
      female: "â™€",
      ffilig: "ï¬ƒ",
      fflig: "ï¬€",
      ffllig: "ï¬„",
      Ffr: "ð”‰",
      ffr: "ð”£",
      filig: "ï¬",
      FilledSmallSquare: "â—¼",
      FilledVerySmallSquare: "â–ª",
      fjlig: "fj",
      flat: "â™­",
      fllig: "ï¬‚",
      fltns: "â–±",
      fnof: "Æ’",
      Fopf: "ð”½",
      fopf: "ð•—",
      ForAll: "âˆ€",
      forall: "âˆ€",
      fork: "â‹”",
      forkv: "â«™",
      Fouriertrf: "â„±",
      fpartint: "â¨",
      frac12: "Â½",
      frac13: "â…“",
      frac14: "Â¼",
      frac15: "â…•",
      frac16: "â…™",
      frac18: "â…›",
      frac23: "â…”",
      frac25: "â…–",
      frac34: "Â¾",
      frac35: "â…—",
      frac38: "â…œ",
      frac45: "â…˜",
      frac56: "â…š",
      frac58: "â…",
      frac78: "â…ž",
      frasl: "â„",
      frown: "âŒ¢",
      Fscr: "â„±",
      fscr: "ð’»",
      gacute: "Çµ",
      Gamma: "Î“",
      gamma: "Î³",
      Gammad: "Ïœ",
      gammad: "Ï",
      gap: "âª†",
      Gbreve: "Äž",
      gbreve: "ÄŸ",
      Gcedil: "Ä¢",
      Gcirc: "Äœ",
      gcirc: "Ä",
      Gcy: "Ð“",
      gcy: "Ð³",
      Gdot: "Ä ",
      gdot: "Ä¡",
      gE: "â‰§",
      ge: "â‰¥",
      gEl: "âªŒ",
      gel: "â‹›",
      geq: "â‰¥",
      geqq: "â‰§",
      geqslant: "â©¾",
      ges: "â©¾",
      gescc: "âª©",
      gesdot: "âª€",
      gesdoto: "âª‚",
      gesdotol: "âª„",
      gesl: "â‹›ï¸€",
      gesles: "âª”",
      Gfr: "ð”Š",
      gfr: "ð”¤",
      Gg: "â‹™",
      gg: "â‰«",
      ggg: "â‹™",
      gimel: "â„·",
      GJcy: "Ðƒ",
      gjcy: "Ñ“",
      gl: "â‰·",
      gla: "âª¥",
      glE: "âª’",
      glj: "âª¤",
      gnap: "âªŠ",
      gnapprox: "âªŠ",
      gnE: "â‰©",
      gne: "âªˆ",
      gneq: "âªˆ",
      gneqq: "â‰©",
      gnsim: "â‹§",
      Gopf: "ð”¾",
      gopf: "ð•˜",
      grave: "`",
      GreaterEqual: "â‰¥",
      GreaterEqualLess: "â‹›",
      GreaterFullEqual: "â‰§",
      GreaterGreater: "âª¢",
      GreaterLess: "â‰·",
      GreaterSlantEqual: "â©¾",
      GreaterTilde: "â‰³",
      Gscr: "ð’¢",
      gscr: "â„Š",
      gsim: "â‰³",
      gsime: "âªŽ",
      gsiml: "âª",
      Gt: "â‰«",
      GT: ">",
      gt: ">",
      gtcc: "âª§",
      gtcir: "â©º",
      gtdot: "â‹—",
      gtlPar: "â¦•",
      gtquest: "â©¼",
      gtrapprox: "âª†",
      gtrarr: "â¥¸",
      gtrdot: "â‹—",
      gtreqless: "â‹›",
      gtreqqless: "âªŒ",
      gtrless: "â‰·",
      gtrsim: "â‰³",
      gvertneqq: "â‰©ï¸€",
      gvnE: "â‰©ï¸€",
      Hacek: "Ë‡",
      hairsp: "â€Š",
      half: "Â½",
      hamilt: "â„‹",
      HARDcy: "Ðª",
      hardcy: "ÑŠ",
      hArr: "â‡”",
      harr: "â†”",
      harrcir: "â¥ˆ",
      harrw: "â†­",
      Hat: "^",
      hbar: "â„",
      Hcirc: "Ä¤",
      hcirc: "Ä¥",
      hearts: "â™¥",
      heartsuit: "â™¥",
      hellip: "â€¦",
      hercon: "âŠ¹",
      Hfr: "â„Œ",
      hfr: "ð”¥",
      HilbertSpace: "â„‹",
      hksearow: "â¤¥",
      hkswarow: "â¤¦",
      hoarr: "â‡¿",
      homtht: "âˆ»",
      hookleftarrow: "â†©",
      hookrightarrow: "â†ª",
      Hopf: "â„",
      hopf: "ð•™",
      horbar: "â€•",
      HorizontalLine: "â”€",
      Hscr: "â„‹",
      hscr: "ð’½",
      hslash: "â„",
      Hstrok: "Ä¦",
      hstrok: "Ä§",
      HumpDownHump: "â‰Ž",
      HumpEqual: "â‰",
      hybull: "âƒ",
      hyphen: "â€",
      Iacute: "Ã",
      iacute: "Ã­",
      ic: "â£",
      Icirc: "ÃŽ",
      icirc: "Ã®",
      Icy: "Ð˜",
      icy: "Ð¸",
      Idot: "Ä°",
      IEcy: "Ð•",
      iecy: "Ðµ",
      iexcl: "Â¡",
      iff: "â‡”",
      Ifr: "â„‘",
      ifr: "ð”¦",
      Igrave: "ÃŒ",
      igrave: "Ã¬",
      ii: "â…ˆ",
      iiiint: "â¨Œ",
      iiint: "âˆ­",
      iinfin: "â§œ",
      iiota: "â„©",
      IJlig: "Ä²",
      ijlig: "Ä³",
      Im: "â„‘",
      Imacr: "Äª",
      imacr: "Ä«",
      image: "â„‘",
      ImaginaryI: "â…ˆ",
      imagline: "â„",
      imagpart: "â„‘",
      imath: "Ä±",
      imof: "âŠ·",
      imped: "Æµ",
      Implies: "â‡’",
      in: "âˆˆ",
      incare: "â„…",
      infin: "âˆž",
      infintie: "â§",
      inodot: "Ä±",
      Int: "âˆ¬",
      int: "âˆ«",
      intcal: "âŠº",
      integers: "â„¤",
      Integral: "âˆ«",
      intercal: "âŠº",
      Intersection: "â‹‚",
      intlarhk: "â¨—",
      intprod: "â¨¼",
      InvisibleComma: "â£",
      InvisibleTimes: "â¢",
      IOcy: "Ð",
      iocy: "Ñ‘",
      Iogon: "Ä®",
      iogon: "Ä¯",
      Iopf: "ð•€",
      iopf: "ð•š",
      Iota: "Î™",
      iota: "Î¹",
      iprod: "â¨¼",
      iquest: "Â¿",
      Iscr: "â„",
      iscr: "ð’¾",
      isin: "âˆˆ",
      isindot: "â‹µ",
      isinE: "â‹¹",
      isins: "â‹´",
      isinsv: "â‹³",
      isinv: "âˆˆ",
      it: "â¢",
      Itilde: "Ä¨",
      itilde: "Ä©",
      Iukcy: "Ð†",
      iukcy: "Ñ–",
      Iuml: "Ã",
      iuml: "Ã¯",
      Jcirc: "Ä´",
      jcirc: "Äµ",
      Jcy: "Ð™",
      jcy: "Ð¹",
      Jfr: "ð”",
      jfr: "ð”§",
      jmath: "È·",
      Jopf: "ð•",
      jopf: "ð•›",
      Jscr: "ð’¥",
      jscr: "ð’¿",
      Jsercy: "Ðˆ",
      jsercy: "Ñ˜",
      Jukcy: "Ð„",
      jukcy: "Ñ”",
      Kappa: "Îš",
      kappa: "Îº",
      kappav: "Ï°",
      Kcedil: "Ä¶",
      kcedil: "Ä·",
      Kcy: "Ðš",
      kcy: "Ðº",
      Kfr: "ð”Ž",
      kfr: "ð”¨",
      kgreen: "Ä¸",
      KHcy: "Ð¥",
      khcy: "Ñ…",
      KJcy: "ÐŒ",
      kjcy: "Ñœ",
      Kopf: "ð•‚",
      kopf: "ð•œ",
      Kscr: "ð’¦",
      kscr: "ð“€",
      lAarr: "â‡š",
      Lacute: "Ä¹",
      lacute: "Äº",
      laemptyv: "â¦´",
      lagran: "â„’",
      Lambda: "Î›",
      lambda: "Î»",
      Lang: "âŸª",
      lang: "âŸ¨",
      langd: "â¦‘",
      langle: "âŸ¨",
      lap: "âª…",
      Laplacetrf: "â„’",
      laquo: "Â«",
      Larr: "â†ž",
      lArr: "â‡",
      larr: "â†",
      larrb: "â‡¤",
      larrbfs: "â¤Ÿ",
      larrfs: "â¤",
      larrhk: "â†©",
      larrlp: "â†«",
      larrpl: "â¤¹",
      larrsim: "â¥³",
      larrtl: "â†¢",
      lat: "âª«",
      lAtail: "â¤›",
      latail: "â¤™",
      late: "âª­",
      lates: "âª­ï¸€",
      lBarr: "â¤Ž",
      lbarr: "â¤Œ",
      lbbrk: "â²",
      lbrace: "{",
      lbrack: "[",
      lbrke: "â¦‹",
      lbrksld: "â¦",
      lbrkslu: "â¦",
      Lcaron: "Ä½",
      lcaron: "Ä¾",
      Lcedil: "Ä»",
      lcedil: "Ä¼",
      lceil: "âŒˆ",
      lcub: "{",
      Lcy: "Ð›",
      lcy: "Ð»",
      ldca: "â¤¶",
      ldquo: "â€œ",
      ldquor: "â€ž",
      ldrdhar: "â¥§",
      ldrushar: "â¥‹",
      ldsh: "â†²",
      lE: "â‰¦",
      le: "â‰¤",
      LeftAngleBracket: "âŸ¨",
      LeftArrow: "â†",
      Leftarrow: "â‡",
      leftarrow: "â†",
      LeftArrowBar: "â‡¤",
      LeftArrowRightArrow: "â‡†",
      leftarrowtail: "â†¢",
      LeftCeiling: "âŒˆ",
      LeftDoubleBracket: "âŸ¦",
      LeftDownTeeVector: "â¥¡",
      LeftDownVector: "â‡ƒ",
      LeftDownVectorBar: "â¥™",
      LeftFloor: "âŒŠ",
      leftharpoondown: "â†½",
      leftharpoonup: "â†¼",
      leftleftarrows: "â‡‡",
      LeftRightArrow: "â†”",
      Leftrightarrow: "â‡”",
      leftrightarrow: "â†”",
      leftrightarrows: "â‡†",
      leftrightharpoons: "â‡‹",
      leftrightsquigarrow: "â†­",
      LeftRightVector: "â¥Ž",
      LeftTee: "âŠ£",
      LeftTeeArrow: "â†¤",
      LeftTeeVector: "â¥š",
      leftthreetimes: "â‹‹",
      LeftTriangle: "âŠ²",
      LeftTriangleBar: "â§",
      LeftTriangleEqual: "âŠ´",
      LeftUpDownVector: "â¥‘",
      LeftUpTeeVector: "â¥ ",
      LeftUpVector: "â†¿",
      LeftUpVectorBar: "â¥˜",
      LeftVector: "â†¼",
      LeftVectorBar: "â¥’",
      lEg: "âª‹",
      leg: "â‹š",
      leq: "â‰¤",
      leqq: "â‰¦",
      leqslant: "â©½",
      les: "â©½",
      lescc: "âª¨",
      lesdot: "â©¿",
      lesdoto: "âª",
      lesdotor: "âªƒ",
      lesg: "â‹šï¸€",
      lesges: "âª“",
      lessapprox: "âª…",
      lessdot: "â‹–",
      lesseqgtr: "â‹š",
      lesseqqgtr: "âª‹",
      LessEqualGreater: "â‹š",
      LessFullEqual: "â‰¦",
      LessGreater: "â‰¶",
      lessgtr: "â‰¶",
      LessLess: "âª¡",
      lesssim: "â‰²",
      LessSlantEqual: "â©½",
      LessTilde: "â‰²",
      lfisht: "â¥¼",
      lfloor: "âŒŠ",
      Lfr: "ð”",
      lfr: "ð”©",
      lg: "â‰¶",
      lgE: "âª‘",
      lHar: "â¥¢",
      lhard: "â†½",
      lharu: "â†¼",
      lharul: "â¥ª",
      lhblk: "â–„",
      LJcy: "Ð‰",
      ljcy: "Ñ™",
      Ll: "â‹˜",
      ll: "â‰ª",
      llarr: "â‡‡",
      llcorner: "âŒž",
      Lleftarrow: "â‡š",
      llhard: "â¥«",
      lltri: "â—º",
      Lmidot: "Ä¿",
      lmidot: "Å€",
      lmoust: "âŽ°",
      lmoustache: "âŽ°",
      lnap: "âª‰",
      lnapprox: "âª‰",
      lnE: "â‰¨",
      lne: "âª‡",
      lneq: "âª‡",
      lneqq: "â‰¨",
      lnsim: "â‹¦",
      loang: "âŸ¬",
      loarr: "â‡½",
      lobrk: "âŸ¦",
      LongLeftArrow: "âŸµ",
      Longleftarrow: "âŸ¸",
      longleftarrow: "âŸµ",
      LongLeftRightArrow: "âŸ·",
      Longleftrightarrow: "âŸº",
      longleftrightarrow: "âŸ·",
      longmapsto: "âŸ¼",
      LongRightArrow: "âŸ¶",
      Longrightarrow: "âŸ¹",
      longrightarrow: "âŸ¶",
      looparrowleft: "â†«",
      looparrowright: "â†¬",
      lopar: "â¦…",
      Lopf: "ð•ƒ",
      lopf: "ð•",
      loplus: "â¨­",
      lotimes: "â¨´",
      lowast: "âˆ—",
      lowbar: "_",
      LowerLeftArrow: "â†™",
      LowerRightArrow: "â†˜",
      loz: "â—Š",
      lozenge: "â—Š",
      lozf: "â§«",
      lpar: "(",
      lparlt: "â¦“",
      lrarr: "â‡†",
      lrcorner: "âŒŸ",
      lrhar: "â‡‹",
      lrhard: "â¥­",
      lrm: "â€Ž",
      lrtri: "âŠ¿",
      lsaquo: "â€¹",
      Lscr: "â„’",
      lscr: "ð“",
      Lsh: "â†°",
      lsh: "â†°",
      lsim: "â‰²",
      lsime: "âª",
      lsimg: "âª",
      lsqb: "[",
      lsquo: "â€˜",
      lsquor: "â€š",
      Lstrok: "Å",
      lstrok: "Å‚",
      Lt: "â‰ª",
      LT: "<",
      lt: "<",
      ltcc: "âª¦",
      ltcir: "â©¹",
      ltdot: "â‹–",
      lthree: "â‹‹",
      ltimes: "â‹‰",
      ltlarr: "â¥¶",
      ltquest: "â©»",
      ltri: "â—ƒ",
      ltrie: "âŠ´",
      ltrif: "â—‚",
      ltrPar: "â¦–",
      lurdshar: "â¥Š",
      luruhar: "â¥¦",
      lvertneqq: "â‰¨ï¸€",
      lvnE: "â‰¨ï¸€",
      macr: "Â¯",
      male: "â™‚",
      malt: "âœ ",
      maltese: "âœ ",
      Map: "â¤…",
      map: "â†¦",
      mapsto: "â†¦",
      mapstodown: "â†§",
      mapstoleft: "â†¤",
      mapstoup: "â†¥",
      marker: "â–®",
      mcomma: "â¨©",
      Mcy: "Ðœ",
      mcy: "Ð¼",
      mdash: "â€”",
      mDDot: "âˆº",
      measuredangle: "âˆ¡",
      MediumSpace: "âŸ",
      Mellintrf: "â„³",
      Mfr: "ð”",
      mfr: "ð”ª",
      mho: "â„§",
      micro: "Âµ",
      mid: "âˆ£",
      midast: "*",
      midcir: "â«°",
      middot: "Â·",
      minus: "âˆ’",
      minusb: "âŠŸ",
      minusd: "âˆ¸",
      minusdu: "â¨ª",
      MinusPlus: "âˆ“",
      mlcp: "â«›",
      mldr: "â€¦",
      mnplus: "âˆ“",
      models: "âŠ§",
      Mopf: "ð•„",
      mopf: "ð•ž",
      mp: "âˆ“",
      Mscr: "â„³",
      mscr: "ð“‚",
      mstpos: "âˆ¾",
      Mu: "Îœ",
      mu: "Î¼",
      multimap: "âŠ¸",
      mumap: "âŠ¸",
      nabla: "âˆ‡",
      Nacute: "Åƒ",
      nacute: "Å„",
      nang: "âˆ âƒ’",
      nap: "â‰‰",
      napE: "â©°Ì¸",
      napid: "â‰‹Ì¸",
      napos: "Å‰",
      napprox: "â‰‰",
      natur: "â™®",
      natural: "â™®",
      naturals: "â„•",
      nbsp: "Â ",
      nbump: "â‰ŽÌ¸",
      nbumpe: "â‰Ì¸",
      ncap: "â©ƒ",
      Ncaron: "Å‡",
      ncaron: "Åˆ",
      Ncedil: "Å…",
      ncedil: "Å†",
      ncong: "â‰‡",
      ncongdot: "â©­Ì¸",
      ncup: "â©‚",
      Ncy: "Ð",
      ncy: "Ð½",
      ndash: "â€“",
      ne: "â‰ ",
      nearhk: "â¤¤",
      neArr: "â‡—",
      nearr: "â†—",
      nearrow: "â†—",
      nedot: "â‰Ì¸",
      NegativeMediumSpace: "â€‹",
      NegativeThickSpace: "â€‹",
      NegativeThinSpace: "â€‹",
      NegativeVeryThinSpace: "â€‹",
      nequiv: "â‰¢",
      nesear: "â¤¨",
      nesim: "â‰‚Ì¸",
      NestedGreaterGreater: "â‰«",
      NestedLessLess: "â‰ª",
      NewLine: "\n",
      nexist: "âˆ„",
      nexists: "âˆ„",
      Nfr: "ð”‘",
      nfr: "ð”«",
      ngE: "â‰§Ì¸",
      nge: "â‰±",
      ngeq: "â‰±",
      ngeqq: "â‰§Ì¸",
      ngeqslant: "â©¾Ì¸",
      nges: "â©¾Ì¸",
      nGg: "â‹™Ì¸",
      ngsim: "â‰µ",
      nGt: "â‰«âƒ’",
      ngt: "â‰¯",
      ngtr: "â‰¯",
      nGtv: "â‰«Ì¸",
      nhArr: "â‡Ž",
      nharr: "â†®",
      nhpar: "â«²",
      ni: "âˆ‹",
      nis: "â‹¼",
      nisd: "â‹º",
      niv: "âˆ‹",
      NJcy: "ÐŠ",
      njcy: "Ñš",
      nlArr: "â‡",
      nlarr: "â†š",
      nldr: "â€¥",
      nlE: "â‰¦Ì¸",
      nle: "â‰°",
      nLeftarrow: "â‡",
      nleftarrow: "â†š",
      nLeftrightarrow: "â‡Ž",
      nleftrightarrow: "â†®",
      nleq: "â‰°",
      nleqq: "â‰¦Ì¸",
      nleqslant: "â©½Ì¸",
      nles: "â©½Ì¸",
      nless: "â‰®",
      nLl: "â‹˜Ì¸",
      nlsim: "â‰´",
      nLt: "â‰ªâƒ’",
      nlt: "â‰®",
      nltri: "â‹ª",
      nltrie: "â‹¬",
      nLtv: "â‰ªÌ¸",
      nmid: "âˆ¤",
      NoBreak: "â ",
      NonBreakingSpace: "Â ",
      Nopf: "â„•",
      nopf: "ð•Ÿ",
      Not: "â«¬",
      not: "Â¬",
      NotCongruent: "â‰¢",
      NotCupCap: "â‰­",
      NotDoubleVerticalBar: "âˆ¦",
      NotElement: "âˆ‰",
      NotEqual: "â‰ ",
      NotEqualTilde: "â‰‚Ì¸",
      NotExists: "âˆ„",
      NotGreater: "â‰¯",
      NotGreaterEqual: "â‰±",
      NotGreaterFullEqual: "â‰§Ì¸",
      NotGreaterGreater: "â‰«Ì¸",
      NotGreaterLess: "â‰¹",
      NotGreaterSlantEqual: "â©¾Ì¸",
      NotGreaterTilde: "â‰µ",
      NotHumpDownHump: "â‰ŽÌ¸",
      NotHumpEqual: "â‰Ì¸",
      notin: "âˆ‰",
      notindot: "â‹µÌ¸",
      notinE: "â‹¹Ì¸",
      notinva: "âˆ‰",
      notinvb: "â‹·",
      notinvc: "â‹¶",
      NotLeftTriangle: "â‹ª",
      NotLeftTriangleBar: "â§Ì¸",
      NotLeftTriangleEqual: "â‹¬",
      NotLess: "â‰®",
      NotLessEqual: "â‰°",
      NotLessGreater: "â‰¸",
      NotLessLess: "â‰ªÌ¸",
      NotLessSlantEqual: "â©½Ì¸",
      NotLessTilde: "â‰´",
      NotNestedGreaterGreater: "âª¢Ì¸",
      NotNestedLessLess: "âª¡Ì¸",
      notni: "âˆŒ",
      notniva: "âˆŒ",
      notnivb: "â‹¾",
      notnivc: "â‹½",
      NotPrecedes: "âŠ€",
      NotPrecedesEqual: "âª¯Ì¸",
      NotPrecedesSlantEqual: "â‹ ",
      NotReverseElement: "âˆŒ",
      NotRightTriangle: "â‹«",
      NotRightTriangleBar: "â§Ì¸",
      NotRightTriangleEqual: "â‹­",
      NotSquareSubset: "âŠÌ¸",
      NotSquareSubsetEqual: "â‹¢",
      NotSquareSuperset: "âŠÌ¸",
      NotSquareSupersetEqual: "â‹£",
      NotSubset: "âŠ‚âƒ’",
      NotSubsetEqual: "âŠˆ",
      NotSucceeds: "âŠ",
      NotSucceedsEqual: "âª°Ì¸",
      NotSucceedsSlantEqual: "â‹¡",
      NotSucceedsTilde: "â‰¿Ì¸",
      NotSuperset: "âŠƒâƒ’",
      NotSupersetEqual: "âŠ‰",
      NotTilde: "â‰",
      NotTildeEqual: "â‰„",
      NotTildeFullEqual: "â‰‡",
      NotTildeTilde: "â‰‰",
      NotVerticalBar: "âˆ¤",
      npar: "âˆ¦",
      nparallel: "âˆ¦",
      nparsl: "â«½âƒ¥",
      npart: "âˆ‚Ì¸",
      npolint: "â¨”",
      npr: "âŠ€",
      nprcue: "â‹ ",
      npre: "âª¯Ì¸",
      nprec: "âŠ€",
      npreceq: "âª¯Ì¸",
      nrArr: "â‡",
      nrarr: "â†›",
      nrarrc: "â¤³Ì¸",
      nrarrw: "â†Ì¸",
      nRightarrow: "â‡",
      nrightarrow: "â†›",
      nrtri: "â‹«",
      nrtrie: "â‹­",
      nsc: "âŠ",
      nsccue: "â‹¡",
      nsce: "âª°Ì¸",
      Nscr: "ð’©",
      nscr: "ð“ƒ",
      nshortmid: "âˆ¤",
      nshortparallel: "âˆ¦",
      nsim: "â‰",
      nsime: "â‰„",
      nsimeq: "â‰„",
      nsmid: "âˆ¤",
      nspar: "âˆ¦",
      nsqsube: "â‹¢",
      nsqsupe: "â‹£",
      nsub: "âŠ„",
      nsubE: "â«…Ì¸",
      nsube: "âŠˆ",
      nsubset: "âŠ‚âƒ’",
      nsubseteq: "âŠˆ",
      nsubseteqq: "â«…Ì¸",
      nsucc: "âŠ",
      nsucceq: "âª°Ì¸",
      nsup: "âŠ…",
      nsupE: "â«†Ì¸",
      nsupe: "âŠ‰",
      nsupset: "âŠƒâƒ’",
      nsupseteq: "âŠ‰",
      nsupseteqq: "â«†Ì¸",
      ntgl: "â‰¹",
      Ntilde: "Ã‘",
      ntilde: "Ã±",
      ntlg: "â‰¸",
      ntriangleleft: "â‹ª",
      ntrianglelefteq: "â‹¬",
      ntriangleright: "â‹«",
      ntrianglerighteq: "â‹­",
      Nu: "Î",
      nu: "Î½",
      num: "#",
      numero: "â„–",
      numsp: "â€‡",
      nvap: "â‰âƒ’",
      nVDash: "âŠ¯",
      nVdash: "âŠ®",
      nvDash: "âŠ­",
      nvdash: "âŠ¬",
      nvge: "â‰¥âƒ’",
      nvgt: ">âƒ’",
      nvHarr: "â¤„",
      nvinfin: "â§ž",
      nvlArr: "â¤‚",
      nvle: "â‰¤âƒ’",
      nvlt: "<âƒ’",
      nvltrie: "âŠ´âƒ’",
      nvrArr: "â¤ƒ",
      nvrtrie: "âŠµâƒ’",
      nvsim: "âˆ¼âƒ’",
      nwarhk: "â¤£",
      nwArr: "â‡–",
      nwarr: "â†–",
      nwarrow: "â†–",
      nwnear: "â¤§",
      Oacute: "Ã“",
      oacute: "Ã³",
      oast: "âŠ›",
      ocir: "âŠš",
      Ocirc: "Ã”",
      ocirc: "Ã´",
      Ocy: "Ðž",
      ocy: "Ð¾",
      odash: "âŠ",
      Odblac: "Å",
      odblac: "Å‘",
      odiv: "â¨¸",
      odot: "âŠ™",
      odsold: "â¦¼",
      OElig: "Å’",
      oelig: "Å“",
      ofcir: "â¦¿",
      Ofr: "ð”’",
      ofr: "ð”¬",
      ogon: "Ë›",
      Ograve: "Ã’",
      ograve: "Ã²",
      ogt: "â§",
      ohbar: "â¦µ",
      ohm: "Î©",
      oint: "âˆ®",
      olarr: "â†º",
      olcir: "â¦¾",
      olcross: "â¦»",
      oline: "â€¾",
      olt: "â§€",
      Omacr: "ÅŒ",
      omacr: "Å",
      Omega: "Î©",
      omega: "Ï‰",
      Omicron: "ÎŸ",
      omicron: "Î¿",
      omid: "â¦¶",
      ominus: "âŠ–",
      Oopf: "ð•†",
      oopf: "ð• ",
      opar: "â¦·",
      OpenCurlyDoubleQuote: "â€œ",
      OpenCurlyQuote: "â€˜",
      operp: "â¦¹",
      oplus: "âŠ•",
      Or: "â©”",
      or: "âˆ¨",
      orarr: "â†»",
      ord: "â©",
      order: "â„´",
      orderof: "â„´",
      ordf: "Âª",
      ordm: "Âº",
      origof: "âŠ¶",
      oror: "â©–",
      orslope: "â©—",
      orv: "â©›",
      oS: "â“ˆ",
      Oscr: "ð’ª",
      oscr: "â„´",
      Oslash: "Ã˜",
      oslash: "Ã¸",
      osol: "âŠ˜",
      Otilde: "Ã•",
      otilde: "Ãµ",
      Otimes: "â¨·",
      otimes: "âŠ—",
      otimesas: "â¨¶",
      Ouml: "Ã–",
      ouml: "Ã¶",
      ovbar: "âŒ½",
      OverBar: "â€¾",
      OverBrace: "âž",
      OverBracket: "âŽ´",
      OverParenthesis: "âœ",
      par: "âˆ¥",
      para: "Â¶",
      parallel: "âˆ¥",
      parsim: "â«³",
      parsl: "â«½",
      part: "âˆ‚",
      PartialD: "âˆ‚",
      Pcy: "ÐŸ",
      pcy: "Ð¿",
      percnt: "%",
      period: ".",
      permil: "â€°",
      perp: "âŠ¥",
      pertenk: "â€±",
      Pfr: "ð”“",
      pfr: "ð”­",
      Phi: "Î¦",
      phi: "Ï†",
      phiv: "Ï•",
      phmmat: "â„³",
      phone: "â˜Ž",
      Pi: "Î ",
      pi: "Ï€",
      pitchfork: "â‹”",
      piv: "Ï–",
      planck: "â„",
      planckh: "â„Ž",
      plankv: "â„",
      plus: "+",
      plusacir: "â¨£",
      plusb: "âŠž",
      pluscir: "â¨¢",
      plusdo: "âˆ”",
      plusdu: "â¨¥",
      pluse: "â©²",
      PlusMinus: "Â±",
      plusmn: "Â±",
      plussim: "â¨¦",
      plustwo: "â¨§",
      pm: "Â±",
      Poincareplane: "â„Œ",
      pointint: "â¨•",
      Popf: "â„™",
      popf: "ð•¡",
      pound: "Â£",
      Pr: "âª»",
      pr: "â‰º",
      prap: "âª·",
      prcue: "â‰¼",
      prE: "âª³",
      pre: "âª¯",
      prec: "â‰º",
      precapprox: "âª·",
      preccurlyeq: "â‰¼",
      Precedes: "â‰º",
      PrecedesEqual: "âª¯",
      PrecedesSlantEqual: "â‰¼",
      PrecedesTilde: "â‰¾",
      preceq: "âª¯",
      precnapprox: "âª¹",
      precneqq: "âªµ",
      precnsim: "â‹¨",
      precsim: "â‰¾",
      Prime: "â€³",
      prime: "â€²",
      primes: "â„™",
      prnap: "âª¹",
      prnE: "âªµ",
      prnsim: "â‹¨",
      prod: "âˆ",
      Product: "âˆ",
      profalar: "âŒ®",
      profline: "âŒ’",
      profsurf: "âŒ“",
      prop: "âˆ",
      Proportion: "âˆ·",
      Proportional: "âˆ",
      propto: "âˆ",
      prsim: "â‰¾",
      prurel: "âŠ°",
      Pscr: "ð’«",
      pscr: "ð“…",
      Psi: "Î¨",
      psi: "Ïˆ",
      puncsp: "â€ˆ",
      Qfr: "ð””",
      qfr: "ð”®",
      qint: "â¨Œ",
      Qopf: "â„š",
      qopf: "ð•¢",
      qprime: "â—",
      Qscr: "ð’¬",
      qscr: "ð“†",
      quaternions: "â„",
      quatint: "â¨–",
      quest: "?",
      questeq: "â‰Ÿ",
      QUOT: '"',
      quot: '"',
      rAarr: "â‡›",
      race: "âˆ½Ì±",
      Racute: "Å”",
      racute: "Å•",
      radic: "âˆš",
      raemptyv: "â¦³",
      Rang: "âŸ«",
      rang: "âŸ©",
      rangd: "â¦’",
      range: "â¦¥",
      rangle: "âŸ©",
      raquo: "Â»",
      Rarr: "â† ",
      rArr: "â‡’",
      rarr: "â†’",
      rarrap: "â¥µ",
      rarrb: "â‡¥",
      rarrbfs: "â¤ ",
      rarrc: "â¤³",
      rarrfs: "â¤ž",
      rarrhk: "â†ª",
      rarrlp: "â†¬",
      rarrpl: "â¥…",
      rarrsim: "â¥´",
      Rarrtl: "â¤–",
      rarrtl: "â†£",
      rarrw: "â†",
      rAtail: "â¤œ",
      ratail: "â¤š",
      ratio: "âˆ¶",
      rationals: "â„š",
      RBarr: "â¤",
      rBarr: "â¤",
      rbarr: "â¤",
      rbbrk: "â³",
      rbrace: "}",
      rbrack: "]",
      rbrke: "â¦Œ",
      rbrksld: "â¦Ž",
      rbrkslu: "â¦",
      Rcaron: "Å˜",
      rcaron: "Å™",
      Rcedil: "Å–",
      rcedil: "Å—",
      rceil: "âŒ‰",
      rcub: "}",
      Rcy: "Ð ",
      rcy: "Ñ€",
      rdca: "â¤·",
      rdldhar: "â¥©",
      rdquo: "â€",
      rdquor: "â€",
      rdsh: "â†³",
      Re: "â„œ",
      real: "â„œ",
      realine: "â„›",
      realpart: "â„œ",
      reals: "â„",
      rect: "â–­",
      REG: "Â®",
      reg: "Â®",
      ReverseElement: "âˆ‹",
      ReverseEquilibrium: "â‡‹",
      ReverseUpEquilibrium: "â¥¯",
      rfisht: "â¥½",
      rfloor: "âŒ‹",
      Rfr: "â„œ",
      rfr: "ð”¯",
      rHar: "â¥¤",
      rhard: "â‡",
      rharu: "â‡€",
      rharul: "â¥¬",
      Rho: "Î¡",
      rho: "Ï",
      rhov: "Ï±",
      RightAngleBracket: "âŸ©",
      RightArrow: "â†’",
      Rightarrow: "â‡’",
      rightarrow: "â†’",
      RightArrowBar: "â‡¥",
      RightArrowLeftArrow: "â‡„",
      rightarrowtail: "â†£",
      RightCeiling: "âŒ‰",
      RightDoubleBracket: "âŸ§",
      RightDownTeeVector: "â¥",
      RightDownVector: "â‡‚",
      RightDownVectorBar: "â¥•",
      RightFloor: "âŒ‹",
      rightharpoondown: "â‡",
      rightharpoonup: "â‡€",
      rightleftarrows: "â‡„",
      rightleftharpoons: "â‡Œ",
      rightrightarrows: "â‡‰",
      rightsquigarrow: "â†",
      RightTee: "âŠ¢",
      RightTeeArrow: "â†¦",
      RightTeeVector: "â¥›",
      rightthreetimes: "â‹Œ",
      RightTriangle: "âŠ³",
      RightTriangleBar: "â§",
      RightTriangleEqual: "âŠµ",
      RightUpDownVector: "â¥",
      RightUpTeeVector: "â¥œ",
      RightUpVector: "â†¾",
      RightUpVectorBar: "â¥”",
      RightVector: "â‡€",
      RightVectorBar: "â¥“",
      ring: "Ëš",
      risingdotseq: "â‰“",
      rlarr: "â‡„",
      rlhar: "â‡Œ",
      rlm: "â€",
      rmoust: "âŽ±",
      rmoustache: "âŽ±",
      rnmid: "â«®",
      roang: "âŸ­",
      roarr: "â‡¾",
      robrk: "âŸ§",
      ropar: "â¦†",
      Ropf: "â„",
      ropf: "ð•£",
      roplus: "â¨®",
      rotimes: "â¨µ",
      RoundImplies: "â¥°",
      rpar: ")",
      rpargt: "â¦”",
      rppolint: "â¨’",
      rrarr: "â‡‰",
      Rrightarrow: "â‡›",
      rsaquo: "â€º",
      Rscr: "â„›",
      rscr: "ð“‡",
      Rsh: "â†±",
      rsh: "â†±",
      rsqb: "]",
      rsquo: "â€™",
      rsquor: "â€™",
      rthree: "â‹Œ",
      rtimes: "â‹Š",
      rtri: "â–¹",
      rtrie: "âŠµ",
      rtrif: "â–¸",
      rtriltri: "â§Ž",
      RuleDelayed: "â§´",
      ruluhar: "â¥¨",
      rx: "â„ž",
      Sacute: "Åš",
      sacute: "Å›",
      sbquo: "â€š",
      Sc: "âª¼",
      sc: "â‰»",
      scap: "âª¸",
      Scaron: "Å ",
      scaron: "Å¡",
      sccue: "â‰½",
      scE: "âª´",
      sce: "âª°",
      Scedil: "Åž",
      scedil: "ÅŸ",
      Scirc: "Åœ",
      scirc: "Å",
      scnap: "âªº",
      scnE: "âª¶",
      scnsim: "â‹©",
      scpolint: "â¨“",
      scsim: "â‰¿",
      Scy: "Ð¡",
      scy: "Ñ",
      sdot: "â‹…",
      sdotb: "âŠ¡",
      sdote: "â©¦",
      searhk: "â¤¥",
      seArr: "â‡˜",
      searr: "â†˜",
      searrow: "â†˜",
      sect: "Â§",
      semi: ";",
      seswar: "â¤©",
      setminus: "âˆ–",
      setmn: "âˆ–",
      sext: "âœ¶",
      Sfr: "ð”–",
      sfr: "ð”°",
      sfrown: "âŒ¢",
      sharp: "â™¯",
      SHCHcy: "Ð©",
      shchcy: "Ñ‰",
      SHcy: "Ð¨",
      shcy: "Ñˆ",
      ShortDownArrow: "â†“",
      ShortLeftArrow: "â†",
      shortmid: "âˆ£",
      shortparallel: "âˆ¥",
      ShortRightArrow: "â†’",
      ShortUpArrow: "â†‘",
      shy: "Â­",
      Sigma: "Î£",
      sigma: "Ïƒ",
      sigmaf: "Ï‚",
      sigmav: "Ï‚",
      sim: "âˆ¼",
      simdot: "â©ª",
      sime: "â‰ƒ",
      simeq: "â‰ƒ",
      simg: "âªž",
      simgE: "âª ",
      siml: "âª",
      simlE: "âªŸ",
      simne: "â‰†",
      simplus: "â¨¤",
      simrarr: "â¥²",
      slarr: "â†",
      SmallCircle: "âˆ˜",
      smallsetminus: "âˆ–",
      smashp: "â¨³",
      smeparsl: "â§¤",
      smid: "âˆ£",
      smile: "âŒ£",
      smt: "âªª",
      smte: "âª¬",
      smtes: "âª¬ï¸€",
      SOFTcy: "Ð¬",
      softcy: "ÑŒ",
      sol: "/",
      solb: "â§„",
      solbar: "âŒ¿",
      Sopf: "ð•Š",
      sopf: "ð•¤",
      spades: "â™ ",
      spadesuit: "â™ ",
      spar: "âˆ¥",
      sqcap: "âŠ“",
      sqcaps: "âŠ“ï¸€",
      sqcup: "âŠ”",
      sqcups: "âŠ”ï¸€",
      Sqrt: "âˆš",
      sqsub: "âŠ",
      sqsube: "âŠ‘",
      sqsubset: "âŠ",
      sqsubseteq: "âŠ‘",
      sqsup: "âŠ",
      sqsupe: "âŠ’",
      sqsupset: "âŠ",
      sqsupseteq: "âŠ’",
      squ: "â–¡",
      Square: "â–¡",
      square: "â–¡",
      SquareIntersection: "âŠ“",
      SquareSubset: "âŠ",
      SquareSubsetEqual: "âŠ‘",
      SquareSuperset: "âŠ",
      SquareSupersetEqual: "âŠ’",
      SquareUnion: "âŠ”",
      squarf: "â–ª",
      squf: "â–ª",
      srarr: "â†’",
      Sscr: "ð’®",
      sscr: "ð“ˆ",
      ssetmn: "âˆ–",
      ssmile: "âŒ£",
      sstarf: "â‹†",
      Star: "â‹†",
      star: "â˜†",
      starf: "â˜…",
      straightepsilon: "Ïµ",
      straightphi: "Ï•",
      strns: "Â¯",
      Sub: "â‹",
      sub: "âŠ‚",
      subdot: "âª½",
      subE: "â«…",
      sube: "âŠ†",
      subedot: "â«ƒ",
      submult: "â«",
      subnE: "â«‹",
      subne: "âŠŠ",
      subplus: "âª¿",
      subrarr: "â¥¹",
      Subset: "â‹",
      subset: "âŠ‚",
      subseteq: "âŠ†",
      subseteqq: "â«…",
      SubsetEqual: "âŠ†",
      subsetneq: "âŠŠ",
      subsetneqq: "â«‹",
      subsim: "â«‡",
      subsub: "â«•",
      subsup: "â«“",
      succ: "â‰»",
      succapprox: "âª¸",
      succcurlyeq: "â‰½",
      Succeeds: "â‰»",
      SucceedsEqual: "âª°",
      SucceedsSlantEqual: "â‰½",
      SucceedsTilde: "â‰¿",
      succeq: "âª°",
      succnapprox: "âªº",
      succneqq: "âª¶",
      succnsim: "â‹©",
      succsim: "â‰¿",
      SuchThat: "âˆ‹",
      Sum: "âˆ‘",
      sum: "âˆ‘",
      sung: "â™ª",
      Sup: "â‹‘",
      sup: "âŠƒ",
      sup1: "Â¹",
      sup2: "Â²",
      sup3: "Â³",
      supdot: "âª¾",
      supdsub: "â«˜",
      supE: "â«†",
      supe: "âŠ‡",
      supedot: "â«„",
      Superset: "âŠƒ",
      SupersetEqual: "âŠ‡",
      suphsol: "âŸ‰",
      suphsub: "â«—",
      suplarr: "â¥»",
      supmult: "â«‚",
      supnE: "â«Œ",
      supne: "âŠ‹",
      supplus: "â«€",
      Supset: "â‹‘",
      supset: "âŠƒ",
      supseteq: "âŠ‡",
      supseteqq: "â«†",
      supsetneq: "âŠ‹",
      supsetneqq: "â«Œ",
      supsim: "â«ˆ",
      supsub: "â«”",
      supsup: "â«–",
      swarhk: "â¤¦",
      swArr: "â‡™",
      swarr: "â†™",
      swarrow: "â†™",
      swnwar: "â¤ª",
      szlig: "ÃŸ",
      Tab: "	",
      target: "âŒ–",
      Tau: "Î¤",
      tau: "Ï„",
      tbrk: "âŽ´",
      Tcaron: "Å¤",
      tcaron: "Å¥",
      Tcedil: "Å¢",
      tcedil: "Å£",
      Tcy: "Ð¢",
      tcy: "Ñ‚",
      tdot: "âƒ›",
      telrec: "âŒ•",
      Tfr: "ð”—",
      tfr: "ð”±",
      there4: "âˆ´",
      Therefore: "âˆ´",
      therefore: "âˆ´",
      Theta: "Î˜",
      theta: "Î¸",
      thetasym: "Ï‘",
      thetav: "Ï‘",
      thickapprox: "â‰ˆ",
      thicksim: "âˆ¼",
      ThickSpace: "âŸâ€Š",
      thinsp: "â€‰",
      ThinSpace: "â€‰",
      thkap: "â‰ˆ",
      thksim: "âˆ¼",
      THORN: "Ãž",
      thorn: "Ã¾",
      Tilde: "âˆ¼",
      tilde: "Ëœ",
      TildeEqual: "â‰ƒ",
      TildeFullEqual: "â‰…",
      TildeTilde: "â‰ˆ",
      times: "Ã—",
      timesb: "âŠ ",
      timesbar: "â¨±",
      timesd: "â¨°",
      tint: "âˆ­",
      toea: "â¤¨",
      top: "âŠ¤",
      topbot: "âŒ¶",
      topcir: "â«±",
      Topf: "ð•‹",
      topf: "ð•¥",
      topfork: "â«š",
      tosa: "â¤©",
      tprime: "â€´",
      TRADE: "â„¢",
      trade: "â„¢",
      triangle: "â–µ",
      triangledown: "â–¿",
      triangleleft: "â—ƒ",
      trianglelefteq: "âŠ´",
      triangleq: "â‰œ",
      triangleright: "â–¹",
      trianglerighteq: "âŠµ",
      tridot: "â—¬",
      trie: "â‰œ",
      triminus: "â¨º",
      TripleDot: "âƒ›",
      triplus: "â¨¹",
      trisb: "â§",
      tritime: "â¨»",
      trpezium: "â¢",
      Tscr: "ð’¯",
      tscr: "ð“‰",
      TScy: "Ð¦",
      tscy: "Ñ†",
      TSHcy: "Ð‹",
      tshcy: "Ñ›",
      Tstrok: "Å¦",
      tstrok: "Å§",
      twixt: "â‰¬",
      twoheadleftarrow: "â†ž",
      twoheadrightarrow: "â† ",
      Uacute: "Ãš",
      uacute: "Ãº",
      Uarr: "â†Ÿ",
      uArr: "â‡‘",
      uarr: "â†‘",
      Uarrocir: "â¥‰",
      Ubrcy: "ÐŽ",
      ubrcy: "Ñž",
      Ubreve: "Å¬",
      ubreve: "Å­",
      Ucirc: "Ã›",
      ucirc: "Ã»",
      Ucy: "Ð£",
      ucy: "Ñƒ",
      udarr: "â‡…",
      Udblac: "Å°",
      udblac: "Å±",
      udhar: "â¥®",
      ufisht: "â¥¾",
      Ufr: "ð”˜",
      ufr: "ð”²",
      Ugrave: "Ã™",
      ugrave: "Ã¹",
      uHar: "â¥£",
      uharl: "â†¿",
      uharr: "â†¾",
      uhblk: "â–€",
      ulcorn: "âŒœ",
      ulcorner: "âŒœ",
      ulcrop: "âŒ",
      ultri: "â—¸",
      Umacr: "Åª",
      umacr: "Å«",
      uml: "Â¨",
      UnderBar: "_",
      UnderBrace: "âŸ",
      UnderBracket: "âŽµ",
      UnderParenthesis: "â",
      Union: "â‹ƒ",
      UnionPlus: "âŠŽ",
      Uogon: "Å²",
      uogon: "Å³",
      Uopf: "ð•Œ",
      uopf: "ð•¦",
      UpArrow: "â†‘",
      Uparrow: "â‡‘",
      uparrow: "â†‘",
      UpArrowBar: "â¤’",
      UpArrowDownArrow: "â‡…",
      UpDownArrow: "â†•",
      Updownarrow: "â‡•",
      updownarrow: "â†•",
      UpEquilibrium: "â¥®",
      upharpoonleft: "â†¿",
      upharpoonright: "â†¾",
      uplus: "âŠŽ",
      UpperLeftArrow: "â†–",
      UpperRightArrow: "â†—",
      Upsi: "Ï’",
      upsi: "Ï…",
      upsih: "Ï’",
      Upsilon: "Î¥",
      upsilon: "Ï…",
      UpTee: "âŠ¥",
      UpTeeArrow: "â†¥",
      upuparrows: "â‡ˆ",
      urcorn: "âŒ",
      urcorner: "âŒ",
      urcrop: "âŒŽ",
      Uring: "Å®",
      uring: "Å¯",
      urtri: "â—¹",
      Uscr: "ð’°",
      uscr: "ð“Š",
      utdot: "â‹°",
      Utilde: "Å¨",
      utilde: "Å©",
      utri: "â–µ",
      utrif: "â–´",
      uuarr: "â‡ˆ",
      Uuml: "Ãœ",
      uuml: "Ã¼",
      uwangle: "â¦§",
      vangrt: "â¦œ",
      varepsilon: "Ïµ",
      varkappa: "Ï°",
      varnothing: "âˆ…",
      varphi: "Ï•",
      varpi: "Ï–",
      varpropto: "âˆ",
      vArr: "â‡•",
      varr: "â†•",
      varrho: "Ï±",
      varsigma: "Ï‚",
      varsubsetneq: "âŠŠï¸€",
      varsubsetneqq: "â«‹ï¸€",
      varsupsetneq: "âŠ‹ï¸€",
      varsupsetneqq: "â«Œï¸€",
      vartheta: "Ï‘",
      vartriangleleft: "âŠ²",
      vartriangleright: "âŠ³",
      Vbar: "â««",
      vBar: "â«¨",
      vBarv: "â«©",
      Vcy: "Ð’",
      vcy: "Ð²",
      VDash: "âŠ«",
      Vdash: "âŠ©",
      vDash: "âŠ¨",
      vdash: "âŠ¢",
      Vdashl: "â«¦",
      Vee: "â‹",
      vee: "âˆ¨",
      veebar: "âŠ»",
      veeeq: "â‰š",
      vellip: "â‹®",
      Verbar: "â€–",
      verbar: "|",
      Vert: "â€–",
      vert: "|",
      VerticalBar: "âˆ£",
      VerticalLine: "|",
      VerticalSeparator: "â˜",
      VerticalTilde: "â‰€",
      VeryThinSpace: "â€Š",
      Vfr: "ð”™",
      vfr: "ð”³",
      vltri: "âŠ²",
      vnsub: "âŠ‚âƒ’",
      vnsup: "âŠƒâƒ’",
      Vopf: "ð•",
      vopf: "ð•§",
      vprop: "âˆ",
      vrtri: "âŠ³",
      Vscr: "ð’±",
      vscr: "ð“‹",
      vsubnE: "â«‹ï¸€",
      vsubne: "âŠŠï¸€",
      vsupnE: "â«Œï¸€",
      vsupne: "âŠ‹ï¸€",
      Vvdash: "âŠª",
      vzigzag: "â¦š",
      Wcirc: "Å´",
      wcirc: "Åµ",
      wedbar: "â©Ÿ",
      Wedge: "â‹€",
      wedge: "âˆ§",
      wedgeq: "â‰™",
      weierp: "â„˜",
      Wfr: "ð”š",
      wfr: "ð”´",
      Wopf: "ð•Ž",
      wopf: "ð•¨",
      wp: "â„˜",
      wr: "â‰€",
      wreath: "â‰€",
      Wscr: "ð’²",
      wscr: "ð“Œ",
      xcap: "â‹‚",
      xcirc: "â—¯",
      xcup: "â‹ƒ",
      xdtri: "â–½",
      Xfr: "ð”›",
      xfr: "ð”µ",
      xhArr: "âŸº",
      xharr: "âŸ·",
      Xi: "Îž",
      xi: "Î¾",
      xlArr: "âŸ¸",
      xlarr: "âŸµ",
      xmap: "âŸ¼",
      xnis: "â‹»",
      xodot: "â¨€",
      Xopf: "ð•",
      xopf: "ð•©",
      xoplus: "â¨",
      xotime: "â¨‚",
      xrArr: "âŸ¹",
      xrarr: "âŸ¶",
      Xscr: "ð’³",
      xscr: "ð“",
      xsqcup: "â¨†",
      xuplus: "â¨„",
      xutri: "â–³",
      xvee: "â‹",
      xwedge: "â‹€",
      Yacute: "Ã",
      yacute: "Ã½",
      YAcy: "Ð¯",
      yacy: "Ñ",
      Ycirc: "Å¶",
      ycirc: "Å·",
      Ycy: "Ð«",
      ycy: "Ñ‹",
      yen: "Â¥",
      Yfr: "ð”œ",
      yfr: "ð”¶",
      YIcy: "Ð‡",
      yicy: "Ñ—",
      Yopf: "ð•",
      yopf: "ð•ª",
      Yscr: "ð’´",
      yscr: "ð“Ž",
      YUcy: "Ð®",
      yucy: "ÑŽ",
      Yuml: "Å¸",
      yuml: "Ã¿",
      Zacute: "Å¹",
      zacute: "Åº",
      Zcaron: "Å½",
      zcaron: "Å¾",
      Zcy: "Ð—",
      zcy: "Ð·",
      Zdot: "Å»",
      zdot: "Å¼",
      zeetrf: "â„¨",
      ZeroWidthSpace: "â€‹",
      Zeta: "Î–",
      zeta: "Î¶",
      Zfr: "â„¨",
      zfr: "ð”·",
      ZHcy: "Ð–",
      zhcy: "Ð¶",
      zigrarr: "â‡",
      Zopf: "â„¤",
      zopf: "ð•«",
      Zscr: "ð’µ",
      zscr: "ð“",
      zwj: "â€",
      zwnj: "â€Œ"
    });
    exports$1.entityMap = exports$1.HTML_ENTITIES;
  })(entities);
  return entities;
}
var sax = {};
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  var NAMESPACE = requireConventions().NAMESPACE;
  var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
  var S_TAG = 0;
  var S_ATTR = 1;
  var S_ATTR_SPACE = 2;
  var S_EQ = 3;
  var S_ATTR_NOQUOT_VALUE = 4;
  var S_ATTR_END = 5;
  var S_TAG_SPACE = 6;
  var S_TAG_CLOSE = 7;
  function ParseError(message, locator) {
    this.message = message;
    this.locator = locator;
    if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
  }
  ParseError.prototype = new Error();
  ParseError.prototype.name = ParseError.name;
  function XMLReader() {
  }
  XMLReader.prototype = {
    parse: function(source, defaultNSMap, entityMap) {
      var domBuilder = this.domBuilder;
      domBuilder.startDocument();
      _copy(defaultNSMap, defaultNSMap = {});
      parse(
        source,
        defaultNSMap,
        entityMap,
        domBuilder,
        this.errorHandler
      );
      domBuilder.endDocument();
    }
  };
  function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
    function fixedFromCharCode(code) {
      if (code > 65535) {
        code -= 65536;
        var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      } else {
        return String.fromCharCode(code);
      }
    }
    function entityReplacer(a2) {
      var k = a2.slice(1, -1);
      if (Object.hasOwnProperty.call(entityMap, k)) {
        return entityMap[k];
      } else if (k.charAt(0) === "#") {
        return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
      } else {
        errorHandler.error("entity not found:" + a2);
        return a2;
      }
    }
    function appendText(end2) {
      if (end2 > start) {
        var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
        locator && position(start);
        domBuilder.characters(xt, 0, end2 - start);
        start = end2;
      }
    }
    function position(p, m) {
      while (p >= lineEnd && (m = linePattern.exec(source))) {
        lineStart = m.index;
        lineEnd = lineStart + m[0].length;
        locator.lineNumber++;
      }
      locator.columnNumber = p - lineStart + 1;
    }
    var lineStart = 0;
    var lineEnd = 0;
    var linePattern = /.*(?:\r\n?|\n)|.*$/g;
    var locator = domBuilder.locator;
    var parseStack = [{ currentNSMap: defaultNSMapCopy }];
    var closeMap = {};
    var start = 0;
    while (true) {
      try {
        var tagStart = source.indexOf("<", start);
        if (tagStart < 0) {
          if (!source.substr(start).match(/^\s*$/)) {
            var doc = domBuilder.doc;
            var text = doc.createTextNode(source.substr(start));
            doc.appendChild(text);
            domBuilder.currentElement = text;
          }
          return;
        }
        if (tagStart > start) {
          appendText(tagStart);
        }
        switch (source.charAt(tagStart + 1)) {
          case "/":
            var end = source.indexOf(">", tagStart + 3);
            var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
            var config = parseStack.pop();
            if (end < 0) {
              tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
              end = tagStart + 1 + tagName.length;
            } else if (tagName.match(/\s</)) {
              tagName = tagName.replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " maybe not complete");
              end = tagStart + 1 + tagName.length;
            }
            var localNSMap = config.localNSMap;
            var endMatch = config.tagName == tagName;
            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
            if (endIgnoreCaseMach) {
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
              if (!endMatch) {
                errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
              }
            } else {
              parseStack.push(config);
            }
            end++;
            break;
          // end elment
          case "?":
            locator && position(tagStart);
            end = parseInstruction(source, tagStart, domBuilder);
            break;
          case "!":
            locator && position(tagStart);
            end = parseDCC(source, tagStart, domBuilder, errorHandler);
            break;
          default:
            locator && position(tagStart);
            var el2 = new ElementAttributes();
            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
            var end = parseElementStartPart(source, tagStart, el2, currentNSMap, entityReplacer, errorHandler);
            var len = el2.length;
            if (!el2.closed && fixSelfClosed(source, end, el2.tagName, closeMap)) {
              el2.closed = true;
              if (!entityMap.nbsp) {
                errorHandler.warning("unclosed xml attribute");
              }
            }
            if (locator && len) {
              var locator2 = copyLocator(locator, {});
              for (var i = 0; i < len; i++) {
                var a = el2[i];
                position(a.offset);
                a.locator = copyLocator(locator, {});
              }
              domBuilder.locator = locator2;
              if (appendElement(el2, domBuilder, currentNSMap)) {
                parseStack.push(el2);
              }
              domBuilder.locator = locator;
            } else {
              if (appendElement(el2, domBuilder, currentNSMap)) {
                parseStack.push(el2);
              }
            }
            if (NAMESPACE.isHTML(el2.uri) && !el2.closed) {
              end = parseHtmlSpecialContent(source, end, el2.tagName, entityReplacer, domBuilder);
            } else {
              end++;
            }
        }
      } catch (e) {
        if (e instanceof ParseError) {
          throw e;
        }
        errorHandler.error("element parse error: " + e);
        end = -1;
      }
      if (end > start) {
        start = end;
      } else {
        appendText(Math.max(tagStart, start) + 1);
      }
    }
  }
  function copyLocator(f, t) {
    t.lineNumber = f.lineNumber;
    t.columnNumber = f.columnNumber;
    return t;
  }
  function parseElementStartPart(source, start, el2, currentNSMap, entityReplacer, errorHandler) {
    function addAttribute(qname, value2, startIndex) {
      if (el2.attributeNames.hasOwnProperty(qname)) {
        errorHandler.fatalError("Attribute " + qname + " redefined");
      }
      el2.addValue(
        qname,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
        startIndex
      );
    }
    var attrName;
    var value;
    var p = ++start;
    var s = S_TAG;
    while (true) {
      var c = source.charAt(p);
      switch (c) {
        case "=":
          if (s === S_ATTR) {
            attrName = source.slice(start, p);
            s = S_EQ;
          } else if (s === S_ATTR_SPACE) {
            s = S_EQ;
          } else {
            throw new Error("attribute equal must after attrName");
          }
          break;
        case "'":
        case '"':
          if (s === S_EQ || s === S_ATTR) {
            if (s === S_ATTR) {
              errorHandler.warning('attribute value must after "="');
              attrName = source.slice(start, p);
            }
            start = p + 1;
            p = source.indexOf(c, start);
            if (p > 0) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start - 1);
              s = S_ATTR_END;
            } else {
              throw new Error("attribute value no end '" + c + "' match");
            }
          } else if (s == S_ATTR_NOQUOT_VALUE) {
            value = source.slice(start, p);
            addAttribute(attrName, value, start);
            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
            start = p + 1;
            s = S_ATTR_END;
          } else {
            throw new Error('attribute value must after "="');
          }
          break;
        case "/":
          switch (s) {
            case S_TAG:
              el2.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              s = S_TAG_CLOSE;
              el2.closed = true;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
              break;
            case S_ATTR_SPACE:
              el2.closed = true;
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          errorHandler.error("unexpected end of input");
          if (s == S_TAG) {
            el2.setTagName(source.slice(start, p));
          }
          return p;
        case ">":
          switch (s) {
            case S_TAG:
              el2.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              break;
            //normal
            case S_ATTR_NOQUOT_VALUE:
            //Compatible state
            case S_ATTR:
              value = source.slice(start, p);
              if (value.slice(-1) === "/") {
                el2.closed = true;
                value = value.slice(0, -1);
              }
            case S_ATTR_SPACE:
              if (s === S_ATTR_SPACE) {
                value = attrName;
              }
              if (s == S_ATTR_NOQUOT_VALUE) {
                errorHandler.warning('attribute "' + value + '" missed quot(")!');
                addAttribute(attrName, value, start);
              } else {
                if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                }
                addAttribute(value, value, start);
              }
              break;
            case S_EQ:
              throw new Error("attribute value missed!!");
          }
          return p;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "Â€":
          c = " ";
        default:
          if (c <= " ") {
            switch (s) {
              case S_TAG:
                el2.setTagName(source.slice(start, p));
                s = S_TAG_SPACE;
                break;
              case S_ATTR:
                attrName = source.slice(start, p);
                s = S_ATTR_SPACE;
                break;
              case S_ATTR_NOQUOT_VALUE:
                var value = source.slice(start, p);
                errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                addAttribute(attrName, value, start);
              case S_ATTR_END:
                s = S_TAG_SPACE;
                break;
            }
          } else {
            switch (s) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case S_ATTR_SPACE:
                el2.tagName;
                if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                }
                addAttribute(attrName, attrName, start);
                start = p;
                s = S_ATTR;
                break;
              case S_ATTR_END:
                errorHandler.warning('attribute space is required"' + attrName + '"!!');
              case S_TAG_SPACE:
                s = S_ATTR;
                start = p;
                break;
              case S_EQ:
                s = S_ATTR_NOQUOT_VALUE;
                start = p;
                break;
              case S_TAG_CLOSE:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
          }
      }
      p++;
    }
  }
  function appendElement(el2, domBuilder, currentNSMap) {
    var tagName = el2.tagName;
    var localNSMap = null;
    var i = el2.length;
    while (i--) {
      var a = el2[i];
      var qName = a.qName;
      var value = a.value;
      var nsp = qName.indexOf(":");
      if (nsp > 0) {
        var prefix = a.prefix = qName.slice(0, nsp);
        var localName = qName.slice(nsp + 1);
        var nsPrefix = prefix === "xmlns" && localName;
      } else {
        localName = qName;
        prefix = null;
        nsPrefix = qName === "xmlns" && "";
      }
      a.localName = localName;
      if (nsPrefix !== false) {
        if (localNSMap == null) {
          localNSMap = {};
          _copy(currentNSMap, currentNSMap = {});
        }
        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
        a.uri = NAMESPACE.XMLNS;
        domBuilder.startPrefixMapping(nsPrefix, value);
      }
    }
    var i = el2.length;
    while (i--) {
      a = el2[i];
      var prefix = a.prefix;
      if (prefix) {
        if (prefix === "xml") {
          a.uri = NAMESPACE.XML;
        }
        if (prefix !== "xmlns") {
          a.uri = currentNSMap[prefix || ""];
        }
      }
    }
    var nsp = tagName.indexOf(":");
    if (nsp > 0) {
      prefix = el2.prefix = tagName.slice(0, nsp);
      localName = el2.localName = tagName.slice(nsp + 1);
    } else {
      prefix = null;
      localName = el2.localName = tagName;
    }
    var ns = el2.uri = currentNSMap[prefix || ""];
    domBuilder.startElement(ns, localName, tagName, el2);
    if (el2.closed) {
      domBuilder.endElement(ns, localName, tagName);
      if (localNSMap) {
        for (prefix in localNSMap) {
          if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
            domBuilder.endPrefixMapping(prefix);
          }
        }
      }
    } else {
      el2.currentNSMap = currentNSMap;
      el2.localNSMap = localNSMap;
      return true;
    }
  }
  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
    if (/^(?:script|textarea)$/i.test(tagName)) {
      var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
      var text = source.substring(elStartEnd + 1, elEndStart);
      if (/[&<]/.test(text)) {
        if (/^script$/i.test(tagName)) {
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
        text = text.replace(/&#?\w+;/g, entityReplacer);
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
    }
    return elStartEnd + 1;
  }
  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
    var pos = closeMap[tagName];
    if (pos == null) {
      pos = source.lastIndexOf("</" + tagName + ">");
      if (pos < elStartEnd) {
        pos = source.lastIndexOf("</" + tagName);
      }
      closeMap[tagName] = pos;
    }
    return pos < elStartEnd;
  }
  function _copy(source, target2) {
    for (var n in source) {
      if (Object.prototype.hasOwnProperty.call(source, n)) {
        target2[n] = source[n];
      }
    }
  }
  function parseDCC(source, start, domBuilder, errorHandler) {
    var next = source.charAt(start + 2);
    switch (next) {
      case "-":
        if (source.charAt(start + 3) === "-") {
          var end = source.indexOf("-->", start + 4);
          if (end > start) {
            domBuilder.comment(source, start + 4, end - start - 4);
            return end + 3;
          } else {
            errorHandler.error("Unclosed comment");
            return -1;
          }
        } else {
          return -1;
        }
      default:
        if (source.substr(start + 3, 6) == "CDATA[") {
          var end = source.indexOf("]]>", start + 9);
          domBuilder.startCDATA();
          domBuilder.characters(source, start + 9, end - start - 9);
          domBuilder.endCDATA();
          return end + 3;
        }
        var matchs = split(source, start);
        var len = matchs.length;
        if (len > 1 && /!doctype/i.test(matchs[0][0])) {
          var name = matchs[1][0];
          var pubid = false;
          var sysid = false;
          if (len > 3) {
            if (/^public$/i.test(matchs[2][0])) {
              pubid = matchs[3][0];
              sysid = len > 4 && matchs[4][0];
            } else if (/^system$/i.test(matchs[2][0])) {
              sysid = matchs[3][0];
            }
          }
          var lastMatch = matchs[len - 1];
          domBuilder.startDTD(name, pubid, sysid);
          domBuilder.endDTD();
          return lastMatch.index + lastMatch[0].length;
        }
    }
    return -1;
  }
  function parseInstruction(source, start, domBuilder) {
    var end = source.indexOf("?>", start);
    if (end) {
      var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      if (match) {
        match[0].length;
        domBuilder.processingInstruction(match[1], match[2]);
        return end + 2;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function ElementAttributes() {
    this.attributeNames = {};
  }
  ElementAttributes.prototype = {
    setTagName: function(tagName) {
      if (!tagNamePattern.test(tagName)) {
        throw new Error("invalid tagName:" + tagName);
      }
      this.tagName = tagName;
    },
    addValue: function(qName, value, offset) {
      if (!tagNamePattern.test(qName)) {
        throw new Error("invalid attribute:" + qName);
      }
      this.attributeNames[qName] = this.length;
      this[this.length++] = { qName, value, offset };
    },
    length: 0,
    getLocalName: function(i) {
      return this[i].localName;
    },
    getLocator: function(i) {
      return this[i].locator;
    },
    getQName: function(i) {
      return this[i].qName;
    },
    getURI: function(i) {
      return this[i].uri;
    },
    getValue: function(i) {
      return this[i].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function split(source, start) {
    var match;
    var buf = [];
    var reg2 = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    reg2.lastIndex = start;
    reg2.exec(source);
    while (match = reg2.exec(source)) {
      buf.push(match);
      if (match[1]) return buf;
    }
  }
  sax.XMLReader = XMLReader;
  sax.ParseError = ParseError;
  return sax;
}
var hasRequiredDomParser;
function requireDomParser() {
  if (hasRequiredDomParser) return domParser;
  hasRequiredDomParser = 1;
  var conventions2 = requireConventions();
  var dom2 = requireDom$2();
  var entities2 = requireEntities();
  var sax2 = requireSax();
  var DOMImplementation = dom2.DOMImplementation;
  var NAMESPACE = conventions2.NAMESPACE;
  var ParseError = sax2.ParseError;
  var XMLReader = sax2.XMLReader;
  function normalizeLineEndings(input) {
    return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
  }
  function DOMParser(options) {
    this.options = options || { locator: {} };
  }
  DOMParser.prototype.parseFromString = function(source, mimeType) {
    var options = this.options;
    var sax3 = new XMLReader();
    var domBuilder = options.domBuilder || new DOMHandler();
    var errorHandler = options.errorHandler;
    var locator = options.locator;
    var defaultNSMap = options.xmlns || {};
    var isHTML = /\/x?html?$/.test(mimeType);
    var entityMap = isHTML ? entities2.HTML_ENTITIES : entities2.XML_ENTITIES;
    if (locator) {
      domBuilder.setDocumentLocator(locator);
    }
    sax3.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax3.domBuilder = options.domBuilder || domBuilder;
    if (isHTML) {
      defaultNSMap[""] = NAMESPACE.HTML;
    }
    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
    var normalize2 = options.normalizeLineEndings || normalizeLineEndings;
    if (source && typeof source === "string") {
      sax3.parse(
        normalize2(source),
        defaultNSMap,
        entityMap
      );
    } else {
      sax3.errorHandler.error("invalid doc source");
    }
    return domBuilder.doc;
  };
  function buildErrorHandler(errorImpl, domBuilder, locator) {
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }
      errorImpl = domBuilder;
    }
    var errorHandler = {};
    var isCallback = errorImpl instanceof Function;
    locator = locator || {};
    function build(key) {
      var fn = errorImpl[key];
      if (!fn && isCallback) {
        fn = errorImpl.length == 2 ? function(msg) {
          errorImpl(key, msg);
        } : errorImpl;
      }
      errorHandler[key] = fn && function(msg) {
        fn("[xmldom " + key + "]	" + msg + _locator(locator));
      } || function() {
      };
    }
    build("warning");
    build("error");
    build("fatalError");
    return errorHandler;
  }
  function DOMHandler() {
    this.cdata = false;
  }
  function position(locator, node2) {
    node2.lineNumber = locator.lineNumber;
    node2.columnNumber = locator.columnNumber;
  }
  DOMHandler.prototype = {
    startDocument: function() {
      this.doc = new DOMImplementation().createDocument(null, null, null);
      if (this.locator) {
        this.doc.documentURI = this.locator.systemId;
      }
    },
    startElement: function(namespaceURI, localName, qName, attrs) {
      var doc = this.doc;
      var el2 = doc.createElementNS(namespaceURI, qName || localName);
      var len = attrs.length;
      appendElement(this, el2);
      this.currentElement = el2;
      this.locator && position(this.locator, el2);
      for (var i = 0; i < len; i++) {
        var namespaceURI = attrs.getURI(i);
        var value = attrs.getValue(i);
        var qName = attrs.getQName(i);
        var attr = doc.createAttributeNS(namespaceURI, qName);
        this.locator && position(attrs.getLocator(i), attr);
        attr.value = attr.nodeValue = value;
        el2.setAttributeNode(attr);
      }
    },
    endElement: function(namespaceURI, localName, qName) {
      var current = this.currentElement;
      current.tagName;
      this.currentElement = current.parentNode;
    },
    startPrefixMapping: function(prefix, uri2) {
    },
    endPrefixMapping: function(prefix) {
    },
    processingInstruction: function(target2, data) {
      var ins = this.doc.createProcessingInstruction(target2, data);
      this.locator && position(this.locator, ins);
      appendElement(this, ins);
    },
    ignorableWhitespace: function(ch, start, length) {
    },
    characters: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      if (chars) {
        if (this.cdata) {
          var charNode = this.doc.createCDATASection(chars);
        } else {
          var charNode = this.doc.createTextNode(chars);
        }
        if (this.currentElement) {
          this.currentElement.appendChild(charNode);
        } else if (/^\s*$/.test(chars)) {
          this.doc.appendChild(charNode);
        }
        this.locator && position(this.locator, charNode);
      }
    },
    skippedEntity: function(name) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(locator) {
      if (this.locator = locator) {
        locator.lineNumber = 0;
      }
    },
    //LexicalHandler
    comment: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      var comm = this.doc.createComment(chars);
      this.locator && position(this.locator, comm);
      appendElement(this, comm);
    },
    startCDATA: function() {
      this.cdata = true;
    },
    endCDATA: function() {
      this.cdata = false;
    },
    startDTD: function(name, publicId, systemId) {
      var impl = this.doc.implementation;
      if (impl && impl.createDocumentType) {
        var dt = impl.createDocumentType(name, publicId, systemId);
        this.locator && position(this.locator, dt);
        appendElement(this, dt);
        this.doc.doctype = dt;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(error) {
      console.warn("[xmldom warning]	" + error, _locator(this.locator));
    },
    error: function(error) {
      console.error("[xmldom error]	" + error, _locator(this.locator));
    },
    fatalError: function(error) {
      throw new ParseError(error, this.locator);
    }
  };
  function _locator(l) {
    if (l) {
      return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
    }
  }
  function _toString(chars, start, length) {
    if (typeof chars == "string") {
      return chars.substr(start, length);
    } else {
      if (chars.length >= start + length || start) {
        return new java.lang.String(chars, start, length) + "";
      }
      return chars;
    }
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
    DOMHandler.prototype[key] = function() {
      return null;
    };
  });
  function appendElement(hander, node2) {
    if (!hander.currentElement) {
      hander.doc.appendChild(node2);
    } else {
      hander.currentElement.appendChild(node2);
    }
  }
  domParser.__DOMHandler = DOMHandler;
  domParser.normalizeLineEndings = normalizeLineEndings;
  domParser.DOMParser = DOMParser;
  return domParser;
}
var hasRequiredLib$d;
function requireLib$d() {
  if (hasRequiredLib$d) return lib$d;
  hasRequiredLib$d = 1;
  var dom2 = requireDom$2();
  lib$d.DOMImplementation = dom2.DOMImplementation;
  lib$d.XMLSerializer = dom2.XMLSerializer;
  lib$d.DOMParser = requireDomParser().DOMParser;
  return lib$d;
}
var hasRequiredXmldom;
function requireXmldom() {
  if (hasRequiredXmldom) return xmldom;
  hasRequiredXmldom = 1;
  var xmldom$1 = requireLib$d();
  var dom2 = requireDom$2();
  function parseFromString(string) {
    var error = null;
    var domParser2 = new xmldom$1.DOMParser({
      errorHandler: function(level, message) {
        error = { level, message };
      }
    });
    var document2 = domParser2.parseFromString(string);
    if (error === null) {
      return document2;
    } else {
      throw new Error(error.level + ": " + error.message);
    }
  }
  xmldom.parseFromString = parseFromString;
  xmldom.Node = dom2.Node;
  return xmldom;
}
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  var promises2 = requirePromises();
  var _ = requireUnderscoreNode();
  var xmldom2 = requireXmldom();
  var nodes2 = requireNodes();
  var Element2 = nodes2.Element;
  reader.readString = readString;
  var Node = xmldom2.Node;
  function readString(xmlString, namespaceMap) {
    namespaceMap = namespaceMap || {};
    try {
      var document2 = xmldom2.parseFromString(xmlString, "text/xml");
    } catch (error) {
      return promises2.reject(error);
    }
    if (document2.documentElement.tagName === "parsererror") {
      return promises2.resolve(new Error(document2.documentElement.textContent));
    }
    function convertNode(node2) {
      switch (node2.nodeType) {
        case Node.ELEMENT_NODE:
          return convertElement(node2);
        case Node.TEXT_NODE:
          return nodes2.text(node2.nodeValue);
      }
    }
    function convertElement(element2) {
      var convertedName = convertName(element2);
      var convertedChildren = [];
      _.forEach(element2.childNodes, function(childNode) {
        var convertedNode = convertNode(childNode);
        if (convertedNode) {
          convertedChildren.push(convertedNode);
        }
      });
      var convertedAttributes = {};
      _.forEach(element2.attributes, function(attribute2) {
        convertedAttributes[convertName(attribute2)] = attribute2.value;
      });
      return new Element2(convertedName, convertedAttributes, convertedChildren);
    }
    function convertName(node2) {
      if (node2.namespaceURI) {
        var mappedPrefix = namespaceMap[node2.namespaceURI];
        var prefix;
        if (mappedPrefix) {
          prefix = mappedPrefix + ":";
        } else {
          prefix = "{" + node2.namespaceURI + "}";
        }
        return prefix + node2.localName;
      } else {
        return node2.localName;
      }
    }
    return promises2.resolve(convertNode(document2.documentElement));
  }
  return reader;
}
var writer = {};
var lib$c = {};
var Utility = {};
var hasRequiredUtility;
function requireUtility() {
  if (hasRequiredUtility) return Utility;
  hasRequiredUtility = 1;
  (function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
    assign = function() {
      var i, key, len, source, sources, target2;
      target2 = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (isFunction(Object.assign)) {
        Object.assign.apply(null, arguments);
      } else {
        for (i = 0, len = sources.length; i < len; i++) {
          source = sources[i];
          if (source != null) {
            for (key in source) {
              if (!hasProp.call(source, key)) continue;
              target2[key] = source[key];
            }
          }
        }
      }
      return target2;
    };
    isFunction = function(val) {
      return !!val && Object.prototype.toString.call(val) === "[object Function]";
    };
    isObject = function(val) {
      var ref2;
      return !!val && ((ref2 = typeof val) === "function" || ref2 === "object");
    };
    isArray = function(val) {
      if (isFunction(Array.isArray)) {
        return Array.isArray(val);
      } else {
        return Object.prototype.toString.call(val) === "[object Array]";
      }
    };
    isEmpty = function(val) {
      var key;
      if (isArray(val)) {
        return !val.length;
      } else {
        for (key in val) {
          if (!hasProp.call(val, key)) continue;
          return false;
        }
        return true;
      }
    };
    isPlainObject = function(val) {
      var ctor, proto;
      return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
      if (isFunction(obj.valueOf)) {
        return obj.valueOf();
      } else {
        return obj;
      }
    };
    Utility.assign = assign;
    Utility.isFunction = isFunction;
    Utility.isObject = isObject;
    Utility.isArray = isArray;
    Utility.isEmpty = isEmpty;
    Utility.isPlainObject = isPlainObject;
    Utility.getValue = getValue;
  }).call(Utility);
  return Utility;
}
var XMLDocument$1 = { exports: {} };
var XMLNode$1 = { exports: {} };
var XMLElement$1 = { exports: {} };
var XMLAttribute$1 = { exports: {} };
var XMLAttribute = XMLAttribute$1.exports;
var hasRequiredXMLAttribute;
function requireXMLAttribute() {
  if (hasRequiredXMLAttribute) return XMLAttribute$1.exports;
  hasRequiredXMLAttribute = 1;
  (function() {
    XMLAttribute$1.exports = (function() {
      function XMLAttribute2(parent, name, value) {
        this.options = parent.options;
        this.stringify = parent.stringify;
        this.parent = parent;
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo(name));
        }
        if (value == null) {
          throw new Error("Missing attribute value. " + this.debugInfo(name));
        }
        this.name = this.stringify.attName(name);
        this.value = this.stringify.attValue(value);
      }
      XMLAttribute2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLAttribute2.prototype.toString = function(options) {
        return this.options.writer.set(options).attribute(this);
      };
      XMLAttribute2.prototype.debugInfo = function(name) {
        name = name || this.name;
        if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else {
          return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        }
      };
      return XMLAttribute2;
    })();
  }).call(XMLAttribute);
  return XMLAttribute$1.exports;
}
var XMLElement = XMLElement$1.exports;
var hasRequiredXMLElement;
function requireXMLElement() {
  if (hasRequiredXMLElement) return XMLElement$1.exports;
  hasRequiredXMLElement = 1;
  (function() {
    var XMLAttribute2, XMLNode2, getValue, isFunction, isObject, ref2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    ref2 = requireUtility(), isObject = ref2.isObject, isFunction = ref2.isFunction, getValue = ref2.getValue;
    XMLNode2 = requireXMLNode();
    XMLAttribute2 = requireXMLAttribute();
    XMLElement$1.exports = (function(superClass) {
      extend(XMLElement2, superClass);
      function XMLElement2(parent, name, attributes) {
        XMLElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing element name. " + this.debugInfo());
        }
        this.name = this.stringify.eleName(name);
        this.attributes = {};
        if (attributes != null) {
          this.attribute(attributes);
        }
        if (parent.isDocument) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;
        }
      }
      XMLElement2.prototype.clone = function() {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this);
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        clonedSelf.attributes = {};
        ref1 = this.attributes;
        for (attName in ref1) {
          if (!hasProp.call(ref1, attName)) continue;
          att = ref1[attName];
          clonedSelf.attributes[attName] = att.clone();
        }
        clonedSelf.children = [];
        this.children.forEach(function(child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };
      XMLElement2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (!this.options.skipNullAttributes || value != null) {
            this.attributes[name] = new XMLAttribute2(this, name, value);
          }
        }
        return this;
      };
      XMLElement2.prototype.removeAttribute = function(name) {
        var attName, i, len;
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo());
        }
        name = getValue(name);
        if (Array.isArray(name)) {
          for (i = 0, len = name.length; i < len; i++) {
            attName = name[i];
            delete this.attributes[attName];
          }
        } else {
          delete this.attributes[name];
        }
        return this;
      };
      XMLElement2.prototype.toString = function(options) {
        return this.options.writer.set(options).element(this);
      };
      XMLElement2.prototype.att = function(name, value) {
        return this.attribute(name, value);
      };
      XMLElement2.prototype.a = function(name, value) {
        return this.attribute(name, value);
      };
      return XMLElement2;
    })(XMLNode2);
  }).call(XMLElement);
  return XMLElement$1.exports;
}
var XMLCData$1 = { exports: {} };
var XMLCData = XMLCData$1.exports;
var hasRequiredXMLCData;
function requireXMLCData() {
  if (hasRequiredXMLCData) return XMLCData$1.exports;
  hasRequiredXMLCData = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLCData$1.exports = (function(superClass) {
      extend(XMLCData2, superClass);
      function XMLCData2(parent, text) {
        XMLCData2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing CDATA text. " + this.debugInfo());
        }
        this.text = this.stringify.cdata(text);
      }
      XMLCData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCData2.prototype.toString = function(options) {
        return this.options.writer.set(options).cdata(this);
      };
      return XMLCData2;
    })(XMLNode2);
  }).call(XMLCData);
  return XMLCData$1.exports;
}
var XMLComment$1 = { exports: {} };
var XMLComment = XMLComment$1.exports;
var hasRequiredXMLComment;
function requireXMLComment() {
  if (hasRequiredXMLComment) return XMLComment$1.exports;
  hasRequiredXMLComment = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLComment$1.exports = (function(superClass) {
      extend(XMLComment2, superClass);
      function XMLComment2(parent, text) {
        XMLComment2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing comment text. " + this.debugInfo());
        }
        this.text = this.stringify.comment(text);
      }
      XMLComment2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLComment2.prototype.toString = function(options) {
        return this.options.writer.set(options).comment(this);
      };
      return XMLComment2;
    })(XMLNode2);
  }).call(XMLComment);
  return XMLComment$1.exports;
}
var XMLDeclaration$1 = { exports: {} };
var XMLDeclaration = XMLDeclaration$1.exports;
var hasRequiredXMLDeclaration;
function requireXMLDeclaration() {
  if (hasRequiredXMLDeclaration) return XMLDeclaration$1.exports;
  hasRequiredXMLDeclaration = 1;
  (function() {
    var XMLNode2, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = requireUtility().isObject;
    XMLNode2 = requireXMLNode();
    XMLDeclaration$1.exports = (function(superClass) {
      extend(XMLDeclaration2, superClass);
      function XMLDeclaration2(parent, version, encoding, standalone) {
        var ref2;
        XMLDeclaration2.__super__.constructor.call(this, parent);
        if (isObject(version)) {
          ref2 = version, version = ref2.version, encoding = ref2.encoding, standalone = ref2.standalone;
        }
        if (!version) {
          version = "1.0";
        }
        this.version = this.stringify.xmlVersion(version);
        if (encoding != null) {
          this.encoding = this.stringify.xmlEncoding(encoding);
        }
        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }
      XMLDeclaration2.prototype.toString = function(options) {
        return this.options.writer.set(options).declaration(this);
      };
      return XMLDeclaration2;
    })(XMLNode2);
  }).call(XMLDeclaration);
  return XMLDeclaration$1.exports;
}
var XMLDocType$1 = { exports: {} };
var XMLDTDAttList$1 = { exports: {} };
var XMLDTDAttList = XMLDTDAttList$1.exports;
var hasRequiredXMLDTDAttList;
function requireXMLDTDAttList() {
  if (hasRequiredXMLDTDAttList) return XMLDTDAttList$1.exports;
  hasRequiredXMLDTDAttList = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDTDAttList$1.exports = (function(superClass) {
      extend(XMLDTDAttList2, superClass);
      function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        XMLDTDAttList2.__super__.constructor.call(this, parent);
        if (elementName == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (attributeName == null) {
          throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
        }
        if (!attributeType) {
          throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
        }
        if (!defaultValueType) {
          throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
        }
        if (defaultValueType.indexOf("#") !== 0) {
          defaultValueType = "#" + defaultValueType;
        }
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        this.elementName = this.stringify.eleName(elementName);
        this.attributeName = this.stringify.attName(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);
        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        this.defaultValueType = defaultValueType;
      }
      XMLDTDAttList2.prototype.toString = function(options) {
        return this.options.writer.set(options).dtdAttList(this);
      };
      return XMLDTDAttList2;
    })(XMLNode2);
  }).call(XMLDTDAttList);
  return XMLDTDAttList$1.exports;
}
var XMLDTDEntity$1 = { exports: {} };
var XMLDTDEntity = XMLDTDEntity$1.exports;
var hasRequiredXMLDTDEntity;
function requireXMLDTDEntity() {
  if (hasRequiredXMLDTDEntity) return XMLDTDEntity$1.exports;
  hasRequiredXMLDTDEntity = 1;
  (function() {
    var XMLNode2, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = requireUtility().isObject;
    XMLNode2 = requireXMLNode();
    XMLDTDEntity$1.exports = (function(superClass) {
      extend(XMLDTDEntity2, superClass);
      function XMLDTDEntity2(parent, pe, name, value) {
        XMLDTDEntity2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD entity name. " + this.debugInfo(name));
        }
        if (value == null) {
          throw new Error("Missing DTD entity value. " + this.debugInfo(name));
        }
        this.pe = !!pe;
        this.name = this.stringify.eleName(name);
        if (!isObject(value)) {
          this.value = this.stringify.dtdEntityValue(value);
        } else {
          if (!value.pubID && !value.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          if (value.pubID && !value.sysID) {
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
          }
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
          if (value.nData != null) {
            this.nData = this.stringify.dtdNData(value.nData);
          }
          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
          }
        }
      }
      XMLDTDEntity2.prototype.toString = function(options) {
        return this.options.writer.set(options).dtdEntity(this);
      };
      return XMLDTDEntity2;
    })(XMLNode2);
  }).call(XMLDTDEntity);
  return XMLDTDEntity$1.exports;
}
var XMLDTDElement$1 = { exports: {} };
var XMLDTDElement = XMLDTDElement$1.exports;
var hasRequiredXMLDTDElement;
function requireXMLDTDElement() {
  if (hasRequiredXMLDTDElement) return XMLDTDElement$1.exports;
  hasRequiredXMLDTDElement = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDTDElement$1.exports = (function(superClass) {
      extend(XMLDTDElement2, superClass);
      function XMLDTDElement2(parent, name, value) {
        XMLDTDElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (!value) {
          value = "(#PCDATA)";
        }
        if (Array.isArray(value)) {
          value = "(" + value.join(",") + ")";
        }
        this.name = this.stringify.eleName(name);
        this.value = this.stringify.dtdElementValue(value);
      }
      XMLDTDElement2.prototype.toString = function(options) {
        return this.options.writer.set(options).dtdElement(this);
      };
      return XMLDTDElement2;
    })(XMLNode2);
  }).call(XMLDTDElement);
  return XMLDTDElement$1.exports;
}
var XMLDTDNotation$1 = { exports: {} };
var XMLDTDNotation = XMLDTDNotation$1.exports;
var hasRequiredXMLDTDNotation;
function requireXMLDTDNotation() {
  if (hasRequiredXMLDTDNotation) return XMLDTDNotation$1.exports;
  hasRequiredXMLDTDNotation = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDTDNotation$1.exports = (function(superClass) {
      extend(XMLDTDNotation2, superClass);
      function XMLDTDNotation2(parent, name, value) {
        XMLDTDNotation2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD notation name. " + this.debugInfo(name));
        }
        if (!value.pubID && !value.sysID) {
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
        }
        this.name = this.stringify.eleName(name);
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
      }
      XMLDTDNotation2.prototype.toString = function(options) {
        return this.options.writer.set(options).dtdNotation(this);
      };
      return XMLDTDNotation2;
    })(XMLNode2);
  }).call(XMLDTDNotation);
  return XMLDTDNotation$1.exports;
}
var XMLDocType = XMLDocType$1.exports;
var hasRequiredXMLDocType;
function requireXMLDocType() {
  if (hasRequiredXMLDocType) return XMLDocType$1.exports;
  hasRequiredXMLDocType = 1;
  (function() {
    var XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLNode2, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = requireUtility().isObject;
    XMLNode2 = requireXMLNode();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLDocType$1.exports = (function(superClass) {
      extend(XMLDocType2, superClass);
      function XMLDocType2(parent, pubID, sysID) {
        var ref2, ref1;
        XMLDocType2.__super__.constructor.call(this, parent);
        this.name = "!DOCTYPE";
        this.documentObject = parent;
        if (isObject(pubID)) {
          ref2 = pubID, pubID = ref2.pubID, sysID = ref2.sysID;
        }
        if (sysID == null) {
          ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }
      XMLDocType2.prototype.element = function(name, value) {
        var child;
        child = new XMLDTDElement2(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList2(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.entity = function(name, value) {
        var child;
        child = new XMLDTDEntity2(this, false, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.pEntity = function(name, value) {
        var child;
        child = new XMLDTDEntity2(this, true, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.notation = function(name, value) {
        var child;
        child = new XMLDTDNotation2(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.toString = function(options) {
        return this.options.writer.set(options).docType(this);
      };
      XMLDocType2.prototype.ele = function(name, value) {
        return this.element(name, value);
      };
      XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      };
      XMLDocType2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      };
      XMLDocType2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      };
      XMLDocType2.prototype.not = function(name, value) {
        return this.notation(name, value);
      };
      XMLDocType2.prototype.up = function() {
        return this.root() || this.documentObject;
      };
      return XMLDocType2;
    })(XMLNode2);
  }).call(XMLDocType);
  return XMLDocType$1.exports;
}
var XMLRaw$1 = { exports: {} };
var XMLRaw = XMLRaw$1.exports;
var hasRequiredXMLRaw;
function requireXMLRaw() {
  if (hasRequiredXMLRaw) return XMLRaw$1.exports;
  hasRequiredXMLRaw = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLRaw$1.exports = (function(superClass) {
      extend(XMLRaw2, superClass);
      function XMLRaw2(parent, text) {
        XMLRaw2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing raw text. " + this.debugInfo());
        }
        this.value = this.stringify.raw(text);
      }
      XMLRaw2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLRaw2.prototype.toString = function(options) {
        return this.options.writer.set(options).raw(this);
      };
      return XMLRaw2;
    })(XMLNode2);
  }).call(XMLRaw);
  return XMLRaw$1.exports;
}
var XMLText$1 = { exports: {} };
var XMLText = XMLText$1.exports;
var hasRequiredXMLText;
function requireXMLText() {
  if (hasRequiredXMLText) return XMLText$1.exports;
  hasRequiredXMLText = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLText$1.exports = (function(superClass) {
      extend(XMLText2, superClass);
      function XMLText2(parent, text) {
        XMLText2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing element text. " + this.debugInfo());
        }
        this.value = this.stringify.eleText(text);
      }
      XMLText2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLText2.prototype.toString = function(options) {
        return this.options.writer.set(options).text(this);
      };
      return XMLText2;
    })(XMLNode2);
  }).call(XMLText);
  return XMLText$1.exports;
}
var XMLProcessingInstruction$1 = { exports: {} };
var XMLProcessingInstruction = XMLProcessingInstruction$1.exports;
var hasRequiredXMLProcessingInstruction;
function requireXMLProcessingInstruction() {
  if (hasRequiredXMLProcessingInstruction) return XMLProcessingInstruction$1.exports;
  hasRequiredXMLProcessingInstruction = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLProcessingInstruction$1.exports = (function(superClass) {
      extend(XMLProcessingInstruction2, superClass);
      function XMLProcessingInstruction2(parent, target2, value) {
        XMLProcessingInstruction2.__super__.constructor.call(this, parent);
        if (target2 == null) {
          throw new Error("Missing instruction target. " + this.debugInfo());
        }
        this.target = this.stringify.insTarget(target2);
        if (value) {
          this.value = this.stringify.insValue(value);
        }
      }
      XMLProcessingInstruction2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLProcessingInstruction2.prototype.toString = function(options) {
        return this.options.writer.set(options).processingInstruction(this);
      };
      return XMLProcessingInstruction2;
    })(XMLNode2);
  }).call(XMLProcessingInstruction);
  return XMLProcessingInstruction$1.exports;
}
var XMLDummy$1 = { exports: {} };
var XMLDummy = XMLDummy$1.exports;
var hasRequiredXMLDummy;
function requireXMLDummy() {
  if (hasRequiredXMLDummy) return XMLDummy$1.exports;
  hasRequiredXMLDummy = 1;
  (function() {
    var XMLNode2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDummy$1.exports = (function(superClass) {
      extend(XMLDummy2, superClass);
      function XMLDummy2(parent) {
        XMLDummy2.__super__.constructor.call(this, parent);
        this.isDummy = true;
      }
      XMLDummy2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLDummy2.prototype.toString = function(options) {
        return "";
      };
      return XMLDummy2;
    })(XMLNode2);
  }).call(XMLDummy);
  return XMLDummy$1.exports;
}
var XMLNode = XMLNode$1.exports;
var hasRequiredXMLNode;
function requireXMLNode() {
  if (hasRequiredXMLNode) return XMLNode$1.exports;
  hasRequiredXMLNode = 1;
  (function() {
    var XMLCData2, XMLComment2, XMLDeclaration2, XMLDocType2, XMLDummy2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLText2, getValue, isEmpty, isFunction, isObject, ref2, hasProp = {}.hasOwnProperty;
    ref2 = requireUtility(), isObject = ref2.isObject, isFunction = ref2.isFunction, isEmpty = ref2.isEmpty, getValue = ref2.getValue;
    XMLElement2 = null;
    XMLCData2 = null;
    XMLComment2 = null;
    XMLDeclaration2 = null;
    XMLDocType2 = null;
    XMLRaw2 = null;
    XMLText2 = null;
    XMLProcessingInstruction2 = null;
    XMLDummy2 = null;
    XMLNode$1.exports = (function() {
      function XMLNode2(parent) {
        this.parent = parent;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        this.children = [];
        if (!XMLElement2) {
          XMLElement2 = requireXMLElement();
          XMLCData2 = requireXMLCData();
          XMLComment2 = requireXMLComment();
          XMLDeclaration2 = requireXMLDeclaration();
          XMLDocType2 = requireXMLDocType();
          XMLRaw2 = requireXMLRaw();
          XMLText2 = requireXMLText();
          XMLProcessingInstruction2 = requireXMLProcessingInstruction();
          XMLDummy2 = requireXMLDummy();
        }
      }
      XMLNode2.prototype.element = function(name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, ref1, ref22, val;
        lastChild = null;
        if (attributes === null && text == null) {
          ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref22 = [attributes, text], text = ref22[0], attributes = ref22[1];
        }
        if (name != null) {
          name = getValue(name);
        }
        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        } else if (isFunction(name)) {
          lastChild = this.element(name.apply());
        } else if (isObject(name)) {
          for (key in name) {
            if (!hasProp.call(name, key)) continue;
            val = name[key];
            if (isFunction(val)) {
              val = val.apply();
            }
            if (isObject(val) && isEmpty(val)) {
              val = null;
            }
            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length; k < len1; k++) {
                item = val[k];
                childNode = {};
                childNode[key] = item;
                lastChild = this.element(childNode);
              }
            } else if (isObject(val)) {
              lastChild = this.element(key);
              lastChild.element(val);
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else if (this.options.skipNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
          } else {
            lastChild = this.node(name, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
        }
        return lastChild;
      };
      XMLNode2.prototype.insertBefore = function(name, attributes, text) {
        var child, i, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.insertAfter = function(name, attributes, text) {
        var child, i, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.remove = function() {
        var i;
        if (this.isRoot) {
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        }
        i = this.parent.children.indexOf(this);
        [].splice.apply(this.parent.children, [i, i - i + 1].concat([]));
        return this.parent;
      };
      XMLNode2.prototype.node = function(name, attributes, text) {
        var child, ref1;
        if (name != null) {
          name = getValue(name);
        }
        attributes || (attributes = {});
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
        }
        child = new XMLElement2(this, name, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.text = function(value) {
        var child;
        child = new XMLText2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.cdata = function(value) {
        var child;
        child = new XMLCData2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.comment = function(value) {
        var child;
        child = new XMLComment2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.commentBefore = function(value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.commentAfter = function(value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.raw = function(value) {
        var child;
        child = new XMLRaw2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.dummy = function() {
        var child;
        child = new XMLDummy2(this);
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.instruction = function(target2, value) {
        var insTarget, insValue, instruction, j, len;
        if (target2 != null) {
          target2 = getValue(target2);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target2)) {
          for (j = 0, len = target2.length; j < len; j++) {
            insTarget = target2[j];
            this.instruction(insTarget);
          }
        } else if (isObject(target2)) {
          for (insTarget in target2) {
            if (!hasProp.call(target2, insTarget)) continue;
            insValue = target2[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          instruction = new XMLProcessingInstruction2(this, target2, value);
          this.children.push(instruction);
        }
        return this;
      };
      XMLNode2.prototype.instructionBefore = function(target2, value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        this.parent.instruction(target2, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.instructionAfter = function(target2, value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        this.parent.instruction(target2, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.declaration = function(version, encoding, standalone) {
        var doc, xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration2(doc, version, encoding, standalone);
        if (doc.children[0] instanceof XMLDeclaration2) {
          doc.children[0] = xmldec;
        } else {
          doc.children.unshift(xmldec);
        }
        return doc.root() || doc;
      };
      XMLNode2.prototype.doctype = function(pubID, sysID) {
        var child, doc, doctype, i, j, k, len, len1, ref1, ref22;
        doc = this.document();
        doctype = new XMLDocType2(doc, pubID, sysID);
        ref1 = doc.children;
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          child = ref1[i];
          if (child instanceof XMLDocType2) {
            doc.children[i] = doctype;
            return doctype;
          }
        }
        ref22 = doc.children;
        for (i = k = 0, len1 = ref22.length; k < len1; i = ++k) {
          child = ref22[i];
          if (child.isRoot) {
            doc.children.splice(i, 0, doctype);
            return doctype;
          }
        }
        doc.children.push(doctype);
        return doctype;
      };
      XMLNode2.prototype.up = function() {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }
        return this.parent;
      };
      XMLNode2.prototype.root = function() {
        var node2;
        node2 = this;
        while (node2) {
          if (node2.isDocument) {
            return node2.rootObject;
          } else if (node2.isRoot) {
            return node2;
          } else {
            node2 = node2.parent;
          }
        }
      };
      XMLNode2.prototype.document = function() {
        var node2;
        node2 = this;
        while (node2) {
          if (node2.isDocument) {
            return node2;
          } else {
            node2 = node2.parent;
          }
        }
      };
      XMLNode2.prototype.end = function(options) {
        return this.document().end(options);
      };
      XMLNode2.prototype.prev = function() {
        var i;
        i = this.parent.children.indexOf(this);
        while (i > 0 && this.parent.children[i - 1].isDummy) {
          i = i - 1;
        }
        if (i < 1) {
          throw new Error("Already at the first node. " + this.debugInfo());
        }
        return this.parent.children[i - 1];
      };
      XMLNode2.prototype.next = function() {
        var i;
        i = this.parent.children.indexOf(this);
        while (i < this.parent.children.length - 1 && this.parent.children[i + 1].isDummy) {
          i = i + 1;
        }
        if (i === -1 || i === this.parent.children.length - 1) {
          throw new Error("Already at the last node. " + this.debugInfo());
        }
        return this.parent.children[i + 1];
      };
      XMLNode2.prototype.importDocument = function(doc) {
        var clonedRoot;
        clonedRoot = doc.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };
      XMLNode2.prototype.debugInfo = function(name) {
        var ref1, ref22;
        name = name || this.name;
        if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {
          return "";
        } else if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else if (!((ref22 = this.parent) != null ? ref22.name : void 0)) {
          return "node: <" + name + ">";
        } else {
          return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        }
      };
      XMLNode2.prototype.ele = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.txt = function(value) {
        return this.text(value);
      };
      XMLNode2.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLNode2.prototype.ins = function(target2, value) {
        return this.instruction(target2, value);
      };
      XMLNode2.prototype.doc = function() {
        return this.document();
      };
      XMLNode2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLNode2.prototype.dtd = function(pubID, sysID) {
        return this.doctype(pubID, sysID);
      };
      XMLNode2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.t = function(value) {
        return this.text(value);
      };
      XMLNode2.prototype.d = function(value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.c = function(value) {
        return this.comment(value);
      };
      XMLNode2.prototype.r = function(value) {
        return this.raw(value);
      };
      XMLNode2.prototype.i = function(target2, value) {
        return this.instruction(target2, value);
      };
      XMLNode2.prototype.u = function() {
        return this.up();
      };
      XMLNode2.prototype.importXMLBuilder = function(doc) {
        return this.importDocument(doc);
      };
      return XMLNode2;
    })();
  }).call(XMLNode);
  return XMLNode$1.exports;
}
var XMLStringifier$1 = { exports: {} };
var XMLStringifier = XMLStringifier$1.exports;
var hasRequiredXMLStringifier;
function requireXMLStringifier() {
  if (hasRequiredXMLStringifier) return XMLStringifier$1.exports;
  hasRequiredXMLStringifier = 1;
  (function() {
    var bind2 = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, hasProp = {}.hasOwnProperty;
    XMLStringifier$1.exports = (function() {
      function XMLStringifier2(options) {
        this.assertLegalChar = bind2(this.assertLegalChar, this);
        var key, ref2, value;
        options || (options = {});
        this.noDoubleEncoding = options.noDoubleEncoding;
        ref2 = options.stringify || {};
        for (key in ref2) {
          if (!hasProp.call(ref2, key)) continue;
          value = ref2[key];
          this[key] = value;
        }
      }
      XMLStringifier2.prototype.eleName = function(val) {
        val = "" + val || "";
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.eleText = function(val) {
        val = "" + val || "";
        return this.assertLegalChar(this.elEscape(val));
      };
      XMLStringifier2.prototype.cdata = function(val) {
        val = "" + val || "";
        val = val.replace("]]>", "]]]]><![CDATA[>");
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.comment = function(val) {
        val = "" + val || "";
        if (val.match(/--/)) {
          throw new Error("Comment text cannot contain double-hypen: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.raw = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.attName = function(val) {
        return val = "" + val || "";
      };
      XMLStringifier2.prototype.attValue = function(val) {
        val = "" + val || "";
        return this.attEscape(val);
      };
      XMLStringifier2.prototype.insTarget = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.insValue = function(val) {
        val = "" + val || "";
        if (val.match(/\?>/)) {
          throw new Error("Invalid processing instruction value: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlVersion = function(val) {
        val = "" + val || "";
        if (!val.match(/1\.[0-9]+/)) {
          throw new Error("Invalid version number: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlEncoding = function(val) {
        val = "" + val || "";
        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error("Invalid encoding: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlStandalone = function(val) {
        if (val) {
          return "yes";
        } else {
          return "no";
        }
      };
      XMLStringifier2.prototype.dtdPubID = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdSysID = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdElementValue = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdAttType = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdAttDefault = function(val) {
        if (val != null) {
          return "" + val || "";
        } else {
          return val;
        }
      };
      XMLStringifier2.prototype.dtdEntityValue = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdNData = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.convertAttKey = "@";
      XMLStringifier2.prototype.convertPIKey = "?";
      XMLStringifier2.prototype.convertTextKey = "#text";
      XMLStringifier2.prototype.convertCDataKey = "#cdata";
      XMLStringifier2.prototype.convertCommentKey = "#comment";
      XMLStringifier2.prototype.convertRawKey = "#raw";
      XMLStringifier2.prototype.assertLegalChar = function(str) {
        var res;
        res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
        if (res) {
          throw new Error("Invalid character in string: " + str + " at index " + res.index);
        }
        return str;
      };
      XMLStringifier2.prototype.elEscape = function(str) {
        var ampregex;
        ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      };
      XMLStringifier2.prototype.attEscape = function(str) {
        var ampregex;
        ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      };
      return XMLStringifier2;
    })();
  }).call(XMLStringifier);
  return XMLStringifier$1.exports;
}
var XMLStringWriter$1 = { exports: {} };
var XMLWriterBase$1 = { exports: {} };
var XMLWriterBase = XMLWriterBase$1.exports;
var hasRequiredXMLWriterBase;
function requireXMLWriterBase() {
  if (hasRequiredXMLWriterBase) return XMLWriterBase$1.exports;
  hasRequiredXMLWriterBase = 1;
  (function() {
    var hasProp = {}.hasOwnProperty;
    XMLWriterBase$1.exports = (function() {
      function XMLWriterBase2(options) {
        var key, ref2, ref1, ref22, ref3, ref4, ref5, ref6, value;
        options || (options = {});
        this.pretty = options.pretty || false;
        this.allowEmpty = (ref2 = options.allowEmpty) != null ? ref2 : false;
        if (this.pretty) {
          this.indent = (ref1 = options.indent) != null ? ref1 : "  ";
          this.newline = (ref22 = options.newline) != null ? ref22 : "\n";
          this.offset = (ref3 = options.offset) != null ? ref3 : 0;
          this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
        } else {
          this.indent = "";
          this.newline = "";
          this.offset = 0;
          this.dontprettytextnodes = 0;
        }
        this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : "";
        if (this.spacebeforeslash === true) {
          this.spacebeforeslash = " ";
        }
        this.newlinedefault = this.newline;
        this.prettydefault = this.pretty;
        ref6 = options.writer || {};
        for (key in ref6) {
          if (!hasProp.call(ref6, key)) continue;
          value = ref6[key];
          this[key] = value;
        }
      }
      XMLWriterBase2.prototype.set = function(options) {
        var key, ref2, value;
        options || (options = {});
        if ("pretty" in options) {
          this.pretty = options.pretty;
        }
        if ("allowEmpty" in options) {
          this.allowEmpty = options.allowEmpty;
        }
        if (this.pretty) {
          this.indent = "indent" in options ? options.indent : "  ";
          this.newline = "newline" in options ? options.newline : "\n";
          this.offset = "offset" in options ? options.offset : 0;
          this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
        } else {
          this.indent = "";
          this.newline = "";
          this.offset = 0;
          this.dontprettytextnodes = 0;
        }
        this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : "";
        if (this.spacebeforeslash === true) {
          this.spacebeforeslash = " ";
        }
        this.newlinedefault = this.newline;
        this.prettydefault = this.pretty;
        ref2 = options.writer || {};
        for (key in ref2) {
          if (!hasProp.call(ref2, key)) continue;
          value = ref2[key];
          this[key] = value;
        }
        return this;
      };
      XMLWriterBase2.prototype.space = function(level) {
        var indent;
        if (this.pretty) {
          indent = (level || 0) + this.offset + 1;
          if (indent > 0) {
            return new Array(indent).join(this.indent);
          } else {
            return "";
          }
        } else {
          return "";
        }
      };
      return XMLWriterBase2;
    })();
  }).call(XMLWriterBase);
  return XMLWriterBase$1.exports;
}
var XMLStringWriter = XMLStringWriter$1.exports;
var hasRequiredXMLStringWriter;
function requireXMLStringWriter() {
  if (hasRequiredXMLStringWriter) return XMLStringWriter$1.exports;
  hasRequiredXMLStringWriter = 1;
  (function() {
    var XMLCData2, XMLComment2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLDeclaration2, XMLDocType2, XMLDummy2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLText2, XMLWriterBase2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLDeclaration2 = requireXMLDeclaration();
    XMLDocType2 = requireXMLDocType();
    XMLCData2 = requireXMLCData();
    XMLComment2 = requireXMLComment();
    XMLElement2 = requireXMLElement();
    XMLRaw2 = requireXMLRaw();
    XMLText2 = requireXMLText();
    XMLProcessingInstruction2 = requireXMLProcessingInstruction();
    XMLDummy2 = requireXMLDummy();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLWriterBase2 = requireXMLWriterBase();
    XMLStringWriter$1.exports = (function(superClass) {
      extend(XMLStringWriter2, superClass);
      function XMLStringWriter2(options) {
        XMLStringWriter2.__super__.constructor.call(this, options);
      }
      XMLStringWriter2.prototype.document = function(doc) {
        var child, i, len, r, ref2;
        this.textispresent = false;
        r = "";
        ref2 = doc.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          if (child instanceof XMLDummy2) {
            continue;
          }
          r += (function() {
            switch (false) {
              case !(child instanceof XMLDeclaration2):
                return this.declaration(child);
              case !(child instanceof XMLDocType2):
                return this.docType(child);
              case !(child instanceof XMLComment2):
                return this.comment(child);
              case !(child instanceof XMLProcessingInstruction2):
                return this.processingInstruction(child);
              default:
                return this.element(child, 0);
            }
          }).call(this);
        }
        if (this.pretty && r.slice(-this.newline.length) === this.newline) {
          r = r.slice(0, -this.newline.length);
        }
        return r;
      };
      XMLStringWriter2.prototype.attribute = function(att) {
        return " " + att.name + '="' + att.value + '"';
      };
      XMLStringWriter2.prototype.cdata = function(node2, level) {
        return this.space(level) + "<![CDATA[" + node2.text + "]]>" + this.newline;
      };
      XMLStringWriter2.prototype.comment = function(node2, level) {
        return this.space(level) + "<!-- " + node2.text + " -->" + this.newline;
      };
      XMLStringWriter2.prototype.declaration = function(node2, level) {
        var r;
        r = this.space(level);
        r += '<?xml version="' + node2.version + '"';
        if (node2.encoding != null) {
          r += ' encoding="' + node2.encoding + '"';
        }
        if (node2.standalone != null) {
          r += ' standalone="' + node2.standalone + '"';
        }
        r += this.spacebeforeslash + "?>";
        r += this.newline;
        return r;
      };
      XMLStringWriter2.prototype.docType = function(node2, level) {
        var child, i, len, r, ref2;
        level || (level = 0);
        r = this.space(level);
        r += "<!DOCTYPE " + node2.root().name;
        if (node2.pubID && node2.sysID) {
          r += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
        } else if (node2.sysID) {
          r += ' SYSTEM "' + node2.sysID + '"';
        }
        if (node2.children.length > 0) {
          r += " [";
          r += this.newline;
          ref2 = node2.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            r += (function() {
              switch (false) {
                case !(child instanceof XMLDTDAttList2):
                  return this.dtdAttList(child, level + 1);
                case !(child instanceof XMLDTDElement2):
                  return this.dtdElement(child, level + 1);
                case !(child instanceof XMLDTDEntity2):
                  return this.dtdEntity(child, level + 1);
                case !(child instanceof XMLDTDNotation2):
                  return this.dtdNotation(child, level + 1);
                case !(child instanceof XMLCData2):
                  return this.cdata(child, level + 1);
                case !(child instanceof XMLComment2):
                  return this.comment(child, level + 1);
                case !(child instanceof XMLProcessingInstruction2):
                  return this.processingInstruction(child, level + 1);
                default:
                  throw new Error("Unknown DTD node type: " + child.constructor.name);
              }
            }).call(this);
          }
          r += "]";
        }
        r += this.spacebeforeslash + ">";
        r += this.newline;
        return r;
      };
      XMLStringWriter2.prototype.element = function(node2, level) {
        var att, child, i, j, len, len1, name, r, ref2, ref1, ref22, space, textispresentwasset;
        level || (level = 0);
        textispresentwasset = false;
        if (this.textispresent) {
          this.newline = "";
          this.pretty = false;
        } else {
          this.newline = this.newlinedefault;
          this.pretty = this.prettydefault;
        }
        space = this.space(level);
        r = "";
        r += space + "<" + node2.name;
        ref2 = node2.attributes;
        for (name in ref2) {
          if (!hasProp.call(ref2, name)) continue;
          att = ref2[name];
          r += this.attribute(att);
        }
        if (node2.children.length === 0 || node2.children.every(function(e) {
          return e.value === "";
        })) {
          if (this.allowEmpty) {
            r += "></" + node2.name + ">" + this.newline;
          } else {
            r += this.spacebeforeslash + "/>" + this.newline;
          }
        } else if (this.pretty && node2.children.length === 1 && node2.children[0].value != null) {
          r += ">";
          r += node2.children[0].value;
          r += "</" + node2.name + ">" + this.newline;
        } else {
          if (this.dontprettytextnodes) {
            ref1 = node2.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              if (child.value != null) {
                this.textispresent++;
                textispresentwasset = true;
                break;
              }
            }
          }
          if (this.textispresent) {
            this.newline = "";
            this.pretty = false;
            space = this.space(level);
          }
          r += ">" + this.newline;
          ref22 = node2.children;
          for (j = 0, len1 = ref22.length; j < len1; j++) {
            child = ref22[j];
            r += (function() {
              switch (false) {
                case !(child instanceof XMLCData2):
                  return this.cdata(child, level + 1);
                case !(child instanceof XMLComment2):
                  return this.comment(child, level + 1);
                case !(child instanceof XMLElement2):
                  return this.element(child, level + 1);
                case !(child instanceof XMLRaw2):
                  return this.raw(child, level + 1);
                case !(child instanceof XMLText2):
                  return this.text(child, level + 1);
                case !(child instanceof XMLProcessingInstruction2):
                  return this.processingInstruction(child, level + 1);
                case !(child instanceof XMLDummy2):
                  return "";
                default:
                  throw new Error("Unknown XML node type: " + child.constructor.name);
              }
            }).call(this);
          }
          if (textispresentwasset) {
            this.textispresent--;
          }
          if (!this.textispresent) {
            this.newline = this.newlinedefault;
            this.pretty = this.prettydefault;
          }
          r += space + "</" + node2.name + ">" + this.newline;
        }
        return r;
      };
      XMLStringWriter2.prototype.processingInstruction = function(node2, level) {
        var r;
        r = this.space(level) + "<?" + node2.target;
        if (node2.value) {
          r += " " + node2.value;
        }
        r += this.spacebeforeslash + "?>" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.raw = function(node2, level) {
        return this.space(level) + node2.value + this.newline;
      };
      XMLStringWriter2.prototype.text = function(node2, level) {
        return this.space(level) + node2.value + this.newline;
      };
      XMLStringWriter2.prototype.dtdAttList = function(node2, level) {
        var r;
        r = this.space(level) + "<!ATTLIST " + node2.elementName + " " + node2.attributeName + " " + node2.attributeType;
        if (node2.defaultValueType !== "#DEFAULT") {
          r += " " + node2.defaultValueType;
        }
        if (node2.defaultValue) {
          r += ' "' + node2.defaultValue + '"';
        }
        r += this.spacebeforeslash + ">" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.dtdElement = function(node2, level) {
        return this.space(level) + "<!ELEMENT " + node2.name + " " + node2.value + this.spacebeforeslash + ">" + this.newline;
      };
      XMLStringWriter2.prototype.dtdEntity = function(node2, level) {
        var r;
        r = this.space(level) + "<!ENTITY";
        if (node2.pe) {
          r += " %";
        }
        r += " " + node2.name;
        if (node2.value) {
          r += ' "' + node2.value + '"';
        } else {
          if (node2.pubID && node2.sysID) {
            r += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
          } else if (node2.sysID) {
            r += ' SYSTEM "' + node2.sysID + '"';
          }
          if (node2.nData) {
            r += " NDATA " + node2.nData;
          }
        }
        r += this.spacebeforeslash + ">" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.dtdNotation = function(node2, level) {
        var r;
        r = this.space(level) + "<!NOTATION " + node2.name;
        if (node2.pubID && node2.sysID) {
          r += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
        } else if (node2.pubID) {
          r += ' PUBLIC "' + node2.pubID + '"';
        } else if (node2.sysID) {
          r += ' SYSTEM "' + node2.sysID + '"';
        }
        r += this.spacebeforeslash + ">" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.openNode = function(node2, level) {
        var att, name, r, ref2;
        level || (level = 0);
        if (node2 instanceof XMLElement2) {
          r = this.space(level) + "<" + node2.name;
          ref2 = node2.attributes;
          for (name in ref2) {
            if (!hasProp.call(ref2, name)) continue;
            att = ref2[name];
            r += this.attribute(att);
          }
          r += (node2.children ? ">" : "/>") + this.newline;
          return r;
        } else {
          r = this.space(level) + "<!DOCTYPE " + node2.rootNodeName;
          if (node2.pubID && node2.sysID) {
            r += ' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"';
          } else if (node2.sysID) {
            r += ' SYSTEM "' + node2.sysID + '"';
          }
          r += (node2.children ? " [" : ">") + this.newline;
          return r;
        }
      };
      XMLStringWriter2.prototype.closeNode = function(node2, level) {
        level || (level = 0);
        switch (false) {
          case !(node2 instanceof XMLElement2):
            return this.space(level) + "</" + node2.name + ">" + this.newline;
          case !(node2 instanceof XMLDocType2):
            return this.space(level) + "]>" + this.newline;
        }
      };
      return XMLStringWriter2;
    })(XMLWriterBase2);
  }).call(XMLStringWriter);
  return XMLStringWriter$1.exports;
}
var XMLDocument = XMLDocument$1.exports;
var hasRequiredXMLDocument;
function requireXMLDocument() {
  if (hasRequiredXMLDocument) return XMLDocument$1.exports;
  hasRequiredXMLDocument = 1;
  (function() {
    var XMLNode2, XMLStringWriter2, XMLStringifier2, isPlainObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isPlainObject = requireUtility().isPlainObject;
    XMLNode2 = requireXMLNode();
    XMLStringifier2 = requireXMLStringifier();
    XMLStringWriter2 = requireXMLStringWriter();
    XMLDocument$1.exports = (function(superClass) {
      extend(XMLDocument2, superClass);
      function XMLDocument2(options) {
        XMLDocument2.__super__.constructor.call(this, null);
        this.name = "?xml";
        options || (options = {});
        if (!options.writer) {
          options.writer = new XMLStringWriter2();
        }
        this.options = options;
        this.stringify = new XMLStringifier2(options);
        this.isDocument = true;
      }
      XMLDocument2.prototype.end = function(writer2) {
        var writerOptions;
        if (!writer2) {
          writer2 = this.options.writer;
        } else if (isPlainObject(writer2)) {
          writerOptions = writer2;
          writer2 = this.options.writer.set(writerOptions);
        }
        return writer2.document(this);
      };
      XMLDocument2.prototype.toString = function(options) {
        return this.options.writer.set(options).document(this);
      };
      return XMLDocument2;
    })(XMLNode2);
  }).call(XMLDocument);
  return XMLDocument$1.exports;
}
var XMLDocumentCB$1 = { exports: {} };
var XMLDocumentCB = XMLDocumentCB$1.exports;
var hasRequiredXMLDocumentCB;
function requireXMLDocumentCB() {
  if (hasRequiredXMLDocumentCB) return XMLDocumentCB$1.exports;
  hasRequiredXMLDocumentCB = 1;
  (function() {
    var XMLAttribute2, XMLCData2, XMLComment2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLDeclaration2, XMLDocType2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLStringWriter2, XMLStringifier2, XMLText2, getValue, isFunction, isObject, isPlainObject, ref2, hasProp = {}.hasOwnProperty;
    ref2 = requireUtility(), isObject = ref2.isObject, isFunction = ref2.isFunction, isPlainObject = ref2.isPlainObject, getValue = ref2.getValue;
    XMLElement2 = requireXMLElement();
    XMLCData2 = requireXMLCData();
    XMLComment2 = requireXMLComment();
    XMLRaw2 = requireXMLRaw();
    XMLText2 = requireXMLText();
    XMLProcessingInstruction2 = requireXMLProcessingInstruction();
    XMLDeclaration2 = requireXMLDeclaration();
    XMLDocType2 = requireXMLDocType();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLAttribute2 = requireXMLAttribute();
    XMLStringifier2 = requireXMLStringifier();
    XMLStringWriter2 = requireXMLStringWriter();
    XMLDocumentCB$1.exports = (function() {
      function XMLDocumentCB2(options, onData, onEnd) {
        var writerOptions;
        this.name = "?xml";
        options || (options = {});
        if (!options.writer) {
          options.writer = new XMLStringWriter2(options);
        } else if (isPlainObject(options.writer)) {
          writerOptions = options.writer;
          options.writer = new XMLStringWriter2(writerOptions);
        }
        this.options = options;
        this.writer = options.writer;
        this.stringify = new XMLStringifier2(options);
        this.onDataCallback = onData || function() {
        };
        this.onEndCallback = onEnd || function() {
        };
        this.currentNode = null;
        this.currentLevel = -1;
        this.openTags = {};
        this.documentStarted = false;
        this.documentCompleted = false;
        this.root = null;
      }
      XMLDocumentCB2.prototype.node = function(name, attributes, text) {
        var ref1, ref22;
        if (name == null) {
          throw new Error("Missing node name.");
        }
        if (this.root && this.currentLevel === -1) {
          throw new Error("Document can only have one root node. " + this.debugInfo(name));
        }
        this.openCurrent();
        name = getValue(name);
        if (attributes === null && text == null) {
          ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref22 = [attributes, text], text = ref22[0], attributes = ref22[1];
        }
        this.currentNode = new XMLElement2(this, name, attributes);
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        if (text != null) {
          this.text(text);
        }
        return this;
      };
      XMLDocumentCB2.prototype.element = function(name, attributes, text) {
        if (this.currentNode && this.currentNode instanceof XMLDocType2) {
          return this.dtdElement.apply(this, arguments);
        } else {
          return this.node(name, attributes, text);
        }
      };
      XMLDocumentCB2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (!this.currentNode || this.currentNode.children) {
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
        }
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (!this.options.skipNullAttributes || value != null) {
            this.currentNode.attributes[name] = new XMLAttribute2(this, name, value);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.text = function(value) {
        var node2;
        this.openCurrent();
        node2 = new XMLText2(this, value);
        this.onData(this.writer.text(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.cdata = function(value) {
        var node2;
        this.openCurrent();
        node2 = new XMLCData2(this, value);
        this.onData(this.writer.cdata(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.comment = function(value) {
        var node2;
        this.openCurrent();
        node2 = new XMLComment2(this, value);
        this.onData(this.writer.comment(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.raw = function(value) {
        var node2;
        this.openCurrent();
        node2 = new XMLRaw2(this, value);
        this.onData(this.writer.raw(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.instruction = function(target2, value) {
        var i, insTarget, insValue, len, node2;
        this.openCurrent();
        if (target2 != null) {
          target2 = getValue(target2);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target2)) {
          for (i = 0, len = target2.length; i < len; i++) {
            insTarget = target2[i];
            this.instruction(insTarget);
          }
        } else if (isObject(target2)) {
          for (insTarget in target2) {
            if (!hasProp.call(target2, insTarget)) continue;
            insValue = target2[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          node2 = new XMLProcessingInstruction2(this, target2, value);
          this.onData(this.writer.processingInstruction(node2, this.currentLevel + 1), this.currentLevel + 1);
        }
        return this;
      };
      XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
        var node2;
        this.openCurrent();
        if (this.documentStarted) {
          throw new Error("declaration() must be the first node.");
        }
        node2 = new XMLDeclaration2(this, version, encoding, standalone);
        this.onData(this.writer.declaration(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
        this.openCurrent();
        if (root == null) {
          throw new Error("Missing root node name.");
        }
        if (this.root) {
          throw new Error("dtd() must come before the root node.");
        }
        this.currentNode = new XMLDocType2(this, pubID, sysID);
        this.currentNode.rootNodeName = root;
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        return this;
      };
      XMLDocumentCB2.prototype.dtdElement = function(name, value) {
        var node2;
        this.openCurrent();
        node2 = new XMLDTDElement2(this, name, value);
        this.onData(this.writer.dtdElement(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var node2;
        this.openCurrent();
        node2 = new XMLDTDAttList2(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.onData(this.writer.dtdAttList(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.entity = function(name, value) {
        var node2;
        this.openCurrent();
        node2 = new XMLDTDEntity2(this, false, name, value);
        this.onData(this.writer.dtdEntity(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.pEntity = function(name, value) {
        var node2;
        this.openCurrent();
        node2 = new XMLDTDEntity2(this, true, name, value);
        this.onData(this.writer.dtdEntity(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.notation = function(name, value) {
        var node2;
        this.openCurrent();
        node2 = new XMLDTDNotation2(this, name, value);
        this.onData(this.writer.dtdNotation(node2, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.up = function() {
        if (this.currentLevel < 0) {
          throw new Error("The document node has no parent.");
        }
        if (this.currentNode) {
          if (this.currentNode.children) {
            this.closeNode(this.currentNode);
          } else {
            this.openNode(this.currentNode);
          }
          this.currentNode = null;
        } else {
          this.closeNode(this.openTags[this.currentLevel]);
        }
        delete this.openTags[this.currentLevel];
        this.currentLevel--;
        return this;
      };
      XMLDocumentCB2.prototype.end = function() {
        while (this.currentLevel >= 0) {
          this.up();
        }
        return this.onEnd();
      };
      XMLDocumentCB2.prototype.openCurrent = function() {
        if (this.currentNode) {
          this.currentNode.children = true;
          return this.openNode(this.currentNode);
        }
      };
      XMLDocumentCB2.prototype.openNode = function(node2) {
        if (!node2.isOpen) {
          if (!this.root && this.currentLevel === 0 && node2 instanceof XMLElement2) {
            this.root = node2;
          }
          this.onData(this.writer.openNode(node2, this.currentLevel), this.currentLevel);
          return node2.isOpen = true;
        }
      };
      XMLDocumentCB2.prototype.closeNode = function(node2) {
        if (!node2.isClosed) {
          this.onData(this.writer.closeNode(node2, this.currentLevel), this.currentLevel);
          return node2.isClosed = true;
        }
      };
      XMLDocumentCB2.prototype.onData = function(chunk, level) {
        this.documentStarted = true;
        return this.onDataCallback(chunk, level + 1);
      };
      XMLDocumentCB2.prototype.onEnd = function() {
        this.documentCompleted = true;
        return this.onEndCallback();
      };
      XMLDocumentCB2.prototype.debugInfo = function(name) {
        if (name == null) {
          return "";
        } else {
          return "node: <" + name + ">";
        }
      };
      XMLDocumentCB2.prototype.ele = function() {
        return this.element.apply(this, arguments);
      };
      XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.txt = function(value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.ins = function(target2, value) {
        return this.instruction(target2, value);
      };
      XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
        return this.doctype(root, pubID, sysID);
      };
      XMLDocumentCB2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLDocumentCB2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.t = function(value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.d = function(value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.c = function(value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.r = function(value) {
        return this.raw(value);
      };
      XMLDocumentCB2.prototype.i = function(target2, value) {
        return this.instruction(target2, value);
      };
      XMLDocumentCB2.prototype.att = function() {
        if (this.currentNode && this.currentNode instanceof XMLDocType2) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.a = function() {
        if (this.currentNode && this.currentNode instanceof XMLDocType2) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      };
      XMLDocumentCB2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      };
      XMLDocumentCB2.prototype.not = function(name, value) {
        return this.notation(name, value);
      };
      return XMLDocumentCB2;
    })();
  }).call(XMLDocumentCB);
  return XMLDocumentCB$1.exports;
}
var XMLStreamWriter$1 = { exports: {} };
var XMLStreamWriter = XMLStreamWriter$1.exports;
var hasRequiredXMLStreamWriter;
function requireXMLStreamWriter() {
  if (hasRequiredXMLStreamWriter) return XMLStreamWriter$1.exports;
  hasRequiredXMLStreamWriter = 1;
  (function() {
    var XMLCData2, XMLComment2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLDeclaration2, XMLDocType2, XMLDummy2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLText2, XMLWriterBase2, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLDeclaration2 = requireXMLDeclaration();
    XMLDocType2 = requireXMLDocType();
    XMLCData2 = requireXMLCData();
    XMLComment2 = requireXMLComment();
    XMLElement2 = requireXMLElement();
    XMLRaw2 = requireXMLRaw();
    XMLText2 = requireXMLText();
    XMLProcessingInstruction2 = requireXMLProcessingInstruction();
    XMLDummy2 = requireXMLDummy();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLWriterBase2 = requireXMLWriterBase();
    XMLStreamWriter$1.exports = (function(superClass) {
      extend(XMLStreamWriter2, superClass);
      function XMLStreamWriter2(stream2, options) {
        XMLStreamWriter2.__super__.constructor.call(this, options);
        this.stream = stream2;
      }
      XMLStreamWriter2.prototype.document = function(doc) {
        var child, i, j, len, len1, ref2, ref1, results2;
        ref2 = doc.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          child.isLastRootNode = false;
        }
        doc.children[doc.children.length - 1].isLastRootNode = true;
        ref1 = doc.children;
        results2 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          child = ref1[j];
          if (child instanceof XMLDummy2) {
            continue;
          }
          switch (false) {
            case !(child instanceof XMLDeclaration2):
              results2.push(this.declaration(child));
              break;
            case !(child instanceof XMLDocType2):
              results2.push(this.docType(child));
              break;
            case !(child instanceof XMLComment2):
              results2.push(this.comment(child));
              break;
            case !(child instanceof XMLProcessingInstruction2):
              results2.push(this.processingInstruction(child));
              break;
            default:
              results2.push(this.element(child));
          }
        }
        return results2;
      };
      XMLStreamWriter2.prototype.attribute = function(att) {
        return this.stream.write(" " + att.name + '="' + att.value + '"');
      };
      XMLStreamWriter2.prototype.cdata = function(node2, level) {
        return this.stream.write(this.space(level) + "<![CDATA[" + node2.text + "]]>" + this.endline(node2));
      };
      XMLStreamWriter2.prototype.comment = function(node2, level) {
        return this.stream.write(this.space(level) + "<!-- " + node2.text + " -->" + this.endline(node2));
      };
      XMLStreamWriter2.prototype.declaration = function(node2, level) {
        this.stream.write(this.space(level));
        this.stream.write('<?xml version="' + node2.version + '"');
        if (node2.encoding != null) {
          this.stream.write(' encoding="' + node2.encoding + '"');
        }
        if (node2.standalone != null) {
          this.stream.write(' standalone="' + node2.standalone + '"');
        }
        this.stream.write(this.spacebeforeslash + "?>");
        return this.stream.write(this.endline(node2));
      };
      XMLStreamWriter2.prototype.docType = function(node2, level) {
        var child, i, len, ref2;
        level || (level = 0);
        this.stream.write(this.space(level));
        this.stream.write("<!DOCTYPE " + node2.root().name);
        if (node2.pubID && node2.sysID) {
          this.stream.write(' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"');
        } else if (node2.sysID) {
          this.stream.write(' SYSTEM "' + node2.sysID + '"');
        }
        if (node2.children.length > 0) {
          this.stream.write(" [");
          this.stream.write(this.endline(node2));
          ref2 = node2.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            switch (false) {
              case !(child instanceof XMLDTDAttList2):
                this.dtdAttList(child, level + 1);
                break;
              case !(child instanceof XMLDTDElement2):
                this.dtdElement(child, level + 1);
                break;
              case !(child instanceof XMLDTDEntity2):
                this.dtdEntity(child, level + 1);
                break;
              case !(child instanceof XMLDTDNotation2):
                this.dtdNotation(child, level + 1);
                break;
              case !(child instanceof XMLCData2):
                this.cdata(child, level + 1);
                break;
              case !(child instanceof XMLComment2):
                this.comment(child, level + 1);
                break;
              case !(child instanceof XMLProcessingInstruction2):
                this.processingInstruction(child, level + 1);
                break;
              default:
                throw new Error("Unknown DTD node type: " + child.constructor.name);
            }
          }
          this.stream.write("]");
        }
        this.stream.write(this.spacebeforeslash + ">");
        return this.stream.write(this.endline(node2));
      };
      XMLStreamWriter2.prototype.element = function(node2, level) {
        var att, child, i, len, name, ref2, ref1, space;
        level || (level = 0);
        space = this.space(level);
        this.stream.write(space + "<" + node2.name);
        ref2 = node2.attributes;
        for (name in ref2) {
          if (!hasProp.call(ref2, name)) continue;
          att = ref2[name];
          this.attribute(att);
        }
        if (node2.children.length === 0 || node2.children.every(function(e) {
          return e.value === "";
        })) {
          if (this.allowEmpty) {
            this.stream.write("></" + node2.name + ">");
          } else {
            this.stream.write(this.spacebeforeslash + "/>");
          }
        } else if (this.pretty && node2.children.length === 1 && node2.children[0].value != null) {
          this.stream.write(">");
          this.stream.write(node2.children[0].value);
          this.stream.write("</" + node2.name + ">");
        } else {
          this.stream.write(">" + this.newline);
          ref1 = node2.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            switch (false) {
              case !(child instanceof XMLCData2):
                this.cdata(child, level + 1);
                break;
              case !(child instanceof XMLComment2):
                this.comment(child, level + 1);
                break;
              case !(child instanceof XMLElement2):
                this.element(child, level + 1);
                break;
              case !(child instanceof XMLRaw2):
                this.raw(child, level + 1);
                break;
              case !(child instanceof XMLText2):
                this.text(child, level + 1);
                break;
              case !(child instanceof XMLProcessingInstruction2):
                this.processingInstruction(child, level + 1);
                break;
              case !(child instanceof XMLDummy2):
                break;
              default:
                throw new Error("Unknown XML node type: " + child.constructor.name);
            }
          }
          this.stream.write(space + "</" + node2.name + ">");
        }
        return this.stream.write(this.endline(node2));
      };
      XMLStreamWriter2.prototype.processingInstruction = function(node2, level) {
        this.stream.write(this.space(level) + "<?" + node2.target);
        if (node2.value) {
          this.stream.write(" " + node2.value);
        }
        return this.stream.write(this.spacebeforeslash + "?>" + this.endline(node2));
      };
      XMLStreamWriter2.prototype.raw = function(node2, level) {
        return this.stream.write(this.space(level) + node2.value + this.endline(node2));
      };
      XMLStreamWriter2.prototype.text = function(node2, level) {
        return this.stream.write(this.space(level) + node2.value + this.endline(node2));
      };
      XMLStreamWriter2.prototype.dtdAttList = function(node2, level) {
        this.stream.write(this.space(level) + "<!ATTLIST " + node2.elementName + " " + node2.attributeName + " " + node2.attributeType);
        if (node2.defaultValueType !== "#DEFAULT") {
          this.stream.write(" " + node2.defaultValueType);
        }
        if (node2.defaultValue) {
          this.stream.write(' "' + node2.defaultValue + '"');
        }
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node2));
      };
      XMLStreamWriter2.prototype.dtdElement = function(node2, level) {
        this.stream.write(this.space(level) + "<!ELEMENT " + node2.name + " " + node2.value);
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node2));
      };
      XMLStreamWriter2.prototype.dtdEntity = function(node2, level) {
        this.stream.write(this.space(level) + "<!ENTITY");
        if (node2.pe) {
          this.stream.write(" %");
        }
        this.stream.write(" " + node2.name);
        if (node2.value) {
          this.stream.write(' "' + node2.value + '"');
        } else {
          if (node2.pubID && node2.sysID) {
            this.stream.write(' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"');
          } else if (node2.sysID) {
            this.stream.write(' SYSTEM "' + node2.sysID + '"');
          }
          if (node2.nData) {
            this.stream.write(" NDATA " + node2.nData);
          }
        }
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node2));
      };
      XMLStreamWriter2.prototype.dtdNotation = function(node2, level) {
        this.stream.write(this.space(level) + "<!NOTATION " + node2.name);
        if (node2.pubID && node2.sysID) {
          this.stream.write(' PUBLIC "' + node2.pubID + '" "' + node2.sysID + '"');
        } else if (node2.pubID) {
          this.stream.write(' PUBLIC "' + node2.pubID + '"');
        } else if (node2.sysID) {
          this.stream.write(' SYSTEM "' + node2.sysID + '"');
        }
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node2));
      };
      XMLStreamWriter2.prototype.endline = function(node2) {
        if (!node2.isLastRootNode) {
          return this.newline;
        } else {
          return "";
        }
      };
      return XMLStreamWriter2;
    })(XMLWriterBase2);
  }).call(XMLStreamWriter);
  return XMLStreamWriter$1.exports;
}
var hasRequiredLib$c;
function requireLib$c() {
  if (hasRequiredLib$c) return lib$c;
  hasRequiredLib$c = 1;
  (function() {
    var XMLDocument2, XMLDocumentCB2, XMLStreamWriter2, XMLStringWriter2, assign, isFunction, ref2;
    ref2 = requireUtility(), assign = ref2.assign, isFunction = ref2.isFunction;
    XMLDocument2 = requireXMLDocument();
    XMLDocumentCB2 = requireXMLDocumentCB();
    XMLStringWriter2 = requireXMLStringWriter();
    XMLStreamWriter2 = requireXMLStreamWriter();
    lib$c.create = function(name, xmldec, doctype, options) {
      var doc, root;
      if (name == null) {
        throw new Error("Root element needs a name.");
      }
      options = assign({}, xmldec, doctype, options);
      doc = new XMLDocument2(options);
      root = doc.element(name);
      if (!options.headless) {
        doc.declaration(options);
        if (options.pubID != null || options.sysID != null) {
          doc.doctype(options);
        }
      }
      return root;
    };
    lib$c.begin = function(options, onData, onEnd) {
      var ref1;
      if (isFunction(options)) {
        ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
        options = {};
      }
      if (onData) {
        return new XMLDocumentCB2(options, onData, onEnd);
      } else {
        return new XMLDocument2(options);
      }
    };
    lib$c.stringWriter = function(options) {
      return new XMLStringWriter2(options);
    };
    lib$c.streamWriter = function(stream2, options) {
      return new XMLStreamWriter2(stream2, options);
    };
  }).call(lib$c);
  return lib$c;
}
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  var _ = requireUnderscoreNode();
  var xmlbuilder = requireLib$c();
  writer.writeString = writeString;
  function writeString(root, namespaces) {
    var uriToPrefix = _.invert(namespaces);
    var nodeWriters = {
      element: writeElement,
      text: writeTextNode
    };
    function writeNode(builder2, node2) {
      return nodeWriters[node2.type](builder2, node2);
    }
    function writeElement(builder2, element2) {
      var elementBuilder = builder2.element(mapElementName(element2.name), element2.attributes);
      element2.children.forEach(function(child) {
        writeNode(elementBuilder, child);
      });
    }
    function mapElementName(name) {
      var longFormMatch = /^\{(.*)\}(.*)$/.exec(name);
      if (longFormMatch) {
        var prefix = uriToPrefix[longFormMatch[1]];
        return prefix + (prefix === "" ? "" : ":") + longFormMatch[2];
      } else {
        return name;
      }
    }
    function writeDocument(root2) {
      var builder2 = xmlbuilder.create(mapElementName(root2.name), {
        version: "1.0",
        encoding: "UTF-8",
        standalone: true
      });
      _.forEach(namespaces, function(uri2, prefix) {
        var key = "xmlns" + (prefix === "" ? "" : ":" + prefix);
        builder2.attribute(key, uri2);
      });
      root2.children.forEach(function(child) {
        writeNode(builder2, child);
      });
      return builder2.end();
    }
    return writeDocument(root);
  }
  function writeTextNode(builder2, node2) {
    builder2.text(node2.value);
  }
  return writer;
}
var hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml;
  hasRequiredXml = 1;
  var nodes2 = requireNodes();
  xml.Element = nodes2.Element;
  xml.element = nodes2.element;
  xml.emptyElement = nodes2.emptyElement;
  xml.text = nodes2.text;
  xml.readString = requireReader().readString;
  xml.writeString = requireWriter().writeString;
  return xml;
}
var hasRequiredOfficeXmlReader;
function requireOfficeXmlReader() {
  if (hasRequiredOfficeXmlReader) return officeXmlReader;
  hasRequiredOfficeXmlReader = 1;
  var _ = requireUnderscoreNode();
  var promises2 = requirePromises();
  var xml2 = requireXml();
  officeXmlReader.read = read;
  officeXmlReader.readXmlFromZipFile = readXmlFromZipFile;
  var xmlNamespaceMap = {
    // Transitional format
    "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
    "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
    "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
    "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
    // Strict format
    "http://purl.oclc.org/ooxml/wordprocessingml/main": "w",
    "http://purl.oclc.org/ooxml/officeDocument/relationships": "r",
    "http://purl.oclc.org/ooxml/drawingml/wordprocessingDrawing": "wp",
    "http://purl.oclc.org/ooxml/drawingml/main": "a",
    "http://purl.oclc.org/ooxml/drawingml/picture": "pic",
    // Common
    "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
    "http://schemas.openxmlformats.org/package/2006/relationships": "relationships",
    "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
    "urn:schemas-microsoft-com:vml": "v",
    "urn:schemas-microsoft-com:office:word": "office-word",
    // [MS-DOCX]: Word Extensions to the Office Open XML (.docx) File Format
    // https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b839fe1f-e1ca-4fa6-8c26-5954d0abbccd
    "http://schemas.microsoft.com/office/word/2010/wordml": "wordml"
  };
  function read(xmlString) {
    return xml2.readString(xmlString, xmlNamespaceMap).then(function(document2) {
      return collapseAlternateContent(document2)[0];
    });
  }
  function readXmlFromZipFile(docxFile, path2) {
    if (docxFile.exists(path2)) {
      return docxFile.read(path2, "utf-8").then(stripUtf8Bom).then(read);
    } else {
      return promises2.resolve(null);
    }
  }
  function stripUtf8Bom(xmlString) {
    return xmlString.replace(/^\uFEFF/g, "");
  }
  function collapseAlternateContent(node2) {
    if (node2.type === "element") {
      if (node2.name === "mc:AlternateContent") {
        return node2.firstOrEmpty("mc:Fallback").children;
      } else {
        node2.children = _.flatten(node2.children.map(collapseAlternateContent, true));
        return [node2];
      }
    } else {
      return [node2];
    }
  }
  return officeXmlReader;
}
var bodyReader = {};
var dist$1 = {};
var dingbats = {};
var hasRequiredDingbats;
function requireDingbats() {
  if (hasRequiredDingbats) return dingbats;
  hasRequiredDingbats = 1;
  Object.defineProperty(dingbats, "__esModule", { value: true });
  var dingbats$1 = [
    { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
    { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
    { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
    { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
    { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
    { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
    { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
    { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
    { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
    { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
    { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
    { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
    { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
    { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
    { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
    { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
    { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
    { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
    { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
    { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
    { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
    { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
    { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
    { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
    { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
    { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
    { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
    { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
    { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
    { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
    { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
    { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
    { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
    { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
    { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
    { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
    { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
    { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
    { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
    { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
    { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
    { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
    { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
    { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
    { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
    { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
    { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
    { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
    { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
    { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
    { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
    { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
    { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
    { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
    { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
    { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
    { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
    { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
    { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
    { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
    { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
    { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
    { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
    { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
    { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
    { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
    { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
    { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
    { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
    { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
    { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
    { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
    { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
    { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
    { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
    { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
    { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
    { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
    { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
    { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
    { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
    { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
    { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
    { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
    { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
    { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
    { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
    { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
    { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
    { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
    { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
    { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
    { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
    { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
    { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
    { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
    { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
    { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
    { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
    { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
    { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
    { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
    { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
    { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
    { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
    { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
    { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
    { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
    { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
    { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
    { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
    { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
    { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
    { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
    { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
    { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
    { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
    { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
    { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
    { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
    { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
    { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
    { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
    { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
    { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
    { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
    { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
    { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
    { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
    { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
    { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
    { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
    { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
    { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
    { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
    { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
    { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
    { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
    { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
    { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
    { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
    { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
    { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
    { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
    { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
    { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
    { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
    { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
    { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
    { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
    { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
    { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
    { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
    { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
    { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
    { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
    { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
    { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
    { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
    { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
    { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
    { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
    { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
    { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
    { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
    { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
    { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
    { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
    { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
    { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
    { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
    { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
    { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
    { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
    { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
    { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
    { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
    { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
    { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
    { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
    { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
    { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
    { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
    { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
    { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
    { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
    { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
    { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
    { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
    { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
    { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
    { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
    { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
    { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
    { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
    { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
    { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
    { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
    { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
    { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
    { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
    { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
    { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
    { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
    { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
    { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
    { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
    { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
    { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
    { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
    { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
    { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
    { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
    { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
    { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
    { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
    { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
    { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
    { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
    { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
    { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
    { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
    { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
    { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
    { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
    { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
    { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
    { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
    { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
    { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
    { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
    { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
    { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
    { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
    { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
    { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
    { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
    { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
    { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
    { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
    { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
    { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
    { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
    { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
    { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
    { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
    { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
    { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
    { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
    { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
    { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
    { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
    { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
    { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
    { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
    { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
    { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
    { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
    { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
    { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
    { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
    { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
    { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
    { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
    { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
    { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
    { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
    { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
    { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
    { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
    { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
    { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
    { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
    { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
    { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
    { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
    { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
    { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
    { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
    { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
    { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
    { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
    { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
    { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
    { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
    { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
    { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
    { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
    { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
    { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
    { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
    { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
    { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
    { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
    { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
    { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
    { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
    { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
    { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
    { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
    { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
    { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
    { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
    { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
    { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
    { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
    { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
    { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
    { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
    { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
    { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
    { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
    { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
    { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
    { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
    { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
    { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
    { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
    { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
    { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
    { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
    { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
    { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
    { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
    { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
    { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
    { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
    { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
    { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
    { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
    { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
    { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
    { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
    { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
    { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
    { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
    { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
    { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
    { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
    { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
    { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
    { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
    { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
    { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
    { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
    { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
    { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
    { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
    { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
    { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
    { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
    { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
    { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
    { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
    { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
    { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
    { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
    { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
    { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
    { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
    { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
    { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
    { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
    { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
    { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
    { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
    { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
    { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
    { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
    { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
    { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
    { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
    { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
    { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
    { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
    { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
    { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
    { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
    { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
    { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
    { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
    { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
    { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
    { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
    { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
    { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
    { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
    { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
    { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
    { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
    { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
    { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
    { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
    { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
    { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
    { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
    { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
    { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
    { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
    { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
    { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
    { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
    { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
    { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
    { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
    { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
    { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
    { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
    { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
    { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
    { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
    { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
    { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
    { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
    { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
    { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
    { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
    { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
    { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
    { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
    { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
    { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
    { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
    { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
    { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
    { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
    { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
    { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
    { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
    { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
    { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
    { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
    { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
    { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
    { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
    { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
    { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
    { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
    { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
    { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
    { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
    { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
    { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
    { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
    { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
    { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
    { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
    { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
    { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
    { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
    { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
    { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
    { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
    { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
    { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
    { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
    { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
    { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
    { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
    { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
    { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
    { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
    { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
    { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
  ];
  dingbats.default = dingbats$1;
  return dingbats;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist$1;
  hasRequiredDist = 1;
  var __importDefault = dist$1 && dist$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(dist$1, "__esModule", { value: true });
  dist$1.hex = dist$1.dec = dist$1.codePoint = void 0;
  var dingbats_1 = __importDefault(requireDingbats());
  var dingbatsByCodePoint = {};
  var fromCodePoint2 = String.fromCodePoint ? String.fromCodePoint : fromCodePointPolyfill;
  for (var _i = 0, dingbats_2 = dingbats_1.default; _i < dingbats_2.length; _i++) {
    var dingbat = dingbats_2[_i];
    var codePoint_1 = parseInt(dingbat["Unicode dec"], 10);
    var scalarValue = {
      codePoint: codePoint_1,
      string: fromCodePoint2(codePoint_1)
    };
    dingbatsByCodePoint[dingbat["Typeface name"].toUpperCase() + "_" + dingbat["Dingbat dec"]] = scalarValue;
  }
  function codePoint(typeface, codePoint2) {
    return dingbatsByCodePoint[typeface.toUpperCase() + "_" + codePoint2];
  }
  dist$1.codePoint = codePoint;
  function dec(typeface, dec2) {
    return codePoint(typeface, parseInt(dec2, 10));
  }
  dist$1.dec = dec;
  function hex(typeface, hex2) {
    return codePoint(typeface, parseInt(hex2, 16));
  }
  dist$1.hex = hex;
  function fromCodePointPolyfill(codePoint2) {
    if (codePoint2 <= 65535) {
      return String.fromCharCode(codePoint2);
    } else {
      var highSurrogate = Math.floor((codePoint2 - 65536) / 1024) + 55296;
      var lowSurrogate = (codePoint2 - 65536) % 1024 + 56320;
      return String.fromCharCode(highSurrogate, lowSurrogate);
    }
  }
  return dist$1;
}
var transforms = {};
var hasRequiredTransforms;
function requireTransforms() {
  if (hasRequiredTransforms) return transforms;
  hasRequiredTransforms = 1;
  var _ = requireUnderscoreNode();
  transforms.paragraph = paragraph;
  transforms.run = run;
  transforms._elements = elements;
  transforms._elementsOfType = elementsOfType;
  transforms.getDescendantsOfType = getDescendantsOfType;
  transforms.getDescendants = getDescendants;
  function paragraph(transform) {
    return elementsOfType("paragraph", transform);
  }
  function run(transform) {
    return elementsOfType("run", transform);
  }
  function elementsOfType(elementType, transform) {
    return elements(function(element2) {
      if (element2.type === elementType) {
        return transform(element2);
      } else {
        return element2;
      }
    });
  }
  function elements(transform) {
    return function transformElement(element2) {
      if (element2.children) {
        var children = _.map(element2.children, transformElement);
        element2 = _.extend(element2, { children });
      }
      return transform(element2);
    };
  }
  function getDescendantsOfType(element2, type2) {
    return getDescendants(element2).filter(function(descendant) {
      return descendant.type === type2;
    });
  }
  function getDescendants(element2) {
    var descendants = [];
    visitDescendants(element2, function(descendant) {
      descendants.push(descendant);
    });
    return descendants;
  }
  function visitDescendants(element2, visit) {
    if (element2.children) {
      element2.children.forEach(function(child) {
        visitDescendants(child, visit);
        visit(child);
      });
    }
  }
  return transforms;
}
var uris = {};
var hasRequiredUris;
function requireUris() {
  if (hasRequiredUris) return uris;
  hasRequiredUris = 1;
  uris.uriToZipEntryName = uriToZipEntryName;
  uris.replaceFragment = replaceFragment;
  function uriToZipEntryName(base, uri2) {
    if (uri2.charAt(0) === "/") {
      return uri2.substr(1);
    } else {
      return base + "/" + uri2;
    }
  }
  function replaceFragment(uri2, fragment) {
    var hashIndex = uri2.indexOf("#");
    if (hashIndex !== -1) {
      uri2 = uri2.substring(0, hashIndex);
    }
    return uri2 + "#" + fragment;
  }
  return uris;
}
var hasRequiredBodyReader;
function requireBodyReader() {
  if (hasRequiredBodyReader) return bodyReader;
  hasRequiredBodyReader = 1;
  bodyReader.createBodyReader = createBodyReader;
  bodyReader._readNumberingProperties = readNumberingProperties;
  var dingbatToUnicode = requireDist();
  var _ = requireUnderscoreNode();
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  var warning = requireResults().warning;
  var xml2 = requireXml();
  var transforms2 = requireTransforms();
  var uris2 = requireUris();
  function createBodyReader(options) {
    return {
      readXmlElement: function(element2) {
        return new BodyReader(options).readXmlElement(element2);
      },
      readXmlElements: function(elements) {
        return new BodyReader(options).readXmlElements(elements);
      }
    };
  }
  function BodyReader(options) {
    var complexFieldStack = [];
    var currentInstrText = [];
    var deletedParagraphContents = [];
    var relationships = options.relationships;
    var contentTypes = options.contentTypes;
    var docxFile = options.docxFile;
    var files2 = options.files;
    var numbering = options.numbering;
    var styles = options.styles;
    function readXmlElements(elements) {
      var results2 = elements.map(readXmlElement);
      return combineResults(results2);
    }
    function readXmlElement(element2) {
      if (element2.type === "element") {
        var handler = xmlElementReaders[element2.name];
        if (handler) {
          return handler(element2);
        } else if (!Object.prototype.hasOwnProperty.call(ignoreElements, element2.name)) {
          var message = warning("An unrecognised element was ignored: " + element2.name);
          return emptyResultWithMessages([message]);
        }
      }
      return emptyResult();
    }
    function readParagraphProperties(element2) {
      return readParagraphStyle(element2).map(function(style) {
        return {
          type: "paragraphProperties",
          styleId: style.styleId,
          styleName: style.name,
          alignment: element2.firstOrEmpty("w:jc").attributes["w:val"],
          numbering: readNumberingProperties(style.styleId, element2.firstOrEmpty("w:numPr"), numbering),
          indent: readParagraphIndent(element2.firstOrEmpty("w:ind"))
        };
      });
    }
    function readParagraphIndent(element2) {
      return {
        start: element2.attributes["w:start"] || element2.attributes["w:left"],
        end: element2.attributes["w:end"] || element2.attributes["w:right"],
        firstLine: element2.attributes["w:firstLine"],
        hanging: element2.attributes["w:hanging"]
      };
    }
    function readRunProperties(element2) {
      return readRunStyle(element2).map(function(style) {
        var fontSizeString = element2.firstOrEmpty("w:sz").attributes["w:val"];
        var fontSize = /^[0-9]+$/.test(fontSizeString) ? parseInt(fontSizeString, 10) / 2 : null;
        return {
          type: "runProperties",
          styleId: style.styleId,
          styleName: style.name,
          verticalAlignment: element2.firstOrEmpty("w:vertAlign").attributes["w:val"],
          font: element2.firstOrEmpty("w:rFonts").attributes["w:ascii"],
          fontSize,
          isBold: readBooleanElement(element2.first("w:b")),
          isUnderline: readUnderline(element2.first("w:u")),
          isItalic: readBooleanElement(element2.first("w:i")),
          isStrikethrough: readBooleanElement(element2.first("w:strike")),
          isAllCaps: readBooleanElement(element2.first("w:caps")),
          isSmallCaps: readBooleanElement(element2.first("w:smallCaps")),
          highlight: readHighlightValue(element2.firstOrEmpty("w:highlight").attributes["w:val"])
        };
      });
    }
    function readUnderline(element2) {
      if (element2) {
        var value = element2.attributes["w:val"];
        return value !== void 0 && value !== "false" && value !== "0" && value !== "none";
      } else {
        return false;
      }
    }
    function readBooleanElement(element2) {
      if (element2) {
        var value = element2.attributes["w:val"];
        return value !== "false" && value !== "0";
      } else {
        return false;
      }
    }
    function readBooleanAttributeValue(value) {
      return value !== "false" && value !== "0";
    }
    function readHighlightValue(value) {
      if (!value || value === "none") {
        return null;
      } else {
        return value;
      }
    }
    function readParagraphStyle(element2) {
      return readStyle(element2, "w:pStyle", "Paragraph", styles.findParagraphStyleById);
    }
    function readRunStyle(element2) {
      return readStyle(element2, "w:rStyle", "Run", styles.findCharacterStyleById);
    }
    function readTableStyle(element2) {
      return readStyle(element2, "w:tblStyle", "Table", styles.findTableStyleById);
    }
    function readStyle(element2, styleTagName, styleType, findStyleById) {
      var messages2 = [];
      var styleElement = element2.first(styleTagName);
      var styleId = null;
      var name = null;
      if (styleElement) {
        styleId = styleElement.attributes["w:val"];
        if (styleId) {
          var style = findStyleById(styleId);
          if (style) {
            name = style.name;
          } else {
            messages2.push(undefinedStyleWarning(styleType, styleId));
          }
        }
      }
      return elementResultWithMessages({ styleId, name }, messages2);
    }
    function readFldChar(element2) {
      var type2 = element2.attributes["w:fldCharType"];
      if (type2 === "begin") {
        complexFieldStack.push({ type: "begin", fldChar: element2 });
        currentInstrText = [];
      } else if (type2 === "end") {
        var complexFieldEnd = complexFieldStack.pop();
        if (complexFieldEnd.type === "begin") {
          complexFieldEnd = parseCurrentInstrText(complexFieldEnd);
        }
        if (complexFieldEnd.type === "checkbox") {
          return elementResult(documents2.checkbox({
            checked: complexFieldEnd.checked
          }));
        }
      } else if (type2 === "separate") {
        var complexFieldSeparate = complexFieldStack.pop();
        var complexField = parseCurrentInstrText(complexFieldSeparate);
        complexFieldStack.push(complexField);
      }
      return emptyResult();
    }
    function currentHyperlinkOptions() {
      var topHyperlink = _.last(complexFieldStack.filter(function(complexField) {
        return complexField.type === "hyperlink";
      }));
      return topHyperlink ? topHyperlink.options : null;
    }
    function parseCurrentInstrText(complexField) {
      return parseInstrText(
        currentInstrText.join(""),
        complexField.type === "begin" ? complexField.fldChar : xml2.emptyElement
      );
    }
    function parseInstrText(instrText, fldChar) {
      var externalLinkResult = /\s*HYPERLINK "(.*)"/.exec(instrText);
      if (externalLinkResult) {
        return { type: "hyperlink", options: { href: externalLinkResult[1] } };
      }
      var internalLinkResult = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(instrText);
      if (internalLinkResult) {
        return { type: "hyperlink", options: { anchor: internalLinkResult[1] } };
      }
      var checkboxResult = /\s*FORMCHECKBOX\s*/.exec(instrText);
      if (checkboxResult) {
        var checkboxElement = fldChar.firstOrEmpty("w:ffData").firstOrEmpty("w:checkBox");
        var checkedElement = checkboxElement.first("w:checked");
        var checked = checkedElement == null ? readBooleanElement(checkboxElement.first("w:default")) : readBooleanElement(checkedElement);
        return { type: "checkbox", checked };
      }
      return { type: "unknown" };
    }
    function readInstrText(element2) {
      currentInstrText.push(element2.text());
      return emptyResult();
    }
    function readSymbol(element2) {
      var font = element2.attributes["w:font"];
      var char = element2.attributes["w:char"];
      var unicodeCharacter = dingbatToUnicode.hex(font, char);
      if (unicodeCharacter == null && /^F0..$/.test(char)) {
        unicodeCharacter = dingbatToUnicode.hex(font, char.substring(2));
      }
      if (unicodeCharacter == null) {
        return emptyResultWithMessages([warning(
          "A w:sym element with an unsupported character was ignored: char " + char + " in font " + font
        )]);
      } else {
        return elementResult(new documents2.Text(unicodeCharacter.string));
      }
    }
    function noteReferenceReader(noteType) {
      return function(element2) {
        var noteId = element2.attributes["w:id"];
        return elementResult(new documents2.NoteReference({
          noteType,
          noteId
        }));
      };
    }
    function readCommentReference(element2) {
      return elementResult(documents2.commentReference({
        commentId: element2.attributes["w:id"]
      }));
    }
    function readChildElements(element2) {
      return readXmlElements(element2.children);
    }
    var xmlElementReaders = {
      "w:p": function(element2) {
        var paragraphPropertiesElement = element2.firstOrEmpty("w:pPr");
        var isDeleted = !!paragraphPropertiesElement.firstOrEmpty("w:rPr").first("w:del");
        if (isDeleted) {
          element2.children.forEach(function(child) {
            deletedParagraphContents.push(child);
          });
          return emptyResult();
        } else {
          var childrenXml = element2.children;
          if (deletedParagraphContents.length > 0) {
            childrenXml = deletedParagraphContents.concat(childrenXml);
            deletedParagraphContents = [];
          }
          return ReadResult.map(
            readParagraphProperties(paragraphPropertiesElement),
            readXmlElements(childrenXml),
            function(properties, children) {
              return new documents2.Paragraph(children, properties);
            }
          ).insertExtra();
        }
      },
      "w:r": function(element2) {
        return ReadResult.map(
          readRunProperties(element2.firstOrEmpty("w:rPr")),
          readXmlElements(element2.children),
          function(properties, children) {
            var hyperlinkOptions = currentHyperlinkOptions();
            if (hyperlinkOptions !== null) {
              children = [new documents2.Hyperlink(children, hyperlinkOptions)];
            }
            return new documents2.Run(children, properties);
          }
        );
      },
      "w:fldChar": readFldChar,
      "w:instrText": readInstrText,
      "w:t": function(element2) {
        return elementResult(new documents2.Text(element2.text()));
      },
      "w:tab": function(element2) {
        return elementResult(new documents2.Tab());
      },
      "w:noBreakHyphen": function() {
        return elementResult(new documents2.Text("â€‘"));
      },
      "w:softHyphen": function(element2) {
        return elementResult(new documents2.Text("Â­"));
      },
      "w:sym": readSymbol,
      "w:hyperlink": function(element2) {
        var relationshipId = element2.attributes["r:id"];
        var anchor = element2.attributes["w:anchor"];
        return readXmlElements(element2.children).map(function(children) {
          function create(options2) {
            var targetFrame = element2.attributes["w:tgtFrame"] || null;
            return new documents2.Hyperlink(
              children,
              _.extend({ targetFrame }, options2)
            );
          }
          if (relationshipId) {
            var href = relationships.findTargetByRelationshipId(relationshipId);
            if (anchor) {
              href = uris2.replaceFragment(href, anchor);
            }
            return create({ href });
          } else if (anchor) {
            return create({ anchor });
          } else {
            return children;
          }
        });
      },
      "w:tbl": readTable,
      "w:tr": readTableRow,
      "w:tc": readTableCell,
      "w:footnoteReference": noteReferenceReader("footnote"),
      "w:endnoteReference": noteReferenceReader("endnote"),
      "w:commentReference": readCommentReference,
      "w:br": function(element2) {
        var breakType = element2.attributes["w:type"];
        if (breakType == null || breakType === "textWrapping") {
          return elementResult(documents2.lineBreak);
        } else if (breakType === "page") {
          return elementResult(documents2.pageBreak);
        } else if (breakType === "column") {
          return elementResult(documents2.columnBreak);
        } else {
          return emptyResultWithMessages([warning("Unsupported break type: " + breakType)]);
        }
      },
      "w:bookmarkStart": function(element2) {
        var name = element2.attributes["w:name"];
        if (name === "_GoBack") {
          return emptyResult();
        } else {
          return elementResult(new documents2.BookmarkStart({ name }));
        }
      },
      "mc:AlternateContent": function(element2) {
        return readChildElements(element2.firstOrEmpty("mc:Fallback"));
      },
      "w:sdt": function(element2) {
        var contentResult = readXmlElements(element2.firstOrEmpty("w:sdtContent").children);
        return contentResult.map(function(content) {
          var checkbox = element2.firstOrEmpty("w:sdtPr").first("wordml:checkbox");
          if (checkbox) {
            var checkedElement = checkbox.first("wordml:checked");
            var isChecked = !!checkedElement && readBooleanAttributeValue(
              checkedElement.attributes["wordml:val"]
            );
            var documentCheckbox = documents2.checkbox({
              checked: isChecked
            });
            var hasCheckbox = false;
            var replacedContent = content.map(transforms2._elementsOfType(
              documents2.types.text,
              function(text) {
                if (text.value.length > 0 && !hasCheckbox) {
                  hasCheckbox = true;
                  return documentCheckbox;
                } else {
                  return text;
                }
              }
            ));
            if (hasCheckbox) {
              return replacedContent;
            } else {
              return documentCheckbox;
            }
          } else {
            return content;
          }
        });
      },
      "w:ins": readChildElements,
      "w:object": readChildElements,
      "w:smartTag": readChildElements,
      "w:drawing": readChildElements,
      "w:pict": function(element2) {
        return readChildElements(element2).toExtra();
      },
      "v:roundrect": readChildElements,
      "v:shape": readChildElements,
      "v:textbox": readChildElements,
      "w:txbxContent": readChildElements,
      "wp:inline": readDrawingElement,
      "wp:anchor": readDrawingElement,
      "v:imagedata": readImageData,
      "v:group": readChildElements,
      "v:rect": readChildElements
    };
    return {
      readXmlElement,
      readXmlElements
    };
    function readTable(element2) {
      var propertiesResult = readTableProperties(element2.firstOrEmpty("w:tblPr"));
      return readXmlElements(element2.children).flatMap(calculateRowSpans).flatMap(function(children) {
        return propertiesResult.map(function(properties) {
          return documents2.Table(children, properties);
        });
      });
    }
    function readTableProperties(element2) {
      return readTableStyle(element2).map(function(style) {
        return {
          styleId: style.styleId,
          styleName: style.name
        };
      });
    }
    function readTableRow(element2) {
      var properties = element2.firstOrEmpty("w:trPr");
      var isDeleted = !!properties.first("w:del");
      if (isDeleted) {
        return emptyResult();
      }
      var isHeader = !!properties.first("w:tblHeader");
      return readXmlElements(element2.children).map(function(children) {
        return documents2.TableRow(children, { isHeader });
      });
    }
    function readTableCell(element2) {
      return readXmlElements(element2.children).map(function(children) {
        var properties = element2.firstOrEmpty("w:tcPr");
        var gridSpan = properties.firstOrEmpty("w:gridSpan").attributes["w:val"];
        var colSpan = gridSpan ? parseInt(gridSpan, 10) : 1;
        var cell = documents2.TableCell(children, { colSpan });
        cell._vMerge = readVMerge(properties);
        return cell;
      });
    }
    function readVMerge(properties) {
      var element2 = properties.first("w:vMerge");
      if (element2) {
        var val = element2.attributes["w:val"];
        return val === "continue" || !val;
      } else {
        return null;
      }
    }
    function calculateRowSpans(rows) {
      var unexpectedNonRows = _.any(rows, function(row) {
        return row.type !== documents2.types.tableRow;
      });
      if (unexpectedNonRows) {
        removeVMergeProperties(rows);
        return elementResultWithMessages(rows, [warning(
          "unexpected non-row element in table, cell merging may be incorrect"
        )]);
      }
      var unexpectedNonCells = _.any(rows, function(row) {
        return _.any(row.children, function(cell) {
          return cell.type !== documents2.types.tableCell;
        });
      });
      if (unexpectedNonCells) {
        removeVMergeProperties(rows);
        return elementResultWithMessages(rows, [warning(
          "unexpected non-cell element in table row, cell merging may be incorrect"
        )]);
      }
      var columns = {};
      rows.forEach(function(row) {
        var cellIndex = 0;
        row.children.forEach(function(cell) {
          if (cell._vMerge && columns[cellIndex]) {
            columns[cellIndex].rowSpan++;
          } else {
            columns[cellIndex] = cell;
            cell._vMerge = false;
          }
          cellIndex += cell.colSpan;
        });
      });
      rows.forEach(function(row) {
        row.children = row.children.filter(function(cell) {
          return !cell._vMerge;
        });
        row.children.forEach(function(cell) {
          delete cell._vMerge;
        });
      });
      return elementResult(rows);
    }
    function removeVMergeProperties(rows) {
      rows.forEach(function(row) {
        var cells = transforms2.getDescendantsOfType(row, documents2.types.tableCell);
        cells.forEach(function(cell) {
          delete cell._vMerge;
        });
      });
    }
    function readDrawingElement(element2) {
      var blips = element2.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
      return combineResults(blips.map(readBlip.bind(null, element2)));
    }
    function readBlip(element2, blip) {
      var properties = element2.first("wp:docPr").attributes;
      var altText = isBlank(properties.descr) ? properties.title : properties.descr;
      var blipImageFile = findBlipImageFile(blip);
      if (blipImageFile === null) {
        return emptyResultWithMessages([warning("Could not find image file for a:blip element")]);
      } else {
        return readImage(blipImageFile, altText);
      }
    }
    function isBlank(value) {
      return value == null || /^\s*$/.test(value);
    }
    function findBlipImageFile(blip) {
      var embedRelationshipId = blip.attributes["r:embed"];
      var linkRelationshipId = blip.attributes["r:link"];
      if (embedRelationshipId) {
        return findEmbeddedImageFile(embedRelationshipId);
      } else if (linkRelationshipId) {
        var imagePath = relationships.findTargetByRelationshipId(linkRelationshipId);
        return {
          path: imagePath,
          read: files2.read.bind(files2, imagePath)
        };
      } else {
        return null;
      }
    }
    function readImageData(element2) {
      var relationshipId = element2.attributes["r:id"];
      if (relationshipId) {
        return readImage(
          findEmbeddedImageFile(relationshipId),
          element2.attributes["o:title"]
        );
      } else {
        return emptyResultWithMessages([warning("A v:imagedata element without a relationship ID was ignored")]);
      }
    }
    function findEmbeddedImageFile(relationshipId) {
      var path2 = uris2.uriToZipEntryName("word", relationships.findTargetByRelationshipId(relationshipId));
      return {
        path: path2,
        read: docxFile.read.bind(docxFile, path2)
      };
    }
    function readImage(imageFile, altText) {
      var contentType = contentTypes.findContentType(imageFile.path);
      var image2 = documents2.Image({
        readImage: imageFile.read,
        altText,
        contentType
      });
      var warnings = supportedImageTypes[contentType] ? [] : warning("Image of type " + contentType + " is unlikely to display in web browsers");
      return elementResultWithMessages(image2, warnings);
    }
    function undefinedStyleWarning(type2, styleId) {
      return warning(
        type2 + " style with ID " + styleId + " was referenced but not defined in the document"
      );
    }
  }
  function readNumberingProperties(styleId, element2, numbering) {
    var level = element2.firstOrEmpty("w:ilvl").attributes["w:val"];
    var numId = element2.firstOrEmpty("w:numId").attributes["w:val"];
    if (level !== void 0 && numId !== void 0) {
      return numbering.findLevel(numId, level);
    }
    if (styleId != null) {
      var levelByStyleId = numbering.findLevelByParagraphStyleId(styleId);
      if (levelByStyleId != null) {
        return levelByStyleId;
      }
    }
    if (numId !== void 0) {
      return numbering.findLevel(numId, "0");
    }
    return null;
  }
  var supportedImageTypes = {
    "image/png": true,
    "image/gif": true,
    "image/jpeg": true,
    "image/svg+xml": true,
    "image/tiff": true
  };
  var ignoreElements = {
    "office-word:wrap": true,
    "v:shadow": true,
    "v:shapetype": true,
    "w:annotationRef": true,
    "w:bookmarkEnd": true,
    "w:sectPr": true,
    "w:proofErr": true,
    "w:lastRenderedPageBreak": true,
    "w:commentRangeStart": true,
    "w:commentRangeEnd": true,
    "w:del": true,
    "w:footnoteRef": true,
    "w:endnoteRef": true,
    "w:pPr": true,
    "w:rPr": true,
    "w:tblPr": true,
    "w:tblGrid": true,
    "w:trPr": true,
    "w:tcPr": true
  };
  function emptyResultWithMessages(messages2) {
    return new ReadResult(null, null, messages2);
  }
  function emptyResult() {
    return new ReadResult(null);
  }
  function elementResult(element2) {
    return new ReadResult(element2);
  }
  function elementResultWithMessages(element2, messages2) {
    return new ReadResult(element2, null, messages2);
  }
  function ReadResult(element2, extra, messages2) {
    this.value = element2 || [];
    this.extra = extra || [];
    this._result = new Result({
      element: this.value,
      extra
    }, messages2);
    this.messages = this._result.messages;
  }
  ReadResult.prototype.toExtra = function() {
    return new ReadResult(null, joinElements(this.extra, this.value), this.messages);
  };
  ReadResult.prototype.insertExtra = function() {
    var extra = this.extra;
    if (extra && extra.length) {
      return new ReadResult(joinElements(this.value, extra), null, this.messages);
    } else {
      return this;
    }
  };
  ReadResult.prototype.map = function(func) {
    var result = this._result.map(function(value) {
      return func(value.element);
    });
    return new ReadResult(result.value, this.extra, result.messages);
  };
  ReadResult.prototype.flatMap = function(func) {
    var result = this._result.flatMap(function(value) {
      return func(value.element)._result;
    });
    return new ReadResult(result.value.element, joinElements(this.extra, result.value.extra), result.messages);
  };
  ReadResult.map = function(first, second, func) {
    return new ReadResult(
      func(first.value, second.value),
      joinElements(first.extra, second.extra),
      first.messages.concat(second.messages)
    );
  };
  function combineResults(results2) {
    var result = Result.combine(_.pluck(results2, "_result"));
    return new ReadResult(
      _.flatten(_.pluck(result.value, "element")),
      _.filter(_.flatten(_.pluck(result.value, "extra")), identity),
      result.messages
    );
  }
  function joinElements(first, second) {
    return _.flatten([first, second]);
  }
  function identity(value) {
    return value;
  }
  return bodyReader;
}
var documentXmlReader = {};
var hasRequiredDocumentXmlReader;
function requireDocumentXmlReader() {
  if (hasRequiredDocumentXmlReader) return documentXmlReader;
  hasRequiredDocumentXmlReader = 1;
  documentXmlReader.DocumentXmlReader = DocumentXmlReader;
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  function DocumentXmlReader(options) {
    var bodyReader2 = options.bodyReader;
    function convertXmlToDocument(element2) {
      var body = element2.first("w:body");
      if (body == null) {
        throw new Error("Could not find the body element: are you sure this is a docx file?");
      }
      var result = bodyReader2.readXmlElements(body.children).map(function(children) {
        return new documents2.Document(children, {
          notes: options.notes,
          comments: options.comments
        });
      });
      return new Result(result.value, result.messages);
    }
    return {
      convertXmlToDocument
    };
  }
  return documentXmlReader;
}
var relationshipsReader = {};
var hasRequiredRelationshipsReader;
function requireRelationshipsReader() {
  if (hasRequiredRelationshipsReader) return relationshipsReader;
  hasRequiredRelationshipsReader = 1;
  relationshipsReader.readRelationships = readRelationships;
  relationshipsReader.defaultValue = new Relationships([]);
  relationshipsReader.Relationships = Relationships;
  function readRelationships(element2) {
    var relationships = [];
    element2.children.forEach(function(child) {
      if (child.name === "relationships:Relationship") {
        var relationship = {
          relationshipId: child.attributes.Id,
          target: child.attributes.Target,
          type: child.attributes.Type
        };
        relationships.push(relationship);
      }
    });
    return new Relationships(relationships);
  }
  function Relationships(relationships) {
    var targetsByRelationshipId = {};
    relationships.forEach(function(relationship) {
      targetsByRelationshipId[relationship.relationshipId] = relationship.target;
    });
    var targetsByType = {};
    relationships.forEach(function(relationship) {
      if (!targetsByType[relationship.type]) {
        targetsByType[relationship.type] = [];
      }
      targetsByType[relationship.type].push(relationship.target);
    });
    return {
      findTargetByRelationshipId: function(relationshipId) {
        return targetsByRelationshipId[relationshipId];
      },
      findTargetsByType: function(type2) {
        return targetsByType[type2] || [];
      }
    };
  }
  return relationshipsReader;
}
var contentTypesReader = {};
var hasRequiredContentTypesReader;
function requireContentTypesReader() {
  if (hasRequiredContentTypesReader) return contentTypesReader;
  hasRequiredContentTypesReader = 1;
  contentTypesReader.readContentTypesFromXml = readContentTypesFromXml;
  var fallbackContentTypes = {
    "png": "png",
    "gif": "gif",
    "jpeg": "jpeg",
    "jpg": "jpeg",
    "tif": "tiff",
    "tiff": "tiff",
    "bmp": "bmp"
  };
  contentTypesReader.defaultContentTypes = contentTypes({}, {});
  function readContentTypesFromXml(element2) {
    var extensionDefaults = {};
    var overrides = {};
    element2.children.forEach(function(child) {
      if (child.name === "content-types:Default") {
        extensionDefaults[child.attributes.Extension] = child.attributes.ContentType;
      }
      if (child.name === "content-types:Override") {
        var name = child.attributes.PartName;
        if (name.charAt(0) === "/") {
          name = name.substring(1);
        }
        overrides[name] = child.attributes.ContentType;
      }
    });
    return contentTypes(overrides, extensionDefaults);
  }
  function contentTypes(overrides, extensionDefaults) {
    return {
      findContentType: function(path2) {
        var overrideContentType = overrides[path2];
        if (overrideContentType) {
          return overrideContentType;
        } else {
          var pathParts = path2.split(".");
          var extension = pathParts[pathParts.length - 1];
          if (extensionDefaults.hasOwnProperty(extension)) {
            return extensionDefaults[extension];
          } else {
            var fallback = fallbackContentTypes[extension.toLowerCase()];
            if (fallback) {
              return "image/" + fallback;
            } else {
              return null;
            }
          }
        }
      }
    };
  }
  return contentTypesReader;
}
var numberingXml = {};
var hasRequiredNumberingXml;
function requireNumberingXml() {
  if (hasRequiredNumberingXml) return numberingXml;
  hasRequiredNumberingXml = 1;
  var _ = requireUnderscoreNode();
  numberingXml.readNumberingXml = readNumberingXml;
  numberingXml.Numbering = Numbering;
  numberingXml.defaultNumbering = new Numbering({}, {});
  function Numbering(nums, abstractNums, styles) {
    var allLevels = _.flatten(_.values(abstractNums).map(function(abstractNum) {
      return _.values(abstractNum.levels);
    }));
    var levelsByParagraphStyleId = _.indexBy(
      allLevels.filter(function(level) {
        return level.paragraphStyleId != null;
      }),
      "paragraphStyleId"
    );
    function findLevel(numId, level) {
      var num2 = nums[numId];
      if (num2) {
        var abstractNum = abstractNums[num2.abstractNumId];
        if (!abstractNum) {
          return null;
        } else if (abstractNum.numStyleLink == null) {
          return abstractNums[num2.abstractNumId].levels[level];
        } else {
          var style = styles.findNumberingStyleById(abstractNum.numStyleLink);
          return findLevel(style.numId, level);
        }
      } else {
        return null;
      }
    }
    function findLevelByParagraphStyleId(styleId) {
      return levelsByParagraphStyleId[styleId] || null;
    }
    return {
      findLevel,
      findLevelByParagraphStyleId
    };
  }
  function readNumberingXml(root, options) {
    if (!options || !options.styles) {
      throw new Error("styles is missing");
    }
    var abstractNums = readAbstractNums(root);
    var nums = readNums(root);
    return new Numbering(nums, abstractNums, options.styles);
  }
  function readAbstractNums(root) {
    var abstractNums = {};
    root.getElementsByTagName("w:abstractNum").forEach(function(element2) {
      var id = element2.attributes["w:abstractNumId"];
      abstractNums[id] = readAbstractNum(element2);
    });
    return abstractNums;
  }
  function readAbstractNum(element2) {
    var levels = {};
    var levelWithoutIndex = null;
    element2.getElementsByTagName("w:lvl").forEach(function(levelElement) {
      var levelIndex = levelElement.attributes["w:ilvl"];
      var numFmt = levelElement.firstOrEmpty("w:numFmt").attributes["w:val"];
      var isOrdered = numFmt !== "bullet";
      var paragraphStyleId = levelElement.firstOrEmpty("w:pStyle").attributes["w:val"];
      if (levelIndex === void 0) {
        levelWithoutIndex = {
          isOrdered,
          level: "0",
          paragraphStyleId
        };
      } else {
        levels[levelIndex] = {
          isOrdered,
          level: levelIndex,
          paragraphStyleId
        };
      }
    });
    if (levelWithoutIndex !== null && levels[levelWithoutIndex.level] === void 0) {
      levels[levelWithoutIndex.level] = levelWithoutIndex;
    }
    var numStyleLink = element2.firstOrEmpty("w:numStyleLink").attributes["w:val"];
    return { levels, numStyleLink };
  }
  function readNums(root) {
    var nums = {};
    root.getElementsByTagName("w:num").forEach(function(element2) {
      var numId = element2.attributes["w:numId"];
      var abstractNumId = element2.first("w:abstractNumId").attributes["w:val"];
      nums[numId] = { abstractNumId };
    });
    return nums;
  }
  return numberingXml;
}
var stylesReader = {};
var hasRequiredStylesReader;
function requireStylesReader() {
  if (hasRequiredStylesReader) return stylesReader;
  hasRequiredStylesReader = 1;
  stylesReader.readStylesXml = readStylesXml;
  stylesReader.Styles = Styles;
  stylesReader.defaultStyles = new Styles({}, {});
  function Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles) {
    return {
      findParagraphStyleById: function(styleId) {
        return paragraphStyles[styleId];
      },
      findCharacterStyleById: function(styleId) {
        return characterStyles[styleId];
      },
      findTableStyleById: function(styleId) {
        return tableStyles[styleId];
      },
      findNumberingStyleById: function(styleId) {
        return numberingStyles[styleId];
      }
    };
  }
  Styles.EMPTY = new Styles({}, {}, {}, {});
  function readStylesXml(root) {
    var paragraphStyles = {};
    var characterStyles = {};
    var tableStyles = {};
    var numberingStyles = {};
    var styles = {
      "paragraph": paragraphStyles,
      "character": characterStyles,
      "table": tableStyles,
      "numbering": numberingStyles
    };
    root.getElementsByTagName("w:style").forEach(function(styleElement) {
      var style = readStyleElement(styleElement);
      var styleSet = styles[style.type];
      if (styleSet && styleSet[style.styleId] === void 0) {
        styleSet[style.styleId] = style;
      }
    });
    return new Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles);
  }
  function readStyleElement(styleElement) {
    var type2 = styleElement.attributes["w:type"];
    if (type2 === "numbering") {
      return readNumberingStyleElement(type2, styleElement);
    } else {
      var styleId = readStyleId(styleElement);
      var name = styleName(styleElement);
      return { type: type2, styleId, name };
    }
  }
  function styleName(styleElement) {
    var nameElement = styleElement.first("w:name");
    return nameElement ? nameElement.attributes["w:val"] : null;
  }
  function readNumberingStyleElement(type2, styleElement) {
    var styleId = readStyleId(styleElement);
    var numId = styleElement.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
    return { type: type2, numId, styleId };
  }
  function readStyleId(styleElement) {
    return styleElement.attributes["w:styleId"];
  }
  return stylesReader;
}
var notesReader = {};
var hasRequiredNotesReader;
function requireNotesReader() {
  if (hasRequiredNotesReader) return notesReader;
  hasRequiredNotesReader = 1;
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  notesReader.createFootnotesReader = createReader.bind(notesReader, "footnote");
  notesReader.createEndnotesReader = createReader.bind(notesReader, "endnote");
  function createReader(noteType, bodyReader2) {
    function readNotesXml(element2) {
      return Result.combine(element2.getElementsByTagName("w:" + noteType).filter(isFootnoteElement).map(readFootnoteElement));
    }
    function isFootnoteElement(element2) {
      var type2 = element2.attributes["w:type"];
      return type2 !== "continuationSeparator" && type2 !== "separator";
    }
    function readFootnoteElement(footnoteElement) {
      var id = footnoteElement.attributes["w:id"];
      return bodyReader2.readXmlElements(footnoteElement.children).map(function(body) {
        return documents2.Note({ noteType, noteId: id, body });
      });
    }
    return readNotesXml;
  }
  return notesReader;
}
var commentsReader = {};
var hasRequiredCommentsReader;
function requireCommentsReader() {
  if (hasRequiredCommentsReader) return commentsReader;
  hasRequiredCommentsReader = 1;
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  function createCommentsReader(bodyReader2) {
    function readCommentsXml(element2) {
      return Result.combine(element2.getElementsByTagName("w:comment").map(readCommentElement));
    }
    function readCommentElement(element2) {
      var id = element2.attributes["w:id"];
      function readOptionalAttribute(name) {
        return (element2.attributes[name] || "").trim() || null;
      }
      return bodyReader2.readXmlElements(element2.children).map(function(body) {
        return documents2.comment({
          commentId: id,
          body,
          authorName: readOptionalAttribute("w:author"),
          authorInitials: readOptionalAttribute("w:initials")
        });
      });
    }
    return readCommentsXml;
  }
  commentsReader.createCommentsReader = createCommentsReader;
  return commentsReader;
}
var files = {};
var pathIsAbsolute = { exports: {} };
var hasRequiredPathIsAbsolute;
function requirePathIsAbsolute() {
  if (hasRequiredPathIsAbsolute) return pathIsAbsolute.exports;
  hasRequiredPathIsAbsolute = 1;
  function posix(path2) {
    return path2.charAt(0) === "/";
  }
  function win32(path2) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path2);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  pathIsAbsolute.exports = process.platform === "win32" ? win32 : posix;
  pathIsAbsolute.exports.posix = posix;
  pathIsAbsolute.exports.win32 = win32;
  return pathIsAbsolute.exports;
}
var hasRequiredFiles;
function requireFiles() {
  if (hasRequiredFiles) return files;
  hasRequiredFiles = 1;
  var fs$12 = fs;
  var url = Url;
  var os = require$$2$4;
  var dirname = path.dirname;
  var resolvePath = path.resolve;
  var isAbsolutePath = requirePathIsAbsolute();
  var promises2 = requirePromises();
  files.Files = Files;
  files.uriToPath = uriToPath;
  function Files(options) {
    options = options || {};
    if (!options.externalFileAccess) {
      return {
        read: function(uri2) {
          return promises2.reject(new Error("could not read external image '" + uri2 + "', external file access is disabled"));
        }
      };
    }
    var base = options.relativeToFile ? dirname(options.relativeToFile) : null;
    function read(uri2, encoding) {
      return resolveUri(uri2).then(function(path2) {
        return readFile(path2, encoding).caught(function(error) {
          var message = "could not open external image: '" + uri2 + "' (document directory: '" + base + "')\n" + error.message;
          return promises2.reject(new Error(message));
        });
      });
    }
    function resolveUri(uri2) {
      var path2 = uriToPath(uri2);
      if (isAbsolutePath(path2)) {
        return promises2.resolve(path2);
      } else if (base) {
        return promises2.resolve(resolvePath(base, path2));
      } else {
        return promises2.reject(new Error("could not find external image '" + uri2 + "', path of input document is unknown"));
      }
    }
    return {
      read
    };
  }
  var readFile = promises2.promisify(fs$12.readFile.bind(fs$12));
  function uriToPath(uriString, platform) {
    if (!platform) {
      platform = os.platform();
    }
    var uri2 = url.parse(uriString);
    if (isLocalFileUri(uri2) || isRelativeUri(uri2)) {
      var path2 = decodeURIComponent(uri2.path);
      if (platform === "win32" && /^\/[a-z]:/i.test(path2)) {
        return path2.slice(1);
      } else {
        return path2;
      }
    } else {
      throw new Error("Could not convert URI to path: " + uriString);
    }
  }
  function isLocalFileUri(uri2) {
    return uri2.protocol === "file:" && (!uri2.host || uri2.host === "localhost");
  }
  function isRelativeUri(uri2) {
    return !uri2.protocol && !uri2.host;
  }
  return files;
}
var hasRequiredDocxReader;
function requireDocxReader() {
  if (hasRequiredDocxReader) return docxReader;
  hasRequiredDocxReader = 1;
  docxReader.read = read;
  docxReader._findPartPaths = findPartPaths;
  var promises2 = requirePromises();
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  var zipfile2 = requireZipfile();
  var readXmlFromZipFile = requireOfficeXmlReader().readXmlFromZipFile;
  var createBodyReader = requireBodyReader().createBodyReader;
  var DocumentXmlReader = requireDocumentXmlReader().DocumentXmlReader;
  var relationshipsReader2 = requireRelationshipsReader();
  var contentTypesReader2 = requireContentTypesReader();
  var numberingXml2 = requireNumberingXml();
  var stylesReader2 = requireStylesReader();
  var notesReader2 = requireNotesReader();
  var commentsReader2 = requireCommentsReader();
  var Files = requireFiles().Files;
  function read(docxFile, input, options) {
    input = input || {};
    options = options || {};
    var files2 = new Files({
      externalFileAccess: options.externalFileAccess,
      relativeToFile: input.path
    });
    return promises2.props({
      contentTypes: readContentTypesFromZipFile(docxFile),
      partPaths: findPartPaths(docxFile),
      docxFile,
      files: files2
    }).also(function(result) {
      return {
        styles: readStylesFromZipFile(docxFile, result.partPaths.styles)
      };
    }).also(function(result) {
      return {
        numbering: readNumberingFromZipFile(docxFile, result.partPaths.numbering, result.styles)
      };
    }).also(function(result) {
      return {
        footnotes: readXmlFileWithBody(result.partPaths.footnotes, result, function(bodyReader2, xml2) {
          if (xml2) {
            return notesReader2.createFootnotesReader(bodyReader2)(xml2);
          } else {
            return new Result([]);
          }
        }),
        endnotes: readXmlFileWithBody(result.partPaths.endnotes, result, function(bodyReader2, xml2) {
          if (xml2) {
            return notesReader2.createEndnotesReader(bodyReader2)(xml2);
          } else {
            return new Result([]);
          }
        }),
        comments: readXmlFileWithBody(result.partPaths.comments, result, function(bodyReader2, xml2) {
          if (xml2) {
            return commentsReader2.createCommentsReader(bodyReader2)(xml2);
          } else {
            return new Result([]);
          }
        })
      };
    }).also(function(result) {
      return {
        notes: result.footnotes.flatMap(function(footnotes) {
          return result.endnotes.map(function(endnotes) {
            return new documents2.Notes(footnotes.concat(endnotes));
          });
        })
      };
    }).then(function(result) {
      return readXmlFileWithBody(result.partPaths.mainDocument, result, function(bodyReader2, xml2) {
        return result.notes.flatMap(function(notes) {
          return result.comments.flatMap(function(comments) {
            var reader2 = new DocumentXmlReader({
              bodyReader: bodyReader2,
              notes,
              comments
            });
            return reader2.convertXmlToDocument(xml2);
          });
        });
      });
    });
  }
  function findPartPaths(docxFile) {
    return readPackageRelationships(docxFile).then(function(packageRelationships) {
      var mainDocumentPath = findPartPath({
        docxFile,
        relationships: packageRelationships,
        relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
        basePath: "",
        fallbackPath: "word/document.xml"
      });
      if (!docxFile.exists(mainDocumentPath)) {
        throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
      }
      return xmlFileReader({
        filename: relationshipsFilename(mainDocumentPath),
        readElement: relationshipsReader2.readRelationships,
        defaultValue: relationshipsReader2.defaultValue
      })(docxFile).then(function(documentRelationships) {
        function findPartRelatedToMainDocument(name) {
          return findPartPath({
            docxFile,
            relationships: documentRelationships,
            relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + name,
            basePath: zipfile2.splitPath(mainDocumentPath).dirname,
            fallbackPath: "word/" + name + ".xml"
          });
        }
        return {
          mainDocument: mainDocumentPath,
          comments: findPartRelatedToMainDocument("comments"),
          endnotes: findPartRelatedToMainDocument("endnotes"),
          footnotes: findPartRelatedToMainDocument("footnotes"),
          numbering: findPartRelatedToMainDocument("numbering"),
          styles: findPartRelatedToMainDocument("styles")
        };
      });
    });
  }
  function findPartPath(options) {
    var docxFile = options.docxFile;
    var relationships = options.relationships;
    var relationshipType = options.relationshipType;
    var basePath = options.basePath;
    var fallbackPath = options.fallbackPath;
    var targets = relationships.findTargetsByType(relationshipType);
    var normalisedTargets = targets.map(function(target2) {
      return stripPrefix(zipfile2.joinPath(basePath, target2), "/");
    });
    var validTargets = normalisedTargets.filter(function(target2) {
      return docxFile.exists(target2);
    });
    if (validTargets.length === 0) {
      return fallbackPath;
    } else {
      return validTargets[0];
    }
  }
  function stripPrefix(value, prefix) {
    if (value.substring(0, prefix.length) === prefix) {
      return value.substring(prefix.length);
    } else {
      return value;
    }
  }
  function xmlFileReader(options) {
    return function(zipFile) {
      return readXmlFromZipFile(zipFile, options.filename).then(function(element2) {
        return element2 ? options.readElement(element2) : options.defaultValue;
      });
    };
  }
  function readXmlFileWithBody(filename, options, func) {
    var readRelationshipsFromZipFile = xmlFileReader({
      filename: relationshipsFilename(filename),
      readElement: relationshipsReader2.readRelationships,
      defaultValue: relationshipsReader2.defaultValue
    });
    return readRelationshipsFromZipFile(options.docxFile).then(function(relationships) {
      var bodyReader2 = new createBodyReader({
        relationships,
        contentTypes: options.contentTypes,
        docxFile: options.docxFile,
        numbering: options.numbering,
        styles: options.styles,
        files: options.files
      });
      return readXmlFromZipFile(options.docxFile, filename).then(function(xml2) {
        return func(bodyReader2, xml2);
      });
    });
  }
  function relationshipsFilename(filename) {
    var split = zipfile2.splitPath(filename);
    return zipfile2.joinPath(split.dirname, "_rels", split.basename + ".rels");
  }
  var readContentTypesFromZipFile = xmlFileReader({
    filename: "[Content_Types].xml",
    readElement: contentTypesReader2.readContentTypesFromXml,
    defaultValue: contentTypesReader2.defaultContentTypes
  });
  function readNumberingFromZipFile(zipFile, path2, styles) {
    return xmlFileReader({
      filename: path2,
      readElement: function(element2) {
        return numberingXml2.readNumberingXml(element2, { styles });
      },
      defaultValue: numberingXml2.defaultNumbering
    })(zipFile);
  }
  function readStylesFromZipFile(zipFile, path2) {
    return xmlFileReader({
      filename: path2,
      readElement: stylesReader2.readStylesXml,
      defaultValue: stylesReader2.defaultStyles
    })(zipFile);
  }
  var readPackageRelationships = xmlFileReader({
    filename: "_rels/.rels",
    readElement: relationshipsReader2.readRelationships,
    defaultValue: relationshipsReader2.defaultValue
  });
  return docxReader;
}
var styleMap = {};
var hasRequiredStyleMap;
function requireStyleMap() {
  if (hasRequiredStyleMap) return styleMap;
  hasRequiredStyleMap = 1;
  var _ = requireUnderscoreNode();
  var promises2 = requirePromises();
  var xml2 = requireXml();
  styleMap.writeStyleMap = writeStyleMap;
  styleMap.readStyleMap = readStyleMap;
  var schema = "http://schemas.zwobble.org/mammoth/style-map";
  var styleMapPath = "mammoth/style-map";
  var styleMapAbsolutePath = "/" + styleMapPath;
  function writeStyleMap(docxFile, styleMap2) {
    docxFile.write(styleMapPath, styleMap2);
    return updateRelationships(docxFile).then(function() {
      return updateContentTypes(docxFile);
    });
  }
  function updateRelationships(docxFile) {
    var path2 = "word/_rels/document.xml.rels";
    var relationshipsUri = "http://schemas.openxmlformats.org/package/2006/relationships";
    var relationshipElementName = "{" + relationshipsUri + "}Relationship";
    return docxFile.read(path2, "utf8").then(xml2.readString).then(function(relationshipsContainer) {
      var relationships = relationshipsContainer.children;
      addOrUpdateElement(relationships, relationshipElementName, "Id", {
        "Id": "rMammothStyleMap",
        "Type": schema,
        "Target": styleMapAbsolutePath
      });
      var namespaces = { "": relationshipsUri };
      return docxFile.write(path2, xml2.writeString(relationshipsContainer, namespaces));
    });
  }
  function updateContentTypes(docxFile) {
    var path2 = "[Content_Types].xml";
    var contentTypesUri = "http://schemas.openxmlformats.org/package/2006/content-types";
    var overrideName = "{" + contentTypesUri + "}Override";
    return docxFile.read(path2, "utf8").then(xml2.readString).then(function(typesElement) {
      var children = typesElement.children;
      addOrUpdateElement(children, overrideName, "PartName", {
        "PartName": styleMapAbsolutePath,
        "ContentType": "text/prs.mammoth.style-map"
      });
      var namespaces = { "": contentTypesUri };
      return docxFile.write(path2, xml2.writeString(typesElement, namespaces));
    });
  }
  function addOrUpdateElement(elements, name, identifyingAttribute, attributes) {
    var existingElement = _.find(elements, function(element2) {
      return element2.name === name && element2.attributes[identifyingAttribute] === attributes[identifyingAttribute];
    });
    if (existingElement) {
      existingElement.attributes = attributes;
    } else {
      elements.push(xml2.element(name, attributes));
    }
  }
  function readStyleMap(docxFile) {
    if (docxFile.exists(styleMapPath)) {
      return docxFile.read(styleMapPath, "utf8");
    } else {
      return promises2.resolve(null);
    }
  }
  return styleMap;
}
var documentToHtml = {};
var htmlPaths = {};
var html = {};
var ast$2 = {};
var hasRequiredAst;
function requireAst() {
  if (hasRequiredAst) return ast$2;
  hasRequiredAst = 1;
  var htmlPaths2 = requireHtmlPaths();
  function nonFreshElement(tagName, attributes, children) {
    return elementWithTag(
      htmlPaths2.element(tagName, attributes, { fresh: false }),
      children
    );
  }
  function freshElement(tagName, attributes, children) {
    var tag = htmlPaths2.element(tagName, attributes, { fresh: true });
    return elementWithTag(tag, children);
  }
  function elementWithTag(tag, children) {
    return {
      type: "element",
      tag,
      children: children || []
    };
  }
  function text(value) {
    return {
      type: "text",
      value
    };
  }
  var forceWrite = {
    type: "forceWrite"
  };
  ast$2.freshElement = freshElement;
  ast$2.nonFreshElement = nonFreshElement;
  ast$2.elementWithTag = elementWithTag;
  ast$2.text = text;
  ast$2.forceWrite = forceWrite;
  var voidTagNames = {
    "br": true,
    "hr": true,
    "img": true,
    "input": true
  };
  function isVoidElement(node2) {
    return node2.children.length === 0 && voidTagNames[node2.tag.tagName];
  }
  ast$2.isVoidElement = isVoidElement;
  return ast$2;
}
var simplify_1;
var hasRequiredSimplify;
function requireSimplify() {
  if (hasRequiredSimplify) return simplify_1;
  hasRequiredSimplify = 1;
  var _ = requireUnderscoreNode();
  var ast2 = requireAst();
  function simplify(nodes2) {
    return collapse(removeEmpty(nodes2));
  }
  function collapse(nodes2) {
    var children = [];
    nodes2.map(collapseNode).forEach(function(child) {
      appendChild(children, child);
    });
    return children;
  }
  function collapseNode(node2) {
    return collapsers[node2.type](node2);
  }
  var collapsers = {
    element: collapseElement,
    text: identity,
    forceWrite: identity
  };
  function collapseElement(node2) {
    return ast2.elementWithTag(node2.tag, collapse(node2.children));
  }
  function identity(value) {
    return value;
  }
  function appendChild(children, child) {
    var lastChild = children[children.length - 1];
    if (child.type === "element" && !child.tag.fresh && lastChild && lastChild.type === "element" && child.tag.matchesElement(lastChild.tag)) {
      if (child.tag.separator) {
        appendChild(lastChild.children, ast2.text(child.tag.separator));
      }
      child.children.forEach(function(grandChild) {
        appendChild(lastChild.children, grandChild);
      });
    } else {
      children.push(child);
    }
  }
  function removeEmpty(nodes2) {
    return flatMap(nodes2, function(node2) {
      return emptiers[node2.type](node2);
    });
  }
  function flatMap(values, func) {
    return _.flatten(_.map(values, func), true);
  }
  var emptiers = {
    element: elementEmptier,
    text: textEmptier,
    forceWrite: neverEmpty
  };
  function neverEmpty(node2) {
    return [node2];
  }
  function elementEmptier(element2) {
    var children = removeEmpty(element2.children);
    if (children.length === 0 && !ast2.isVoidElement(element2)) {
      return [];
    } else {
      return [ast2.elementWithTag(element2.tag, children)];
    }
  }
  function textEmptier(node2) {
    if (node2.value.length === 0) {
      return [];
    } else {
      return [node2];
    }
  }
  simplify_1 = simplify;
  return simplify_1;
}
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html;
  hasRequiredHtml = 1;
  var ast2 = requireAst();
  html.freshElement = ast2.freshElement;
  html.nonFreshElement = ast2.nonFreshElement;
  html.elementWithTag = ast2.elementWithTag;
  html.text = ast2.text;
  html.forceWrite = ast2.forceWrite;
  html.simplify = requireSimplify();
  function write(writer2, nodes2) {
    nodes2.forEach(function(node2) {
      writeNode(writer2, node2);
    });
  }
  function writeNode(writer2, node2) {
    toStrings[node2.type](writer2, node2);
  }
  var toStrings = {
    element: generateElementString,
    text: generateTextString,
    forceWrite: function() {
    }
  };
  function generateElementString(writer2, node2) {
    if (ast2.isVoidElement(node2)) {
      writer2.selfClosing(node2.tag.tagName, node2.tag.attributes);
    } else {
      writer2.open(node2.tag.tagName, node2.tag.attributes);
      write(writer2, node2.children);
      writer2.close(node2.tag.tagName);
    }
  }
  function generateTextString(writer2, node2) {
    writer2.text(node2.value);
  }
  html.write = write;
  return html;
}
var hasRequiredHtmlPaths;
function requireHtmlPaths() {
  if (hasRequiredHtmlPaths) return htmlPaths;
  hasRequiredHtmlPaths = 1;
  var _ = requireUnderscoreNode();
  var html2 = requireHtml();
  htmlPaths.topLevelElement = topLevelElement;
  htmlPaths.elements = elements;
  htmlPaths.element = element2;
  function topLevelElement(tagName, attributes) {
    return elements([element2(tagName, attributes, { fresh: true })]);
  }
  function elements(elementStyles) {
    return new HtmlPath(elementStyles.map(function(elementStyle) {
      if (_.isString(elementStyle)) {
        return element2(elementStyle);
      } else {
        return elementStyle;
      }
    }));
  }
  function HtmlPath(elements2) {
    this._elements = elements2;
  }
  HtmlPath.prototype.wrap = function wrap(children) {
    var result = children();
    for (var index = this._elements.length - 1; index >= 0; index--) {
      result = this._elements[index].wrapNodes(result);
    }
    return result;
  };
  function element2(tagName, attributes, options) {
    options = options || {};
    return new Element2(tagName, attributes, options);
  }
  function Element2(tagName, attributes, options) {
    var tagNames = {};
    if (_.isArray(tagName)) {
      tagName.forEach(function(tagName2) {
        tagNames[tagName2] = true;
      });
      tagName = tagName[0];
    } else {
      tagNames[tagName] = true;
    }
    this.tagName = tagName;
    this.tagNames = tagNames;
    this.attributes = attributes || {};
    this.fresh = options.fresh;
    this.separator = options.separator;
  }
  Element2.prototype.matchesElement = function(element3) {
    return this.tagNames[element3.tagName] && _.isEqual(this.attributes || {}, element3.attributes || {});
  };
  Element2.prototype.wrap = function wrap(generateNodes) {
    return this.wrapNodes(generateNodes());
  };
  Element2.prototype.wrapNodes = function wrapNodes(nodes2) {
    return [html2.elementWithTag(this, nodes2)];
  };
  htmlPaths.empty = elements([]);
  htmlPaths.ignore = {
    wrap: function() {
      return [];
    }
  };
  return htmlPaths;
}
var images = {};
var hasRequiredImages;
function requireImages() {
  if (hasRequiredImages) return images;
  hasRequiredImages = 1;
  (function(exports$1) {
    var _ = requireUnderscoreNode();
    var promises2 = requirePromises();
    var Html = requireHtml();
    exports$1.imgElement = imgElement;
    function imgElement(func) {
      return function(element2, messages2) {
        return promises2.when(func(element2)).then(function(result) {
          var attributes = {};
          if (element2.altText) {
            attributes.alt = element2.altText;
          }
          _.extend(attributes, result);
          return [Html.freshElement("img", attributes)];
        });
      };
    }
    exports$1.inline = exports$1.imgElement;
    exports$1.dataUri = imgElement(function(element2) {
      return element2.readAsBase64String().then(function(imageBuffer) {
        return {
          src: "data:" + element2.contentType + ";base64," + imageBuffer
        };
      });
    });
  })(images);
  return images;
}
var writers$1 = {};
var htmlWriter = {};
var hasRequiredHtmlWriter;
function requireHtmlWriter() {
  if (hasRequiredHtmlWriter) return htmlWriter;
  hasRequiredHtmlWriter = 1;
  var _ = requireUnderscoreNode();
  htmlWriter.writer = writer2;
  function writer2(options) {
    options = options || {};
    if (options.prettyPrint) {
      return prettyWriter();
    } else {
      return simpleWriter();
    }
  }
  var indentedElements = {
    div: true,
    p: true,
    ul: true,
    li: true
  };
  function prettyWriter() {
    var indentationLevel = 0;
    var indentation = "  ";
    var stack = [];
    var start = true;
    var inText = false;
    var writer3 = simpleWriter();
    function open(tagName, attributes) {
      if (indentedElements[tagName]) {
        indent();
      }
      stack.push(tagName);
      writer3.open(tagName, attributes);
      if (indentedElements[tagName]) {
        indentationLevel++;
      }
      start = false;
    }
    function close(tagName) {
      if (indentedElements[tagName]) {
        indentationLevel--;
        indent();
      }
      stack.pop();
      writer3.close(tagName);
    }
    function text(value) {
      startText();
      var text2 = isInPre() ? value : value.replace("\n", "\n" + indentation);
      writer3.text(text2);
    }
    function selfClosing(tagName, attributes) {
      indent();
      writer3.selfClosing(tagName, attributes);
    }
    function insideIndentedElement() {
      return stack.length === 0 || indentedElements[stack[stack.length - 1]];
    }
    function startText() {
      if (!inText) {
        indent();
        inText = true;
      }
    }
    function indent() {
      inText = false;
      if (!start && insideIndentedElement() && !isInPre()) {
        writer3._append("\n");
        for (var i = 0; i < indentationLevel; i++) {
          writer3._append(indentation);
        }
      }
    }
    function isInPre() {
      return _.some(stack, function(tagName) {
        return tagName === "pre";
      });
    }
    return {
      asString: writer3.asString,
      open,
      close,
      text,
      selfClosing
    };
  }
  function simpleWriter() {
    var fragments = [];
    function open(tagName, attributes) {
      var attributeString = generateAttributeString(attributes);
      fragments.push("<" + tagName + attributeString + ">");
    }
    function close(tagName) {
      fragments.push("</" + tagName + ">");
    }
    function selfClosing(tagName, attributes) {
      var attributeString = generateAttributeString(attributes);
      fragments.push("<" + tagName + attributeString + " />");
    }
    function generateAttributeString(attributes) {
      return _.map(attributes, function(value, key) {
        return " " + key + '="' + escapeHtmlAttribute(value) + '"';
      }).join("");
    }
    function text(value) {
      fragments.push(escapeHtmlText(value));
    }
    function append(html2) {
      fragments.push(html2);
    }
    function asString() {
      return fragments.join("");
    }
    return {
      asString,
      open,
      close,
      text,
      selfClosing,
      _append: append
    };
  }
  function escapeHtmlText(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function escapeHtmlAttribute(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  return htmlWriter;
}
var markdownWriter = {};
var hasRequiredMarkdownWriter;
function requireMarkdownWriter() {
  if (hasRequiredMarkdownWriter) return markdownWriter;
  hasRequiredMarkdownWriter = 1;
  var _ = requireUnderscoreNode();
  function symmetricMarkdownElement(end) {
    return markdownElement(end, end);
  }
  function markdownElement(start, end) {
    return function() {
      return { start, end };
    };
  }
  function markdownLink(attributes) {
    var href = attributes.href || "";
    if (href) {
      return {
        start: "[",
        end: "](" + href + ")",
        anchorPosition: "before"
      };
    } else {
      return {};
    }
  }
  function markdownImage(attributes) {
    var src = attributes.src || "";
    var altText = attributes.alt || "";
    if (src || altText) {
      return { start: "![" + altText + "](" + src + ")" };
    } else {
      return {};
    }
  }
  function markdownList(options) {
    return function(attributes, list) {
      return {
        start: list ? "\n" : "",
        end: list ? "" : "\n",
        list: {
          isOrdered: options.isOrdered,
          indent: list ? list.indent + 1 : 0,
          count: 0
        }
      };
    };
  }
  function markdownListItem(attributes, list, listItem) {
    list = list || { indent: 0, isOrdered: false, count: 0 };
    list.count++;
    listItem.hasClosed = false;
    var bullet2 = list.isOrdered ? list.count + "." : "-";
    var start = repeatString("	", list.indent) + bullet2 + " ";
    return {
      start,
      end: function() {
        if (!listItem.hasClosed) {
          listItem.hasClosed = true;
          return "\n";
        }
      }
    };
  }
  var htmlToMarkdown = {
    "p": markdownElement("", "\n\n"),
    "br": markdownElement("", "  \n"),
    "ul": markdownList({ isOrdered: false }),
    "ol": markdownList({ isOrdered: true }),
    "li": markdownListItem,
    "strong": symmetricMarkdownElement("__"),
    "em": symmetricMarkdownElement("*"),
    "a": markdownLink,
    "img": markdownImage
  };
  (function() {
    for (var i = 1; i <= 6; i++) {
      htmlToMarkdown["h" + i] = markdownElement(repeatString("#", i) + " ", "\n\n");
    }
  })();
  function repeatString(value, count) {
    return new Array(count + 1).join(value);
  }
  function markdownWriter$1() {
    var fragments = [];
    var elementStack = [];
    var list = null;
    var listItem = {};
    function open(tagName, attributes) {
      attributes = attributes || {};
      var createElement = htmlToMarkdown[tagName] || function() {
        return {};
      };
      var element2 = createElement(attributes, list, listItem);
      elementStack.push({ end: element2.end, list });
      if (element2.list) {
        list = element2.list;
      }
      var anchorBeforeStart = element2.anchorPosition === "before";
      if (anchorBeforeStart) {
        writeAnchor(attributes);
      }
      fragments.push(element2.start || "");
      if (!anchorBeforeStart) {
        writeAnchor(attributes);
      }
    }
    function writeAnchor(attributes) {
      if (attributes.id) {
        fragments.push('<a id="' + attributes.id + '"></a>');
      }
    }
    function close(tagName) {
      var element2 = elementStack.pop();
      list = element2.list;
      var end = _.isFunction(element2.end) ? element2.end() : element2.end;
      fragments.push(end || "");
    }
    function selfClosing(tagName, attributes) {
      open(tagName, attributes);
      close();
    }
    function text(value) {
      fragments.push(escapeMarkdown(value));
    }
    function asString() {
      return fragments.join("");
    }
    return {
      asString,
      open,
      close,
      text,
      selfClosing
    };
  }
  markdownWriter.writer = markdownWriter$1;
  function escapeMarkdown(value) {
    return value.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
  }
  return markdownWriter;
}
var hasRequiredWriters$1;
function requireWriters$1() {
  if (hasRequiredWriters$1) return writers$1;
  hasRequiredWriters$1 = 1;
  var htmlWriter2 = requireHtmlWriter();
  var markdownWriter2 = requireMarkdownWriter();
  writers$1.writer = writer2;
  function writer2(options) {
    options = options || {};
    if (options.outputFormat === "markdown") {
      return markdownWriter2.writer();
    } else {
      return htmlWriter2.writer(options);
    }
  }
  return writers$1;
}
var hasRequiredDocumentToHtml;
function requireDocumentToHtml() {
  if (hasRequiredDocumentToHtml) return documentToHtml;
  hasRequiredDocumentToHtml = 1;
  var _ = requireUnderscoreNode();
  var promises2 = requirePromises();
  var documents2 = requireDocuments();
  var htmlPaths2 = requireHtmlPaths();
  var results2 = requireResults();
  var images2 = requireImages();
  var Html = requireHtml();
  var writers2 = requireWriters$1();
  documentToHtml.DocumentConverter = DocumentConverter;
  function DocumentConverter(options) {
    return {
      convertToHtml: function(element2) {
        var comments = _.indexBy(
          element2.type === documents2.types.document ? element2.comments : [],
          "commentId"
        );
        var conversion = new DocumentConversion(options, comments);
        return conversion.convertToHtml(element2);
      }
    };
  }
  function DocumentConversion(options, comments) {
    var noteNumber = 1;
    var noteReferences = [];
    var referencedComments = [];
    options = _.extend({ ignoreEmptyParagraphs: true }, options);
    var idPrefix = options.idPrefix === void 0 ? "" : options.idPrefix;
    var ignoreEmptyParagraphs = options.ignoreEmptyParagraphs;
    var defaultParagraphStyle = htmlPaths2.topLevelElement("p");
    var styleMap2 = options.styleMap || [];
    function convertToHtml(document2) {
      var messages2 = [];
      var html2 = elementToHtml(document2, messages2, {});
      var deferredNodes = [];
      walkHtml(html2, function(node2) {
        if (node2.type === "deferred") {
          deferredNodes.push(node2);
        }
      });
      var deferredValues = {};
      return promises2.mapSeries(deferredNodes, function(deferred) {
        return deferred.value().then(function(value) {
          deferredValues[deferred.id] = value;
        });
      }).then(function() {
        function replaceDeferred(nodes2) {
          return flatMap(nodes2, function(node2) {
            if (node2.type === "deferred") {
              return deferredValues[node2.id];
            } else if (node2.children) {
              return [
                _.extend({}, node2, {
                  children: replaceDeferred(node2.children)
                })
              ];
            } else {
              return [node2];
            }
          });
        }
        var writer2 = writers2.writer({
          prettyPrint: options.prettyPrint,
          outputFormat: options.outputFormat
        });
        Html.write(writer2, Html.simplify(replaceDeferred(html2)));
        return new results2.Result(writer2.asString(), messages2);
      });
    }
    function convertElements(elements, messages2, options2) {
      return flatMap(elements, function(element2) {
        return elementToHtml(element2, messages2, options2);
      });
    }
    function elementToHtml(element2, messages2, options2) {
      if (!options2) {
        throw new Error("options not set");
      }
      var handler = elementConverters[element2.type];
      if (handler) {
        return handler(element2, messages2, options2);
      } else {
        return [];
      }
    }
    function convertParagraph(element2, messages2, options2) {
      return htmlPathForParagraph(element2, messages2).wrap(function() {
        var content = convertElements(element2.children, messages2, options2);
        if (ignoreEmptyParagraphs) {
          return content;
        } else {
          return [Html.forceWrite].concat(content);
        }
      });
    }
    function htmlPathForParagraph(element2, messages2) {
      var style = findStyle(element2);
      if (style) {
        return style.to;
      } else {
        if (element2.styleId) {
          messages2.push(unrecognisedStyleWarning("paragraph", element2));
        }
        return defaultParagraphStyle;
      }
    }
    function convertRun(run, messages2, options2) {
      var nodes2 = function() {
        return convertElements(run.children, messages2, options2);
      };
      var paths = [];
      if (run.highlight !== null) {
        var path2 = findHtmlPath({ type: "highlight", color: run.highlight });
        if (path2) {
          paths.push(path2);
        }
      }
      if (run.isSmallCaps) {
        paths.push(findHtmlPathForRunProperty("smallCaps"));
      }
      if (run.isAllCaps) {
        paths.push(findHtmlPathForRunProperty("allCaps"));
      }
      if (run.isStrikethrough) {
        paths.push(findHtmlPathForRunProperty("strikethrough", "s"));
      }
      if (run.isUnderline) {
        paths.push(findHtmlPathForRunProperty("underline"));
      }
      if (run.verticalAlignment === documents2.verticalAlignment.subscript) {
        paths.push(htmlPaths2.element("sub", {}, { fresh: false }));
      }
      if (run.verticalAlignment === documents2.verticalAlignment.superscript) {
        paths.push(htmlPaths2.element("sup", {}, { fresh: false }));
      }
      if (run.isItalic) {
        paths.push(findHtmlPathForRunProperty("italic", "em"));
      }
      if (run.isBold) {
        paths.push(findHtmlPathForRunProperty("bold", "strong"));
      }
      var stylePath = htmlPaths2.empty;
      var style = findStyle(run);
      if (style) {
        stylePath = style.to;
      } else if (run.styleId) {
        messages2.push(unrecognisedStyleWarning("run", run));
      }
      paths.push(stylePath);
      paths.forEach(function(path3) {
        nodes2 = path3.wrap.bind(path3, nodes2);
      });
      return nodes2();
    }
    function findHtmlPathForRunProperty(elementType, defaultTagName) {
      var path2 = findHtmlPath({ type: elementType });
      if (path2) {
        return path2;
      } else if (defaultTagName) {
        return htmlPaths2.element(defaultTagName, {}, { fresh: false });
      } else {
        return htmlPaths2.empty;
      }
    }
    function findHtmlPath(element2, defaultPath) {
      var style = findStyle(element2);
      return style ? style.to : defaultPath;
    }
    function findStyle(element2) {
      for (var i = 0; i < styleMap2.length; i++) {
        if (styleMap2[i].from.matches(element2)) {
          return styleMap2[i];
        }
      }
    }
    function recoveringConvertImage(convertImage) {
      return function(image2, messages2) {
        return promises2.attempt(function() {
          return convertImage(image2, messages2);
        }).caught(function(error) {
          messages2.push(results2.error(error));
          return [];
        });
      };
    }
    function noteHtmlId(note) {
      return referentHtmlId(note.noteType, note.noteId);
    }
    function noteRefHtmlId(note) {
      return referenceHtmlId(note.noteType, note.noteId);
    }
    function referentHtmlId(referenceType, referenceId) {
      return htmlId(referenceType + "-" + referenceId);
    }
    function referenceHtmlId(referenceType, referenceId) {
      return htmlId(referenceType + "-ref-" + referenceId);
    }
    function htmlId(suffix) {
      return idPrefix + suffix;
    }
    var defaultTablePath = htmlPaths2.elements([
      htmlPaths2.element("table", {}, { fresh: true })
    ]);
    function convertTable(element2, messages2, options2) {
      return findHtmlPath(element2, defaultTablePath).wrap(function() {
        return convertTableChildren(element2, messages2, options2);
      });
    }
    function convertTableChildren(element2, messages2, options2) {
      var bodyIndex = _.findIndex(element2.children, function(child) {
        return !child.type === documents2.types.tableRow || !child.isHeader;
      });
      if (bodyIndex === -1) {
        bodyIndex = element2.children.length;
      }
      var children;
      if (bodyIndex === 0) {
        children = convertElements(
          element2.children,
          messages2,
          _.extend({}, options2, { isTableHeader: false })
        );
      } else {
        var headRows = convertElements(
          element2.children.slice(0, bodyIndex),
          messages2,
          _.extend({}, options2, { isTableHeader: true })
        );
        var bodyRows = convertElements(
          element2.children.slice(bodyIndex),
          messages2,
          _.extend({}, options2, { isTableHeader: false })
        );
        children = [
          Html.freshElement("thead", {}, headRows),
          Html.freshElement("tbody", {}, bodyRows)
        ];
      }
      return [Html.forceWrite].concat(children);
    }
    function convertTableRow(element2, messages2, options2) {
      var children = convertElements(element2.children, messages2, options2);
      return [
        Html.freshElement("tr", {}, [Html.forceWrite].concat(children))
      ];
    }
    function convertTableCell(element2, messages2, options2) {
      var tagName = options2.isTableHeader ? "th" : "td";
      var children = convertElements(element2.children, messages2, options2);
      var attributes = {};
      if (element2.colSpan !== 1) {
        attributes.colspan = element2.colSpan.toString();
      }
      if (element2.rowSpan !== 1) {
        attributes.rowspan = element2.rowSpan.toString();
      }
      return [
        Html.freshElement(tagName, attributes, [Html.forceWrite].concat(children))
      ];
    }
    function convertCommentReference(reference, messages2, options2) {
      return findHtmlPath(reference, htmlPaths2.ignore).wrap(function() {
        var comment = comments[reference.commentId];
        var count = referencedComments.length + 1;
        var label = "[" + commentAuthorLabel(comment) + count + "]";
        referencedComments.push({ label, comment });
        return [
          Html.freshElement("a", {
            href: "#" + referentHtmlId("comment", reference.commentId),
            id: referenceHtmlId("comment", reference.commentId)
          }, [Html.text(label)])
        ];
      });
    }
    function convertComment(referencedComment, messages2, options2) {
      var label = referencedComment.label;
      var comment = referencedComment.comment;
      var body = convertElements(comment.body, messages2, options2).concat([
        Html.nonFreshElement("p", {}, [
          Html.text(" "),
          Html.freshElement("a", { "href": "#" + referenceHtmlId("comment", comment.commentId) }, [
            Html.text("â†‘")
          ])
        ])
      ]);
      return [
        Html.freshElement(
          "dt",
          { "id": referentHtmlId("comment", comment.commentId) },
          [Html.text("Comment " + label)]
        ),
        Html.freshElement("dd", {}, body)
      ];
    }
    function convertBreak(element2, messages2, options2) {
      return htmlPathForBreak(element2).wrap(function() {
        return [];
      });
    }
    function htmlPathForBreak(element2) {
      var style = findStyle(element2);
      if (style) {
        return style.to;
      } else if (element2.breakType === "line") {
        return htmlPaths2.topLevelElement("br");
      } else {
        return htmlPaths2.empty;
      }
    }
    var elementConverters = {
      "document": function(document2, messages2, options2) {
        var children = convertElements(document2.children, messages2, options2);
        var notes = noteReferences.map(function(noteReference) {
          return document2.notes.resolve(noteReference);
        });
        var notesNodes = convertElements(notes, messages2, options2);
        return children.concat([
          Html.freshElement("ol", {}, notesNodes),
          Html.freshElement("dl", {}, flatMap(referencedComments, function(referencedComment) {
            return convertComment(referencedComment, messages2, options2);
          }))
        ]);
      },
      "paragraph": convertParagraph,
      "run": convertRun,
      "text": function(element2, messages2, options2) {
        return [Html.text(element2.value)];
      },
      "tab": function(element2, messages2, options2) {
        return [Html.text("	")];
      },
      "hyperlink": function(element2, messages2, options2) {
        var href = element2.anchor ? "#" + htmlId(element2.anchor) : element2.href;
        var attributes = { href };
        if (element2.targetFrame != null) {
          attributes.target = element2.targetFrame;
        }
        var children = convertElements(element2.children, messages2, options2);
        return [Html.nonFreshElement("a", attributes, children)];
      },
      "checkbox": function(element2) {
        var attributes = { type: "checkbox" };
        if (element2.checked) {
          attributes["checked"] = "checked";
        }
        return [Html.freshElement("input", attributes)];
      },
      "bookmarkStart": function(element2, messages2, options2) {
        var anchor = Html.freshElement("a", {
          id: htmlId(element2.name)
        }, [Html.forceWrite]);
        return [anchor];
      },
      "noteReference": function(element2, messages2, options2) {
        noteReferences.push(element2);
        var anchor = Html.freshElement("a", {
          href: "#" + noteHtmlId(element2),
          id: noteRefHtmlId(element2)
        }, [Html.text("[" + noteNumber++ + "]")]);
        return [Html.freshElement("sup", {}, [anchor])];
      },
      "note": function(element2, messages2, options2) {
        var children = convertElements(element2.body, messages2, options2);
        var backLink = Html.elementWithTag(htmlPaths2.element("p", {}, { fresh: false }), [
          Html.text(" "),
          Html.freshElement("a", { href: "#" + noteRefHtmlId(element2) }, [Html.text("â†‘")])
        ]);
        var body = children.concat([backLink]);
        return Html.freshElement("li", { id: noteHtmlId(element2) }, body);
      },
      "commentReference": convertCommentReference,
      "comment": convertComment,
      "image": deferredConversion(recoveringConvertImage(options.convertImage || images2.dataUri)),
      "table": convertTable,
      "tableRow": convertTableRow,
      "tableCell": convertTableCell,
      "break": convertBreak
    };
    return {
      convertToHtml
    };
  }
  var deferredId = 1;
  function deferredConversion(func) {
    return function(element2, messages2, options) {
      return [
        {
          type: "deferred",
          id: deferredId++,
          value: function() {
            return func(element2, messages2, options);
          }
        }
      ];
    };
  }
  function unrecognisedStyleWarning(type2, element2) {
    return results2.warning(
      "Unrecognised " + type2 + " style: '" + element2.styleName + "' (Style ID: " + element2.styleId + ")"
    );
  }
  function flatMap(values, func) {
    return _.flatten(values.map(func), true);
  }
  function walkHtml(nodes2, callback) {
    nodes2.forEach(function(node2) {
      callback(node2);
      if (node2.children) {
        walkHtml(node2.children, callback);
      }
    });
  }
  var commentAuthorLabel = documentToHtml.commentAuthorLabel = function commentAuthorLabel2(comment) {
    return comment.authorInitials || "";
  };
  return documentToHtml;
}
var rawText = {};
var hasRequiredRawText;
function requireRawText() {
  if (hasRequiredRawText) return rawText;
  hasRequiredRawText = 1;
  var documents2 = requireDocuments();
  function convertElementToRawText(element2) {
    if (element2.type === "text") {
      return element2.value;
    } else if (element2.type === documents2.types.tab) {
      return "	";
    } else {
      var tail = element2.type === "paragraph" ? "\n\n" : "";
      return (element2.children || []).map(convertElementToRawText).join("") + tail;
    }
  }
  rawText.convertElementToRawText = convertElementToRawText;
  return rawText;
}
var styleReader = {};
var lop = {};
var parser$1 = {};
var TokenIterator = { exports: {} };
var hasRequiredTokenIterator;
function requireTokenIterator() {
  if (hasRequiredTokenIterator) return TokenIterator.exports;
  hasRequiredTokenIterator = 1;
  var TokenIterator$1 = TokenIterator.exports = function(tokens, startIndex) {
    this._tokens = tokens;
    this._startIndex = startIndex || 0;
  };
  TokenIterator$1.prototype.head = function() {
    return this._tokens[this._startIndex];
  };
  TokenIterator$1.prototype.tail = function(startIndex) {
    return new TokenIterator$1(this._tokens, this._startIndex + 1);
  };
  TokenIterator$1.prototype.toArray = function() {
    return this._tokens.slice(this._startIndex);
  };
  TokenIterator$1.prototype.end = function() {
    return this._tokens[this._tokens.length - 1];
  };
  TokenIterator$1.prototype.to = function(end) {
    var start = this.head().source;
    var endToken = end.head() || end.end();
    return start.to(endToken.source);
  };
  return TokenIterator.exports;
}
var hasRequiredParser$2;
function requireParser$2() {
  if (hasRequiredParser$2) return parser$1;
  hasRequiredParser$2 = 1;
  var TokenIterator2 = requireTokenIterator();
  parser$1.Parser = function(options) {
    var parseTokens = function(parser2, tokens) {
      return parser2(new TokenIterator2(tokens));
    };
    return {
      parseTokens
    };
  };
  return parser$1;
}
var rules = {};
var option = {};
var hasRequiredOption;
function requireOption() {
  if (hasRequiredOption) return option;
  hasRequiredOption = 1;
  (function(exports$1) {
    exports$1.none = /* @__PURE__ */ Object.create({
      value: function() {
        throw new Error("Called value on none");
      },
      isNone: function() {
        return true;
      },
      isSome: function() {
        return false;
      },
      map: function() {
        return exports$1.none;
      },
      flatMap: function() {
        return exports$1.none;
      },
      filter: function() {
        return exports$1.none;
      },
      toArray: function() {
        return [];
      },
      orElse: callOrReturn,
      valueOrElse: callOrReturn
    });
    function callOrReturn(value) {
      if (typeof value == "function") {
        return value();
      } else {
        return value;
      }
    }
    exports$1.some = function(value) {
      return new Some(value);
    };
    var Some = function(value) {
      this._value = value;
    };
    Some.prototype.value = function() {
      return this._value;
    };
    Some.prototype.isNone = function() {
      return false;
    };
    Some.prototype.isSome = function() {
      return true;
    };
    Some.prototype.map = function(func) {
      return new Some(func(this._value));
    };
    Some.prototype.flatMap = function(func) {
      return func(this._value);
    };
    Some.prototype.filter = function(predicate) {
      return predicate(this._value) ? this : exports$1.none;
    };
    Some.prototype.toArray = function() {
      return [this._value];
    };
    Some.prototype.orElse = function(value) {
      return this;
    };
    Some.prototype.valueOrElse = function(value) {
      return this._value;
    };
    exports$1.isOption = function(value) {
      return value === exports$1.none || value instanceof Some;
    };
    exports$1.fromNullable = function(value) {
      if (value == null) {
        return exports$1.none;
      }
      return new Some(value);
    };
  })(option);
  return option;
}
var parsingResults;
var hasRequiredParsingResults;
function requireParsingResults() {
  if (hasRequiredParsingResults) return parsingResults;
  hasRequiredParsingResults = 1;
  parsingResults = {
    failure: function(errors2, remaining) {
      if (errors2.length < 1) {
        throw new Error("Failure must have errors");
      }
      return new Result({
        status: "failure",
        remaining,
        errors: errors2
      });
    },
    error: function(errors2, remaining) {
      if (errors2.length < 1) {
        throw new Error("Failure must have errors");
      }
      return new Result({
        status: "error",
        remaining,
        errors: errors2
      });
    },
    success: function(value, remaining, source) {
      return new Result({
        status: "success",
        value,
        source,
        remaining,
        errors: []
      });
    },
    cut: function(remaining) {
      return new Result({
        status: "cut",
        remaining,
        errors: []
      });
    }
  };
  var Result = function(options) {
    this._value = options.value;
    this._status = options.status;
    this._hasValue = options.value !== void 0;
    this._remaining = options.remaining;
    this._source = options.source;
    this._errors = options.errors;
  };
  Result.prototype.map = function(func) {
    if (this._hasValue) {
      return new Result({
        value: func(this._value, this._source),
        status: this._status,
        remaining: this._remaining,
        source: this._source,
        errors: this._errors
      });
    } else {
      return this;
    }
  };
  Result.prototype.changeRemaining = function(remaining) {
    return new Result({
      value: this._value,
      status: this._status,
      remaining,
      source: this._source,
      errors: this._errors
    });
  };
  Result.prototype.isSuccess = function() {
    return this._status === "success" || this._status === "cut";
  };
  Result.prototype.isFailure = function() {
    return this._status === "failure";
  };
  Result.prototype.isError = function() {
    return this._status === "error";
  };
  Result.prototype.isCut = function() {
    return this._status === "cut";
  };
  Result.prototype.value = function() {
    return this._value;
  };
  Result.prototype.remaining = function() {
    return this._remaining;
  };
  Result.prototype.source = function() {
    return this._source;
  };
  Result.prototype.errors = function() {
    return this._errors;
  };
  return parsingResults;
}
var errors$1 = {};
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  errors$1.error = function(options) {
    return new Error2(options);
  };
  var Error2 = function(options) {
    this.expected = options.expected;
    this.actual = options.actual;
    this._location = options.location;
  };
  Error2.prototype.describe = function() {
    var locationDescription = this._location ? this._location.describe() + ":\n" : "";
    return locationDescription + "Expected " + this.expected + "\nbut got " + this.actual;
  };
  Error2.prototype.lineNumber = function() {
    return this._location.lineNumber();
  };
  Error2.prototype.characterNumber = function() {
    return this._location.characterNumber();
  };
  return errors$1;
}
var lazyIterators = {};
var hasRequiredLazyIterators;
function requireLazyIterators() {
  if (hasRequiredLazyIterators) return lazyIterators;
  hasRequiredLazyIterators = 1;
  lazyIterators.fromArray = function(array) {
    var index = 0;
    var hasNext = function() {
      return index < array.length;
    };
    return new LazyIterator({
      hasNext,
      next: function() {
        if (!hasNext()) {
          throw new Error("No more elements");
        } else {
          return array[index++];
        }
      }
    });
  };
  var LazyIterator = function(iterator) {
    this._iterator = iterator;
  };
  LazyIterator.prototype.map = function(func) {
    var iterator = this._iterator;
    return new LazyIterator({
      hasNext: function() {
        return iterator.hasNext();
      },
      next: function() {
        return func(iterator.next());
      }
    });
  };
  LazyIterator.prototype.filter = function(condition) {
    var iterator = this._iterator;
    var moved = false;
    var hasNext = false;
    var next;
    var moveIfNecessary = function() {
      if (moved) {
        return;
      }
      moved = true;
      hasNext = false;
      while (iterator.hasNext() && !hasNext) {
        next = iterator.next();
        hasNext = condition(next);
      }
    };
    return new LazyIterator({
      hasNext: function() {
        moveIfNecessary();
        return hasNext;
      },
      next: function() {
        moveIfNecessary();
        var toReturn = next;
        moved = false;
        return toReturn;
      }
    });
  };
  LazyIterator.prototype.first = function() {
    var iterator = this._iterator;
    if (this._iterator.hasNext()) {
      return iterator.next();
    } else {
      return null;
    }
  };
  LazyIterator.prototype.toArray = function() {
    var result = [];
    while (this._iterator.hasNext()) {
      result.push(this._iterator.next());
    }
    return result;
  };
  return lazyIterators;
}
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules) return rules;
  hasRequiredRules = 1;
  (function(exports$1) {
    var _ = requireUnderscoreNode();
    var options = requireOption();
    var results2 = requireParsingResults();
    var errors2 = requireErrors$1();
    var lazyIterators2 = requireLazyIterators();
    exports$1.token = function(tokenType, value) {
      var matchValue = value !== void 0;
      return function(input) {
        var token = input.head();
        if (token && token.name === tokenType && (!matchValue || token.value === value)) {
          return results2.success(token.value, input.tail(), token.source);
        } else {
          var expected = describeToken({ name: tokenType, value });
          return describeTokenMismatch(input, expected);
        }
      };
    };
    exports$1.tokenOfType = function(tokenType) {
      return exports$1.token(tokenType);
    };
    exports$1.firstOf = function(name, parsers) {
      if (!_.isArray(parsers)) {
        parsers = Array.prototype.slice.call(arguments, 1);
      }
      return function(input) {
        return lazyIterators2.fromArray(parsers).map(function(parser2) {
          return parser2(input);
        }).filter(function(result) {
          return result.isSuccess() || result.isError();
        }).first() || describeTokenMismatch(input, name);
      };
    };
    exports$1.then = function(parser2, func) {
      return function(input) {
        var result = parser2(input);
        if (!result.map) {
          console.log(result);
        }
        return result.map(func);
      };
    };
    exports$1.sequence = function() {
      var parsers = Array.prototype.slice.call(arguments, 0);
      var rule = function(input) {
        var result = _.foldl(parsers, function(memo, parser2) {
          var result2 = memo.result;
          var hasCut = memo.hasCut;
          if (!result2.isSuccess()) {
            return { result: result2, hasCut };
          }
          var subResult = parser2(result2.remaining());
          if (subResult.isCut()) {
            return { result: result2, hasCut: true };
          } else if (subResult.isSuccess()) {
            var values;
            if (parser2.isCaptured) {
              values = result2.value().withValue(parser2, subResult.value());
            } else {
              values = result2.value();
            }
            var remaining = subResult.remaining();
            var source2 = input.to(remaining);
            return {
              result: results2.success(values, remaining, source2),
              hasCut
            };
          } else if (hasCut) {
            return { result: results2.error(subResult.errors(), subResult.remaining()), hasCut };
          } else {
            return { result: subResult, hasCut };
          }
        }, { result: results2.success(new SequenceValues(), input), hasCut: false }).result;
        var source = input.to(result.remaining());
        return result.map(function(values) {
          return values.withValue(exports$1.sequence.source, source);
        });
      };
      rule.head = function() {
        var firstCapture = _.find(parsers, isCapturedRule);
        return exports$1.then(
          rule,
          exports$1.sequence.extract(firstCapture)
        );
      };
      rule.map = function(func) {
        return exports$1.then(
          rule,
          function(result) {
            return func.apply(this, result.toArray());
          }
        );
      };
      function isCapturedRule(subRule) {
        return subRule.isCaptured;
      }
      return rule;
    };
    var SequenceValues = function(values, valuesArray) {
      this._values = values || {};
      this._valuesArray = valuesArray || [];
    };
    SequenceValues.prototype.withValue = function(rule, value) {
      if (rule.captureName && rule.captureName in this._values) {
        throw new Error('Cannot add second value for capture "' + rule.captureName + '"');
      } else {
        var newValues = _.clone(this._values);
        newValues[rule.captureName] = value;
        var newValuesArray = this._valuesArray.concat([value]);
        return new SequenceValues(newValues, newValuesArray);
      }
    };
    SequenceValues.prototype.get = function(rule) {
      if (rule.captureName in this._values) {
        return this._values[rule.captureName];
      } else {
        throw new Error('No value for capture "' + rule.captureName + '"');
      }
    };
    SequenceValues.prototype.toArray = function() {
      return this._valuesArray;
    };
    exports$1.sequence.capture = function(rule, name) {
      var captureRule = function() {
        return rule.apply(this, arguments);
      };
      captureRule.captureName = name;
      captureRule.isCaptured = true;
      return captureRule;
    };
    exports$1.sequence.extract = function(rule) {
      return function(result) {
        return result.get(rule);
      };
    };
    exports$1.sequence.applyValues = function(func) {
      var rules2 = Array.prototype.slice.call(arguments, 1);
      return function(result) {
        var values = rules2.map(function(rule) {
          return result.get(rule);
        });
        return func.apply(this, values);
      };
    };
    exports$1.sequence.source = {
      captureName: "â˜ƒsourceâ˜ƒ"
    };
    exports$1.sequence.cut = function() {
      return function(input) {
        return results2.cut(input);
      };
    };
    exports$1.optional = function(rule) {
      return function(input) {
        var result = rule(input);
        if (result.isSuccess()) {
          return result.map(options.some);
        } else if (result.isFailure()) {
          return results2.success(options.none, input);
        } else {
          return result;
        }
      };
    };
    exports$1.zeroOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, false);
    };
    exports$1.oneOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, true);
    };
    var zeroOrMore = exports$1.zeroOrMore = function(rule) {
      return function(input) {
        var values = [];
        var result;
        while ((result = rule(input)) && result.isSuccess()) {
          input = result.remaining();
          values.push(result.value());
        }
        if (result.isError()) {
          return result;
        } else {
          return results2.success(values, input);
        }
      };
    };
    exports$1.oneOrMore = function(rule) {
      return exports$1.oneOrMoreWithSeparator(rule, noOpRule);
    };
    function noOpRule(input) {
      return results2.success(null, input);
    }
    var repeatedWithSeparator = function(rule, separator, isOneOrMore) {
      return function(input) {
        var result = rule(input);
        if (result.isSuccess()) {
          var mainRule = exports$1.sequence.capture(rule, "main");
          var remainingRule = zeroOrMore(exports$1.then(
            exports$1.sequence(separator, mainRule),
            exports$1.sequence.extract(mainRule)
          ));
          var remainingResult = remainingRule(result.remaining());
          return results2.success([result.value()].concat(remainingResult.value()), remainingResult.remaining());
        } else if (isOneOrMore || result.isError()) {
          return result;
        } else {
          return results2.success([], input);
        }
      };
    };
    exports$1.leftAssociative = function(leftRule, rightRule, func) {
      var rights;
      if (func) {
        rights = [{ func, rule: rightRule }];
      } else {
        rights = rightRule;
      }
      rights = rights.map(function(right) {
        return exports$1.then(right.rule, function(rightValue) {
          return function(leftValue, source) {
            return right.func(leftValue, rightValue, source);
          };
        });
      });
      var repeatedRule = exports$1.firstOf.apply(null, ["rules"].concat(rights));
      return function(input) {
        var start = input;
        var leftResult = leftRule(input);
        if (!leftResult.isSuccess()) {
          return leftResult;
        }
        var repeatedResult = repeatedRule(leftResult.remaining());
        while (repeatedResult.isSuccess()) {
          var remaining = repeatedResult.remaining();
          var source = start.to(repeatedResult.remaining());
          var right = repeatedResult.value();
          leftResult = results2.success(
            right(leftResult.value(), source),
            remaining,
            source
          );
          repeatedResult = repeatedRule(leftResult.remaining());
        }
        if (repeatedResult.isError()) {
          return repeatedResult;
        }
        return leftResult;
      };
    };
    exports$1.leftAssociative.firstOf = function() {
      return Array.prototype.slice.call(arguments, 0);
    };
    exports$1.nonConsuming = function(rule) {
      return function(input) {
        return rule(input).changeRemaining(input);
      };
    };
    var describeToken = function(token) {
      if (token.value) {
        return token.name + ' "' + token.value + '"';
      } else {
        return token.name;
      }
    };
    function describeTokenMismatch(input, expected) {
      var error;
      var token = input.head();
      if (token) {
        error = errors2.error({
          expected,
          actual: describeToken(token),
          location: token.source
        });
      } else {
        error = errors2.error({
          expected,
          actual: "end of tokens"
        });
      }
      return results2.failure([error], input);
    }
  })(rules);
  return rules;
}
var StringSource = { exports: {} };
var hasRequiredStringSource;
function requireStringSource() {
  if (hasRequiredStringSource) return StringSource.exports;
  hasRequiredStringSource = 1;
  StringSource.exports = function(string, description) {
    var self2 = {
      asString: function() {
        return string;
      },
      range: function(startIndex, endIndex) {
        return new StringSourceRange(string, description, startIndex, endIndex);
      }
    };
    return self2;
  };
  var StringSourceRange = function(string, description, startIndex, endIndex) {
    this._string = string;
    this._description = description;
    this._startIndex = startIndex;
    this._endIndex = endIndex;
  };
  StringSourceRange.prototype.to = function(otherRange) {
    return new StringSourceRange(this._string, this._description, this._startIndex, otherRange._endIndex);
  };
  StringSourceRange.prototype.describe = function() {
    var position = this._position();
    var description = this._description ? this._description + "\n" : "";
    return description + "Line number: " + position.lineNumber + "\nCharacter number: " + position.characterNumber;
  };
  StringSourceRange.prototype.lineNumber = function() {
    return this._position().lineNumber;
  };
  StringSourceRange.prototype.characterNumber = function() {
    return this._position().characterNumber;
  };
  StringSourceRange.prototype._position = function() {
    var self2 = this;
    var index = 0;
    var nextNewLine = function() {
      return self2._string.indexOf("\n", index);
    };
    var lineNumber = 1;
    while (nextNewLine() !== -1 && nextNewLine() < this._startIndex) {
      index = nextNewLine() + 1;
      lineNumber += 1;
    }
    var characterNumber = this._startIndex - index + 1;
    return { lineNumber, characterNumber };
  };
  return StringSource.exports;
}
var Token;
var hasRequiredToken;
function requireToken() {
  if (hasRequiredToken) return Token;
  hasRequiredToken = 1;
  Token = function(name, value, source) {
    this.name = name;
    this.value = value;
    if (source) {
      this.source = source;
    }
  };
  return Token;
}
var bottomUp = {};
var hasRequiredBottomUp;
function requireBottomUp() {
  if (hasRequiredBottomUp) return bottomUp;
  hasRequiredBottomUp = 1;
  (function(exports$1) {
    var rules2 = requireRules();
    var results2 = requireParsingResults();
    exports$1.parser = function(name, prefixRules, infixRuleBuilders) {
      var self2 = {
        rule,
        leftAssociative,
        rightAssociative
      };
      var infixRules = new InfixRules(infixRuleBuilders.map(createInfixRule));
      var prefixRule = rules2.firstOf(name, prefixRules);
      function createInfixRule(infixRuleBuilder) {
        return {
          name: infixRuleBuilder.name,
          rule: lazyRule(infixRuleBuilder.ruleBuilder.bind(null, self2))
        };
      }
      function rule() {
        return createRule(infixRules);
      }
      function leftAssociative(name2) {
        return createRule(infixRules.untilExclusive(name2));
      }
      function rightAssociative(name2) {
        return createRule(infixRules.untilInclusive(name2));
      }
      function createRule(infixRules2) {
        return apply.bind(null, infixRules2);
      }
      function apply(infixRules2, tokens) {
        var leftResult = prefixRule(tokens);
        if (leftResult.isSuccess()) {
          return infixRules2.apply(leftResult);
        } else {
          return leftResult;
        }
      }
      return self2;
    };
    function InfixRules(infixRules) {
      function untilExclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name)));
      }
      function untilInclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name) + 1));
      }
      function ruleNames() {
        return infixRules.map(function(rule) {
          return rule.name;
        });
      }
      function apply(leftResult) {
        var currentResult;
        var source;
        while (true) {
          currentResult = applyToTokens(leftResult.remaining());
          if (currentResult.isSuccess()) {
            source = leftResult.source().to(currentResult.source());
            leftResult = results2.success(
              currentResult.value()(leftResult.value(), source),
              currentResult.remaining(),
              source
            );
          } else if (currentResult.isFailure()) {
            return leftResult;
          } else {
            return currentResult;
          }
        }
      }
      function applyToTokens(tokens) {
        return rules2.firstOf("infix", infixRules.map(function(infix) {
          return infix.rule;
        }))(tokens);
      }
      return {
        apply,
        untilExclusive,
        untilInclusive
      };
    }
    exports$1.infix = function(name, ruleBuilder) {
      function map2(func) {
        return exports$1.infix(name, function(parser2) {
          var rule = ruleBuilder(parser2);
          return function(tokens) {
            var result = rule(tokens);
            return result.map(function(right) {
              return function(left, source) {
                return func(left, right, source);
              };
            });
          };
        });
      }
      return {
        name,
        ruleBuilder,
        map: map2
      };
    };
    var lazyRule = function(ruleBuilder) {
      var rule;
      return function(input) {
        if (!rule) {
          rule = ruleBuilder();
        }
        return rule(input);
      };
    };
  })(bottomUp);
  return bottomUp;
}
var regexTokeniser = {};
var hasRequiredRegexTokeniser;
function requireRegexTokeniser() {
  if (hasRequiredRegexTokeniser) return regexTokeniser;
  hasRequiredRegexTokeniser = 1;
  var Token2 = requireToken();
  var StringSource2 = requireStringSource();
  regexTokeniser.RegexTokeniser = RegexTokeniser;
  function RegexTokeniser(rules2) {
    rules2 = rules2.map(function(rule) {
      return {
        name: rule.name,
        regex: new RegExp(rule.regex.source, "g")
      };
    });
    function tokenise(input, description) {
      var source = new StringSource2(input, description);
      var index = 0;
      var tokens = [];
      while (index < input.length) {
        var result = readNextToken(input, index, source);
        index = result.endIndex;
        tokens.push(result.token);
      }
      tokens.push(endToken(input, source));
      return tokens;
    }
    function readNextToken(string, startIndex, source) {
      for (var i = 0; i < rules2.length; i++) {
        var regex = rules2[i].regex;
        regex.lastIndex = startIndex;
        var result = regex.exec(string);
        if (result) {
          var endIndex = startIndex + result[0].length;
          if (result.index === startIndex && endIndex > startIndex) {
            var value = result[1];
            var token = new Token2(
              rules2[i].name,
              value,
              source.range(startIndex, endIndex)
            );
            return { token, endIndex };
          }
        }
      }
      var endIndex = startIndex + 1;
      var token = new Token2(
        "unrecognisedCharacter",
        string.substring(startIndex, endIndex),
        source.range(startIndex, endIndex)
      );
      return { token, endIndex };
    }
    function endToken(input, source) {
      return new Token2(
        "end",
        null,
        source.range(input.length, input.length)
      );
    }
    return {
      tokenise
    };
  }
  return regexTokeniser;
}
var hasRequiredLop;
function requireLop() {
  if (hasRequiredLop) return lop;
  hasRequiredLop = 1;
  lop.Parser = requireParser$2().Parser;
  lop.rules = requireRules();
  lop.errors = requireErrors$1();
  lop.results = requireParsingResults();
  lop.StringSource = requireStringSource();
  lop.Token = requireToken();
  lop.bottomUp = requireBottomUp();
  lop.RegexTokeniser = requireRegexTokeniser().RegexTokeniser;
  lop.rule = function(ruleBuilder) {
    var rule;
    return function(input) {
      if (!rule) {
        rule = ruleBuilder();
      }
      return rule(input);
    };
  };
  return lop;
}
var documentMatchers = {};
var hasRequiredDocumentMatchers;
function requireDocumentMatchers() {
  if (hasRequiredDocumentMatchers) return documentMatchers;
  hasRequiredDocumentMatchers = 1;
  documentMatchers.paragraph = paragraph;
  documentMatchers.run = run;
  documentMatchers.table = table;
  documentMatchers.bold = new Matcher("bold");
  documentMatchers.italic = new Matcher("italic");
  documentMatchers.underline = new Matcher("underline");
  documentMatchers.strikethrough = new Matcher("strikethrough");
  documentMatchers.allCaps = new Matcher("allCaps");
  documentMatchers.smallCaps = new Matcher("smallCaps");
  documentMatchers.highlight = highlight;
  documentMatchers.commentReference = new Matcher("commentReference");
  documentMatchers.lineBreak = new BreakMatcher({ breakType: "line" });
  documentMatchers.pageBreak = new BreakMatcher({ breakType: "page" });
  documentMatchers.columnBreak = new BreakMatcher({ breakType: "column" });
  documentMatchers.equalTo = equalTo;
  documentMatchers.startsWith = startsWith;
  function paragraph(options) {
    return new Matcher("paragraph", options);
  }
  function run(options) {
    return new Matcher("run", options);
  }
  function table(options) {
    return new Matcher("table", options);
  }
  function highlight(options) {
    return new HighlightMatcher(options);
  }
  function Matcher(elementType, options) {
    options = options || {};
    this._elementType = elementType;
    this._styleId = options.styleId;
    this._styleName = options.styleName;
    if (options.list) {
      this._listIndex = options.list.levelIndex;
      this._listIsOrdered = options.list.isOrdered;
    }
  }
  Matcher.prototype.matches = function(element2) {
    return element2.type === this._elementType && (this._styleId === void 0 || element2.styleId === this._styleId) && (this._styleName === void 0 || element2.styleName && this._styleName.operator(this._styleName.operand, element2.styleName)) && (this._listIndex === void 0 || isList(element2, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === element2.breakType);
  };
  function HighlightMatcher(options) {
    options = options || {};
    this._color = options.color;
  }
  HighlightMatcher.prototype.matches = function(element2) {
    return element2.type === "highlight" && (this._color === void 0 || element2.color === this._color);
  };
  function BreakMatcher(options) {
    options = options || {};
    this._breakType = options.breakType;
  }
  BreakMatcher.prototype.matches = function(element2) {
    return element2.type === "break" && (this._breakType === void 0 || element2.breakType === this._breakType);
  };
  function isList(element2, levelIndex, isOrdered) {
    return element2.numbering && element2.numbering.level == levelIndex && element2.numbering.isOrdered == isOrdered;
  }
  function equalTo(value) {
    return {
      operator: operatorEqualTo,
      operand: value
    };
  }
  function startsWith(value) {
    return {
      operator: operatorStartsWith,
      operand: value
    };
  }
  function operatorEqualTo(first, second) {
    return first.toUpperCase() === second.toUpperCase();
  }
  function operatorStartsWith(first, second) {
    return second.toUpperCase().indexOf(first.toUpperCase()) === 0;
  }
  return documentMatchers;
}
var tokeniser = {};
var hasRequiredTokeniser;
function requireTokeniser() {
  if (hasRequiredTokeniser) return tokeniser;
  hasRequiredTokeniser = 1;
  var lop2 = requireLop();
  var RegexTokeniser = lop2.RegexTokeniser;
  tokeniser.tokenise = tokenise;
  var stringPrefix = "'((?:\\\\.|[^'])*)";
  function tokenise(string) {
    var identifierCharacter = "(?:[a-zA-Z\\-_]|\\\\.)";
    var tokeniser2 = new RegexTokeniser([
      { name: "identifier", regex: new RegExp("(" + identifierCharacter + "(?:" + identifierCharacter + "|[0-9])*)") },
      { name: "dot", regex: /\./ },
      { name: "colon", regex: /:/ },
      { name: "gt", regex: />/ },
      { name: "whitespace", regex: /\s+/ },
      { name: "arrow", regex: /=>/ },
      { name: "equals", regex: /=/ },
      { name: "startsWith", regex: /\^=/ },
      { name: "open-paren", regex: /\(/ },
      { name: "close-paren", regex: /\)/ },
      { name: "open-square-bracket", regex: /\[/ },
      { name: "close-square-bracket", regex: /\]/ },
      { name: "string", regex: new RegExp(stringPrefix + "'") },
      { name: "unterminated-string", regex: new RegExp(stringPrefix) },
      { name: "integer", regex: /([0-9]+)/ },
      { name: "choice", regex: /\|/ },
      { name: "bang", regex: /(!)/ }
    ]);
    return tokeniser2.tokenise(string);
  }
  return tokeniser;
}
var hasRequiredStyleReader;
function requireStyleReader() {
  if (hasRequiredStyleReader) return styleReader;
  hasRequiredStyleReader = 1;
  var _ = requireUnderscoreNode();
  var lop2 = requireLop();
  var documentMatchers2 = requireDocumentMatchers();
  var htmlPaths2 = requireHtmlPaths();
  var tokenise = requireTokeniser().tokenise;
  var results2 = requireResults();
  styleReader.readHtmlPath = readHtmlPath;
  styleReader.readDocumentMatcher = readDocumentMatcher;
  styleReader.readStyle = readStyle;
  function readStyle(string) {
    return parseString(styleRule, string);
  }
  function createStyleRule() {
    return lop2.rules.sequence(
      lop2.rules.sequence.capture(documentMatcherRule()),
      lop2.rules.tokenOfType("whitespace"),
      lop2.rules.tokenOfType("arrow"),
      lop2.rules.sequence.capture(lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("whitespace"),
        lop2.rules.sequence.capture(htmlPathRule())
      ).head())),
      lop2.rules.tokenOfType("end")
    ).map(function(documentMatcher, htmlPath) {
      return {
        from: documentMatcher,
        to: htmlPath.valueOrElse(htmlPaths2.empty)
      };
    });
  }
  function readDocumentMatcher(string) {
    return parseString(documentMatcherRule(), string);
  }
  function documentMatcherRule() {
    var sequence = lop2.rules.sequence;
    var identifierToConstant = function(identifier, constant) {
      return lop2.rules.then(
        lop2.rules.token("identifier", identifier),
        function() {
          return constant;
        }
      );
    };
    var paragraphRule = identifierToConstant("p", documentMatchers2.paragraph);
    var runRule = identifierToConstant("r", documentMatchers2.run);
    var elementTypeRule = lop2.rules.firstOf(
      "p or r or table",
      paragraphRule,
      runRule
    );
    var styleIdRule = lop2.rules.sequence(
      lop2.rules.tokenOfType("dot"),
      lop2.rules.sequence.cut(),
      lop2.rules.sequence.capture(identifierRule)
    ).map(function(styleId) {
      return { styleId };
    });
    var styleNameMatcherRule = lop2.rules.firstOf(
      "style name matcher",
      lop2.rules.then(
        lop2.rules.sequence(
          lop2.rules.tokenOfType("equals"),
          lop2.rules.sequence.cut(),
          lop2.rules.sequence.capture(stringRule)
        ).head(),
        function(styleName) {
          return { styleName: documentMatchers2.equalTo(styleName) };
        }
      ),
      lop2.rules.then(
        lop2.rules.sequence(
          lop2.rules.tokenOfType("startsWith"),
          lop2.rules.sequence.cut(),
          lop2.rules.sequence.capture(stringRule)
        ).head(),
        function(styleName) {
          return { styleName: documentMatchers2.startsWith(styleName) };
        }
      )
    );
    var styleNameRule = lop2.rules.sequence(
      lop2.rules.tokenOfType("open-square-bracket"),
      lop2.rules.sequence.cut(),
      lop2.rules.token("identifier", "style-name"),
      lop2.rules.sequence.capture(styleNameMatcherRule),
      lop2.rules.tokenOfType("close-square-bracket")
    ).head();
    var listTypeRule = lop2.rules.firstOf(
      "list type",
      identifierToConstant("ordered-list", { isOrdered: true }),
      identifierToConstant("unordered-list", { isOrdered: false })
    );
    var listRule = sequence(
      lop2.rules.tokenOfType("colon"),
      sequence.capture(listTypeRule),
      sequence.cut(),
      lop2.rules.tokenOfType("open-paren"),
      sequence.capture(integerRule),
      lop2.rules.tokenOfType("close-paren")
    ).map(function(listType, levelNumber) {
      return {
        list: {
          isOrdered: listType.isOrdered,
          levelIndex: levelNumber - 1
        }
      };
    });
    function createMatcherSuffixesRule(rules2) {
      var matcherSuffix = lop2.rules.firstOf.apply(
        lop2.rules.firstOf,
        ["matcher suffix"].concat(rules2)
      );
      var matcherSuffixes = lop2.rules.zeroOrMore(matcherSuffix);
      return lop2.rules.then(matcherSuffixes, function(suffixes) {
        var matcherOptions = {};
        suffixes.forEach(function(suffix) {
          _.extend(matcherOptions, suffix);
        });
        return matcherOptions;
      });
    }
    var paragraphOrRun = sequence(
      sequence.capture(elementTypeRule),
      sequence.capture(createMatcherSuffixesRule([
        styleIdRule,
        styleNameRule,
        listRule
      ]))
    ).map(function(createMatcher, matcherOptions) {
      return createMatcher(matcherOptions);
    });
    var table = sequence(
      lop2.rules.token("identifier", "table"),
      sequence.capture(createMatcherSuffixesRule([
        styleIdRule,
        styleNameRule
      ]))
    ).map(function(options) {
      return documentMatchers2.table(options);
    });
    var bold = identifierToConstant("b", documentMatchers2.bold);
    var italic = identifierToConstant("i", documentMatchers2.italic);
    var underline2 = identifierToConstant("u", documentMatchers2.underline);
    var strikethrough = identifierToConstant("strike", documentMatchers2.strikethrough);
    var allCaps = identifierToConstant("all-caps", documentMatchers2.allCaps);
    var smallCaps = identifierToConstant("small-caps", documentMatchers2.smallCaps);
    var highlight = sequence(
      lop2.rules.token("identifier", "highlight"),
      lop2.rules.sequence.capture(lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("open-square-bracket"),
        lop2.rules.sequence.cut(),
        lop2.rules.token("identifier", "color"),
        lop2.rules.tokenOfType("equals"),
        lop2.rules.sequence.capture(stringRule),
        lop2.rules.tokenOfType("close-square-bracket")
      ).head()))
    ).map(function(color) {
      return documentMatchers2.highlight({
        color: color.valueOrElse(void 0)
      });
    });
    var commentReference = identifierToConstant("comment-reference", documentMatchers2.commentReference);
    var breakMatcher = sequence(
      lop2.rules.token("identifier", "br"),
      sequence.cut(),
      lop2.rules.tokenOfType("open-square-bracket"),
      lop2.rules.token("identifier", "type"),
      lop2.rules.tokenOfType("equals"),
      sequence.capture(stringRule),
      lop2.rules.tokenOfType("close-square-bracket")
    ).map(function(breakType) {
      switch (breakType) {
        case "line":
          return documentMatchers2.lineBreak;
        case "page":
          return documentMatchers2.pageBreak;
        case "column":
          return documentMatchers2.columnBreak;
      }
    });
    return lop2.rules.firstOf(
      "element type",
      paragraphOrRun,
      table,
      bold,
      italic,
      underline2,
      strikethrough,
      allCaps,
      smallCaps,
      highlight,
      commentReference,
      breakMatcher
    );
  }
  function readHtmlPath(string) {
    return parseString(htmlPathRule(), string);
  }
  function htmlPathRule() {
    var capture = lop2.rules.sequence.capture;
    var whitespaceRule = lop2.rules.tokenOfType("whitespace");
    var freshRule = lop2.rules.then(
      lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("colon"),
        lop2.rules.token("identifier", "fresh")
      )),
      function(option2) {
        return option2.map(function() {
          return true;
        }).valueOrElse(false);
      }
    );
    var separatorRule = lop2.rules.then(
      lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("colon"),
        lop2.rules.token("identifier", "separator"),
        lop2.rules.tokenOfType("open-paren"),
        capture(stringRule),
        lop2.rules.tokenOfType("close-paren")
      ).head()),
      function(option2) {
        return option2.valueOrElse("");
      }
    );
    var tagNamesRule = lop2.rules.oneOrMoreWithSeparator(
      identifierRule,
      lop2.rules.tokenOfType("choice")
    );
    var styleElementRule = lop2.rules.sequence(
      capture(tagNamesRule),
      capture(lop2.rules.zeroOrMore(attributeOrClassRule)),
      capture(freshRule),
      capture(separatorRule)
    ).map(function(tagName, attributesList, fresh, separator) {
      var attributes = {};
      var options = {};
      attributesList.forEach(function(attribute2) {
        if (attribute2.append && attributes[attribute2.name]) {
          attributes[attribute2.name] += " " + attribute2.value;
        } else {
          attributes[attribute2.name] = attribute2.value;
        }
      });
      if (fresh) {
        options.fresh = true;
      }
      if (separator) {
        options.separator = separator;
      }
      return htmlPaths2.element(tagName, attributes, options);
    });
    return lop2.rules.firstOf(
      "html path",
      lop2.rules.then(lop2.rules.tokenOfType("bang"), function() {
        return htmlPaths2.ignore;
      }),
      lop2.rules.then(
        lop2.rules.zeroOrMoreWithSeparator(
          styleElementRule,
          lop2.rules.sequence(
            whitespaceRule,
            lop2.rules.tokenOfType("gt"),
            whitespaceRule
          )
        ),
        htmlPaths2.elements
      )
    );
  }
  var identifierRule = lop2.rules.then(
    lop2.rules.tokenOfType("identifier"),
    decodeEscapeSequences
  );
  var integerRule = lop2.rules.tokenOfType("integer");
  var stringRule = lop2.rules.then(
    lop2.rules.tokenOfType("string"),
    decodeEscapeSequences
  );
  var escapeSequences = {
    "n": "\n",
    "r": "\r",
    "t": "	"
  };
  function decodeEscapeSequences(value) {
    return value.replace(/\\(.)/g, function(match, code) {
      return escapeSequences[code] || code;
    });
  }
  var attributeRule = lop2.rules.sequence(
    lop2.rules.tokenOfType("open-square-bracket"),
    lop2.rules.sequence.cut(),
    lop2.rules.sequence.capture(identifierRule),
    lop2.rules.tokenOfType("equals"),
    lop2.rules.sequence.capture(stringRule),
    lop2.rules.tokenOfType("close-square-bracket")
  ).map(function(name, value) {
    return { name, value, append: false };
  });
  var classRule = lop2.rules.sequence(
    lop2.rules.tokenOfType("dot"),
    lop2.rules.sequence.cut(),
    lop2.rules.sequence.capture(identifierRule)
  ).map(function(className) {
    return { name: "class", value: className, append: true };
  });
  var attributeOrClassRule = lop2.rules.firstOf(
    "attribute or class",
    attributeRule,
    classRule
  );
  function parseString(rule, string) {
    var tokens = tokenise(string);
    var parser2 = lop2.Parser();
    var parseResult = parser2.parseTokens(rule, tokens);
    if (parseResult.isSuccess()) {
      return results2.success(parseResult.value());
    } else {
      return new results2.Result(null, [results2.warning(describeFailure(string, parseResult))]);
    }
  }
  function describeFailure(input, parseResult) {
    return "Did not understand this style mapping, so ignored it: " + input + "\n" + parseResult.errors().map(describeError).join("\n");
  }
  function describeError(error) {
    return "Error was at character number " + error.characterNumber() + ": Expected " + error.expected + " but got " + error.actual;
  }
  var styleRule = createStyleRule();
  return styleReader;
}
var optionsReader = {};
var hasRequiredOptionsReader;
function requireOptionsReader() {
  if (hasRequiredOptionsReader) return optionsReader;
  hasRequiredOptionsReader = 1;
  optionsReader.readOptions = readOptions;
  var _ = requireUnderscoreNode();
  var defaultStyleMap = optionsReader._defaultStyleMap = [
    "p.Heading1 => h1:fresh",
    "p.Heading2 => h2:fresh",
    "p.Heading3 => h3:fresh",
    "p.Heading4 => h4:fresh",
    "p.Heading5 => h5:fresh",
    "p.Heading6 => h6:fresh",
    "p[style-name='Heading 1'] => h1:fresh",
    "p[style-name='Heading 2'] => h2:fresh",
    "p[style-name='Heading 3'] => h3:fresh",
    "p[style-name='Heading 4'] => h4:fresh",
    "p[style-name='Heading 5'] => h5:fresh",
    "p[style-name='Heading 6'] => h6:fresh",
    "p[style-name='heading 1'] => h1:fresh",
    "p[style-name='heading 2'] => h2:fresh",
    "p[style-name='heading 3'] => h3:fresh",
    "p[style-name='heading 4'] => h4:fresh",
    "p[style-name='heading 5'] => h5:fresh",
    "p[style-name='heading 6'] => h6:fresh",
    // Apple Pages
    "p.Heading => h1:fresh",
    "p[style-name='Heading'] => h1:fresh",
    "r[style-name='Strong'] => strong",
    "p[style-name='footnote text'] => p:fresh",
    "r[style-name='footnote reference'] =>",
    "p[style-name='endnote text'] => p:fresh",
    "r[style-name='endnote reference'] =>",
    "p[style-name='annotation text'] => p:fresh",
    "r[style-name='annotation reference'] =>",
    // LibreOffice
    "p[style-name='Footnote'] => p:fresh",
    "r[style-name='Footnote anchor'] =>",
    "p[style-name='Endnote'] => p:fresh",
    "r[style-name='Endnote anchor'] =>",
    "p:unordered-list(1) => ul > li:fresh",
    "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
    "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:ordered-list(1) => ol > li:fresh",
    "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
    "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
    "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
    "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
    "r[style-name='Hyperlink'] =>",
    "p[style-name='Normal'] => p:fresh",
    // Apple Pages
    "p.Body => p:fresh",
    "p[style-name='Body'] => p:fresh"
  ];
  var standardOptions = optionsReader._standardOptions = {
    externalFileAccess: false,
    transformDocument: identity,
    includeDefaultStyleMap: true,
    includeEmbeddedStyleMap: true
  };
  function readOptions(options) {
    options = options || {};
    return _.extend({}, standardOptions, options, {
      customStyleMap: readStyleMap(options.styleMap),
      readStyleMap: function() {
        var styleMap2 = this.customStyleMap;
        if (this.includeEmbeddedStyleMap) {
          styleMap2 = styleMap2.concat(readStyleMap(this.embeddedStyleMap));
        }
        if (this.includeDefaultStyleMap) {
          styleMap2 = styleMap2.concat(defaultStyleMap);
        }
        return styleMap2;
      }
    });
  }
  function readStyleMap(styleMap2) {
    if (!styleMap2) {
      return [];
    } else if (_.isString(styleMap2)) {
      return styleMap2.split("\n").map(function(line) {
        return line.trim();
      }).filter(function(line) {
        return line !== "" && line.charAt(0) !== "#";
      });
    } else {
      return styleMap2;
    }
  }
  function identity(value) {
    return value;
  }
  return optionsReader;
}
var unzip = {};
var hasRequiredUnzip;
function requireUnzip() {
  if (hasRequiredUnzip) return unzip;
  hasRequiredUnzip = 1;
  var fs$12 = fs;
  var promises2 = requirePromises();
  var zipfile2 = requireZipfile();
  unzip.openZip = openZip;
  var readFile = promises2.promisify(fs$12.readFile);
  function openZip(options) {
    if (options.path) {
      return readFile(options.path).then(zipfile2.openArrayBuffer);
    } else if (options.buffer) {
      return promises2.resolve(zipfile2.openArrayBuffer(options.buffer));
    } else if (options.file) {
      return promises2.resolve(options.file);
    } else {
      return promises2.reject(new Error("Could not find file in options"));
    }
  }
  return unzip;
}
var underline = {};
var hasRequiredUnderline;
function requireUnderline() {
  if (hasRequiredUnderline) return underline;
  hasRequiredUnderline = 1;
  var htmlPaths2 = requireHtmlPaths();
  var Html = requireHtml();
  underline.element = element2;
  function element2(name) {
    return function(html2) {
      return Html.elementWithTag(htmlPaths2.element(name), [html2]);
    };
  }
  return underline;
}
var hasRequiredLib$b;
function requireLib$b() {
  if (hasRequiredLib$b) return lib$h;
  hasRequiredLib$b = 1;
  var _ = requireUnderscoreNode();
  var docxReader2 = requireDocxReader();
  var docxStyleMap = requireStyleMap();
  var DocumentConverter = requireDocumentToHtml().DocumentConverter;
  var convertElementToRawText = requireRawText().convertElementToRawText;
  var readStyle = requireStyleReader().readStyle;
  var readOptions = requireOptionsReader().readOptions;
  var unzip2 = requireUnzip();
  var Result = requireResults().Result;
  lib$h.convertToHtml = convertToHtml;
  lib$h.convertToMarkdown = convertToMarkdown;
  lib$h.convert = convert2;
  lib$h.extractRawText = extractRawText;
  lib$h.images = requireImages();
  lib$h.transforms = requireTransforms();
  lib$h.underline = requireUnderline();
  lib$h.embedStyleMap = embedStyleMap;
  lib$h.readEmbeddedStyleMap = readEmbeddedStyleMap;
  function convertToHtml(input, options) {
    return convert2(input, options);
  }
  function convertToMarkdown(input, options) {
    var markdownOptions = Object.create(options || {});
    markdownOptions.outputFormat = "markdown";
    return convert2(input, markdownOptions);
  }
  function convert2(input, options) {
    options = readOptions(options);
    return unzip2.openZip(input).tap(function(docxFile) {
      return docxStyleMap.readStyleMap(docxFile).then(function(styleMap2) {
        options.embeddedStyleMap = styleMap2;
      });
    }).then(function(docxFile) {
      return docxReader2.read(docxFile, input, options).then(function(documentResult) {
        return documentResult.map(options.transformDocument);
      }).then(function(documentResult) {
        return convertDocumentToHtml(documentResult, options);
      });
    });
  }
  function readEmbeddedStyleMap(input) {
    return unzip2.openZip(input).then(docxStyleMap.readStyleMap);
  }
  function convertDocumentToHtml(documentResult, options) {
    var styleMapResult = parseStyleMap(options.readStyleMap());
    var parsedOptions = _.extend({}, options, {
      styleMap: styleMapResult.value
    });
    var documentConverter = new DocumentConverter(parsedOptions);
    return documentResult.flatMapThen(function(document2) {
      return styleMapResult.flatMapThen(function(styleMap2) {
        return documentConverter.convertToHtml(document2);
      });
    });
  }
  function parseStyleMap(styleMap2) {
    return Result.combine((styleMap2 || []).map(readStyle)).map(function(styleMap3) {
      return styleMap3.filter(function(styleMapping) {
        return !!styleMapping;
      });
    });
  }
  function extractRawText(input) {
    return unzip2.openZip(input).then(docxReader2.read).then(function(documentResult) {
      return documentResult.map(convertElementToRawText);
    });
  }
  function embedStyleMap(input, styleMap2) {
    return unzip2.openZip(input).tap(function(docxFile) {
      return docxStyleMap.writeStyleMap(docxFile, styleMap2);
    }).then(function(docxFile) {
      return docxFile.toArrayBuffer();
    }).then(function(arrayBuffer) {
      return {
        toArrayBuffer: function() {
          return arrayBuffer;
        },
        toBuffer: function() {
          return Buffer.from(arrayBuffer);
        }
      };
    });
  }
  lib$h.styleMapping = function() {
    throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
  };
  return lib$h;
}
var libExports$2 = requireLib$b();
const mammoth = /* @__PURE__ */ getDefaultExportFromCjs(libExports$2);
var libExports$1 = requireLib$e();
const JSZip = /* @__PURE__ */ getDefaultExportFromCjs(libExports$1);
var lib$b = {};
var interfaces$3 = {};
var hasRequiredInterfaces$3;
function requireInterfaces$3() {
  if (hasRequiredInterfaces$3) return interfaces$3;
  hasRequiredInterfaces$3 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DefaultBuilderOptions = {
      version: "1.0",
      encoding: void 0,
      standalone: void 0,
      keepNullNodes: false,
      keepNullAttributes: false,
      ignoreConverters: false,
      convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
      },
      defaultNamespace: {
        ele: void 0,
        att: void 0
      },
      namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
      },
      invalidCharReplacement: void 0
    };
    exports$1.XMLBuilderOptionKeys = new Set(Object.keys(exports$1.DefaultBuilderOptions));
    exports$1.DefaultXMLBuilderCBOptions = {
      format: "xml",
      wellFormed: false,
      prettyPrint: false,
      indent: "  ",
      newline: "\n",
      offset: 0,
      width: 0,
      allowEmptyTags: false,
      spaceBeforeSlash: false,
      keepNullNodes: false,
      keepNullAttributes: false,
      ignoreConverters: false,
      convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
      },
      defaultNamespace: {
        ele: void 0,
        att: void 0
      },
      namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
      }
    };
  })(interfaces$3);
  return interfaces$3;
}
var lib$a = {};
var FixedSizeSet$1 = {};
var hasRequiredFixedSizeSet$1;
function requireFixedSizeSet$1() {
  if (hasRequiredFixedSizeSet$1) return FixedSizeSet$1;
  hasRequiredFixedSizeSet$1 = 1;
  Object.defineProperty(FixedSizeSet$1, "__esModule", { value: true });
  class FixedSizeSet2 {
    /**
     * Initializes a new instance of `FixedSizeSet`.
     *
     * @param limit - maximum number of items to keep in the set. When the limit
     * is exceeded the first item is removed from the set.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Set();
      this._limit = limit;
    }
    /**
     * Adds a new item to the set.
     *
     * @param item - an item
     */
    add(item) {
      this._items.add(item);
      if (this._items.size > this._limit) {
        const it2 = this._items.values().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
      return this;
    }
    /**
     * Removes an item from the set.
     *
     * @param item - an item
     */
    delete(item) {
      return this._items.delete(item);
    }
    /**
     * Determines if an item is in the set.
     *
     * @param item - an item
     */
    has(item) {
      return this._items.has(item);
    }
    /**
     * Removes all items from the set.
     */
    clear() {
      this._items.clear();
    }
    /**
     * Gets the number of items in the set.
     */
    get size() {
      return this._items.size;
    }
    /**
     * Applies the given callback function to all elements of the set.
     */
    forEach(callback, thisArg) {
      this._items.forEach((e) => callback.call(thisArg, e, e, this));
    }
    /**
     * Iterates through the items in the set.
     */
    *keys() {
      yield* this._items.keys();
    }
    /**
     * Iterates through the items in the set.
     */
    *values() {
      yield* this._items.values();
    }
    /**
     * Iterates through the items in the set.
     */
    *entries() {
      yield* this._items.entries();
    }
    /**
     * Iterates through the items in the set.
     */
    *[Symbol.iterator]() {
      yield* this._items;
    }
    /**
     * Returns the string tag of the set.
     */
    get [Symbol.toStringTag]() {
      return "FixedSizeSet";
    }
  }
  FixedSizeSet$1.FixedSizeSet = FixedSizeSet2;
  return FixedSizeSet$1;
}
var ObjectCache$3 = {};
var hasRequiredObjectCache$3;
function requireObjectCache$3() {
  if (hasRequiredObjectCache$3) return ObjectCache$3;
  hasRequiredObjectCache$3 = 1;
  Object.defineProperty(ObjectCache$3, "__esModule", { value: true });
  class ObjectCache2 {
    /**
     * Initializes a new instance of `ObjectCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Map();
      this._limit = limit;
    }
    /**
     * Gets an item from the cache.
     *
     * @param key - object key
     */
    get(key) {
      return this._items.get(key);
    }
    /**
     * Adds a new item to the cache.
     *
     * @param key - object key
     * @param value - object value
     */
    set(key, value) {
      this._items.set(key, value);
      if (this._items.size > this._limit) {
        const it2 = this._items.keys().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
    }
    /**
     * Removes an item from the cache.
     *
     * @param item - an item
     */
    delete(key) {
      return this._items.delete(key);
    }
    /**
     * Determines if an item is in the cache.
     *
     * @param item - an item
     */
    has(key) {
      return this._items.has(key);
    }
    /**
     * Removes all items from the cache.
     */
    clear() {
      this._items.clear();
    }
    /**
     * Gets the number of items in the cache.
     */
    get size() {
      return this._items.size;
    }
    /**
     * Applies the given callback function to all elements of the cache.
     */
    forEach(callback, thisArg) {
      this._items.forEach((v, k) => callback.call(thisArg, k, v));
    }
    /**
     * Iterates through the items in the set.
     */
    *keys() {
      yield* this._items.keys();
    }
    /**
     * Iterates through the items in the set.
     */
    *values() {
      yield* this._items.values();
    }
    /**
     * Iterates through the items in the set.
     */
    *entries() {
      yield* this._items.entries();
    }
    /**
     * Iterates through the items in the set.
     */
    *[Symbol.iterator]() {
      yield* this._items;
    }
    /**
     * Returns the string tag of the cache.
     */
    get [Symbol.toStringTag]() {
      return "ObjectCache";
    }
  }
  ObjectCache$3.ObjectCache = ObjectCache2;
  return ObjectCache$3;
}
var CompareCache$3 = {};
var hasRequiredCompareCache$3;
function requireCompareCache$3() {
  if (hasRequiredCompareCache$3) return CompareCache$3;
  hasRequiredCompareCache$3 = 1;
  Object.defineProperty(CompareCache$3, "__esModule", { value: true });
  class CompareCache2 {
    /**
     * Initializes a new instance of `CompareCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Map();
      this._limit = limit;
    }
    /**
     * Compares and caches the given objects. Returns `true` if `objA < objB` and
     * `false` otherwise.
     *
     * @param objA - an item to compare
     * @param objB - an item to compare
     */
    check(objA, objB) {
      if (this._items.get(objA) === objB)
        return true;
      else if (this._items.get(objB) === objA)
        return false;
      const result = Math.random() < 0.5;
      if (result) {
        this._items.set(objA, objB);
      } else {
        this._items.set(objB, objA);
      }
      if (this._items.size > this._limit) {
        const it2 = this._items.keys().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
      return result;
    }
  }
  CompareCache$3.CompareCache = CompareCache2;
  return CompareCache$3;
}
var Lazy$1 = {};
var hasRequiredLazy$1;
function requireLazy$1() {
  if (hasRequiredLazy$1) return Lazy$1;
  hasRequiredLazy$1 = 1;
  Object.defineProperty(Lazy$1, "__esModule", { value: true });
  class Lazy2 {
    /**
     * Initializes a new instance of `Lazy`.
     *
     * @param initFunc - initializer function
     */
    constructor(initFunc) {
      this._initialized = false;
      this._value = void 0;
      this._initFunc = initFunc;
    }
    /**
     * Gets the value of the object.
     */
    get value() {
      if (!this._initialized) {
        this._value = this._initFunc();
        this._initialized = true;
      }
      return this._value;
    }
  }
  Lazy$1.Lazy = Lazy2;
  return Lazy$1;
}
var hasRequiredLib$a;
function requireLib$a() {
  if (hasRequiredLib$a) return lib$a;
  hasRequiredLib$a = 1;
  Object.defineProperty(lib$a, "__esModule", { value: true });
  var FixedSizeSet_1 = requireFixedSizeSet$1();
  lib$a.FixedSizeSet = FixedSizeSet_1.FixedSizeSet;
  var ObjectCache_1 = requireObjectCache$3();
  lib$a.ObjectCache = ObjectCache_1.ObjectCache;
  var CompareCache_1 = requireCompareCache$3();
  lib$a.CompareCache = CompareCache_1.CompareCache;
  var Lazy_1 = requireLazy$1();
  lib$a.Lazy = Lazy_1.Lazy;
  function applyMixin(baseClass, mixinClass, ...overrides) {
    Object.getOwnPropertyNames(mixinClass.prototype).forEach((name) => {
      if (overrides.includes(name)) {
        const orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
        if (orgPropDesc) {
          Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
        }
      }
      const propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
      if (propDesc) {
        Object.defineProperty(baseClass.prototype, name, propDesc);
      }
    });
  }
  lib$a.applyMixin = applyMixin;
  function applyDefaults(obj, defaults2, overwrite = false) {
    const result = clone2(obj || {});
    forEachObject(defaults2, (key, val) => {
      if (isPlainObject(val)) {
        result[key] = applyDefaults(result[key], val, overwrite);
      } else if (overwrite || result[key] === void 0) {
        result[key] = val;
      }
    });
    return result;
  }
  lib$a.applyDefaults = applyDefaults;
  function forEachArray(arr, callback, thisArg) {
    arr.forEach(callback, thisArg);
  }
  lib$a.forEachArray = forEachArray;
  function forEachObject(obj, callback, thisArg) {
    if (isMap(obj)) {
      obj.forEach((value, key) => callback.call(thisArg, key, value));
    } else {
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          callback.call(thisArg, key, obj[key]);
        }
      }
    }
  }
  lib$a.forEachObject = forEachObject;
  function arrayLength(obj) {
    if (isSet(obj)) {
      return obj.size;
    } else {
      return obj.length;
    }
  }
  lib$a.arrayLength = arrayLength;
  function objectLength(obj) {
    if (isMap(obj)) {
      return obj.size;
    } else {
      return Object.keys(obj).length;
    }
  }
  lib$a.objectLength = objectLength;
  function getObjectValue(obj, key) {
    if (isMap(obj)) {
      return obj.get(key);
    } else {
      return obj[key];
    }
  }
  lib$a.getObjectValue = getObjectValue;
  function removeObjectValue(obj, key) {
    if (isMap(obj)) {
      obj.delete(key);
    } else {
      delete obj[key];
    }
  }
  lib$a.removeObjectValue = removeObjectValue;
  function clone2(obj) {
    if (isFunction(obj)) {
      return obj;
    } else if (isArray(obj)) {
      const result = [];
      for (const item of obj) {
        result.push(clone2(item));
      }
      return result;
    } else if (isObject(obj)) {
      const result = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const val = obj[key];
          result[key] = clone2(val);
        }
      }
      return result;
    } else {
      return obj;
    }
  }
  lib$a.clone = clone2;
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  lib$a.isBoolean = isBoolean;
  function isNumber(x) {
    return typeof x === "number";
  }
  lib$a.isNumber = isNumber;
  function isString(x) {
    return typeof x === "string";
  }
  lib$a.isString = isString;
  function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === "[object Function]";
  }
  lib$a.isFunction = isFunction;
  function isObject(x) {
    const type2 = typeof x;
    return !!x && (type2 === "function" || type2 === "object");
  }
  lib$a.isObject = isObject;
  function isArray(x) {
    return Array.isArray(x);
  }
  lib$a.isArray = isArray;
  function isSet(x) {
    return x instanceof Set;
  }
  lib$a.isSet = isSet;
  function isMap(x) {
    return x instanceof Map;
  }
  lib$a.isMap = isMap;
  function isEmpty(x) {
    if (isArray(x)) {
      return !x.length;
    } else if (isSet(x)) {
      return !x.size;
    } else if (isMap(x)) {
      return !x.size;
    } else if (isObject(x)) {
      for (const key in x) {
        if (x.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  lib$a.isEmpty = isEmpty;
  function isPlainObject(x) {
    if (isObject(x)) {
      const proto = Object.getPrototypeOf(x);
      const ctor = proto.constructor;
      return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }
    return false;
  }
  lib$a.isPlainObject = isPlainObject;
  function isIterable(x) {
    return x && typeof x[Symbol.iterator] === "function";
  }
  lib$a.isIterable = isIterable;
  function getValue(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  }
  lib$a.getValue = getValue;
  function utf8Encode(input) {
    const bytes = new Uint8Array(input.length * 4);
    let byteIndex = 0;
    for (let i = 0; i < input.length; i++) {
      let char = input.charCodeAt(i);
      if (char < 128) {
        bytes[byteIndex++] = char;
        continue;
      } else if (char < 2048) {
        bytes[byteIndex++] = char >> 6 | 192;
      } else {
        if (char > 55295 && char < 56320) {
          if (++i >= input.length) {
            throw new Error("Incomplete surrogate pair.");
          }
          const c2 = input.charCodeAt(i);
          if (c2 < 56320 || c2 > 57343) {
            throw new Error("Invalid surrogate character.");
          }
          char = 65536 + ((char & 1023) << 10) + (c2 & 1023);
          bytes[byteIndex++] = char >> 18 | 240;
          bytes[byteIndex++] = char >> 12 & 63 | 128;
        } else {
          bytes[byteIndex++] = char >> 12 | 224;
        }
        bytes[byteIndex++] = char >> 6 & 63 | 128;
      }
      bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
  }
  lib$a.utf8Encode = utf8Encode;
  function utf8Decode(bytes) {
    let result = "";
    let i = 0;
    while (i < bytes.length) {
      var c = bytes[i++];
      if (c > 127) {
        if (c > 191 && c < 224) {
          if (i >= bytes.length) {
            throw new Error("Incomplete 2-byte sequence.");
          }
          c = (c & 31) << 6 | bytes[i++] & 63;
        } else if (c > 223 && c < 240) {
          if (i + 1 >= bytes.length) {
            throw new Error("Incomplete 3-byte sequence.");
          }
          c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else if (c > 239 && c < 248) {
          if (i + 2 >= bytes.length) {
            throw new Error("Incomplete 4-byte sequence.");
          }
          c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else {
          throw new Error("Unknown multi-byte start.");
        }
      }
      if (c <= 65535) {
        result += String.fromCharCode(c);
      } else if (c <= 1114111) {
        c -= 65536;
        result += String.fromCharCode(c >> 10 | 55296);
        result += String.fromCharCode(c & 1023 | 56320);
      } else {
        throw new Error("Code point exceeds UTF-16 limit.");
      }
    }
    return result;
  }
  lib$a.utf8Decode = utf8Decode;
  return lib$a;
}
var util$1 = {};
var Cast = {};
var Guard = {};
var interfaces$2 = {};
var hasRequiredInterfaces$2;
function requireInterfaces$2() {
  if (hasRequiredInterfaces$2) return interfaces$2;
  hasRequiredInterfaces$2 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    (function(BoundaryPosition) {
      BoundaryPosition[BoundaryPosition["Before"] = 0] = "Before";
      BoundaryPosition[BoundaryPosition["Equal"] = 1] = "Equal";
      BoundaryPosition[BoundaryPosition["After"] = 2] = "After";
    })(exports$1.BoundaryPosition || (exports$1.BoundaryPosition = {}));
    (function(EventPhase) {
      EventPhase[EventPhase["None"] = 0] = "None";
      EventPhase[EventPhase["Capturing"] = 1] = "Capturing";
      EventPhase[EventPhase["AtTarget"] = 2] = "AtTarget";
      EventPhase[EventPhase["Bubbling"] = 3] = "Bubbling";
    })(exports$1.EventPhase || (exports$1.EventPhase = {}));
    (function(NodeType) {
      NodeType[NodeType["Element"] = 1] = "Element";
      NodeType[NodeType["Attribute"] = 2] = "Attribute";
      NodeType[NodeType["Text"] = 3] = "Text";
      NodeType[NodeType["CData"] = 4] = "CData";
      NodeType[NodeType["EntityReference"] = 5] = "EntityReference";
      NodeType[NodeType["Entity"] = 6] = "Entity";
      NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
      NodeType[NodeType["Comment"] = 8] = "Comment";
      NodeType[NodeType["Document"] = 9] = "Document";
      NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
      NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
      NodeType[NodeType["Notation"] = 12] = "Notation";
    })(exports$1.NodeType || (exports$1.NodeType = {}));
    (function(Position) {
      Position[Position["Disconnected"] = 1] = "Disconnected";
      Position[Position["Preceding"] = 2] = "Preceding";
      Position[Position["Following"] = 4] = "Following";
      Position[Position["Contains"] = 8] = "Contains";
      Position[Position["ContainedBy"] = 16] = "ContainedBy";
      Position[Position["ImplementationSpecific"] = 32] = "ImplementationSpecific";
    })(exports$1.Position || (exports$1.Position = {}));
    (function(FilterResult) {
      FilterResult[FilterResult["Accept"] = 1] = "Accept";
      FilterResult[FilterResult["Reject"] = 2] = "Reject";
      FilterResult[FilterResult["Skip"] = 3] = "Skip";
    })(exports$1.FilterResult || (exports$1.FilterResult = {}));
    (function(WhatToShow) {
      WhatToShow[WhatToShow["All"] = 4294967295] = "All";
      WhatToShow[WhatToShow["Element"] = 1] = "Element";
      WhatToShow[WhatToShow["Attribute"] = 2] = "Attribute";
      WhatToShow[WhatToShow["Text"] = 4] = "Text";
      WhatToShow[WhatToShow["CDataSection"] = 8] = "CDataSection";
      WhatToShow[WhatToShow["EntityReference"] = 16] = "EntityReference";
      WhatToShow[WhatToShow["Entity"] = 32] = "Entity";
      WhatToShow[WhatToShow["ProcessingInstruction"] = 64] = "ProcessingInstruction";
      WhatToShow[WhatToShow["Comment"] = 128] = "Comment";
      WhatToShow[WhatToShow["Document"] = 256] = "Document";
      WhatToShow[WhatToShow["DocumentType"] = 512] = "DocumentType";
      WhatToShow[WhatToShow["DocumentFragment"] = 1024] = "DocumentFragment";
      WhatToShow[WhatToShow["Notation"] = 2048] = "Notation";
    })(exports$1.WhatToShow || (exports$1.WhatToShow = {}));
    (function(HowToCompare) {
      HowToCompare[HowToCompare["StartToStart"] = 0] = "StartToStart";
      HowToCompare[HowToCompare["StartToEnd"] = 1] = "StartToEnd";
      HowToCompare[HowToCompare["EndToEnd"] = 2] = "EndToEnd";
      HowToCompare[HowToCompare["EndToStart"] = 3] = "EndToStart";
    })(exports$1.HowToCompare || (exports$1.HowToCompare = {}));
  })(interfaces$2);
  return interfaces$2;
}
var hasRequiredGuard;
function requireGuard() {
  if (hasRequiredGuard) return Guard;
  hasRequiredGuard = 1;
  Object.defineProperty(Guard, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  let Guard$1 = class Guard2 {
    /**
     * Determines if the given object is a `Node`.
     *
     * @param a - the object to check
     */
    static isNode(a) {
      return !!a && a._nodeType !== void 0;
    }
    /**
     * Determines if the given object is a `Document`.
     *
     * @param a - the object to check
     */
    static isDocumentNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Document;
    }
    /**
     * Determines if the given object is a `DocumentType`.
     *
     * @param a - the object to check
     */
    static isDocumentTypeNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType;
    }
    /**
     * Determines if the given object is a `DocumentFragment`.
     *
     * @param a - the object to check
     */
    static isDocumentFragmentNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment;
    }
    /**
     * Determines if the given object is a `Attr`.
     *
     * @param a - the object to check
     */
    static isAttrNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute;
    }
    /**
     * Determines if the given node is a `CharacterData` node.
     *
     * @param a - the object to check
     */
    static isCharacterDataNode(a) {
      if (!Guard2.isNode(a))
        return false;
      const type2 = a._nodeType;
      return type2 === interfaces_1.NodeType.Text || type2 === interfaces_1.NodeType.ProcessingInstruction || type2 === interfaces_1.NodeType.Comment || type2 === interfaces_1.NodeType.CData;
    }
    /**
     * Determines if the given object is a `Text` or a `CDATASection`.
     *
     * @param a - the object to check
     */
    static isTextNode(a) {
      return Guard2.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData);
    }
    /**
     * Determines if the given object is a `Text`.
     *
     * @param a - the object to check
     */
    static isExclusiveTextNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Text;
    }
    /**
     * Determines if the given object is a `CDATASection`.
     *
     * @param a - the object to check
     */
    static isCDATASectionNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.CData;
    }
    /**
     * Determines if the given object is a `Comment`.
     *
     * @param a - the object to check
     */
    static isCommentNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment;
    }
    /**
     * Determines if the given object is a `ProcessingInstruction`.
     *
     * @param a - the object to check
     */
    static isProcessingInstructionNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction;
    }
    /**
     * Determines if the given object is an `Element`.
     *
     * @param a - the object to check
     */
    static isElementNode(a) {
      return Guard2.isNode(a) && a._nodeType === interfaces_1.NodeType.Element;
    }
    /**
     * Determines if the given object is a custom `Element`.
     *
     * @param a - the object to check
     */
    static isCustomElementNode(a) {
      return Guard2.isElementNode(a) && a._customElementState === "custom";
    }
    /**
     * Determines if the given object is a `ShadowRoot`.
     *
     * @param a - the object to check
     */
    static isShadowRoot(a) {
      return !!a && a.host !== void 0;
    }
    /**
     * Determines if the given object is a `MouseEvent`.
     *
     * @param a - the object to check
     */
    static isMouseEvent(a) {
      return !!a && a.screenX !== void 0 && a.screenY != void 0;
    }
    /**
     * Determines if the given object is a slotable.
     *
     * Element and Text nodes are slotables. A slotable has an associated name
     * (a string).
     *
     * @param a - the object to check
     */
    static isSlotable(a) {
      return !!a && a._name !== void 0 && a._assignedSlot !== void 0 && (Guard2.isTextNode(a) || Guard2.isElementNode(a));
    }
    /**
     * Determines if the given object is a slot.
     *
     * @param a - the object to check
     */
    static isSlot(a) {
      return !!a && a._name !== void 0 && a._assignedNodes !== void 0 && Guard2.isElementNode(a);
    }
    /**
     * Determines if the given object is a `Window`.
     *
     * @param a - the object to check
     */
    static isWindow(a) {
      return !!a && a.navigator !== void 0;
    }
    /**
     * Determines if the given object is an `EventListener`.
     *
     * @param a - the object to check
     */
    static isEventListener(a) {
      return !!a && a.handleEvent !== void 0;
    }
    /**
     * Determines if the given object is a `RegisteredObserver`.
     *
     * @param a - the object to check
     */
    static isRegisteredObserver(a) {
      return !!a && a.observer !== void 0 && a.options !== void 0;
    }
    /**
    * Determines if the given object is a `TransientRegisteredObserver`.
    *
    * @param a - the object to check
    */
    static isTransientRegisteredObserver(a) {
      return !!a && a.source !== void 0 && Guard2.isRegisteredObserver(a);
    }
  };
  Guard.Guard = Guard$1;
  return Guard;
}
var hasRequiredCast;
function requireCast() {
  if (hasRequiredCast) return Cast;
  hasRequiredCast = 1;
  Object.defineProperty(Cast, "__esModule", { value: true });
  const Guard_1 = requireGuard();
  let Cast$1 = class Cast {
    /**
     * Casts the given object to a `Node`.
     *
     * @param a - the object to cast
     */
    static asNode(a) {
      if (Guard_1.Guard.isNode(a)) {
        return a;
      } else {
        throw new Error("Invalid object. Node expected.");
      }
    }
  };
  Cast.Cast = Cast$1;
  return Cast;
}
var EmptySet = {};
var hasRequiredEmptySet;
function requireEmptySet() {
  if (hasRequiredEmptySet) return EmptySet;
  hasRequiredEmptySet = 1;
  Object.defineProperty(EmptySet, "__esModule", { value: true });
  let EmptySet$1 = class EmptySet {
    get size() {
      return 0;
    }
    add(value) {
      throw new Error("Cannot add to an empty set.");
    }
    clear() {
    }
    delete(value) {
      return false;
    }
    forEach(callbackfn, thisArg) {
    }
    has(value) {
      return false;
    }
    [Symbol.iterator]() {
      return new EmptySetIterator();
    }
    entries() {
      return new EmptySetIterator();
    }
    keys() {
      return new EmptySetIterator();
    }
    values() {
      return new EmptySetIterator();
    }
    get [Symbol.toStringTag]() {
      return "EmptySet";
    }
  };
  EmptySet.EmptySet = EmptySet$1;
  class EmptySetIterator {
    [Symbol.iterator]() {
      return this;
    }
    next() {
      return { done: true, value: null };
    }
  }
  return EmptySet;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  Object.defineProperty(util$1, "__esModule", { value: true });
  var Cast_1 = requireCast();
  util$1.Cast = Cast_1.Cast;
  var Guard_1 = requireGuard();
  util$1.Guard = Guard_1.Guard;
  var EmptySet_1 = requireEmptySet();
  util$1.EmptySet = EmptySet_1.EmptySet;
  return util$1;
}
var builder = {};
var XMLBuilderImpl = {};
var writers = {};
var MapWriter = {};
var ObjectWriter = {};
var BaseWriter = {};
var LocalNameSet = {};
var hasRequiredLocalNameSet;
function requireLocalNameSet() {
  if (hasRequiredLocalNameSet) return LocalNameSet;
  hasRequiredLocalNameSet = 1;
  Object.defineProperty(LocalNameSet, "__esModule", { value: true });
  let LocalNameSet$1 = class LocalNameSet {
    constructor() {
      this._items = {};
      this._nullItems = {};
    }
    /**
     * Adds or replaces a tuple.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */
    set(ns, localName) {
      if (ns === null) {
        this._nullItems[localName] = true;
      } else if (this._items[ns]) {
        this._items[ns][localName] = true;
      } else {
        this._items[ns] = {};
        this._items[ns][localName] = true;
      }
    }
    /**
     * Determines if the given tuple exists in the set.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */
    has(ns, localName) {
      if (ns === null) {
        return this._nullItems[localName] === true;
      } else if (this._items[ns]) {
        return this._items[ns][localName] === true;
      } else {
        return false;
      }
    }
  };
  LocalNameSet.LocalNameSet = LocalNameSet$1;
  return LocalNameSet;
}
var NamespacePrefixMap = {};
var hasRequiredNamespacePrefixMap;
function requireNamespacePrefixMap() {
  if (hasRequiredNamespacePrefixMap) return NamespacePrefixMap;
  hasRequiredNamespacePrefixMap = 1;
  Object.defineProperty(NamespacePrefixMap, "__esModule", { value: true });
  let NamespacePrefixMap$1 = class NamespacePrefixMap2 {
    constructor() {
      this._items = {};
      this._nullItems = [];
    }
    /**
     * Creates a copy of the map.
     */
    copy() {
      const mapCopy = new NamespacePrefixMap2();
      for (const key in this._items) {
        mapCopy._items[key] = this._items[key].slice(0);
      }
      mapCopy._nullItems = this._nullItems.slice(0);
      return mapCopy;
    }
    /**
     * Retrieves a preferred prefix string from the namespace prefix map.
     *
     * @param preferredPrefix - preferred prefix string
     * @param ns - namespace
     */
    get(preferredPrefix, ns) {
      const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (candidatesList === null) {
        return null;
      }
      let prefix = null;
      for (let i = 0; i < candidatesList.length; i++) {
        prefix = candidatesList[i];
        if (prefix === preferredPrefix) {
          return prefix;
        }
      }
      return prefix;
    }
    /**
     * Checks if a prefix string is found in the namespace prefix map associated
     * with the given namespace.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */
    has(prefix, ns) {
      const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (candidatesList === null) {
        return false;
      }
      return candidatesList.indexOf(prefix) !== -1;
    }
    /**
     * Checks if a prefix string is found in the namespace prefix map.
     *
     * @param prefix - prefix string
     */
    hasPrefix(prefix) {
      if (this._nullItems.indexOf(prefix) !== -1)
        return true;
      for (const key in this._items) {
        if (this._items[key].indexOf(prefix) !== -1)
          return true;
      }
      return false;
    }
    /**
     * Adds a prefix string associated with a namespace to the prefix map.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */
    set(prefix, ns) {
      const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
      if (ns !== null && candidatesList === null) {
        this._items[ns] = [prefix];
      } else {
        candidatesList.push(prefix);
      }
    }
  };
  NamespacePrefixMap.NamespacePrefixMap = NamespacePrefixMap$1;
  return NamespacePrefixMap;
}
var DOMException = {};
var hasRequiredDOMException;
function requireDOMException() {
  if (hasRequiredDOMException) return DOMException;
  hasRequiredDOMException = 1;
  Object.defineProperty(DOMException, "__esModule", { value: true });
  let DOMException$1 = class DOMException extends Error {
    /**
     *
     * @param name - message name
     * @param message - error message
     */
    constructor(name, message = "") {
      super(message);
      this.name = name;
    }
  };
  DOMException.DOMException = DOMException$1;
  class DOMStringSizeError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("DOMStringSizeError", message);
    }
  }
  DOMException.DOMStringSizeError = DOMStringSizeError;
  class WrongDocumentError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("WrongDocumentError", "The object is in the wrong document. " + message);
    }
  }
  DOMException.WrongDocumentError = WrongDocumentError;
  class NoDataAllowedError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("NoDataAllowedError", message);
    }
  }
  DOMException.NoDataAllowedError = NoDataAllowedError;
  class NoModificationAllowedError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("NoModificationAllowedError", "The object can not be modified. " + message);
    }
  }
  DOMException.NoModificationAllowedError = NoModificationAllowedError;
  class NotSupportedError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("NotSupportedError", "The operation is not supported. " + message);
    }
  }
  DOMException.NotSupportedError = NotSupportedError;
  class InUseAttributeError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("InUseAttributeError", message);
    }
  }
  DOMException.InUseAttributeError = InUseAttributeError;
  class InvalidStateError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("InvalidStateError", "The object is in an invalid state. " + message);
    }
  }
  DOMException.InvalidStateError = InvalidStateError;
  class InvalidModificationError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("InvalidModificationError", "The object can not be modified in this way. " + message);
    }
  }
  DOMException.InvalidModificationError = InvalidModificationError;
  class NamespaceError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + message);
    }
  }
  DOMException.NamespaceError = NamespaceError;
  class InvalidAccessError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("InvalidAccessError", "The object does not support the operation or argument. " + message);
    }
  }
  DOMException.InvalidAccessError = InvalidAccessError;
  class ValidationError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("ValidationError", message);
    }
  }
  DOMException.ValidationError = ValidationError;
  class TypeMismatchError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("TypeMismatchError", message);
    }
  }
  DOMException.TypeMismatchError = TypeMismatchError;
  class SecurityError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("SecurityError", "The operation is insecure. " + message);
    }
  }
  DOMException.SecurityError = SecurityError;
  class NetworkError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("NetworkError", "A network error occurred. " + message);
    }
  }
  DOMException.NetworkError = NetworkError;
  class AbortError2 extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("AbortError", "The operation was aborted. " + message);
    }
  }
  DOMException.AbortError = AbortError2;
  class URLMismatchError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("URLMismatchError", "The given URL does not match another URL. " + message);
    }
  }
  DOMException.URLMismatchError = URLMismatchError;
  class QuotaExceededError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("QuotaExceededError", "The quota has been exceeded. " + message);
    }
  }
  DOMException.QuotaExceededError = QuotaExceededError;
  class TimeoutError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("TimeoutError", "The operation timed out. " + message);
    }
  }
  DOMException.TimeoutError = TimeoutError;
  class InvalidNodeTypeError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + message);
    }
  }
  DOMException.InvalidNodeTypeError = InvalidNodeTypeError;
  class DataCloneError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("DataCloneError", "The object can not be cloned. " + message);
    }
  }
  DOMException.DataCloneError = DataCloneError;
  class NotImplementedError extends DOMException$1 {
    /**
    * @param message - error message
    */
    constructor(message = "") {
      super("NotImplementedError", "The DOM method is not implemented by this module. " + message);
    }
  }
  DOMException.NotImplementedError = NotImplementedError;
  class HierarchyRequestError extends DOMException$1 {
    /**
     * @param message - error message
     */
    constructor(message = "") {
      super("HierarchyRequestError", "The operation would yield an incorrect node tree. " + message);
    }
  }
  DOMException.HierarchyRequestError = HierarchyRequestError;
  class NotFoundError extends DOMException$1 {
    /**
     * @param message - error message
     */
    constructor(message = "") {
      super("NotFoundError", "The object can not be found here. " + message);
    }
  }
  DOMException.NotFoundError = NotFoundError;
  class IndexSizeError extends DOMException$1 {
    /**
     * @param message - error message
     */
    constructor(message = "") {
      super("IndexSizeError", "The index is not in the allowed range. " + message);
    }
  }
  DOMException.IndexSizeError = IndexSizeError;
  class SyntaxError2 extends DOMException$1 {
    /**
     * @param message - error message
     */
    constructor(message = "") {
      super("SyntaxError", "The string did not match the expected pattern. " + message);
    }
  }
  DOMException.SyntaxError = SyntaxError2;
  class InvalidCharacterError extends DOMException$1 {
    /**
     * @param message - error message
     */
    constructor(message = "") {
      super("InvalidCharacterError", "The string contains invalid characters. " + message);
    }
  }
  DOMException.InvalidCharacterError = InvalidCharacterError;
  return DOMException;
}
var lib$9 = {};
var Base64$1 = {};
var CodePoints$1 = {};
var hasRequiredCodePoints$1;
function requireCodePoints$1() {
  if (hasRequiredCodePoints$1) return CodePoints$1;
  hasRequiredCodePoints$1 = 1;
  Object.defineProperty(CodePoints$1, "__esModule", { value: true });
  CodePoints$1.Surrogate = /[\uD800-\uDFFF]/;
  CodePoints$1.ScalarValue = /[\uD800-\uDFFF]/;
  CodePoints$1.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
  CodePoints$1.ASCIICodePoint = /[\u0000-\u007F]/;
  CodePoints$1.ASCIITabOrNewLine = /[\t\n\r]/;
  CodePoints$1.ASCIIWhiteSpace = /[\t\n\f\r ]/;
  CodePoints$1.C0Control = /[\u0000-\u001F]/;
  CodePoints$1.C0ControlOrSpace = /[\u0000-\u001F ]/;
  CodePoints$1.Control = /[\u0000-\u001F\u007F-\u009F]/;
  CodePoints$1.ASCIIDigit = /[0-9]/;
  CodePoints$1.ASCIIUpperHexDigit = /[0-9A-F]/;
  CodePoints$1.ASCIILowerHexDigit = /[0-9a-f]/;
  CodePoints$1.ASCIIHexDigit = /[0-9A-Fa-f]/;
  CodePoints$1.ASCIIUpperAlpha = /[A-Z]/;
  CodePoints$1.ASCIILowerAlpha = /[a-z]/;
  CodePoints$1.ASCIIAlpha = /[A-Za-z]/;
  CodePoints$1.ASCIIAlphanumeric = /[0-9A-Za-z]/;
  return CodePoints$1;
}
var hasRequiredBase64$1;
function requireBase64$1() {
  if (hasRequiredBase64$1) return Base64$1;
  hasRequiredBase64$1 = 1;
  Object.defineProperty(Base64$1, "__esModule", { value: true });
  const CodePoints_1 = requireCodePoints$1();
  function forgivingBase64Encode(input) {
    return Buffer.from(input).toString("base64");
  }
  Base64$1.forgivingBase64Encode = forgivingBase64Encode;
  function forgivingBase64Decode(input) {
    if (input === "")
      return "";
    input = input.replace(CodePoints_1.ASCIIWhiteSpace, "");
    if (input.length % 4 === 0) {
      if (input.endsWith("==")) {
        input = input.substr(0, input.length - 2);
      } else if (input.endsWith("=")) {
        input = input.substr(0, input.length - 1);
      }
    }
    if (input.length % 4 === 1)
      return null;
    if (!/[0-9A-Za-z+/]/.test(input))
      return null;
    return Buffer.from(input, "base64").toString("utf8");
  }
  Base64$1.forgivingBase64Decode = forgivingBase64Decode;
  return Base64$1;
}
var Byte$1 = {};
var hasRequiredByte$1;
function requireByte$1() {
  if (hasRequiredByte$1) return Byte$1;
  hasRequiredByte$1 = 1;
  Object.defineProperty(Byte$1, "__esModule", { value: true });
  function isASCIIByte(byte) {
    return byte >= 0 && byte <= 127;
  }
  Byte$1.isASCIIByte = isASCIIByte;
  return Byte$1;
}
var ByteSequence$1 = {};
var hasRequiredByteSequence$1;
function requireByteSequence$1() {
  if (hasRequiredByteSequence$1) return ByteSequence$1;
  hasRequiredByteSequence$1 = 1;
  Object.defineProperty(ByteSequence$1, "__esModule", { value: true });
  function length(list) {
    return list.length;
  }
  ByteSequence$1.length = length;
  function byteLowercase(list) {
    for (let i = 0; i < list.length; i++) {
      const c = list[i];
      if (c >= 65 && c <= 90) {
        list[i] = c + 32;
      }
    }
  }
  ByteSequence$1.byteLowercase = byteLowercase;
  function byteUppercase(list) {
    for (let i = 0; i < list.length; i++) {
      const c = list[i];
      if (c >= 97 && c <= 122) {
        list[i] = c - 32;
      }
    }
  }
  ByteSequence$1.byteUppercase = byteUppercase;
  function byteCaseInsensitiveMatch(listA, listB) {
    if (listA.length !== listB.length)
      return false;
    for (let i = 0; i < listA.length; i++) {
      let a = listA[i];
      let b = listB[i];
      if (a >= 65 && a <= 90)
        a += 32;
      if (b >= 65 && b <= 90)
        b += 32;
      if (a !== b)
        return false;
    }
    return true;
  }
  ByteSequence$1.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
  function startsWith(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      if (listA[i] !== listB[i])
        return false;
      i++;
    }
  }
  ByteSequence$1.startsWith = startsWith;
  function byteLessThan(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      const a = listA[i];
      const b = listB[i];
      if (a < b)
        return true;
      else if (a > b)
        return false;
      i++;
    }
  }
  ByteSequence$1.byteLessThan = byteLessThan;
  function isomorphicDecode(list) {
    return String.fromCodePoint(...list);
  }
  ByteSequence$1.isomorphicDecode = isomorphicDecode;
  return ByteSequence$1;
}
var _JSON$1 = {};
var lib$8 = {};
var FixedSizeSet = {};
var hasRequiredFixedSizeSet;
function requireFixedSizeSet() {
  if (hasRequiredFixedSizeSet) return FixedSizeSet;
  hasRequiredFixedSizeSet = 1;
  Object.defineProperty(FixedSizeSet, "__esModule", { value: true });
  let FixedSizeSet$12 = class FixedSizeSet {
    /**
     * Initializes a new instance of `FixedSizeSet`.
     *
     * @param limit - maximum number of items to keep in the set. When the limit
     * is exceeded the first item is removed from the set.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Set();
      this._limit = limit;
    }
    /**
     * Adds a new item to the set.
     *
     * @param item - an item
     */
    add(item) {
      this._items.add(item);
      if (this._items.size > this._limit) {
        const it2 = this._items.values().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
      return this;
    }
    /**
     * Removes an item from the set.
     *
     * @param item - an item
     */
    delete(item) {
      return this._items.delete(item);
    }
    /**
     * Determines if an item is in the set.
     *
     * @param item - an item
     */
    has(item) {
      return this._items.has(item);
    }
    /**
     * Removes all items from the set.
     */
    clear() {
      this._items.clear();
    }
    /**
     * Gets the number of items in the set.
     */
    get size() {
      return this._items.size;
    }
    /**
     * Applies the given callback function to all elements of the set.
     */
    forEach(callback, thisArg) {
      this._items.forEach((e) => callback.call(thisArg, e, e, this));
    }
    /**
     * Iterates through the items in the set.
     */
    *keys() {
      yield* this._items.keys();
    }
    /**
     * Iterates through the items in the set.
     */
    *values() {
      yield* this._items.values();
    }
    /**
     * Iterates through the items in the set.
     */
    *entries() {
      yield* this._items.entries();
    }
    /**
     * Iterates through the items in the set.
     */
    *[Symbol.iterator]() {
      yield* this._items;
    }
    /**
     * Returns the string tag of the set.
     */
    get [Symbol.toStringTag]() {
      return "FixedSizeSet";
    }
  };
  FixedSizeSet.FixedSizeSet = FixedSizeSet$12;
  return FixedSizeSet;
}
var ObjectCache$2 = {};
var hasRequiredObjectCache$2;
function requireObjectCache$2() {
  if (hasRequiredObjectCache$2) return ObjectCache$2;
  hasRequiredObjectCache$2 = 1;
  Object.defineProperty(ObjectCache$2, "__esModule", { value: true });
  class ObjectCache2 {
    /**
     * Initializes a new instance of `ObjectCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Map();
      this._limit = limit;
    }
    /**
     * Gets an item from the cache.
     *
     * @param key - object key
     */
    get(key) {
      return this._items.get(key);
    }
    /**
     * Adds a new item to the cache.
     *
     * @param key - object key
     * @param value - object value
     */
    set(key, value) {
      this._items.set(key, value);
      if (this._items.size > this._limit) {
        const it2 = this._items.keys().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
    }
    /**
     * Removes an item from the cache.
     *
     * @param item - an item
     */
    delete(key) {
      return this._items.delete(key);
    }
    /**
     * Determines if an item is in the cache.
     *
     * @param item - an item
     */
    has(key) {
      return this._items.has(key);
    }
    /**
     * Removes all items from the cache.
     */
    clear() {
      this._items.clear();
    }
    /**
     * Gets the number of items in the cache.
     */
    get size() {
      return this._items.size;
    }
    /**
     * Applies the given callback function to all elements of the cache.
     */
    forEach(callback, thisArg) {
      this._items.forEach((v, k) => callback.call(thisArg, k, v));
    }
    /**
     * Iterates through the items in the set.
     */
    *keys() {
      yield* this._items.keys();
    }
    /**
     * Iterates through the items in the set.
     */
    *values() {
      yield* this._items.values();
    }
    /**
     * Iterates through the items in the set.
     */
    *entries() {
      yield* this._items.entries();
    }
    /**
     * Iterates through the items in the set.
     */
    *[Symbol.iterator]() {
      yield* this._items;
    }
    /**
     * Returns the string tag of the cache.
     */
    get [Symbol.toStringTag]() {
      return "ObjectCache";
    }
  }
  ObjectCache$2.ObjectCache = ObjectCache2;
  return ObjectCache$2;
}
var CompareCache$2 = {};
var hasRequiredCompareCache$2;
function requireCompareCache$2() {
  if (hasRequiredCompareCache$2) return CompareCache$2;
  hasRequiredCompareCache$2 = 1;
  Object.defineProperty(CompareCache$2, "__esModule", { value: true });
  class CompareCache2 {
    /**
     * Initializes a new instance of `CompareCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Map();
      this._limit = limit;
    }
    /**
     * Compares and caches the given objects. Returns `true` if `objA < objB` and
     * `false` otherwise.
     *
     * @param objA - an item to compare
     * @param objB - an item to compare
     */
    check(objA, objB) {
      if (this._items.get(objA) === objB)
        return true;
      else if (this._items.get(objB) === objA)
        return false;
      const result = Math.random() < 0.5;
      if (result) {
        this._items.set(objA, objB);
      } else {
        this._items.set(objB, objA);
      }
      if (this._items.size > this._limit) {
        const it2 = this._items.keys().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
      return result;
    }
  }
  CompareCache$2.CompareCache = CompareCache2;
  return CompareCache$2;
}
var Lazy = {};
var hasRequiredLazy;
function requireLazy() {
  if (hasRequiredLazy) return Lazy;
  hasRequiredLazy = 1;
  Object.defineProperty(Lazy, "__esModule", { value: true });
  let Lazy$12 = class Lazy {
    /**
     * Initializes a new instance of `Lazy`.
     *
     * @param initFunc - initializer function
     */
    constructor(initFunc) {
      this._initialized = false;
      this._value = void 0;
      this._initFunc = initFunc;
    }
    /**
     * Gets the value of the object.
     */
    get value() {
      if (!this._initialized) {
        this._value = this._initFunc();
        this._initialized = true;
      }
      return this._value;
    }
  };
  Lazy.Lazy = Lazy$12;
  return Lazy;
}
var hasRequiredLib$9;
function requireLib$9() {
  if (hasRequiredLib$9) return lib$8;
  hasRequiredLib$9 = 1;
  Object.defineProperty(lib$8, "__esModule", { value: true });
  var FixedSizeSet_1 = requireFixedSizeSet();
  lib$8.FixedSizeSet = FixedSizeSet_1.FixedSizeSet;
  var ObjectCache_1 = requireObjectCache$2();
  lib$8.ObjectCache = ObjectCache_1.ObjectCache;
  var CompareCache_1 = requireCompareCache$2();
  lib$8.CompareCache = CompareCache_1.CompareCache;
  var Lazy_1 = requireLazy();
  lib$8.Lazy = Lazy_1.Lazy;
  function applyMixin(baseClass, mixinClass, ...overrides) {
    Object.getOwnPropertyNames(mixinClass.prototype).forEach((name) => {
      if (overrides.includes(name)) {
        const orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
        if (orgPropDesc) {
          Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
        }
      }
      const propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
      if (propDesc) {
        Object.defineProperty(baseClass.prototype, name, propDesc);
      }
    });
  }
  lib$8.applyMixin = applyMixin;
  function applyDefaults(obj, defaults2, overwrite = false) {
    const result = clone2(obj || {});
    forEachObject(defaults2, (key, val) => {
      if (isObject(val)) {
        result[key] = applyDefaults(result[key], val);
      } else if (overwrite || result[key] === void 0) {
        result[key] = val;
      }
    });
    return result;
  }
  lib$8.applyDefaults = applyDefaults;
  function forEachArray(arr, callback, thisArg) {
    arr.forEach(callback, thisArg);
  }
  lib$8.forEachArray = forEachArray;
  function forEachObject(obj, callback, thisArg) {
    if (isMap(obj)) {
      obj.forEach((value, key) => callback.call(thisArg, key, value));
    } else {
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          callback.call(thisArg, key, obj[key]);
        }
      }
    }
  }
  lib$8.forEachObject = forEachObject;
  function arrayLength(obj) {
    if (isSet(obj)) {
      return obj.size;
    } else {
      return obj.length;
    }
  }
  lib$8.arrayLength = arrayLength;
  function objectLength(obj) {
    if (isMap(obj)) {
      return obj.size;
    } else {
      return Object.keys(obj).length;
    }
  }
  lib$8.objectLength = objectLength;
  function getObjectValue(obj, key) {
    if (isMap(obj)) {
      return obj.get(key);
    } else {
      return obj[key];
    }
  }
  lib$8.getObjectValue = getObjectValue;
  function removeObjectValue(obj, key) {
    if (isMap(obj)) {
      obj.delete(key);
    } else {
      delete obj[key];
    }
  }
  lib$8.removeObjectValue = removeObjectValue;
  function clone2(obj) {
    if (isFunction(obj)) {
      return obj;
    } else if (isArray(obj)) {
      const result = [];
      for (const item of obj) {
        result.push(clone2(item));
      }
      return result;
    } else if (isObject(obj)) {
      const result = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const val = obj[key];
          result[key] = clone2(val);
        }
      }
      return result;
    } else {
      return obj;
    }
  }
  lib$8.clone = clone2;
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  lib$8.isBoolean = isBoolean;
  function isNumber(x) {
    return typeof x === "number";
  }
  lib$8.isNumber = isNumber;
  function isString(x) {
    return typeof x === "string";
  }
  lib$8.isString = isString;
  function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === "[object Function]";
  }
  lib$8.isFunction = isFunction;
  function isObject(x) {
    const type2 = typeof x;
    return !!x && (type2 === "function" || type2 === "object");
  }
  lib$8.isObject = isObject;
  function isArray(x) {
    return Array.isArray(x);
  }
  lib$8.isArray = isArray;
  function isSet(x) {
    return x instanceof Set;
  }
  lib$8.isSet = isSet;
  function isMap(x) {
    return x instanceof Map;
  }
  lib$8.isMap = isMap;
  function isEmpty(x) {
    if (isArray(x)) {
      return !x.length;
    } else if (isSet(x)) {
      return !x.size;
    } else if (isMap(x)) {
      return !x.size;
    } else if (isObject(x)) {
      for (const key in x) {
        if (x.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  lib$8.isEmpty = isEmpty;
  function isPlainObject(x) {
    if (isObject(x)) {
      const proto = Object.getPrototypeOf(x);
      const ctor = proto.constructor;
      return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }
    return false;
  }
  lib$8.isPlainObject = isPlainObject;
  function isIterable(x) {
    return x && typeof x[Symbol.iterator] === "function";
  }
  lib$8.isIterable = isIterable;
  function getValue(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  }
  lib$8.getValue = getValue;
  function utf8Encode(input) {
    const bytes = new Uint8Array(input.length * 4);
    let byteIndex = 0;
    for (let i = 0; i < input.length; i++) {
      let char = input.charCodeAt(i);
      if (char < 128) {
        bytes[byteIndex++] = char;
        continue;
      } else if (char < 2048) {
        bytes[byteIndex++] = char >> 6 | 192;
      } else {
        if (char > 55295 && char < 56320) {
          if (++i >= input.length) {
            throw new Error("Incomplete surrogate pair.");
          }
          const c2 = input.charCodeAt(i);
          if (c2 < 56320 || c2 > 57343) {
            throw new Error("Invalid surrogate character.");
          }
          char = 65536 + ((char & 1023) << 10) + (c2 & 1023);
          bytes[byteIndex++] = char >> 18 | 240;
          bytes[byteIndex++] = char >> 12 & 63 | 128;
        } else {
          bytes[byteIndex++] = char >> 12 | 224;
        }
        bytes[byteIndex++] = char >> 6 & 63 | 128;
      }
      bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
  }
  lib$8.utf8Encode = utf8Encode;
  function utf8Decode(bytes) {
    let result = "";
    let i = 0;
    while (i < bytes.length) {
      var c = bytes[i++];
      if (c > 127) {
        if (c > 191 && c < 224) {
          if (i >= bytes.length) {
            throw new Error("Incomplete 2-byte sequence.");
          }
          c = (c & 31) << 6 | bytes[i++] & 63;
        } else if (c > 223 && c < 240) {
          if (i + 1 >= bytes.length) {
            throw new Error("Incomplete 3-byte sequence.");
          }
          c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else if (c > 239 && c < 248) {
          if (i + 2 >= bytes.length) {
            throw new Error("Incomplete 4-byte sequence.");
          }
          c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else {
          throw new Error("Unknown multi-byte start.");
        }
      }
      if (c <= 65535) {
        result += String.fromCharCode(c);
      } else if (c <= 1114111) {
        c -= 65536;
        result += String.fromCharCode(c >> 10 | 55296);
        result += String.fromCharCode(c & 1023 | 56320);
      } else {
        throw new Error("Code point exceeds UTF-16 limit.");
      }
    }
    return result;
  }
  lib$8.utf8Decode = utf8Decode;
  return lib$8;
}
var hasRequired_JSON$1;
function require_JSON$1() {
  if (hasRequired_JSON$1) return _JSON$1;
  hasRequired_JSON$1 = 1;
  Object.defineProperty(_JSON$1, "__esModule", { value: true });
  const util_1 = requireLib$9();
  function parseJSONFromBytes(bytes) {
    const jsonText = util_1.utf8Decode(bytes);
    return JSON.parse.call(void 0, jsonText);
  }
  _JSON$1.parseJSONFromBytes = parseJSONFromBytes;
  function serializeJSONToBytes(value) {
    const jsonString = JSON.stringify.call(void 0, value);
    return util_1.utf8Encode(jsonString);
  }
  _JSON$1.serializeJSONToBytes = serializeJSONToBytes;
  function parseJSONIntoInfraValues(jsonText) {
    const jsValue = JSON.parse.call(void 0, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
  }
  _JSON$1.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
  function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue))
      return jsValue;
    if (util_1.isArray(jsValue)) {
      const result = new Array();
      for (const jsValueAtIndex of jsValue) {
        result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
      }
      return result;
    } else if (util_1.isObject(jsValue)) {
      const result = /* @__PURE__ */ new Map();
      for (const key in jsValue) {
        if (jsValue.hasOwnProperty(key)) {
          const jsValueAtKey = jsValue[key];
          result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
        }
      }
      return result;
    }
    return jsValue;
  }
  _JSON$1.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
  return _JSON$1;
}
var List$1 = {};
var hasRequiredList$1;
function requireList$1() {
  if (hasRequiredList$1) return List$1;
  hasRequiredList$1 = 1;
  Object.defineProperty(List$1, "__esModule", { value: true });
  const util_1 = requireLib$9();
  function append(list, item) {
    list.push(item);
  }
  List$1.append = append;
  function extend(listA, listB) {
    listA.push(...listB);
  }
  List$1.extend = extend;
  function prepend(list, item) {
    list.unshift(item);
  }
  List$1.prepend = prepend;
  function replace(list, conditionOrItem, newItem) {
    let i = 0;
    for (const oldItem of list) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list[i] = newItem;
        }
      } else if (oldItem === conditionOrItem) {
        list[i] = newItem;
        return;
      }
      i++;
    }
  }
  List$1.replace = replace;
  function insert(list, item, index) {
    list.splice(index, 0, item);
  }
  List$1.insert = insert;
  function remove(list, conditionOrItem) {
    let i = list.length;
    while (i--) {
      const oldItem = list[i];
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list.splice(i, 1);
        }
      } else if (oldItem === conditionOrItem) {
        list.splice(i, 1);
        return;
      }
    }
  }
  List$1.remove = remove;
  function empty2(list) {
    list.length = 0;
  }
  List$1.empty = empty2;
  function contains(list, conditionOrItem) {
    for (const oldItem of list) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      } else if (oldItem === conditionOrItem) {
        return true;
      }
    }
    return false;
  }
  List$1.contains = contains;
  function size(list, condition) {
    if (condition === void 0) {
      return list.length;
    } else {
      let count = 0;
      for (const item of list) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  List$1.size = size;
  function isEmpty(list) {
    return list.length === 0;
  }
  List$1.isEmpty = isEmpty;
  function* forEach(list, condition) {
    if (condition === void 0) {
      yield* list;
    } else {
      for (const item of list) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  List$1.forEach = forEach;
  function clone2(list) {
    return new Array(...list);
  }
  List$1.clone = clone2;
  function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
  }
  List$1.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
  }
  List$1.sortInDescendingOrder = sortInDescendingOrder;
  return List$1;
}
var _Map$1 = {};
var hasRequired_Map$1;
function require_Map$1() {
  if (hasRequired_Map$1) return _Map$1;
  hasRequired_Map$1 = 1;
  Object.defineProperty(_Map$1, "__esModule", { value: true });
  const util_1 = requireLib$9();
  function get2(map2, key) {
    return map2.get(key);
  }
  _Map$1.get = get2;
  function set(map2, key, val) {
    map2.set(key, val);
  }
  _Map$1.set = set;
  function remove(map2, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      map2.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of map2) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item[0]);
        }
      }
      for (const key of toRemove) {
        map2.delete(key);
      }
    }
  }
  _Map$1.remove = remove;
  function contains(map2, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      return map2.has(conditionOrItem);
    } else {
      for (const item of map2) {
        if (!!conditionOrItem.call(null, item)) {
          return true;
        }
      }
      return false;
    }
  }
  _Map$1.contains = contains;
  function keys(map2) {
    return new Set(map2.keys());
  }
  _Map$1.keys = keys;
  function values(map2) {
    return [...map2.values()];
  }
  _Map$1.values = values;
  function size(map2, condition) {
    if (condition === void 0) {
      return map2.size;
    } else {
      let count = 0;
      for (const item of map2) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  _Map$1.size = size;
  function isEmpty(map2) {
    return map2.size === 0;
  }
  _Map$1.isEmpty = isEmpty;
  function* forEach(map2, condition) {
    if (condition === void 0) {
      yield* map2;
    } else {
      for (const item of map2) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  _Map$1.forEach = forEach;
  function clone2(map2) {
    return new Map(map2);
  }
  _Map$1.clone = clone2;
  function sortInAscendingOrder(map2, lessThanAlgo) {
    const list = new Array(...map2);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Map(list);
  }
  _Map$1.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(map2, lessThanAlgo) {
    const list = new Array(...map2);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Map(list);
  }
  _Map$1.sortInDescendingOrder = sortInDescendingOrder;
  return _Map$1;
}
var Namespace$1 = {};
var hasRequiredNamespace$1;
function requireNamespace$1() {
  if (hasRequiredNamespace$1) return Namespace$1;
  hasRequiredNamespace$1 = 1;
  Object.defineProperty(Namespace$1, "__esModule", { value: true });
  Namespace$1.HTML = "http://www.w3.org/1999/xhtml";
  Namespace$1.XML = "http://www.w3.org/XML/1998/namespace";
  Namespace$1.XMLNS = "http://www.w3.org/2000/xmlns/";
  Namespace$1.MathML = "http://www.w3.org/1998/Math/MathML";
  Namespace$1.SVG = "http://www.w3.org/2000/svg";
  Namespace$1.XLink = "http://www.w3.org/1999/xlink";
  return Namespace$1;
}
var Queue$2 = {};
var hasRequiredQueue$1;
function requireQueue$1() {
  if (hasRequiredQueue$1) return Queue$2;
  hasRequiredQueue$1 = 1;
  Object.defineProperty(Queue$2, "__esModule", { value: true });
  function enqueue(list, item) {
    list.push(item);
  }
  Queue$2.enqueue = enqueue;
  function dequeue(list) {
    return list.shift() || null;
  }
  Queue$2.dequeue = dequeue;
  return Queue$2;
}
var _Set$1 = {};
var hasRequired_Set$1;
function require_Set$1() {
  if (hasRequired_Set$1) return _Set$1;
  hasRequired_Set$1 = 1;
  Object.defineProperty(_Set$1, "__esModule", { value: true });
  const util_1 = requireLib$9();
  function append(set, item) {
    set.add(item);
  }
  _Set$1.append = append;
  function extend(setA, setB) {
    setB.forEach(setA.add, setA);
  }
  _Set$1.extend = extend;
  function prepend(set, item) {
    const cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
  }
  _Set$1.prepend = prepend;
  function replace(set, conditionOrItem, newItem) {
    const newSet = /* @__PURE__ */ new Set();
    for (const oldItem of set) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          newSet.add(newItem);
        } else {
          newSet.add(oldItem);
        }
      } else if (oldItem === conditionOrItem) {
        newSet.add(newItem);
      } else {
        newSet.add(oldItem);
      }
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  _Set$1.replace = replace;
  function insert(set, item, index) {
    const newSet = /* @__PURE__ */ new Set();
    let i = 0;
    for (const oldItem of set) {
      if (i === index)
        newSet.add(item);
      newSet.add(oldItem);
      i++;
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  _Set$1.insert = insert;
  function remove(set, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      set.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of set) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item);
        }
      }
      for (const oldItem of toRemove) {
        set.delete(oldItem);
      }
    }
  }
  _Set$1.remove = remove;
  function empty2(set) {
    set.clear();
  }
  _Set$1.empty = empty2;
  function contains(set, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      return set.has(conditionOrItem);
    } else {
      for (const oldItem of set) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      }
    }
    return false;
  }
  _Set$1.contains = contains;
  function size(set, condition) {
    if (condition === void 0) {
      return set.size;
    } else {
      let count = 0;
      for (const item of set) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  _Set$1.size = size;
  function isEmpty(set) {
    return set.size === 0;
  }
  _Set$1.isEmpty = isEmpty;
  function* forEach(set, condition) {
    if (condition === void 0) {
      yield* set;
    } else {
      for (const item of set) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  _Set$1.forEach = forEach;
  function clone2(set) {
    return new Set(set);
  }
  _Set$1.clone = clone2;
  function sortInAscendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Set(list);
  }
  _Set$1.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Set(list);
  }
  _Set$1.sortInDescendingOrder = sortInDescendingOrder;
  function isSubsetOf(subset2, superset) {
    for (const item of subset2) {
      if (!superset.has(item))
        return false;
    }
    return true;
  }
  _Set$1.isSubsetOf = isSubsetOf;
  function isSupersetOf(superset, subset2) {
    return isSubsetOf(subset2, superset);
  }
  _Set$1.isSupersetOf = isSupersetOf;
  function intersection(setA, setB) {
    const newSet = /* @__PURE__ */ new Set();
    for (const item of setA) {
      if (setB.has(item))
        newSet.add(item);
    }
    return newSet;
  }
  _Set$1.intersection = intersection;
  function union(setA, setB) {
    const newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
  }
  _Set$1.union = union;
  function range2(n, m) {
    const newSet = /* @__PURE__ */ new Set();
    for (let i = n; i <= m; i++) {
      newSet.add(i);
    }
    return newSet;
  }
  _Set$1.range = range2;
  return _Set$1;
}
var Stack$1 = {};
var hasRequiredStack$1;
function requireStack$1() {
  if (hasRequiredStack$1) return Stack$1;
  hasRequiredStack$1 = 1;
  Object.defineProperty(Stack$1, "__esModule", { value: true });
  function push(list, item) {
    list.push(item);
  }
  Stack$1.push = push;
  function pop(list) {
    return list.pop() || null;
  }
  Stack$1.pop = pop;
  return Stack$1;
}
var _String$1 = {};
var hasRequired_String$1;
function require_String$1() {
  if (hasRequired_String$1) return _String$1;
  hasRequired_String$1 = 1;
  Object.defineProperty(_String$1, "__esModule", { value: true });
  const CodePoints_1 = requireCodePoints$1();
  const ByteSequence_1 = requireByteSequence$1();
  const Byte_1 = requireByte$1();
  const util_1 = requireLib$9();
  function isCodeUnitPrefix(a, b) {
    let i = 0;
    while (true) {
      const aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
      const bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
      if (aCodeUnit === null)
        return true;
      if (aCodeUnit !== bCodeUnit)
        return false;
      i++;
    }
  }
  _String$1.isCodeUnitPrefix = isCodeUnitPrefix;
  function isCodeUnitLessThan(a, b) {
    if (isCodeUnitPrefix(b, a))
      return false;
    if (isCodeUnitPrefix(a, b))
      return true;
    for (let i = 0; i < Math.min(a.length, b.length); i++) {
      const aCodeUnit = a.charCodeAt(i);
      const bCodeUnit = b.charCodeAt(i);
      if (aCodeUnit === bCodeUnit)
        continue;
      return aCodeUnit < bCodeUnit;
    }
    return false;
  }
  _String$1.isCodeUnitLessThan = isCodeUnitLessThan;
  function isomorphicEncode(str) {
    const codePoints = Array.from(str);
    const bytes = new Uint8Array(codePoints.length);
    let i = 0;
    for (const codePoint of str) {
      const byte = codePoint.codePointAt(0);
      console.assert(byte !== void 0 && byte <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
      if (byte !== void 0 && byte <= 255) {
        bytes[i++] = byte;
      }
    }
    return bytes;
  }
  _String$1.isomorphicEncode = isomorphicEncode;
  function isASCIIString(str) {
    return /^[\u0000-\u007F]*$/.test(str);
  }
  _String$1.isASCIIString = isASCIIString;
  function asciiLowercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== void 0 && code >= 65 && code <= 90) {
        result += String.fromCodePoint(code + 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  _String$1.asciiLowercase = asciiLowercase;
  function asciiUppercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== void 0 && code >= 97 && code <= 122) {
        result += String.fromCodePoint(code - 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  _String$1.asciiUppercase = asciiUppercase;
  function asciiCaseInsensitiveMatch(a, b) {
    return asciiLowercase(a) === asciiLowercase(b);
  }
  _String$1.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
  function asciiEncode(str) {
    console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
  }
  _String$1.asciiEncode = asciiEncode;
  function asciiDecode(bytes) {
    for (const byte of bytes) {
      console.assert(Byte_1.isASCIIByte(byte), "asciiDecode requires an ASCII byte sequence.");
    }
    return ByteSequence_1.isomorphicDecode(bytes);
  }
  _String$1.asciiDecode = asciiDecode;
  function stripNewlines(str) {
    return str.replace(/[\n\r]/g, "");
  }
  _String$1.stripNewlines = stripNewlines;
  function normalizeNewlines(str) {
    return str.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  }
  _String$1.normalizeNewlines = normalizeNewlines;
  function stripLeadingAndTrailingASCIIWhitespace(str) {
    return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
  }
  _String$1.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
  function stripAndCollapseASCIIWhitespace(str) {
    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
  }
  _String$1.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
  function collectASequenceOfCodePoints(condition, input, options) {
    if (!util_1.isArray(input))
      return collectASequenceOfCodePoints(condition, Array.from(input), options);
    let result = "";
    while (options.position < input.length && !!condition.call(null, input[options.position])) {
      result += input[options.position];
      options.position++;
    }
    return result;
  }
  _String$1.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
  function skipASCIIWhitespace(input, options) {
    collectASequenceOfCodePoints((str) => CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
  }
  _String$1.skipASCIIWhitespace = skipASCIIWhitespace;
  function strictlySplit(input, delimiter) {
    if (!util_1.isArray(input))
      return strictlySplit(Array.from(input), delimiter);
    const options = { position: 0 };
    const tokens = [];
    let token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
    tokens.push(token);
    while (options.position < input.length) {
      console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
      options.position++;
      token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
      tokens.push(token);
    }
    return tokens;
  }
  _String$1.strictlySplit = strictlySplit;
  function splitAStringOnASCIIWhitespace(input) {
    if (!util_1.isArray(input))
      return splitAStringOnASCIIWhitespace(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    skipASCIIWhitespace(input, options);
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => !CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
      tokens.push(token);
      skipASCIIWhitespace(input, options);
    }
    return tokens;
  }
  _String$1.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
  function splitAStringOnCommas(input) {
    if (!util_1.isArray(input))
      return splitAStringOnCommas(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => str !== ",", input, options);
      tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
      if (options.position < input.length) {
        console.assert(input[options.position] === ",", "splitAStringOnCommas found no delimiter in input string.");
        options.position++;
      }
    }
    return tokens;
  }
  _String$1.splitAStringOnCommas = splitAStringOnCommas;
  function concatenate(list, separator = "") {
    if (list.length === 0)
      return "";
    return list.join(separator);
  }
  _String$1.concatenate = concatenate;
  return _String$1;
}
var hasRequiredLib$8;
function requireLib$8() {
  if (hasRequiredLib$8) return lib$9;
  hasRequiredLib$8 = 1;
  var __importStar = lib$9 && lib$9.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(lib$9, "__esModule", { value: true });
  const base642 = __importStar(requireBase64$1());
  lib$9.base64 = base642;
  const byte = __importStar(requireByte$1());
  lib$9.byte = byte;
  const byteSequence = __importStar(requireByteSequence$1());
  lib$9.byteSequence = byteSequence;
  const codePoint = __importStar(requireCodePoints$1());
  lib$9.codePoint = codePoint;
  const json = __importStar(require_JSON$1());
  lib$9.json = json;
  const list = __importStar(requireList$1());
  lib$9.list = list;
  const map2 = __importStar(require_Map$1());
  lib$9.map = map2;
  const namespace = __importStar(requireNamespace$1());
  lib$9.namespace = namespace;
  const queue2 = __importStar(requireQueue$1());
  lib$9.queue = queue2;
  const set = __importStar(require_Set$1());
  lib$9.set = set;
  const stack = __importStar(requireStack$1());
  lib$9.stack = stack;
  const string = __importStar(require_String$1());
  lib$9.string = string;
  return lib$9;
}
var algorithm = {};
var AbortAlgorithm = {};
var EventAlgorithm = {};
var dom$1 = {};
var AbortControllerImpl = {};
var hasRequiredAbortControllerImpl;
function requireAbortControllerImpl() {
  if (hasRequiredAbortControllerImpl) return AbortControllerImpl;
  hasRequiredAbortControllerImpl = 1;
  Object.defineProperty(AbortControllerImpl, "__esModule", { value: true });
  const algorithm_1 = requireAlgorithm();
  let AbortControllerImpl$1 = class AbortControllerImpl {
    /**
     * Initializes a new instance of `AbortController`.
     */
    constructor() {
      this._signal = algorithm_1.create_abortSignal();
    }
    /** @inheritdoc */
    get signal() {
      return this._signal;
    }
    /** @inheritdoc */
    abort() {
      algorithm_1.abort_signalAbort(this._signal);
    }
  };
  AbortControllerImpl.AbortControllerImpl = AbortControllerImpl$1;
  return AbortControllerImpl;
}
var AbortSignalImpl = {};
var EventTargetImpl = {};
var hasRequiredEventTargetImpl;
function requireEventTargetImpl() {
  if (hasRequiredEventTargetImpl) return EventTargetImpl;
  hasRequiredEventTargetImpl = 1;
  Object.defineProperty(EventTargetImpl, "__esModule", { value: true });
  const DOMException_1 = requireDOMException();
  const util_1 = requireUtil$1();
  const algorithm_1 = requireAlgorithm();
  let EventTargetImpl$1 = class EventTargetImpl {
    /**
     * Initializes a new instance of `EventTarget`.
     */
    constructor() {
    }
    get _eventListenerList() {
      return this.__eventListenerList || (this.__eventListenerList = []);
    }
    get _eventHandlerMap() {
      return this.__eventHandlerMap || (this.__eventHandlerMap = {});
    }
    /** @inheritdoc */
    addEventListener(type2, callback, options = { passive: false, once: false, capture: false }) {
      const [capture, passive, once] = algorithm_1.eventTarget_flattenMore(options);
      let listenerCallback;
      if (!callback) {
        return;
      } else if (util_1.Guard.isEventListener(callback)) {
        listenerCallback = callback;
      } else {
        listenerCallback = { handleEvent: callback };
      }
      algorithm_1.eventTarget_addEventListener(this, {
        type: type2,
        callback: listenerCallback,
        capture,
        passive,
        once,
        removed: false
      });
    }
    /** @inheritdoc */
    removeEventListener(type2, callback, options = { capture: false }) {
      const capture = algorithm_1.eventTarget_flatten(options);
      if (!callback)
        return;
      for (let i = 0; i < this._eventListenerList.length; i++) {
        const entry = this._eventListenerList[i];
        if (entry.type !== type2 || entry.capture !== capture)
          continue;
        if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {
          algorithm_1.eventTarget_removeEventListener(this, entry, i);
          break;
        } else if (callback && entry.callback.handleEvent === callback) {
          algorithm_1.eventTarget_removeEventListener(this, entry, i);
          break;
        }
      }
    }
    /** @inheritdoc */
    dispatchEvent(event) {
      if (event._dispatchFlag || !event._initializedFlag) {
        throw new DOMException_1.InvalidStateError();
      }
      event._isTrusted = false;
      return algorithm_1.event_dispatch(event, this);
    }
    /** @inheritdoc */
    _getTheParent(event) {
      return null;
    }
  };
  EventTargetImpl.EventTargetImpl = EventTargetImpl$1;
  return EventTargetImpl;
}
var hasRequiredAbortSignalImpl;
function requireAbortSignalImpl() {
  if (hasRequiredAbortSignalImpl) return AbortSignalImpl;
  hasRequiredAbortSignalImpl = 1;
  Object.defineProperty(AbortSignalImpl, "__esModule", { value: true });
  const EventTargetImpl_1 = requireEventTargetImpl();
  const algorithm_1 = requireAlgorithm();
  let AbortSignalImpl$1 = class AbortSignalImpl2 extends EventTargetImpl_1.EventTargetImpl {
    /**
     * Initializes a new instance of `AbortSignal`.
     */
    constructor() {
      super();
      this._abortedFlag = false;
      this._abortAlgorithms = /* @__PURE__ */ new Set();
    }
    /** @inheritdoc */
    get aborted() {
      return this._abortedFlag;
    }
    /** @inheritdoc */
    get onabort() {
      return algorithm_1.event_getterEventHandlerIDLAttribute(this, "onabort");
    }
    set onabort(val) {
      algorithm_1.event_setterEventHandlerIDLAttribute(this, "onabort", val);
    }
    /**
     * Creates a new `AbortSignal`.
     */
    static _create() {
      return new AbortSignalImpl2();
    }
  };
  AbortSignalImpl.AbortSignalImpl = AbortSignalImpl$1;
  return AbortSignalImpl;
}
var AbstractRangeImpl = {};
var hasRequiredAbstractRangeImpl;
function requireAbstractRangeImpl() {
  if (hasRequiredAbstractRangeImpl) return AbstractRangeImpl;
  hasRequiredAbstractRangeImpl = 1;
  Object.defineProperty(AbstractRangeImpl, "__esModule", { value: true });
  let AbstractRangeImpl$1 = class AbstractRangeImpl {
    get _startNode() {
      return this._start[0];
    }
    get _startOffset() {
      return this._start[1];
    }
    get _endNode() {
      return this._end[0];
    }
    get _endOffset() {
      return this._end[1];
    }
    get _collapsed() {
      return this._start[0] === this._end[0] && this._start[1] === this._end[1];
    }
    /** @inheritdoc */
    get startContainer() {
      return this._startNode;
    }
    /** @inheritdoc */
    get startOffset() {
      return this._startOffset;
    }
    /** @inheritdoc */
    get endContainer() {
      return this._endNode;
    }
    /** @inheritdoc */
    get endOffset() {
      return this._endOffset;
    }
    /** @inheritdoc */
    get collapsed() {
      return this._collapsed;
    }
  };
  AbstractRangeImpl.AbstractRangeImpl = AbstractRangeImpl$1;
  return AbstractRangeImpl;
}
var AttrImpl = {};
var NodeImpl = {};
var URLAlgorithm = {};
var lib$7 = {};
var ObjectCache$1 = {};
var hasRequiredObjectCache$1;
function requireObjectCache$1() {
  if (hasRequiredObjectCache$1) return ObjectCache$1;
  hasRequiredObjectCache$1 = 1;
  Object.defineProperty(ObjectCache$1, "__esModule", { value: true });
  class ObjectCache2 {
    /**
     * Initializes a new instance of `ObjectCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Set();
      this._limit = limit;
    }
    /**
     * Adds a new item to the cache.
     *
     * @param item - an item
     */
    add(item) {
      this._items.add(item);
      if (this._items.size > this._limit) {
        const it2 = this._items.values().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
    }
    /**
     * Removes an item from the cache.
     *
     * @param item - an item
     */
    remove(item) {
      this._items.delete(item);
    }
    /**
     * Removes all items from the cache.
     */
    clear() {
      this._items.clear();
    }
    /**
     * Gets the number of items in the cache.
     */
    get length() {
      return this._items.size;
    }
    /**
     * Iterates through the items in the cache.
     */
    *entries() {
      yield* this;
    }
    /**
     * Iterates through the items in the cache.
     */
    *[Symbol.iterator]() {
      yield* this._items;
    }
  }
  ObjectCache$1.ObjectCache = ObjectCache2;
  return ObjectCache$1;
}
var CompareCache$1 = {};
var hasRequiredCompareCache$1;
function requireCompareCache$1() {
  if (hasRequiredCompareCache$1) return CompareCache$1;
  hasRequiredCompareCache$1 = 1;
  Object.defineProperty(CompareCache$1, "__esModule", { value: true });
  class CompareCache2 {
    /**
     * Initializes a new instance of `CompareCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Map();
      this._limit = limit;
    }
    /**
     * Compares and caches the given objects. Returns `true` if `objA < objB` and
     * `false` otherwise.
     *
     * @param objA - an item to compare
     * @param objB - an item to compare
     */
    check(objA, objB) {
      if (this._items.get(objA) === objB)
        return true;
      else if (this._items.get(objB) === objA)
        return false;
      const result = Math.random() < 0.5;
      if (result) {
        this._items.set(objA, objB);
      } else {
        this._items.set(objB, objA);
      }
      if (this._items.size > this._limit) {
        const it2 = this._items.keys().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
      return result;
    }
  }
  CompareCache$1.CompareCache = CompareCache2;
  return CompareCache$1;
}
var StringWalker = {};
var hasRequiredStringWalker;
function requireStringWalker() {
  if (hasRequiredStringWalker) return StringWalker;
  hasRequiredStringWalker = 1;
  Object.defineProperty(StringWalker, "__esModule", { value: true });
  let StringWalker$1 = class StringWalker {
    /**
     * Initializes a new `StringWalker`.
     *
     * @param input - input string
     */
    constructor(input) {
      this._pointer = 0;
      this._chars = Array.from(input);
      this._length = this._chars.length;
    }
    /**
     * Determines if the current position is beyond the end of string.
     */
    get eof() {
      return this._pointer >= this._length;
    }
    /**
     * Returns the number of code points in the input string.
     */
    get length() {
      return this._length;
    }
    /**
     * Returns the current code point. Returns `-1` if the position is beyond
     * the end of string.
     */
    codePoint() {
      if (this._codePoint === void 0) {
        if (this.eof) {
          this._codePoint = -1;
        } else {
          const cp = this._chars[this._pointer].codePointAt(0);
          if (cp !== void 0) {
            this._codePoint = cp;
          } else {
            this._codePoint = -1;
          }
        }
      }
      return this._codePoint;
    }
    /**
     * Returns the current character. Returns an empty string if the position is
     * beyond the end of string.
     */
    c() {
      if (this._c === void 0) {
        this._c = this.eof ? "" : this._chars[this._pointer];
      }
      return this._c;
    }
    /**
     * Returns the remaining string.
     */
    remaining() {
      if (this._remaining === void 0) {
        this._remaining = this.eof ? "" : this._chars.slice(this._pointer + 1).join("");
      }
      return this._remaining;
    }
    /**
     * Returns the substring from the current character to the end of string.
     */
    substring() {
      if (this._substring === void 0) {
        this._substring = this.eof ? "" : this._chars.slice(this._pointer).join("");
      }
      return this._substring;
    }
    /**
     * Gets or sets the current position.
     */
    get pointer() {
      return this._pointer;
    }
    set pointer(val) {
      if (val === this._pointer)
        return;
      this._pointer = val;
      this._codePoint = void 0;
      this._c = void 0;
      this._remaining = void 0;
      this._substring = void 0;
    }
  };
  StringWalker.StringWalker = StringWalker$1;
  return StringWalker;
}
var hasRequiredLib$7;
function requireLib$7() {
  if (hasRequiredLib$7) return lib$7;
  hasRequiredLib$7 = 1;
  Object.defineProperty(lib$7, "__esModule", { value: true });
  var ObjectCache_1 = requireObjectCache$1();
  lib$7.ObjectCache = ObjectCache_1.ObjectCache;
  var CompareCache_1 = requireCompareCache$1();
  lib$7.CompareCache = CompareCache_1.CompareCache;
  var StringWalker_1 = requireStringWalker();
  lib$7.StringWalker = StringWalker_1.StringWalker;
  function applyMixin(baseClass, mixinClass, ...overrides) {
    Object.getOwnPropertyNames(mixinClass.prototype).forEach((name) => {
      if (overrides.includes(name)) {
        const orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
        if (orgPropDesc) {
          Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
        }
      }
      const propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
      if (propDesc) {
        Object.defineProperty(baseClass.prototype, name, propDesc);
      }
    });
  }
  lib$7.applyMixin = applyMixin;
  function applyDefaults(obj, defaults2, overwrite = false) {
    const result = clone2(obj || {});
    for (const [key, val] of forEachObject(defaults2)) {
      if (isObject(val)) {
        result[key] = applyDefaults(result[key], val);
      } else if (overwrite || result[key] === void 0) {
        result[key] = val;
      }
    }
    return result;
  }
  lib$7.applyDefaults = applyDefaults;
  function* forEachArray(arr) {
    yield* arr;
  }
  lib$7.forEachArray = forEachArray;
  function* forEachObject(obj) {
    if (isMap(obj)) {
      yield* obj;
    } else {
      for (const key in obj) {
        if (!obj.hasOwnProperty(key))
          continue;
        yield [key, obj[key]];
      }
    }
  }
  lib$7.forEachObject = forEachObject;
  function objectLength(obj) {
    if (isMap(obj)) {
      return obj.size;
    } else {
      return Object.keys(obj).length;
    }
  }
  lib$7.objectLength = objectLength;
  function getObjectValue(obj, key) {
    if (isMap(obj)) {
      return obj.get(key);
    } else {
      return obj[key];
    }
  }
  lib$7.getObjectValue = getObjectValue;
  function removeObjectValue(obj, key) {
    if (isMap(obj)) {
      obj.delete(key);
    } else {
      delete obj[key];
    }
  }
  lib$7.removeObjectValue = removeObjectValue;
  function clone2(obj) {
    if (isFunction(obj)) {
      return obj;
    } else if (isArray(obj)) {
      const result = [];
      for (const item of obj) {
        result.push(clone2(item));
      }
      return result;
    } else if (isObject(obj)) {
      const result = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const val = obj[key];
          result[key] = clone2(val);
        }
      }
      return result;
    } else {
      return obj;
    }
  }
  lib$7.clone = clone2;
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  lib$7.isBoolean = isBoolean;
  function isNumber(x) {
    return typeof x === "number";
  }
  lib$7.isNumber = isNumber;
  function isString(x) {
    return typeof x === "string";
  }
  lib$7.isString = isString;
  function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === "[object Function]";
  }
  lib$7.isFunction = isFunction;
  function isObject(x) {
    const type2 = typeof x;
    return !!x && (type2 === "function" || type2 === "object");
  }
  lib$7.isObject = isObject;
  function isArray(x) {
    return Array.isArray(x);
  }
  lib$7.isArray = isArray;
  function isMap(x) {
    return x instanceof Map;
  }
  lib$7.isMap = isMap;
  function isEmpty(x) {
    if (isArray(x)) {
      return !x.length;
    } else if (isObject(x)) {
      for (const key in x) {
        if (x.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  lib$7.isEmpty = isEmpty;
  function isPlainObject(x) {
    if (isObject(x)) {
      const proto = Object.getPrototypeOf(x);
      const ctor = proto.constructor;
      return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }
    return false;
  }
  lib$7.isPlainObject = isPlainObject;
  function isIterable(x) {
    return x && typeof x[Symbol.iterator] === "function";
  }
  lib$7.isIterable = isIterable;
  function getValue(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  }
  lib$7.getValue = getValue;
  function utf8Encode(input) {
    const bytes = new Uint8Array(input.length * 4);
    let byteIndex = 0;
    for (let i = 0; i < input.length; i++) {
      let char = input.charCodeAt(i);
      if (char < 128) {
        bytes[byteIndex++] = char;
        continue;
      } else if (char < 2048) {
        bytes[byteIndex++] = char >> 6 | 192;
      } else {
        if (char > 55295 && char < 56320) {
          if (++i >= input.length) {
            throw new Error("Incomplete surrogate pair.");
          }
          const c2 = input.charCodeAt(i);
          if (c2 < 56320 || c2 > 57343) {
            throw new Error("Invalid surrogate character.");
          }
          char = 65536 + ((char & 1023) << 10) + (c2 & 1023);
          bytes[byteIndex++] = char >> 18 | 240;
          bytes[byteIndex++] = char >> 12 & 63 | 128;
        } else {
          bytes[byteIndex++] = char >> 12 | 224;
        }
        bytes[byteIndex++] = char >> 6 & 63 | 128;
      }
      bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
  }
  lib$7.utf8Encode = utf8Encode;
  function utf8Decode(bytes) {
    let result = "";
    let i = 0;
    while (i < bytes.length) {
      var c = bytes[i++];
      if (c > 127) {
        if (c > 191 && c < 224) {
          if (i >= bytes.length) {
            throw new Error("Incomplete 2-byte sequence.");
          }
          c = (c & 31) << 6 | bytes[i++] & 63;
        } else if (c > 223 && c < 240) {
          if (i + 1 >= bytes.length) {
            throw new Error("Incomplete 3-byte sequence.");
          }
          c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else if (c > 239 && c < 248) {
          if (i + 2 >= bytes.length) {
            throw new Error("Incomplete 4-byte sequence.");
          }
          c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else {
          throw new Error("Unknown multi-byte start.");
        }
      }
      if (c <= 65535) {
        result += String.fromCharCode(c);
      } else if (c <= 1114111) {
        c -= 65536;
        result += String.fromCharCode(c >> 10 | 55296);
        result += String.fromCharCode(c & 1023 | 56320);
      } else {
        throw new Error("Code point exceeds UTF-16 limit.");
      }
    }
    return result;
  }
  lib$7.utf8Decode = utf8Decode;
  return lib$7;
}
var interfaces$1 = {};
var hasRequiredInterfaces$1;
function requireInterfaces$1() {
  if (hasRequiredInterfaces$1) return interfaces$1;
  hasRequiredInterfaces$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    (function(ParserState) {
      ParserState[ParserState["SchemeStart"] = 0] = "SchemeStart";
      ParserState[ParserState["Scheme"] = 1] = "Scheme";
      ParserState[ParserState["NoScheme"] = 2] = "NoScheme";
      ParserState[ParserState["SpecialRelativeOrAuthority"] = 3] = "SpecialRelativeOrAuthority";
      ParserState[ParserState["PathOrAuthority"] = 4] = "PathOrAuthority";
      ParserState[ParserState["Relative"] = 5] = "Relative";
      ParserState[ParserState["RelativeSlash"] = 6] = "RelativeSlash";
      ParserState[ParserState["SpecialAuthoritySlashes"] = 7] = "SpecialAuthoritySlashes";
      ParserState[ParserState["SpecialAuthorityIgnoreSlashes"] = 8] = "SpecialAuthorityIgnoreSlashes";
      ParserState[ParserState["Authority"] = 9] = "Authority";
      ParserState[ParserState["Host"] = 10] = "Host";
      ParserState[ParserState["Hostname"] = 11] = "Hostname";
      ParserState[ParserState["Port"] = 12] = "Port";
      ParserState[ParserState["File"] = 13] = "File";
      ParserState[ParserState["FileSlash"] = 14] = "FileSlash";
      ParserState[ParserState["FileHost"] = 15] = "FileHost";
      ParserState[ParserState["PathStart"] = 16] = "PathStart";
      ParserState[ParserState["Path"] = 17] = "Path";
      ParserState[ParserState["CannotBeABaseURLPath"] = 18] = "CannotBeABaseURLPath";
      ParserState[ParserState["Query"] = 19] = "Query";
      ParserState[ParserState["Fragment"] = 20] = "Fragment";
    })(exports$1.ParserState || (exports$1.ParserState = {}));
    exports$1.OpaqueOrigin = ["", "", null, null];
  })(interfaces$1);
  return interfaces$1;
}
var lib$6 = {};
var Base64 = {};
var CodePoints = {};
var hasRequiredCodePoints;
function requireCodePoints() {
  if (hasRequiredCodePoints) return CodePoints;
  hasRequiredCodePoints = 1;
  Object.defineProperty(CodePoints, "__esModule", { value: true });
  CodePoints.Surrogate = /[\uD800-\uDFFF]/;
  CodePoints.ScalarValue = /[\uD800-\uDFFF]/;
  CodePoints.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
  CodePoints.ASCIICodePoint = /[\u0000-\u007F]/;
  CodePoints.ASCIITabOrNewLine = /[\t\n\r]/;
  CodePoints.ASCIIWhiteSpace = /[\t\n\f\r ]/;
  CodePoints.C0Control = /[\u0000-\u001F]/;
  CodePoints.C0ControlOrSpace = /[\u0000-\u001F ]/;
  CodePoints.Control = /[\u0000-\u001F\u007F-\u009F]/;
  CodePoints.ASCIIDigit = /[0-9]/;
  CodePoints.ASCIIUpperHexDigit = /[0-9A-F]/;
  CodePoints.ASCIILowerHexDigit = /[0-9a-f]/;
  CodePoints.ASCIIHexDigit = /[0-9A-Fa-f]/;
  CodePoints.ASCIIUpperAlpha = /[A-Z]/;
  CodePoints.ASCIILowerAlpha = /[a-z]/;
  CodePoints.ASCIIAlpha = /[A-Za-z]/;
  CodePoints.ASCIIAlphanumeric = /[0-9A-Za-z]/;
  return CodePoints;
}
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return Base64;
  hasRequiredBase64 = 1;
  Object.defineProperty(Base64, "__esModule", { value: true });
  const CodePoints_1 = requireCodePoints();
  function forgivingBase64Encode(input) {
    return Buffer.from(input).toString("base64");
  }
  Base64.forgivingBase64Encode = forgivingBase64Encode;
  function forgivingBase64Decode(input) {
    if (input === "")
      return "";
    input = input.replace(CodePoints_1.ASCIIWhiteSpace, "");
    if (input.length % 4 === 0) {
      if (input.endsWith("==")) {
        input = input.substr(0, input.length - 2);
      } else if (input.endsWith("=")) {
        input = input.substr(0, input.length - 1);
      }
    }
    if (input.length % 4 === 1)
      return null;
    if (!/[0-9A-Za-z+/]/.test(input))
      return null;
    return Buffer.from(input, "base64").toString("utf8");
  }
  Base64.forgivingBase64Decode = forgivingBase64Decode;
  return Base64;
}
var Byte = {};
var hasRequiredByte;
function requireByte() {
  if (hasRequiredByte) return Byte;
  hasRequiredByte = 1;
  Object.defineProperty(Byte, "__esModule", { value: true });
  function isASCIIByte(byte) {
    return byte >= 0 && byte <= 127;
  }
  Byte.isASCIIByte = isASCIIByte;
  return Byte;
}
var ByteSequence = {};
var hasRequiredByteSequence;
function requireByteSequence() {
  if (hasRequiredByteSequence) return ByteSequence;
  hasRequiredByteSequence = 1;
  Object.defineProperty(ByteSequence, "__esModule", { value: true });
  function length(list) {
    return list.length;
  }
  ByteSequence.length = length;
  function byteLowercase(list) {
    for (let i = 0; i < list.length; i++) {
      const c = list[i];
      if (c >= 65 && c <= 90) {
        list[i] = c + 32;
      }
    }
  }
  ByteSequence.byteLowercase = byteLowercase;
  function byteUppercase(list) {
    for (let i = 0; i < list.length; i++) {
      const c = list[i];
      if (c >= 97 && c <= 122) {
        list[i] = c - 32;
      }
    }
  }
  ByteSequence.byteUppercase = byteUppercase;
  function byteCaseInsensitiveMatch(listA, listB) {
    if (listA.length !== listB.length)
      return false;
    for (let i = 0; i < listA.length; i++) {
      let a = listA[i];
      let b = listB[i];
      if (a >= 65 && a <= 90)
        a += 32;
      if (b >= 65 && b <= 90)
        b += 32;
      if (a !== b)
        return false;
    }
    return true;
  }
  ByteSequence.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
  function startsWith(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      if (listA[i] !== listB[i])
        return false;
      i++;
    }
  }
  ByteSequence.startsWith = startsWith;
  function byteLessThan(listA, listB) {
    let i = 0;
    while (true) {
      if (i >= listA.length)
        return false;
      if (i >= listB.length)
        return true;
      const a = listA[i];
      const b = listB[i];
      if (a < b)
        return true;
      else if (a > b)
        return false;
      i++;
    }
  }
  ByteSequence.byteLessThan = byteLessThan;
  function isomorphicDecode(list) {
    return String.fromCodePoint(...list);
  }
  ByteSequence.isomorphicDecode = isomorphicDecode;
  return ByteSequence;
}
var _JSON = {};
var lib$5 = {};
var ObjectCache = {};
var hasRequiredObjectCache;
function requireObjectCache() {
  if (hasRequiredObjectCache) return ObjectCache;
  hasRequiredObjectCache = 1;
  Object.defineProperty(ObjectCache, "__esModule", { value: true });
  let ObjectCache$12 = class ObjectCache {
    /**
     * Initializes a new instance of `ObjectCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Set();
      this._limit = limit;
    }
    /**
     * Adds a new item to the cache.
     *
     * @param item - an item
     */
    add(item) {
      this._items.add(item);
      if (this._items.size > this._limit) {
        const it2 = this._items.values().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
    }
    /**
     * Removes an item from the cache.
     *
     * @param item - an item
     */
    remove(item) {
      this._items.delete(item);
    }
    /**
     * Removes all items from the cache.
     */
    clear() {
      this._items.clear();
    }
    /**
     * Gets the number of items in the cache.
     */
    get length() {
      return this._items.size;
    }
    /**
     * Iterates through the items in the cache.
     */
    *entries() {
      yield* this;
    }
    /** @inheritdoc */
    *[Symbol.iterator]() {
      for (const item of this._items) {
        yield item;
      }
    }
  };
  ObjectCache.ObjectCache = ObjectCache$12;
  return ObjectCache;
}
var CompareCache = {};
var hasRequiredCompareCache;
function requireCompareCache() {
  if (hasRequiredCompareCache) return CompareCache;
  hasRequiredCompareCache = 1;
  Object.defineProperty(CompareCache, "__esModule", { value: true });
  let CompareCache$12 = class CompareCache {
    /**
     * Initializes a new instance of `CompareCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    constructor(limit = 1e3) {
      this._items = /* @__PURE__ */ new Map();
      this._limit = limit;
    }
    /**
     * Compares and caches the given objects. Returns `true` if `objA < objB` and
     * `false` otherwise.
     *
     * @param objA - an item to compare
     * @param objB - an item to compare
     */
    check(objA, objB) {
      if (this._items.get(objA) === objB)
        return true;
      else if (this._items.get(objB) === objA)
        return false;
      const result = Math.random() < 0.5;
      if (result) {
        this._items.set(objA, objB);
      } else {
        this._items.set(objB, objA);
      }
      if (this._items.size > this._limit) {
        const it2 = this._items.keys().next();
        if (!it2.done) {
          this._items.delete(it2.value);
        }
      }
      return result;
    }
  };
  CompareCache.CompareCache = CompareCache$12;
  return CompareCache;
}
var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$5;
  hasRequiredLib$6 = 1;
  Object.defineProperty(lib$5, "__esModule", { value: true });
  var ObjectCache_1 = requireObjectCache();
  lib$5.ObjectCache = ObjectCache_1.ObjectCache;
  var CompareCache_1 = requireCompareCache();
  lib$5.CompareCache = CompareCache_1.CompareCache;
  function applyMixin(baseClass, mixinClass, ...overrides) {
    Object.getOwnPropertyNames(mixinClass.prototype).forEach((name) => {
      if (overrides.includes(name)) {
        const orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
        if (orgPropDesc) {
          Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
        }
      }
      const propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
      if (propDesc) {
        Object.defineProperty(baseClass.prototype, name, propDesc);
      }
    });
  }
  lib$5.applyMixin = applyMixin;
  function applyDefaults(obj, defaults2, overwrite = false) {
    const result = clone2(obj || {});
    for (const [key, val] of forEachObject(defaults2)) {
      if (isObject(val)) {
        result[key] = applyDefaults(result[key], val);
      } else if (overwrite || result[key] === void 0) {
        result[key] = val;
      }
    }
    return result;
  }
  lib$5.applyDefaults = applyDefaults;
  function* forEachArray(arr) {
    yield* arr;
  }
  lib$5.forEachArray = forEachArray;
  function* forEachObject(obj) {
    if (isMap(obj)) {
      yield* obj;
    } else {
      for (const key in obj) {
        if (!obj.hasOwnProperty(key))
          continue;
        yield [key, obj[key]];
      }
    }
  }
  lib$5.forEachObject = forEachObject;
  function objectLength(obj) {
    if (isMap(obj)) {
      return obj.size;
    } else {
      return Object.keys(obj).length;
    }
  }
  lib$5.objectLength = objectLength;
  function getObjectValue(obj, key) {
    if (isMap(obj)) {
      return obj.get(key);
    } else {
      return obj[key];
    }
  }
  lib$5.getObjectValue = getObjectValue;
  function removeObjectValue(obj, key) {
    if (isMap(obj)) {
      obj.delete(key);
    } else {
      delete obj[key];
    }
  }
  lib$5.removeObjectValue = removeObjectValue;
  function clone2(obj) {
    if (isFunction(obj)) {
      return obj;
    } else if (isArray(obj)) {
      const result = [];
      for (const item of obj) {
        result.push(clone2(item));
      }
      return result;
    } else if (isObject(obj)) {
      const result = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const val = obj[key];
          result[key] = clone2(val);
        }
      }
      return result;
    } else {
      return obj;
    }
  }
  lib$5.clone = clone2;
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  lib$5.isBoolean = isBoolean;
  function isNumber(x) {
    return typeof x === "number";
  }
  lib$5.isNumber = isNumber;
  function isString(x) {
    return typeof x === "string";
  }
  lib$5.isString = isString;
  function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === "[object Function]";
  }
  lib$5.isFunction = isFunction;
  function isObject(x) {
    const type2 = typeof x;
    return !!x && (type2 === "function" || type2 === "object");
  }
  lib$5.isObject = isObject;
  function isArray(x) {
    return Array.isArray(x);
  }
  lib$5.isArray = isArray;
  function isMap(x) {
    return x instanceof Map;
  }
  lib$5.isMap = isMap;
  function isEmpty(x) {
    if (isArray(x)) {
      return !x.length;
    } else if (isObject(x)) {
      for (const key in x) {
        if (x.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  lib$5.isEmpty = isEmpty;
  function isPlainObject(x) {
    if (isObject(x)) {
      const proto = Object.getPrototypeOf(x);
      const ctor = proto.constructor;
      return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }
    return false;
  }
  lib$5.isPlainObject = isPlainObject;
  function isIterable(x) {
    return x && typeof x[Symbol.iterator] === "function";
  }
  lib$5.isIterable = isIterable;
  function getValue(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  }
  lib$5.getValue = getValue;
  return lib$5;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  function utf8Encode(input) {
    const bytes = new Uint8Array(input.length * 4);
    let byteIndex = 0;
    for (let i = 0; i < input.length; i++) {
      let char = input.charCodeAt(i);
      if (char < 128) {
        bytes[byteIndex++] = char;
        continue;
      } else if (char < 2048) {
        bytes[byteIndex++] = char >> 6 | 192;
      } else {
        if (char > 55295 && char < 56320) {
          if (++i >= input.length) {
            throw new Error("Incomplete surrogate pair.");
          }
          const c2 = input.charCodeAt(i);
          if (c2 < 56320 || c2 > 57343) {
            throw new Error("Invalid surrogate character.");
          }
          char = 65536 + ((char & 1023) << 10) + (c2 & 1023);
          bytes[byteIndex++] = char >> 18 | 240;
          bytes[byteIndex++] = char >> 12 & 63 | 128;
        } else {
          bytes[byteIndex++] = char >> 12 | 224;
        }
        bytes[byteIndex++] = char >> 6 & 63 | 128;
      }
      bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
  }
  util.utf8Encode = utf8Encode;
  function utf8Decode(bytes) {
    let result = "";
    let i = 0;
    while (i < bytes.length) {
      var c = bytes[i++];
      if (c > 127) {
        if (c > 191 && c < 224) {
          if (i >= bytes.length) {
            throw new Error("Incomplete 2-byte sequence.");
          }
          c = (c & 31) << 6 | bytes[i++] & 63;
        } else if (c > 223 && c < 240) {
          if (i + 1 >= bytes.length) {
            throw new Error("Incomplete 3-byte sequence.");
          }
          c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else if (c > 239 && c < 248) {
          if (i + 2 >= bytes.length) {
            throw new Error("Incomplete 4-byte sequence.");
          }
          c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
        } else {
          throw new Error("Unknown multi-byte start.");
        }
      }
      if (c <= 65535) {
        result += String.fromCharCode(c);
      } else if (c <= 1114111) {
        c -= 65536;
        result += String.fromCharCode(c >> 10 | 55296);
        result += String.fromCharCode(c & 1023 | 56320);
      } else {
        throw new Error("Code point exceeds UTF-16 limit.");
      }
    }
    return result;
  }
  util.utf8Decode = utf8Decode;
  return util;
}
var hasRequired_JSON;
function require_JSON() {
  if (hasRequired_JSON) return _JSON;
  hasRequired_JSON = 1;
  Object.defineProperty(_JSON, "__esModule", { value: true });
  const util_1 = requireLib$6();
  const util_2 = requireUtil();
  function parseJSONFromBytes(bytes) {
    const jsonText = util_2.utf8Decode(bytes);
    return JSON.parse.call(void 0, jsonText);
  }
  _JSON.parseJSONFromBytes = parseJSONFromBytes;
  function serializeJSONToBytes(value) {
    const jsonString = JSON.stringify.call(void 0, value);
    return util_2.utf8Encode(jsonString);
  }
  _JSON.serializeJSONToBytes = serializeJSONToBytes;
  function parseJSONIntoInfraValues(jsonText) {
    const jsValue = JSON.parse.call(void 0, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
  }
  _JSON.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
  function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue))
      return jsValue;
    if (util_1.isArray(jsValue)) {
      const result = new Array();
      for (const jsValueAtIndex of jsValue) {
        result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
      }
      return result;
    } else if (util_1.isObject(jsValue)) {
      const result = /* @__PURE__ */ new Map();
      for (const key in jsValue) {
        if (jsValue.hasOwnProperty(key)) {
          const jsValueAtKey = jsValue[key];
          result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
        }
      }
      return result;
    }
    return jsValue;
  }
  _JSON.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
  return _JSON;
}
var List = {};
var hasRequiredList;
function requireList() {
  if (hasRequiredList) return List;
  hasRequiredList = 1;
  Object.defineProperty(List, "__esModule", { value: true });
  const util_1 = requireLib$6();
  function append(list, item) {
    list.push(item);
  }
  List.append = append;
  function extend(listA, listB) {
    listA.push(...listB);
  }
  List.extend = extend;
  function prepend(list, item) {
    list.unshift(item);
  }
  List.prepend = prepend;
  function replace(list, conditionOrItem, newItem) {
    let i = 0;
    for (const oldItem of list) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list[i] = newItem;
        }
      } else if (oldItem === conditionOrItem) {
        list[i] = newItem;
        return;
      }
      i++;
    }
  }
  List.replace = replace;
  function insert(list, item, index) {
    list.splice(index, 0, item);
  }
  List.insert = insert;
  function remove(list, conditionOrItem) {
    let i = list.length;
    while (i--) {
      const oldItem = list[i];
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          list.splice(i, 1);
        }
      } else if (oldItem === conditionOrItem) {
        list.splice(i, 1);
        return;
      }
    }
  }
  List.remove = remove;
  function empty2(list) {
    list.length = 0;
  }
  List.empty = empty2;
  function contains(list, conditionOrItem) {
    for (const oldItem of list) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      } else if (oldItem === conditionOrItem) {
        return true;
      }
    }
    return false;
  }
  List.contains = contains;
  function size(list, condition) {
    if (condition === void 0) {
      return list.length;
    } else {
      let count = 0;
      for (const item of list) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  List.size = size;
  function isEmpty(list) {
    return list.length === 0;
  }
  List.isEmpty = isEmpty;
  function* forEach(list, condition) {
    if (condition === void 0) {
      yield* list;
    } else {
      for (const item of list) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  List.forEach = forEach;
  function clone2(list) {
    return new Array(...list);
  }
  List.clone = clone2;
  function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
  }
  List.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
  }
  List.sortInDescendingOrder = sortInDescendingOrder;
  return List;
}
var _Map = {};
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  Object.defineProperty(_Map, "__esModule", { value: true });
  const util_1 = requireLib$6();
  function get2(map2, key) {
    return map2.get(key);
  }
  _Map.get = get2;
  function set(map2, key, val) {
    map2.set(key, val);
  }
  _Map.set = set;
  function remove(map2, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      map2.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of map2) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item[0]);
        }
      }
      for (const key of toRemove) {
        map2.delete(key);
      }
    }
  }
  _Map.remove = remove;
  function contains(map2, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      return map2.has(conditionOrItem);
    } else {
      for (const item of map2) {
        if (!!conditionOrItem.call(null, item)) {
          return true;
        }
      }
      return false;
    }
  }
  _Map.contains = contains;
  function keys(map2) {
    return new Set(map2.keys());
  }
  _Map.keys = keys;
  function values(map2) {
    return [...map2.values()];
  }
  _Map.values = values;
  function size(map2, condition) {
    if (condition === void 0) {
      return map2.size;
    } else {
      let count = 0;
      for (const item of map2) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  _Map.size = size;
  function isEmpty(map2) {
    return map2.size === 0;
  }
  _Map.isEmpty = isEmpty;
  function* forEach(map2, condition) {
    if (condition === void 0) {
      yield* map2;
    } else {
      for (const item of map2) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  _Map.forEach = forEach;
  function clone2(map2) {
    return new Map(map2);
  }
  _Map.clone = clone2;
  function sortInAscendingOrder(map2, lessThanAlgo) {
    const list = new Array(...map2);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Map(list);
  }
  _Map.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(map2, lessThanAlgo) {
    const list = new Array(...map2);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Map(list);
  }
  _Map.sortInDescendingOrder = sortInDescendingOrder;
  return _Map;
}
var Namespace = {};
var hasRequiredNamespace;
function requireNamespace() {
  if (hasRequiredNamespace) return Namespace;
  hasRequiredNamespace = 1;
  Object.defineProperty(Namespace, "__esModule", { value: true });
  Namespace.HTML = "http://www.w3.org/1999/xhtml";
  Namespace.XML = "http://www.w3.org/XML/1998/namespace";
  Namespace.XMLNS = "http://www.w3.org/2000/xmlns/";
  Namespace.MathML = "http://www.w3.org/1998/Math/MathML";
  Namespace.SVG = "http://www.w3.org/2000/svg";
  Namespace.XLink = "http://www.w3.org/1999/xlink";
  return Namespace;
}
var Queue$1 = {};
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return Queue$1;
  hasRequiredQueue = 1;
  Object.defineProperty(Queue$1, "__esModule", { value: true });
  function enqueue(list, item) {
    list.push(item);
  }
  Queue$1.enqueue = enqueue;
  function dequeue(list) {
    return list.shift() || null;
  }
  Queue$1.dequeue = dequeue;
  return Queue$1;
}
var _Set = {};
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set) return _Set;
  hasRequired_Set = 1;
  Object.defineProperty(_Set, "__esModule", { value: true });
  const util_1 = requireLib$6();
  function append(set, item) {
    set.add(item);
  }
  _Set.append = append;
  function extend(setA, setB) {
    setB.forEach(setA.add, setA);
  }
  _Set.extend = extend;
  function prepend(set, item) {
    const cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
  }
  _Set.prepend = prepend;
  function replace(set, conditionOrItem, newItem) {
    const newSet = /* @__PURE__ */ new Set();
    for (const oldItem of set) {
      if (util_1.isFunction(conditionOrItem)) {
        if (!!conditionOrItem.call(null, oldItem)) {
          newSet.add(newItem);
        } else {
          newSet.add(oldItem);
        }
      } else if (oldItem === conditionOrItem) {
        newSet.add(newItem);
      } else {
        newSet.add(oldItem);
      }
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  _Set.replace = replace;
  function insert(set, item, index) {
    const newSet = /* @__PURE__ */ new Set();
    let i = 0;
    for (const oldItem of set) {
      if (i === index)
        newSet.add(item);
      newSet.add(oldItem);
      i++;
    }
    set.clear();
    newSet.forEach(set.add, set);
  }
  _Set.insert = insert;
  function remove(set, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      set.delete(conditionOrItem);
    } else {
      const toRemove = [];
      for (const item of set) {
        if (!!conditionOrItem.call(null, item)) {
          toRemove.push(item);
        }
      }
      for (const oldItem of toRemove) {
        set.delete(oldItem);
      }
    }
  }
  _Set.remove = remove;
  function empty2(set) {
    set.clear();
  }
  _Set.empty = empty2;
  function contains(set, conditionOrItem) {
    if (!util_1.isFunction(conditionOrItem)) {
      return set.has(conditionOrItem);
    } else {
      for (const oldItem of set) {
        if (!!conditionOrItem.call(null, oldItem)) {
          return true;
        }
      }
    }
    return false;
  }
  _Set.contains = contains;
  function size(set, condition) {
    if (condition === void 0) {
      return set.size;
    } else {
      let count = 0;
      for (const item of set) {
        if (!!condition.call(null, item)) {
          count++;
        }
      }
      return count;
    }
  }
  _Set.size = size;
  function isEmpty(set) {
    return set.size === 0;
  }
  _Set.isEmpty = isEmpty;
  function* forEach(set, condition) {
    if (condition === void 0) {
      yield* set;
    } else {
      for (const item of set) {
        if (!!condition.call(null, item)) {
          yield item;
        }
      }
    }
  }
  _Set.forEach = forEach;
  function clone2(set) {
    return new Set(set);
  }
  _Set.clone = clone2;
  function sortInAscendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
    return new Set(list);
  }
  _Set.sortInAscendingOrder = sortInAscendingOrder;
  function sortInDescendingOrder(set, lessThanAlgo) {
    const list = new Array(...set);
    list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
    return new Set(list);
  }
  _Set.sortInDescendingOrder = sortInDescendingOrder;
  function isSubsetOf(subset2, superset) {
    for (const item of subset2) {
      if (!superset.has(item))
        return false;
    }
    return true;
  }
  _Set.isSubsetOf = isSubsetOf;
  function isSupersetOf(superset, subset2) {
    return isSubsetOf(subset2, superset);
  }
  _Set.isSupersetOf = isSupersetOf;
  function intersection(setA, setB) {
    const newSet = /* @__PURE__ */ new Set();
    for (const item of setA) {
      if (setB.has(item))
        newSet.add(item);
    }
    return newSet;
  }
  _Set.intersection = intersection;
  function union(setA, setB) {
    const newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
  }
  _Set.union = union;
  function range2(n, m) {
    const newSet = /* @__PURE__ */ new Set();
    for (let i = n; i <= m; i++) {
      newSet.add(i);
    }
    return newSet;
  }
  _Set.range = range2;
  return _Set;
}
var Stack = {};
var hasRequiredStack;
function requireStack() {
  if (hasRequiredStack) return Stack;
  hasRequiredStack = 1;
  Object.defineProperty(Stack, "__esModule", { value: true });
  function push(list, item) {
    list.push(item);
  }
  Stack.push = push;
  function pop(list) {
    return list.pop() || null;
  }
  Stack.pop = pop;
  return Stack;
}
var _String = {};
var hasRequired_String;
function require_String() {
  if (hasRequired_String) return _String;
  hasRequired_String = 1;
  Object.defineProperty(_String, "__esModule", { value: true });
  const CodePoints_1 = requireCodePoints();
  const ByteSequence_1 = requireByteSequence();
  const Byte_1 = requireByte();
  const util_1 = requireLib$6();
  function isCodeUnitPrefix(a, b) {
    let i = 0;
    while (true) {
      const aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
      const bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
      if (aCodeUnit === null)
        return true;
      if (aCodeUnit !== bCodeUnit)
        return false;
      i++;
    }
  }
  _String.isCodeUnitPrefix = isCodeUnitPrefix;
  function isCodeUnitLessThan(a, b) {
    if (isCodeUnitPrefix(b, a))
      return false;
    if (isCodeUnitPrefix(a, b))
      return true;
    for (let i = 0; i < Math.min(a.length, b.length); i++) {
      const aCodeUnit = a.charCodeAt(i);
      const bCodeUnit = b.charCodeAt(i);
      if (aCodeUnit === bCodeUnit)
        continue;
      return aCodeUnit < bCodeUnit;
    }
    return false;
  }
  _String.isCodeUnitLessThan = isCodeUnitLessThan;
  function isomorphicEncode(str) {
    const codePoints = Array.from(str);
    const bytes = new Uint8Array(codePoints.length);
    let i = 0;
    for (const codePoint of str) {
      const byte = codePoint.codePointAt(0);
      console.assert(byte !== void 0 && byte <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
      if (byte !== void 0 && byte <= 255) {
        bytes[i++] = byte;
      }
    }
    return bytes;
  }
  _String.isomorphicEncode = isomorphicEncode;
  function isASCIIString(str) {
    return /^[\u0000-\u007F]*$/.test(str);
  }
  _String.isASCIIString = isASCIIString;
  function asciiLowercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== void 0 && code >= 65 && code <= 90) {
        result += String.fromCodePoint(code + 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  _String.asciiLowercase = asciiLowercase;
  function asciiUppercase(str) {
    let result = "";
    for (const c of str) {
      const code = c.codePointAt(0);
      if (code !== void 0 && code >= 97 && code <= 122) {
        result += String.fromCodePoint(code - 32);
      } else {
        result += c;
      }
    }
    return result;
  }
  _String.asciiUppercase = asciiUppercase;
  function asciiCaseInsensitiveMatch(a, b) {
    return asciiLowercase(a) === asciiLowercase(b);
  }
  _String.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
  function asciiEncode(str) {
    console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
  }
  _String.asciiEncode = asciiEncode;
  function asciiDecode(bytes) {
    for (const byte of bytes) {
      console.assert(Byte_1.isASCIIByte(byte), "asciiDecode requires an ASCII byte sequence.");
    }
    return ByteSequence_1.isomorphicDecode(bytes);
  }
  _String.asciiDecode = asciiDecode;
  function stripNewlines(str) {
    return str.replace(/[\n\r]/g, "");
  }
  _String.stripNewlines = stripNewlines;
  function normalizeNewlines(str) {
    return str.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  }
  _String.normalizeNewlines = normalizeNewlines;
  function stripLeadingAndTrailingASCIIWhitespace(str) {
    return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
  }
  _String.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
  function stripAndCollapseASCIIWhitespace(str) {
    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
  }
  _String.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
  function collectASequenceOfCodePoints(condition, input, options) {
    if (!util_1.isArray(input))
      return collectASequenceOfCodePoints(condition, Array.from(input), options);
    let result = "";
    while (options.position < input.length && !!condition.call(null, input[options.position])) {
      result += input[options.position];
      options.position++;
    }
    return result;
  }
  _String.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
  function skipASCIIWhitespace(input, options) {
    collectASequenceOfCodePoints((str) => CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
  }
  _String.skipASCIIWhitespace = skipASCIIWhitespace;
  function strictlySplit(input, delimiter) {
    if (!util_1.isArray(input))
      return strictlySplit(Array.from(input), delimiter);
    const options = { position: 0 };
    const tokens = [];
    let token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
    tokens.push(token);
    while (options.position < input.length) {
      console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
      options.position++;
      token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
      tokens.push(token);
    }
    return tokens;
  }
  _String.strictlySplit = strictlySplit;
  function splitAStringOnASCIIWhitespace(input) {
    if (!util_1.isArray(input))
      return splitAStringOnASCIIWhitespace(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    skipASCIIWhitespace(input, options);
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => !CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
      tokens.push(token);
      skipASCIIWhitespace(input, options);
    }
    return tokens;
  }
  _String.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
  function splitAStringOnCommas(input) {
    if (!util_1.isArray(input))
      return splitAStringOnCommas(Array.from(input));
    const options = { position: 0 };
    const tokens = [];
    while (options.position < input.length) {
      const token = collectASequenceOfCodePoints((str) => str !== ",", input, options);
      tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
      if (options.position < input.length) {
        console.assert(input[options.position] === ",", "splitAStringOnCommas found no delimiter in input string.");
        options.position++;
      }
    }
    return tokens;
  }
  _String.splitAStringOnCommas = splitAStringOnCommas;
  function concatenate(list, separator = "") {
    if (list.length === 0)
      return "";
    return list.join(separator);
  }
  _String.concatenate = concatenate;
  return _String;
}
var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$6;
  hasRequiredLib$5 = 1;
  var __importStar = lib$6 && lib$6.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(lib$6, "__esModule", { value: true });
  const base642 = __importStar(requireBase64());
  lib$6.base64 = base642;
  const byte = __importStar(requireByte());
  lib$6.byte = byte;
  const byteSequence = __importStar(requireByteSequence());
  lib$6.byteSequence = byteSequence;
  const codePoint = __importStar(requireCodePoints());
  lib$6.codePoint = codePoint;
  const json = __importStar(require_JSON());
  lib$6.json = json;
  const list = __importStar(requireList());
  lib$6.list = list;
  const map2 = __importStar(require_Map());
  lib$6.map = map2;
  const namespace = __importStar(requireNamespace());
  lib$6.namespace = namespace;
  const queue2 = __importStar(requireQueue());
  lib$6.queue = queue2;
  const set = __importStar(require_Set());
  lib$6.set = set;
  const stack = __importStar(requireStack());
  lib$6.stack = stack;
  const string = __importStar(require_String());
  lib$6.string = string;
  return lib$6;
}
var hasRequiredURLAlgorithm;
function requireURLAlgorithm() {
  if (hasRequiredURLAlgorithm) return URLAlgorithm;
  hasRequiredURLAlgorithm = 1;
  Object.defineProperty(URLAlgorithm, "__esModule", { value: true });
  const util_1 = requireLib$7();
  const interfaces_1 = requireInterfaces$1();
  const infra_1 = requireLib$5();
  const url_1 = Url;
  let _validationErrorCallback;
  const _defaultPorts = {
    "ftp": 21,
    "file": null,
    "http": 80,
    "https": 443,
    "ws": 80,
    "wss": 443
  };
  const _c0ControlPercentEncodeSet = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  const _fragmentPercentEncodeSet = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  const _pathPercentEncodeSet = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  const _userInfoPercentEncodeSet = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  const _urlCodePoints = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/;
  const _forbiddenHostCodePoint = /[\0\t\f\r #%/:?@\[\\\]]/;
  function setValidationErrorCallback(validationErrorCallback) {
    _validationErrorCallback = validationErrorCallback;
  }
  URLAlgorithm.setValidationErrorCallback = setValidationErrorCallback;
  function validationError(message) {
    if (_validationErrorCallback !== void 0) {
      _validationErrorCallback.call(null, "Validation Error: " + message);
    }
  }
  function newURL() {
    return {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,
      _cannotBeABaseURLFlag: false,
      _blobURLEntry: null
    };
  }
  URLAlgorithm.newURL = newURL;
  function isSpecialScheme(scheme) {
    return scheme in _defaultPorts;
  }
  URLAlgorithm.isSpecialScheme = isSpecialScheme;
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  URLAlgorithm.isSpecial = isSpecial;
  function defaultPort(scheme) {
    return _defaultPorts[scheme] || null;
  }
  URLAlgorithm.defaultPort = defaultPort;
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  URLAlgorithm.includesCredentials = includesCredentials;
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url._cannotBeABaseURLFlag || url.scheme === "file";
  }
  URLAlgorithm.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  function urlSerializer(url, excludeFragmentFlag = false) {
    let output = url.scheme + ":";
    if (url.host !== null) {
      output += "//";
      if (includesCredentials(url)) {
        output += url.username;
        if (url.password !== "") {
          output += ":" + url.password;
        }
        output += "@";
      }
      output += hostSerializer(url.host);
      if (url.port !== null) {
        output += ":" + url.port;
      }
    } else if (url.host === null && url.scheme === "file") {
      output += "//";
    }
    if (url._cannotBeABaseURLFlag) {
      output += url.path[0];
    } else {
      for (const str of url.path) {
        output += "/" + str;
      }
    }
    if (url.query !== null) {
      output += "?" + url.query;
    }
    if (!excludeFragmentFlag && url.fragment !== null) {
      output += "#" + url.fragment;
    }
    return output;
  }
  URLAlgorithm.urlSerializer = urlSerializer;
  function hostSerializer(host) {
    if (util_1.isNumber(host)) {
      return iPv4Serializer(host);
    } else if (util_1.isArray(host)) {
      return "[" + iPv6Serializer(host) + "]";
    } else {
      return host;
    }
  }
  URLAlgorithm.hostSerializer = hostSerializer;
  function iPv4Serializer(address) {
    let output = "";
    let n = address;
    for (let i = 1; i <= 4; i++) {
      output = (n % 256).toString() + output;
      if (i !== 4) {
        output = "." + output;
      }
      n = Math.floor(n / 256);
    }
    return output;
  }
  URLAlgorithm.iPv4Serializer = iPv4Serializer;
  function iPv6Serializer(address) {
    let output = "";
    let compress = null;
    let lastIndex = -1;
    let count = 0;
    let lastCount = 0;
    for (let i = 0; i < 8; i++) {
      if (address[i] !== 0)
        continue;
      count = 1;
      for (let j = i + 1; j < 8; j++) {
        if (address[j] !== 0)
          break;
        count++;
        continue;
      }
      if (count > lastCount) {
        lastCount = count;
        lastIndex = i;
      }
    }
    if (lastCount > 1)
      compress = lastIndex;
    let ignore0 = false;
    for (let pieceIndex = 0; pieceIndex < 8; pieceIndex++) {
      if (ignore0 && address[pieceIndex] === 0)
        continue;
      if (ignore0)
        ignore0 = false;
      if (compress === pieceIndex) {
        output += pieceIndex === 0 ? "::" : ":";
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7)
        output += ":";
    }
    return output;
  }
  URLAlgorithm.iPv6Serializer = iPv6Serializer;
  function urlParser(input, baseURL, encodingOverride) {
    const url = basicURLParser(input, baseURL, encodingOverride);
    if (url === null)
      return null;
    if (url.scheme !== "blob")
      return url;
    {
      url._blobURLEntry = null;
    }
    return url;
  }
  URLAlgorithm.urlParser = urlParser;
  function basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {
    if (url === void 0) {
      url = newURL();
      const leadingControlOrSpace = /^[\u0000-\u001F\u0020]+/;
      const trailingControlOrSpace = /[\u0000-\u001F\u0020]+$/;
      if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {
        validationError("Input string contains leading or trailing control characters or space.");
      }
      input = input.replace(leadingControlOrSpace, "");
      input = input.replace(trailingControlOrSpace, "");
    }
    const tabOrNewline = /[\u0009\u000A\u000D]/g;
    if (tabOrNewline.test(input)) {
      validationError("Input string contains tab or newline characters.");
    }
    input = input.replace(tabOrNewline, "");
    let state2 = stateOverride === void 0 ? interfaces_1.ParserState.SchemeStart : stateOverride;
    if (baseURL === void 0)
      baseURL = null;
    let encoding = encodingOverride === void 0 || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    let buffer = "";
    let atFlag = false;
    let arrayFlag = false;
    let passwordTokenSeenFlag = false;
    const EOF = "";
    const walker = new util_1.StringWalker(input);
    while (true) {
      switch (state2) {
        case interfaces_1.ParserState.SchemeStart:
          if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {
            buffer += walker.c().toLowerCase();
            state2 = interfaces_1.ParserState.Scheme;
          } else if (stateOverride === void 0) {
            state2 = interfaces_1.ParserState.NoScheme;
            walker.pointer--;
          } else {
            validationError("Invalid scheme start character.");
            return null;
          }
          break;
        case interfaces_1.ParserState.Scheme:
          if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) || walker.c() === "+" || walker.c() === "-" || walker.c() === ".") {
            buffer += walker.c().toLowerCase();
          } else if (walker.c() === ":") {
            if (stateOverride !== void 0) {
              if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer))
                return url;
              if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer))
                return url;
              if ((includesCredentials(url) || url.port !== null) && buffer === "file")
                return url;
              if (url.scheme === "file" && (url.host === "" || url.host === null))
                return url;
            }
            url.scheme = buffer;
            if (stateOverride !== void 0) {
              if (url.port === defaultPort(url.scheme)) {
                url.port = null;
              }
              return url;
            }
            buffer = "";
            if (url.scheme === "file") {
              if (!walker.remaining().startsWith("//")) {
                validationError("Invalid file URL scheme, '//' expected.");
              }
              state2 = interfaces_1.ParserState.File;
            } else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {
              state2 = interfaces_1.ParserState.SpecialRelativeOrAuthority;
            } else if (isSpecial(url)) {
              state2 = interfaces_1.ParserState.SpecialAuthoritySlashes;
            } else if (walker.remaining().startsWith("/")) {
              state2 = interfaces_1.ParserState.PathOrAuthority;
              walker.pointer++;
            } else {
              url._cannotBeABaseURLFlag = true;
              url.path.push("");
              state2 = interfaces_1.ParserState.CannotBeABaseURLPath;
            }
          } else if (stateOverride === void 0) {
            buffer = "";
            state2 = interfaces_1.ParserState.NoScheme;
            walker.pointer = 0;
            continue;
          } else {
            validationError("Invalid input string.");
            return null;
          }
          break;
        case interfaces_1.ParserState.NoScheme:
          if (baseURL === null || baseURL._cannotBeABaseURLFlag && walker.c() !== "#") {
            validationError("Invalid input string.");
            return null;
          } else if (baseURL._cannotBeABaseURLFlag && walker.c() === "#") {
            url.scheme = baseURL.scheme;
            url.path = infra_1.list.clone(baseURL.path);
            url.query = baseURL.query;
            url.fragment = "";
            url._cannotBeABaseURLFlag = true;
            state2 = interfaces_1.ParserState.Fragment;
          } else if (baseURL.scheme !== "file") {
            state2 = interfaces_1.ParserState.Relative;
            walker.pointer--;
          } else {
            state2 = interfaces_1.ParserState.File;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialRelativeOrAuthority:
          if (walker.c() === "/" && walker.remaining().startsWith("/")) {
            state2 = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer++;
          } else {
            validationError("Invalid input string.");
            state2 = interfaces_1.ParserState.Relative;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.PathOrAuthority:
          if (walker.c() === "/") {
            state2 = interfaces_1.ParserState.Authority;
          } else {
            state2 = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.Relative:
          if (baseURL === null) {
            throw new Error("Invalid parser state. Base URL is null.");
          }
          url.scheme = baseURL.scheme;
          switch (walker.c()) {
            case EOF:
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = baseURL.query;
              break;
            case "/":
              state2 = interfaces_1.ParserState.RelativeSlash;
              break;
            case "?":
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = "";
              state2 = interfaces_1.ParserState.Query;
              break;
            case "#":
              url.username = baseURL.username;
              url.password = baseURL.password;
              url.host = baseURL.host;
              url.port = baseURL.port;
              url.path = infra_1.list.clone(baseURL.path);
              url.query = baseURL.query;
              url.fragment = "";
              state2 = interfaces_1.ParserState.Fragment;
              break;
            default:
              if (isSpecial(url) && walker.c() === "\\") {
                validationError("Invalid input string.");
                state2 = interfaces_1.ParserState.RelativeSlash;
              } else {
                url.username = baseURL.username;
                url.password = baseURL.password;
                url.host = baseURL.host;
                url.port = baseURL.port;
                url.path = infra_1.list.clone(baseURL.path);
                if (url.path.length !== 0)
                  url.path.splice(url.path.length - 1, 1);
                state2 = interfaces_1.ParserState.Path;
                walker.pointer--;
              }
              break;
          }
          break;
        case interfaces_1.ParserState.RelativeSlash:
          if (isSpecial(url) && (walker.c() === "/" || walker.c() === "\\")) {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state2 = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
          } else if (walker.c() === "/") {
            state2 = interfaces_1.ParserState.Authority;
          } else {
            if (baseURL === null) {
              throw new Error("Invalid parser state. Base URL is null.");
            }
            url.username = baseURL.username;
            url.password = baseURL.password;
            url.host = baseURL.host;
            url.port = baseURL.port;
            state2 = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialAuthoritySlashes:
          if (walker.c() === "/" && walker.remaining().startsWith("/")) {
            state2 = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer++;
          } else {
            validationError("Expected '//'.");
            state2 = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:
          if (walker.c() !== "/" && walker.c() !== "\\") {
            state2 = interfaces_1.ParserState.Authority;
            walker.pointer--;
          } else {
            validationError("Unexpected '/' or '\\'.");
          }
          break;
        case interfaces_1.ParserState.Authority:
          if (walker.c() === "@") {
            validationError("Unexpected '@'.");
            if (atFlag)
              buffer = "%40" + buffer;
            atFlag = true;
            for (const codePoint of buffer) {
              if (codePoint === ":" && !passwordTokenSeenFlag) {
                passwordTokenSeenFlag = true;
                continue;
              }
              const encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
              if (passwordTokenSeenFlag) {
                url.password += encodedCodePoints;
              } else {
                url.username += encodedCodePoints;
              }
            }
            buffer = "";
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
            if (atFlag && buffer === "") {
              validationError("Invalid input string.");
              return null;
            }
            walker.pointer -= buffer.length + 1;
            buffer = "";
            state2 = interfaces_1.ParserState.Host;
          } else {
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.Host:
        case interfaces_1.ParserState.Hostname:
          if (stateOverride !== void 0 && url.scheme === "file") {
            walker.pointer--;
            state2 = interfaces_1.ParserState.FileHost;
          } else if (walker.c() === ":" && !arrayFlag) {
            if (buffer === "") {
              validationError("Invalid input string.");
              return null;
            }
            const host = hostParser(buffer, !isSpecial(url));
            if (host === null)
              return null;
            url.host = host;
            buffer = "";
            state2 = interfaces_1.ParserState.Port;
            if (stateOverride === interfaces_1.ParserState.Hostname)
              return url;
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
            walker.pointer--;
            if (isSpecial(url) && buffer === "") {
              validationError("Invalid input string.");
              return null;
            } else if (stateOverride !== void 0 && buffer === "" && (includesCredentials(url) || url.port !== null)) {
              validationError("Invalid input string.");
              return url;
            }
            const host = hostParser(buffer, !isSpecial(url));
            if (host === null)
              return null;
            url.host = host;
            buffer = "";
            state2 = interfaces_1.ParserState.PathStart;
            if (stateOverride !== void 0)
              return url;
          } else {
            if (walker.c() === "[")
              arrayFlag = true;
            if (walker.c() === "]")
              arrayFlag = false;
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.Port:
          if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            buffer += walker.c();
          } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\" || stateOverride) {
            if (buffer !== "") {
              if (buffer !== "") {
                const port = parseInt(buffer, 10);
                if (port > Math.pow(2, 16) - 1) {
                  validationError("Invalid port number.");
                  return null;
                }
                url.port = port === defaultPort(url.scheme) ? null : port;
                buffer = "";
              }
            }
            if (stateOverride !== void 0) {
              return url;
            }
            state2 = interfaces_1.ParserState.PathStart;
            walker.pointer--;
          } else {
            validationError("Invalid input string.");
            return null;
          }
          break;
        case interfaces_1.ParserState.File:
          url.scheme = "file";
          if (walker.c() === "/" || walker.c() === "\\") {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state2 = interfaces_1.ParserState.FileSlash;
          } else if (baseURL !== null && baseURL.scheme === "file") {
            switch (walker.c()) {
              case EOF:
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = baseURL.query;
                break;
              case "?":
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = "";
                state2 = interfaces_1.ParserState.Query;
                break;
              case "#":
                url.host = baseURL.host;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = baseURL.query;
                url.fragment = "";
                state2 = interfaces_1.ParserState.Fragment;
                break;
              default:
                if (!startsWithAWindowsDriveLetter(walker.substring())) {
                  url.host = baseURL.host;
                  url.path = infra_1.list.clone(baseURL.path);
                  shorten(url);
                } else {
                  validationError("Unexpected windows drive letter in input string.");
                }
                state2 = interfaces_1.ParserState.Path;
                walker.pointer--;
                break;
            }
          } else {
            state2 = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.FileSlash:
          if (walker.c() === "/" || walker.c() === "\\") {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state2 = interfaces_1.ParserState.FileHost;
          } else {
            if (baseURL !== null && baseURL.scheme === "file" && !startsWithAWindowsDriveLetter(walker.substring())) {
              if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {
                url.path.push(baseURL.path[0]);
              } else {
                url.host = baseURL.host;
              }
            }
            state2 = interfaces_1.ParserState.Path;
            walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.FileHost:
          if (walker.c() === EOF || walker.c() === "/" || walker.c() === "\\" || walker.c() === "?" || walker.c() === "#") {
            walker.pointer--;
            if (stateOverride === void 0 && isWindowsDriveLetter(buffer)) {
              validationError("Unexpected windows drive letter in input string.");
              state2 = interfaces_1.ParserState.Path;
            } else if (buffer === "") {
              url.host = "";
              if (stateOverride !== void 0)
                return url;
              state2 = interfaces_1.ParserState.PathStart;
            } else {
              let host = hostParser(buffer, !isSpecial(url));
              if (host === null)
                return null;
              if (host === "localhost")
                host = "";
              url.host = host;
              if (stateOverride !== void 0)
                return url;
              buffer = "";
              state2 = interfaces_1.ParserState.PathStart;
            }
          } else {
            buffer += walker.c();
          }
          break;
        case interfaces_1.ParserState.PathStart:
          if (isSpecial(url)) {
            if (walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            state2 = interfaces_1.ParserState.Path;
            if (walker.c() !== "/" && walker.c() !== "\\")
              walker.pointer--;
          } else if (stateOverride === void 0 && walker.c() === "?") {
            url.query = "";
            state2 = interfaces_1.ParserState.Query;
          } else if (stateOverride === void 0 && walker.c() === "#") {
            url.fragment = "";
            state2 = interfaces_1.ParserState.Fragment;
          } else if (walker.c() !== EOF) {
            state2 = interfaces_1.ParserState.Path;
            if (walker.c() !== "/")
              walker.pointer--;
          }
          break;
        case interfaces_1.ParserState.Path:
          if (walker.c() === EOF || walker.c() === "/" || isSpecial(url) && walker.c() === "\\" || stateOverride === void 0 && (walker.c() === "?" || walker.c() === "#")) {
            if (isSpecial(url) && walker.c() === "\\") {
              validationError("Invalid input string.");
            }
            if (isDoubleDotPathSegment(buffer)) {
              shorten(url);
              if (walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
                url.path.push("");
              }
            } else if (isSingleDotPathSegment(buffer) && walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
              url.path.push("");
            } else if (!isSingleDotPathSegment(buffer)) {
              if (url.scheme === "file" && url.path.length === 0 && isWindowsDriveLetter(buffer)) {
                if (url.host !== null && url.host !== "") {
                  validationError("Invalid input string.");
                  url.host = "";
                }
                const bufferCodePoints = Array.from(buffer);
                buffer = bufferCodePoints.slice(0, 1) + ":" + bufferCodePoints.slice(2);
              }
              url.path.push(buffer);
            }
            buffer = "";
            if (url.scheme === "file" && (walker.c() === EOF || walker.c() === "?" || walker.c() === "#")) {
              while (url.path.length > 1 && url.path[0] === "") {
                validationError("Invalid input string.");
                url.path.splice(0, 1);
              }
            }
            if (walker.c() === "?") {
              url.query = "";
              state2 = interfaces_1.ParserState.Query;
            }
            if (walker.c() === "#") {
              url.fragment = "";
              state2 = interfaces_1.ParserState.Fragment;
            }
          } else {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);
          }
          break;
        case interfaces_1.ParserState.CannotBeABaseURLPath:
          if (walker.c() === "?") {
            url.query = "";
            state2 = interfaces_1.ParserState.Query;
          } else if (walker.c() === "#") {
            url.fragment = "";
            state2 = interfaces_1.ParserState.Fragment;
          } else {
            if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            if (walker.c() !== EOF) {
              url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);
            }
          }
          break;
        case interfaces_1.ParserState.Query:
          if (encoding !== "UTF-8" && (!isSpecial(url) || url.scheme === "ws" || url.scheme === "wss")) {
            encoding = "UTF-8";
          }
          if (stateOverride === void 0 && walker.c() === "#") {
            url.fragment = "";
            state2 = interfaces_1.ParserState.Fragment;
          } else if (walker.c() !== EOF) {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Character is not a URL code point or a percent encoded character.");
            }
            if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
              validationError("Percent encoded character must be followed by two hex digits.");
            }
            if (encoding.toUpperCase() !== "UTF-8") {
              throw new Error("Only UTF-8 encoding is supported.");
            }
            let bytes = util_1.utf8Encode(walker.c());
            if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 && bytes[bytes.length - 1] === 59) {
              bytes = bytes.subarray(2, bytes.length - 1);
              url.query += "%26%23" + infra_1.byteSequence.isomorphicDecode(bytes) + "%3B";
            } else {
              for (const byte of bytes) {
                if (byte < 33 || byte > 126 || byte === 34 || byte === 35 || byte === 60 || byte === 62 || byte === 39 && isSpecial(url)) {
                  url.query += percentEncode(byte);
                } else {
                  url.query += String.fromCharCode(byte);
                }
              }
            }
          }
          break;
        case interfaces_1.ParserState.Fragment:
          if (walker.c() === EOF) ;
          else if (walker.c() === "\0") {
            validationError("NULL character in input string.");
          } else {
            if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
              validationError("Unexpected character in fragment string.");
            }
            if (walker.c() === "%" && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {
              validationError("Unexpected character in fragment string.");
            }
            url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);
          }
          break;
      }
      if (walker.eof)
        break;
      else
        walker.pointer++;
    }
    return url;
  }
  URLAlgorithm.basicURLParser = basicURLParser;
  function setTheUsername(url, username) {
    let result = "";
    for (const codePoint of username) {
      result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
    }
    url.username = result;
  }
  URLAlgorithm.setTheUsername = setTheUsername;
  function setThePassword(url, password) {
    let result = "";
    for (const codePoint of password) {
      result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
    }
    url.password = result;
  }
  URLAlgorithm.setThePassword = setThePassword;
  function isSingleDotPathSegment(str) {
    return str === "." || str.toLowerCase() === "%2e";
  }
  URLAlgorithm.isSingleDotPathSegment = isSingleDotPathSegment;
  function isDoubleDotPathSegment(str) {
    const lowerStr = str.toLowerCase();
    return lowerStr === ".." || lowerStr === ".%2e" || lowerStr === "%2e." || lowerStr === "%2e%2e";
  }
  URLAlgorithm.isDoubleDotPathSegment = isDoubleDotPathSegment;
  function shorten(url) {
    const path2 = url.path;
    if (path2.length === 0)
      return;
    if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0]))
      return;
    url.path.splice(url.path.length - 1, 1);
  }
  URLAlgorithm.shorten = shorten;
  function isNormalizedWindowsDriveLetter(str) {
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && str[1] === ":";
  }
  URLAlgorithm.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;
  function isWindowsDriveLetter(str) {
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && (str[1] === ":" || str[1] === "|");
  }
  URLAlgorithm.isWindowsDriveLetter = isWindowsDriveLetter;
  function startsWithAWindowsDriveLetter(str) {
    return str.length >= 2 && isWindowsDriveLetter(str) && (str.length === 2 || (str[2] === "/" || str[2] === "\\" || str[2] === "?" || str[2] === "#"));
  }
  URLAlgorithm.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;
  function hostParser(input, isNotSpecial = false) {
    if (input.startsWith("[")) {
      if (!input.endsWith("]")) {
        validationError("Expected ']' after '['.");
        return null;
      }
      return iPv6Parser(input.substring(1, input.length - 1));
    }
    if (isNotSpecial) {
      return opaqueHostParser(input);
    }
    const domain = util_1.utf8Decode(stringPercentDecode(input));
    const asciiDomain = domainToASCII(domain);
    if (asciiDomain === null) {
      validationError("Invalid domain.");
      return null;
    }
    if (_forbiddenHostCodePoint.test(asciiDomain)) {
      validationError("Invalid domain.");
      return null;
    }
    const ipv4Host = iPv4Parser(asciiDomain);
    if (ipv4Host === null || util_1.isNumber(ipv4Host))
      return ipv4Host;
    return asciiDomain;
  }
  URLAlgorithm.hostParser = hostParser;
  function iPv4NumberParser(input, validationErrorFlag = { value: false }) {
    let R = 10;
    if (input.startsWith("0x") || input.startsWith("0X")) {
      validationErrorFlag.value = true;
      input = input.substr(2);
      R = 16;
    } else if (input.length >= 2 && input[0] === "0") {
      validationErrorFlag.value = true;
      input = input.substr(1);
      R = 8;
    }
    if (input === "")
      return 0;
    const radixRDigits = R === 10 ? /^[0-9]+$/ : R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/;
    if (!radixRDigits.test(input))
      return null;
    return parseInt(input, R);
  }
  URLAlgorithm.iPv4NumberParser = iPv4NumberParser;
  function iPv4Parser(input) {
    const validationErrorFlag = { value: false };
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      validationErrorFlag.value = true;
      if (parts.length > 1)
        parts.pop();
    }
    if (parts.length > 4)
      return input;
    const numbers = [];
    for (const part2 of parts) {
      if (part2 === "")
        return input;
      const n = iPv4NumberParser(part2, validationErrorFlag);
      if (n === null)
        return input;
      numbers.push(n);
    }
    if (validationErrorFlag.value)
      validationError("Invalid IP v4 address.");
    for (let i = 0; i < numbers.length; i++) {
      const item = numbers[i];
      if (item > 255) {
        validationError("Invalid IP v4 address.");
        if (i < numbers.length - 1)
          return null;
      }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
      validationError("Invalid IP v4 address.");
      return null;
    }
    let ipv4 = numbers[numbers.length - 1];
    numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * Math.pow(256, 3 - counter);
      counter++;
    }
    return ipv4;
  }
  URLAlgorithm.iPv4Parser = iPv4Parser;
  function iPv6Parser(input) {
    const EOF = "";
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    const walker = new util_1.StringWalker(input);
    if (walker.c() === ":") {
      if (!walker.remaining().startsWith(":")) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      walker.pointer += 2;
      pieceIndex += 1;
      compress = pieceIndex;
    }
    while (walker.c() !== EOF) {
      if (pieceIndex === 8) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      if (walker.c() === ":") {
        if (compress !== null) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        walker.pointer++;
        pieceIndex++;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())) {
        value = value * 16 + parseInt(walker.c(), 16);
        walker.pointer++;
        length++;
      }
      if (walker.c() === ".") {
        if (length === 0) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        walker.pointer -= length;
        if (pieceIndex > 6) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        let numbersSeen = 0;
        while (walker.c() !== EOF) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (walker.c() === "." && numbersSeen < 4) {
              walker.pointer++;
            } else {
              validationError("Invalid IP v6 address.");
              return null;
            }
          }
          if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          while (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
            const number = parseInt(walker.c(), 10);
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              validationError("Invalid IP v6 address.");
              return null;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              validationError("Invalid IP v6 address.");
              return null;
            }
            walker.pointer++;
          }
          if (ipv4Piece === null) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          numbersSeen++;
          if (numbersSeen === 2 || numbersSeen === 4)
            pieceIndex++;
        }
        if (numbersSeen !== 4) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        break;
      } else if (walker.c() === ":") {
        walker.pointer++;
        if (walker.c() === EOF) {
          validationError("Invalid IP v6 address.");
          return null;
        }
      } else if (walker.c() !== EOF) {
        validationError("Invalid IP v6 address.");
        return null;
      }
      address[pieceIndex] = value;
      pieceIndex++;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        [address[pieceIndex], address[compress + swaps - 1]] = [address[compress + swaps - 1], address[pieceIndex]];
        pieceIndex--;
        swaps--;
      }
    } else if (compress === null && pieceIndex !== 8) {
      validationError("Invalid IP v6 address.");
      return null;
    }
    return address;
  }
  URLAlgorithm.iPv6Parser = iPv6Parser;
  function opaqueHostParser(input) {
    const forbiddenChars = /[\x00\t\f\r #/:?@\[\\\]]/;
    if (forbiddenChars.test(input)) {
      validationError("Invalid host string.");
      return null;
    }
    let output = "";
    for (const codePoint of input) {
      output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);
    }
    return output;
  }
  URLAlgorithm.opaqueHostParser = opaqueHostParser;
  function resolveABlobURL(url) {
    return null;
  }
  URLAlgorithm.resolveABlobURL = resolveABlobURL;
  function percentEncode(value) {
    return "%" + ("00" + value.toString(16).toUpperCase()).slice(-2);
  }
  URLAlgorithm.percentEncode = percentEncode;
  function percentDecode(input) {
    const isHexDigit = (byte) => {
      return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
    };
    const output = new Uint8Array(input.length);
    let n = 0;
    for (let i = 0; i < input.length; i++) {
      const byte = input[i];
      if (byte !== 37) {
        output[n] = byte;
        n++;
      } else if (byte === 37 && i >= input.length - 2) {
        output[n] = byte;
        n++;
      } else if (byte === 37 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {
        output[n] = byte;
        n++;
      } else {
        const bytePoint = parseInt(util_1.utf8Decode(Uint8Array.of(input[i + 1], input[i + 2])), 16);
        output[n] = bytePoint;
        n++;
        i += 2;
      }
    }
    return output.subarray(0, n);
  }
  URLAlgorithm.percentDecode = percentDecode;
  function stringPercentDecode(input) {
    return percentDecode(util_1.utf8Encode(input));
  }
  URLAlgorithm.stringPercentDecode = stringPercentDecode;
  function utf8PercentEncode(codePoint, percentEncodeSet) {
    if (!percentEncodeSet.test(codePoint))
      return codePoint;
    const bytes = util_1.utf8Encode(codePoint);
    let result = "";
    for (const byte of bytes) {
      result += percentEncode(byte);
    }
    return result;
  }
  URLAlgorithm.utf8PercentEncode = utf8PercentEncode;
  function hostEquals(hostA, hostB) {
    return hostA === hostB;
  }
  URLAlgorithm.hostEquals = hostEquals;
  function urlEquals(urlA, urlB, excludeFragmentsFlag = false) {
    return urlSerializer(urlA, excludeFragmentsFlag) === urlSerializer(urlB, excludeFragmentsFlag);
  }
  URLAlgorithm.urlEquals = urlEquals;
  function urlEncodedStringParser(input) {
    return urlEncodedParser(util_1.utf8Encode(input));
  }
  URLAlgorithm.urlEncodedStringParser = urlEncodedStringParser;
  function urlEncodedParser(input) {
    const sequences = [];
    let currentSequence = [];
    for (const byte of input) {
      if (byte === 38) {
        sequences.push(Uint8Array.from(currentSequence));
        currentSequence = [];
      } else {
        currentSequence.push(byte);
      }
    }
    if (currentSequence.length !== 0) {
      sequences.push(Uint8Array.from(currentSequence));
    }
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0)
        continue;
      const index = bytes.indexOf(61);
      const name = index !== -1 ? bytes.slice(0, index) : bytes;
      const value = index !== -1 ? bytes.slice(index + 1) : new Uint8Array();
      for (let i = 0; i < name.length; i++)
        if (name[i] === 43)
          name[i] = 32;
      for (let i = 0; i < value.length; i++)
        if (value[i] === 43)
          value[i] = 32;
      const nameString = util_1.utf8Decode(name);
      const valueString = util_1.utf8Decode(value);
      output.push([nameString, valueString]);
    }
    return output;
  }
  URLAlgorithm.urlEncodedParser = urlEncodedParser;
  function urlEncodedByteSerializer(input) {
    let output = "";
    for (const byte of input) {
      if (byte === 32) {
        output += "+";
      } else if (byte === 42 || byte === 45 || byte === 46 || byte >= 48 && byte <= 57 || byte >= 65 && byte <= 90 || byte === 95 || byte >= 97 && byte <= 122) {
        output += String.fromCodePoint(byte);
      } else {
        output += percentEncode(byte);
      }
    }
    return output;
  }
  URLAlgorithm.urlEncodedByteSerializer = urlEncodedByteSerializer;
  function urlEncodedSerializer(tuples, encodingOverride) {
    const encoding = encodingOverride === void 0 || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    if (encoding.toUpperCase() !== "UTF-8") {
      throw new Error("Only UTF-8 encoding is supported.");
    }
    let output = "";
    for (const tuple of tuples) {
      const name = urlEncodedByteSerializer(util_1.utf8Encode(tuple[0]));
      let value = tuple[1];
      value = urlEncodedByteSerializer(util_1.utf8Encode(value));
      if (output !== "")
        output += "&";
      output += name + "=" + value;
    }
    return output;
  }
  URLAlgorithm.urlEncodedSerializer = urlEncodedSerializer;
  function origin(url) {
    switch (url.scheme) {
      case "blob":
        if (url._blobURLEntry !== null) ;
        const parsedURL = basicURLParser(url.path[0]);
        if (parsedURL === null)
          return interfaces_1.OpaqueOrigin;
        else
          return origin(parsedURL);
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return [url.scheme, url.host === null ? "" : url.host, url.port, null];
      case "file":
        return interfaces_1.OpaqueOrigin;
      default:
        return interfaces_1.OpaqueOrigin;
    }
  }
  URLAlgorithm.origin = origin;
  function domainToASCII(domain, beStrict = false) {
    const result = url_1.domainToASCII(domain);
    if (result === "") {
      validationError("Invalid domain name.");
      return null;
    }
    return result;
  }
  URLAlgorithm.domainToASCII = domainToASCII;
  function domainToUnicode(domain, beStrict = false) {
    const result = url_1.domainToUnicode(domain);
    if (result === "") {
      validationError("Invalid domain name.");
    }
    return result;
  }
  URLAlgorithm.domainToUnicode = domainToUnicode;
  function asciiSerializationOfAnOrigin(origin2) {
    if (origin2[0] === "" && origin2[1] === "" && origin2[2] === null && origin2[3] === null) {
      return "null";
    }
    let result = origin2[0] + "://" + hostSerializer(origin2[1]);
    if (origin2[2] !== null)
      result += ":" + origin2[2].toString();
    return result;
  }
  URLAlgorithm.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin;
  return URLAlgorithm;
}
var WebIDLAlgorithm = {};
var hasRequiredWebIDLAlgorithm;
function requireWebIDLAlgorithm() {
  if (hasRequiredWebIDLAlgorithm) return WebIDLAlgorithm;
  hasRequiredWebIDLAlgorithm = 1;
  Object.defineProperty(WebIDLAlgorithm, "__esModule", { value: true });
  function idl_defineConst(o, name, value) {
    Object.defineProperty(o, name, { writable: false, enumerable: true, configurable: false, value });
  }
  WebIDLAlgorithm.idl_defineConst = idl_defineConst;
  return WebIDLAlgorithm;
}
var hasRequiredNodeImpl;
function requireNodeImpl() {
  if (hasRequiredNodeImpl) return NodeImpl;
  hasRequiredNodeImpl = 1;
  Object.defineProperty(NodeImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const interfaces_1 = requireInterfaces$2();
  const EventTargetImpl_1 = requireEventTargetImpl();
  const util_1 = requireUtil$1();
  const DOMException_1 = requireDOMException();
  const algorithm_1 = requireAlgorithm();
  const URLAlgorithm_1 = requireURLAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let NodeImpl$1 = class NodeImpl extends EventTargetImpl_1.EventTargetImpl {
    /**
     * Initializes a new instance of `Node`.
     */
    constructor() {
      super();
      this._parent = null;
      this._firstChild = null;
      this._lastChild = null;
      this._previousSibling = null;
      this._nextSibling = null;
    }
    get _childNodes() {
      return this.__childNodes || (this.__childNodes = algorithm_1.create_nodeList(this));
    }
    get _nodeDocument() {
      return this._nodeDocumentOverride || _1.dom.window._associatedDocument;
    }
    set _nodeDocument(val) {
      this._nodeDocumentOverride = val;
    }
    get _registeredObserverList() {
      return this.__registeredObserverList || (this.__registeredObserverList = []);
    }
    /** @inheritdoc */
    get nodeType() {
      return this._nodeType;
    }
    /**
     * Returns a string appropriate for the type of node.
     */
    get nodeName() {
      if (util_1.Guard.isElementNode(this)) {
        return this._htmlUppercasedQualifiedName;
      } else if (util_1.Guard.isAttrNode(this)) {
        return this._qualifiedName;
      } else if (util_1.Guard.isExclusiveTextNode(this)) {
        return "#text";
      } else if (util_1.Guard.isCDATASectionNode(this)) {
        return "#cdata-section";
      } else if (util_1.Guard.isProcessingInstructionNode(this)) {
        return this._target;
      } else if (util_1.Guard.isCommentNode(this)) {
        return "#comment";
      } else if (util_1.Guard.isDocumentNode(this)) {
        return "#document";
      } else if (util_1.Guard.isDocumentTypeNode(this)) {
        return this._name;
      } else if (util_1.Guard.isDocumentFragmentNode(this)) {
        return "#document-fragment";
      } else {
        return "";
      }
    }
    /**
     * Gets the absolute base URL of the node.
     */
    get baseURI() {
      return URLAlgorithm_1.urlSerializer(this._nodeDocument._URL);
    }
    /**
     * Returns whether the node is rooted to a document node.
     */
    get isConnected() {
      return util_1.Guard.isElementNode(this) && algorithm_1.shadowTree_isConnected(this);
    }
    /**
     * Returns the parent document.
     */
    get ownerDocument() {
      if (this._nodeType === interfaces_1.NodeType.Document)
        return null;
      else
        return this._nodeDocument;
    }
    /**
     * Returns the root node.
     *
     * @param options - if options has `composed = true` this function
     * returns the node's shadow-including root, otherwise it returns
     * the node's root node.
     */
    getRootNode(options) {
      return algorithm_1.tree_rootNode(this, !!options && options.composed);
    }
    /**
     * Returns the parent node.
     */
    get parentNode() {
      if (this._nodeType === interfaces_1.NodeType.Attribute) {
        return null;
      } else {
        return this._parent;
      }
    }
    /**
     * Returns the parent element.
     */
    get parentElement() {
      if (this._parent && util_1.Guard.isElementNode(this._parent)) {
        return this._parent;
      } else {
        return null;
      }
    }
    /**
     * Determines whether a node has any children.
     */
    hasChildNodes() {
      return this._firstChild !== null;
    }
    /**
     * Returns a {@link NodeList} of child nodes.
     */
    get childNodes() {
      return this._childNodes;
    }
    /**
     * Returns the first child node.
     */
    get firstChild() {
      return this._firstChild;
    }
    /**
     * Returns the last child node.
     */
    get lastChild() {
      return this._lastChild;
    }
    /**
     * Returns the previous sibling node.
     */
    get previousSibling() {
      return this._previousSibling;
    }
    /**
     * Returns the next sibling node.
     */
    get nextSibling() {
      return this._nextSibling;
    }
    /**
     * Gets or sets the data associated with a {@link CharacterData} node or the
     * value of an {@link @Attr} node. For other node types returns `null`.
     */
    get nodeValue() {
      if (util_1.Guard.isAttrNode(this)) {
        return this._value;
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        return this._data;
      } else {
        return null;
      }
    }
    set nodeValue(value) {
      if (value === null) {
        value = "";
      }
      if (util_1.Guard.isAttrNode(this)) {
        algorithm_1.attr_setAnExistingAttributeValue(this, value);
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
      }
    }
    /**
     * Returns the concatenation of data of all the {@link Text}
     * node descendants in tree order. When set, replaces the text
     * contents of the node with the given value.
     */
    get textContent() {
      if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
        return algorithm_1.text_descendantTextContent(this);
      } else if (util_1.Guard.isAttrNode(this)) {
        return this._value;
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        return this._data;
      } else {
        return null;
      }
    }
    set textContent(value) {
      if (value === null) {
        value = "";
      }
      if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
        algorithm_1.node_stringReplaceAll(value, this);
      } else if (util_1.Guard.isAttrNode(this)) {
        algorithm_1.attr_setAnExistingAttributeValue(this, value);
      } else if (util_1.Guard.isCharacterDataNode(this)) {
        algorithm_1.characterData_replaceData(this, 0, algorithm_1.tree_nodeLength(this), value);
      }
    }
    /**
     * Puts all {@link Text} nodes in the full depth of the sub-tree
     * underneath this node into a "normal" form where only markup
     * (e.g., tags, comments, processing instructions, CDATA sections,
     * and entity references) separates {@link Text} nodes, i.e., there
     * are no adjacent Text nodes.
     */
    normalize() {
      const descendantNodes = [];
      let node2 = algorithm_1.tree_getFirstDescendantNode(this, false, false, (e) => util_1.Guard.isExclusiveTextNode(e));
      while (node2 !== null) {
        descendantNodes.push(node2);
        node2 = algorithm_1.tree_getNextDescendantNode(this, node2, false, false, (e) => util_1.Guard.isExclusiveTextNode(e));
      }
      for (let i = 0; i < descendantNodes.length; i++) {
        const node3 = descendantNodes[i];
        if (node3._parent === null)
          continue;
        let length = algorithm_1.tree_nodeLength(node3);
        if (length === 0) {
          algorithm_1.mutation_remove(node3, node3._parent);
          continue;
        }
        const textSiblings = [];
        let data = "";
        for (const sibling of algorithm_1.text_contiguousExclusiveTextNodes(node3)) {
          textSiblings.push(sibling);
          data += sibling._data;
        }
        algorithm_1.characterData_replaceData(node3, length, 0, data);
        if (_1.dom.rangeList.size !== 0) {
          let currentNode = node3._nextSibling;
          while (currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)) {
            const cn = currentNode;
            const index = algorithm_1.tree_index(cn);
            for (const range2 of _1.dom.rangeList) {
              if (range2._start[0] === cn) {
                range2._start[0] = node3;
                range2._start[1] += length;
              }
              if (range2._end[0] === cn) {
                range2._end[0] = node3;
                range2._end[1] += length;
              }
              if (range2._start[0] === cn._parent && range2._start[1] === index) {
                range2._start[0] = node3;
                range2._start[1] = length;
              }
              if (range2._end[0] === cn._parent && range2._end[1] === index) {
                range2._end[0] = node3;
                range2._end[1] = length;
              }
            }
            length += algorithm_1.tree_nodeLength(currentNode);
            currentNode = currentNode._nextSibling;
          }
        }
        for (let i2 = 0; i2 < textSiblings.length; i2++) {
          const sibling = textSiblings[i2];
          if (sibling._parent === null)
            continue;
          algorithm_1.mutation_remove(sibling, sibling._parent);
        }
      }
    }
    /**
     * Returns a duplicate of this node, i.e., serves as a generic copy
     * constructor for nodes. The duplicate node has no parent
     * ({@link parentNode} returns `null`).
     *
     * @param deep - if `true`, recursively clone the subtree under the
     * specified node. If `false`, clone only the node itself (and its
     * attributes, if it is an {@link Element}).
     */
    cloneNode(deep = false) {
      if (util_1.Guard.isShadowRoot(this))
        throw new DOMException_1.NotSupportedError();
      return algorithm_1.node_clone(this, null, deep);
    }
    /**
     * Determines if the given node is equal to this one.
     *
     * @param node - the node to compare with
     */
    isEqualNode(node2 = null) {
      return node2 !== null && algorithm_1.node_equals(this, node2);
    }
    /**
     * Determines if the given node is reference equal to this one.
     *
     * @param node - the node to compare with
     */
    isSameNode(node2 = null) {
      return this === node2;
    }
    /**
     * Returns a bitmask indicating the position of the given `node`
     * relative to this node.
     */
    compareDocumentPosition(other) {
      if (other === this)
        return 0;
      let node1 = other;
      let node2 = this;
      let attr1 = null;
      let attr2 = null;
      if (util_1.Guard.isAttrNode(node1)) {
        attr1 = node1;
        node1 = attr1._element;
      }
      if (util_1.Guard.isAttrNode(node2)) {
        attr2 = node2;
        node2 = attr2._element;
        if (attr1 && node1 && node1 === node2) {
          for (let i = 0; i < node2._attributeList.length; i++) {
            const attr = node2._attributeList[i];
            if (algorithm_1.node_equals(attr, attr1)) {
              return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;
            } else if (algorithm_1.node_equals(attr, attr2)) {
              return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;
            }
          }
        }
      }
      if (node1 === null || node2 === null || algorithm_1.tree_rootNode(node1) !== algorithm_1.tree_rootNode(node2)) {
        return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific | (_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);
      }
      if (!attr1 && algorithm_1.tree_isAncestorOf(node2, node1) || attr2 && node1 === node2) {
        return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;
      }
      if (!attr2 && algorithm_1.tree_isDescendantOf(node2, node1) || attr1 && node1 === node2) {
        return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;
      }
      if (algorithm_1.tree_isPreceding(node2, node1))
        return interfaces_1.Position.Preceding;
      return interfaces_1.Position.Following;
    }
    /**
     * Returns `true` if given node is an inclusive descendant of this
     * node, and `false` otherwise (including when other node is `null`).
     *
     * @param other - the node to check
     */
    contains(other) {
      if (other === null)
        return false;
      return algorithm_1.tree_isDescendantOf(this, other, true);
    }
    /**
     * Returns the prefix for a given namespace URI, if present, and
     * `null` if not.
     *
     * @param namespace - the namespace to search
     */
    lookupPrefix(namespace) {
      if (!namespace)
        return null;
      if (util_1.Guard.isElementNode(this)) {
        return algorithm_1.node_locateANamespacePrefix(this, namespace);
      } else if (util_1.Guard.isDocumentNode(this)) {
        if (this.documentElement === null) {
          return null;
        } else {
          return algorithm_1.node_locateANamespacePrefix(this.documentElement, namespace);
        }
      } else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {
        return null;
      } else if (util_1.Guard.isAttrNode(this)) {
        if (this._element === null) {
          return null;
        } else {
          return algorithm_1.node_locateANamespacePrefix(this._element, namespace);
        }
      } else {
        if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {
          return algorithm_1.node_locateANamespacePrefix(this._parent, namespace);
        } else {
          return null;
        }
      }
    }
    /**
     * Returns the namespace URI for a given prefix if present, and `null`
     * if not.
     *
     * @param prefix - the prefix to search
     */
    lookupNamespaceURI(prefix) {
      return algorithm_1.node_locateANamespace(this, prefix || null);
    }
    /**
     * Returns `true` if the namespace is the default namespace on this
     * node or `false` if not.
     *
     * @param namespace - the namespace to check
     */
    isDefaultNamespace(namespace) {
      if (!namespace)
        namespace = null;
      const defaultNamespace = algorithm_1.node_locateANamespace(this, null);
      return defaultNamespace === namespace;
    }
    /**
     * Inserts the node `newChild` before the existing child node
     * `refChild`. If `refChild` is `null`, inserts `newChild` at the end
     * of the list of children.
     *
     * If `newChild` is a {@link DocumentFragment} object, all of its
     * children are inserted, in the same order, before `refChild`.
     *
     * If `newChild` is already in the tree, it is first removed.
     *
     * @param newChild - the node to insert
     * @param refChild - the node before which the new node must be
     *   inserted
     *
     * @returns the newly inserted child node
     */
    insertBefore(newChild, refChild) {
      return algorithm_1.mutation_preInsert(newChild, this, refChild);
    }
    /**
     * Adds the node `newChild` to the end of the list of children of this
     * node, and returns it. If `newChild` is already in the tree, it is
     * first removed.
     *
     * If `newChild` is a {@link DocumentFragment} object, the entire
     * contents of the document fragment are moved into the child list of
     * this node.
     *
     * @param newChild - the node to add
     *
     * @returns the newly inserted child node
     */
    appendChild(newChild) {
      return algorithm_1.mutation_append(newChild, this);
    }
    /**
     * Replaces the child node `oldChild` with `newChild` in the list of
     * children, and returns the `oldChild` node. If `newChild` is already
     * in the tree, it is first removed.
     *
     * @param newChild - the new node to put in the child list
     * @param oldChild - the node being replaced in the list
     *
     * @returns the removed child node
     */
    replaceChild(newChild, oldChild) {
      return algorithm_1.mutation_replace(oldChild, newChild, this);
    }
    /**
    * Removes the child node indicated by `oldChild` from the list of
    * children, and returns it.
    *
    * @param oldChild - the node being removed from the list
    *
    * @returns the removed child node
    */
    removeChild(oldChild) {
      return algorithm_1.mutation_preRemove(oldChild, this);
    }
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    _getTheParent(event) {
      if (util_1.Guard.isSlotable(this) && algorithm_1.shadowTree_isAssigned(this)) {
        return this._assignedSlot;
      } else {
        return this._parent;
      }
    }
  };
  NodeImpl.NodeImpl = NodeImpl$1;
  NodeImpl$1.ELEMENT_NODE = 1;
  NodeImpl$1.ATTRIBUTE_NODE = 2;
  NodeImpl$1.TEXT_NODE = 3;
  NodeImpl$1.CDATA_SECTION_NODE = 4;
  NodeImpl$1.ENTITY_REFERENCE_NODE = 5;
  NodeImpl$1.ENTITY_NODE = 6;
  NodeImpl$1.PROCESSING_INSTRUCTION_NODE = 7;
  NodeImpl$1.COMMENT_NODE = 8;
  NodeImpl$1.DOCUMENT_NODE = 9;
  NodeImpl$1.DOCUMENT_TYPE_NODE = 10;
  NodeImpl$1.DOCUMENT_FRAGMENT_NODE = 11;
  NodeImpl$1.NOTATION_NODE = 12;
  NodeImpl$1.DOCUMENT_POSITION_DISCONNECTED = 1;
  NodeImpl$1.DOCUMENT_POSITION_PRECEDING = 2;
  NodeImpl$1.DOCUMENT_POSITION_FOLLOWING = 4;
  NodeImpl$1.DOCUMENT_POSITION_CONTAINS = 8;
  NodeImpl$1.DOCUMENT_POSITION_CONTAINED_BY = 16;
  NodeImpl$1.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  NodeImpl$1.prototype._children = new util_1.EmptySet();
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "ELEMENT_NODE", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "ATTRIBUTE_NODE", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "TEXT_NODE", 3);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "CDATA_SECTION_NODE", 4);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "ENTITY_REFERENCE_NODE", 5);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "ENTITY_NODE", 6);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "PROCESSING_INSTRUCTION_NODE", 7);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "COMMENT_NODE", 8);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_NODE", 9);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_TYPE_NODE", 10);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_FRAGMENT_NODE", 11);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "NOTATION_NODE", 12);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_POSITION_DISCONNECTED", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_POSITION_PRECEDING", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_POSITION_FOLLOWING", 4);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_POSITION_CONTAINS", 8);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 16);
  WebIDLAlgorithm_1.idl_defineConst(NodeImpl$1.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
  return NodeImpl;
}
var hasRequiredAttrImpl;
function requireAttrImpl() {
  if (hasRequiredAttrImpl) return AttrImpl;
  hasRequiredAttrImpl = 1;
  Object.defineProperty(AttrImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const NodeImpl_1 = requireNodeImpl();
  const algorithm_1 = requireAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let AttrImpl$1 = class AttrImpl2 extends NodeImpl_1.NodeImpl {
    /**
     * Initializes a new instance of `Attr`.
     *
     * @param localName - local name
     */
    constructor(localName) {
      super();
      this._namespace = null;
      this._namespacePrefix = null;
      this._element = null;
      this._value = "";
      this._localName = localName;
    }
    /** @inheritdoc */
    get ownerElement() {
      return this._element;
    }
    /** @inheritdoc */
    get namespaceURI() {
      return this._namespace;
    }
    /** @inheritdoc */
    get prefix() {
      return this._namespacePrefix;
    }
    /** @inheritdoc */
    get localName() {
      return this._localName;
    }
    /** @inheritdoc */
    get name() {
      return this._qualifiedName;
    }
    /** @inheritdoc */
    get value() {
      return this._value;
    }
    set value(value) {
      algorithm_1.attr_setAnExistingAttributeValue(this, value);
    }
    /**
     * Returns the qualified name.
     */
    get _qualifiedName() {
      return this._namespacePrefix !== null ? this._namespacePrefix + ":" + this._localName : this._localName;
    }
    /**
     * Creates an `Attr`.
     *
     * @param document - owner document
     * @param localName - local name
     */
    static _create(document2, localName) {
      const node2 = new AttrImpl2(localName);
      node2._nodeDocument = document2;
      return node2;
    }
  };
  AttrImpl.AttrImpl = AttrImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(AttrImpl$1.prototype, "_nodeType", interfaces_1.NodeType.Attribute);
  WebIDLAlgorithm_1.idl_defineConst(AttrImpl$1.prototype, "specified", true);
  return AttrImpl;
}
var CDATASectionImpl = {};
var TextImpl = {};
var CharacterDataImpl = {};
var hasRequiredCharacterDataImpl;
function requireCharacterDataImpl() {
  if (hasRequiredCharacterDataImpl) return CharacterDataImpl;
  hasRequiredCharacterDataImpl = 1;
  Object.defineProperty(CharacterDataImpl, "__esModule", { value: true });
  const NodeImpl_1 = requireNodeImpl();
  const algorithm_1 = requireAlgorithm();
  let CharacterDataImpl$1 = class CharacterDataImpl extends NodeImpl_1.NodeImpl {
    /**
     * Initializes a new instance of `CharacterData`.
     *
     * @param data - the text content
     */
    constructor(data) {
      super();
      this._data = data;
    }
    /** @inheritdoc */
    get data() {
      return this._data;
    }
    set data(value) {
      algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
    }
    /** @inheritdoc */
    get length() {
      return this._data.length;
    }
    /** @inheritdoc */
    substringData(offset, count) {
      return algorithm_1.characterData_substringData(this, offset, count);
    }
    /** @inheritdoc */
    appendData(data) {
      return algorithm_1.characterData_replaceData(this, this._data.length, 0, data);
    }
    /** @inheritdoc */
    insertData(offset, data) {
      algorithm_1.characterData_replaceData(this, offset, 0, data);
    }
    /** @inheritdoc */
    deleteData(offset, count) {
      algorithm_1.characterData_replaceData(this, offset, count, "");
    }
    /** @inheritdoc */
    replaceData(offset, count, data) {
      algorithm_1.characterData_replaceData(this, offset, count, data);
    }
    // MIXIN: NonDocumentTypeChildNode
    /* istanbul ignore next */
    get previousElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    /* istanbul ignore next */
    get nextElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    // MIXIN: ChildNode
    /* istanbul ignore next */
    before(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    after(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    replaceWith(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    remove() {
      throw new Error("Mixin: ChildNode not implemented.");
    }
  };
  CharacterDataImpl.CharacterDataImpl = CharacterDataImpl$1;
  return CharacterDataImpl;
}
var hasRequiredTextImpl;
function requireTextImpl() {
  if (hasRequiredTextImpl) return TextImpl;
  hasRequiredTextImpl = 1;
  Object.defineProperty(TextImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const CharacterDataImpl_1 = requireCharacterDataImpl();
  const algorithm_1 = requireAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let TextImpl$1 = class TextImpl2 extends CharacterDataImpl_1.CharacterDataImpl {
    /**
     * Initializes a new instance of `Text`.
     *
     * @param data - the text content
     */
    constructor(data = "") {
      super(data);
      this._name = "";
      this._assignedSlot = null;
    }
    /** @inheritdoc */
    get wholeText() {
      let text = "";
      for (const node2 of algorithm_1.text_contiguousTextNodes(this, true)) {
        text = text + node2._data;
      }
      return text;
    }
    /** @inheritdoc */
    splitText(offset) {
      return algorithm_1.text_split(this, offset);
    }
    // MIXIN: Slotable
    /* istanbul ignore next */
    get assignedSlot() {
      throw new Error("Mixin: Slotable not implemented.");
    }
    /**
     * Creates a `Text`.
     *
     * @param document - owner document
     * @param data - the text content
     */
    static _create(document2, data = "") {
      const node2 = new TextImpl2(data);
      node2._nodeDocument = document2;
      return node2;
    }
  };
  TextImpl.TextImpl = TextImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(TextImpl$1.prototype, "_nodeType", interfaces_1.NodeType.Text);
  return TextImpl;
}
var hasRequiredCDATASectionImpl;
function requireCDATASectionImpl() {
  if (hasRequiredCDATASectionImpl) return CDATASectionImpl;
  hasRequiredCDATASectionImpl = 1;
  Object.defineProperty(CDATASectionImpl, "__esModule", { value: true });
  const TextImpl_1 = requireTextImpl();
  const interfaces_1 = requireInterfaces$2();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let CDATASectionImpl$1 = class CDATASectionImpl2 extends TextImpl_1.TextImpl {
    /**
     * Initializes a new instance of `CDATASection`.
     *
     * @param data - node contents
     */
    constructor(data) {
      super(data);
    }
    /**
     * Creates a new `CDATASection`.
     *
     * @param document - owner document
     * @param data - node contents
     */
    static _create(document2, data = "") {
      const node2 = new CDATASectionImpl2(data);
      node2._nodeDocument = document2;
      return node2;
    }
  };
  CDATASectionImpl.CDATASectionImpl = CDATASectionImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(CDATASectionImpl$1.prototype, "_nodeType", interfaces_1.NodeType.CData);
  return CDATASectionImpl;
}
var ChildNodeImpl = {};
var hasRequiredChildNodeImpl;
function requireChildNodeImpl() {
  if (hasRequiredChildNodeImpl) return ChildNodeImpl;
  hasRequiredChildNodeImpl = 1;
  Object.defineProperty(ChildNodeImpl, "__esModule", { value: true });
  const util_1 = requireUtil$1();
  const algorithm_1 = requireAlgorithm();
  let ChildNodeImpl$1 = class ChildNodeImpl {
    /** @inheritdoc */
    before(...nodes2) {
      const context2 = util_1.Cast.asNode(this);
      const parent = context2._parent;
      if (parent === null)
        return;
      let viablePreviousSibling = context2._previousSibling;
      let flag = true;
      while (flag && viablePreviousSibling) {
        flag = false;
        for (let i = 0; i < nodes2.length; i++) {
          const child = nodes2[i];
          if (child === viablePreviousSibling) {
            viablePreviousSibling = viablePreviousSibling._previousSibling;
            flag = true;
            break;
          }
        }
      }
      const node2 = algorithm_1.parentNode_convertNodesIntoANode(nodes2, context2._nodeDocument);
      if (viablePreviousSibling === null)
        viablePreviousSibling = parent._firstChild;
      else
        viablePreviousSibling = viablePreviousSibling._nextSibling;
      algorithm_1.mutation_preInsert(node2, parent, viablePreviousSibling);
    }
    /** @inheritdoc */
    after(...nodes2) {
      const context2 = util_1.Cast.asNode(this);
      const parent = context2._parent;
      if (!parent)
        return;
      let viableNextSibling = context2._nextSibling;
      let flag = true;
      while (flag && viableNextSibling) {
        flag = false;
        for (let i = 0; i < nodes2.length; i++) {
          const child = nodes2[i];
          if (child === viableNextSibling) {
            viableNextSibling = viableNextSibling._nextSibling;
            flag = true;
            break;
          }
        }
      }
      const node2 = algorithm_1.parentNode_convertNodesIntoANode(nodes2, context2._nodeDocument);
      algorithm_1.mutation_preInsert(node2, parent, viableNextSibling);
    }
    /** @inheritdoc */
    replaceWith(...nodes2) {
      const context2 = util_1.Cast.asNode(this);
      const parent = context2._parent;
      if (!parent)
        return;
      let viableNextSibling = context2._nextSibling;
      let flag = true;
      while (flag && viableNextSibling) {
        flag = false;
        for (let i = 0; i < nodes2.length; i++) {
          const child = nodes2[i];
          if (child === viableNextSibling) {
            viableNextSibling = viableNextSibling._nextSibling;
            flag = true;
            break;
          }
        }
      }
      const node2 = algorithm_1.parentNode_convertNodesIntoANode(nodes2, context2._nodeDocument);
      if (context2._parent === parent)
        algorithm_1.mutation_replace(context2, node2, parent);
      else
        algorithm_1.mutation_preInsert(node2, parent, viableNextSibling);
    }
    /** @inheritdoc */
    remove() {
      const context2 = util_1.Cast.asNode(this);
      const parent = context2._parent;
      if (!parent)
        return;
      algorithm_1.mutation_remove(context2, parent);
    }
  };
  ChildNodeImpl.ChildNodeImpl = ChildNodeImpl$1;
  return ChildNodeImpl;
}
var CommentImpl = {};
var hasRequiredCommentImpl;
function requireCommentImpl() {
  if (hasRequiredCommentImpl) return CommentImpl;
  hasRequiredCommentImpl = 1;
  Object.defineProperty(CommentImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const CharacterDataImpl_1 = requireCharacterDataImpl();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let CommentImpl$1 = class CommentImpl2 extends CharacterDataImpl_1.CharacterDataImpl {
    /**
     * Initializes a new instance of `Comment`.
     *
     * @param data - the text content
     */
    constructor(data = "") {
      super(data);
    }
    /**
     * Creates a new `Comment`.
     *
     * @param document - owner document
     * @param data - node contents
     */
    static _create(document2, data = "") {
      const node2 = new CommentImpl2(data);
      node2._nodeDocument = document2;
      return node2;
    }
  };
  CommentImpl.CommentImpl = CommentImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(CommentImpl$1.prototype, "_nodeType", interfaces_1.NodeType.Comment);
  return CommentImpl;
}
var CustomEventImpl = {};
var EventImpl = {};
var hasRequiredEventImpl;
function requireEventImpl() {
  if (hasRequiredEventImpl) return EventImpl;
  hasRequiredEventImpl = 1;
  Object.defineProperty(EventImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const algorithm_1 = requireAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let EventImpl$1 = class EventImpl {
    /**
     * Initializes a new instance of `Event`.
     */
    constructor(type2, eventInit) {
      this._target = null;
      this._relatedTarget = null;
      this._touchTargetList = [];
      this._path = [];
      this._currentTarget = null;
      this._eventPhase = interfaces_1.EventPhase.None;
      this._stopPropagationFlag = false;
      this._stopImmediatePropagationFlag = false;
      this._canceledFlag = false;
      this._inPassiveListenerFlag = false;
      this._composedFlag = false;
      this._initializedFlag = false;
      this._dispatchFlag = false;
      this._isTrusted = false;
      this._bubbles = false;
      this._cancelable = false;
      this._type = type2;
      if (eventInit) {
        this._bubbles = eventInit.bubbles || false;
        this._cancelable = eventInit.cancelable || false;
        this._composedFlag = eventInit.composed || false;
      }
      this._initializedFlag = true;
      this._timeStamp = (/* @__PURE__ */ new Date()).getTime();
    }
    /** @inheritdoc */
    get type() {
      return this._type;
    }
    /** @inheritdoc */
    get target() {
      return this._target;
    }
    /** @inheritdoc */
    get srcElement() {
      return this._target;
    }
    /** @inheritdoc */
    get currentTarget() {
      return this._currentTarget;
    }
    /** @inheritdoc */
    composedPath() {
      const composedPath = [];
      const path2 = this._path;
      if (path2.length === 0)
        return composedPath;
      const currentTarget = this._currentTarget;
      if (currentTarget === null) {
        throw new Error("Event currentTarget is null.");
      }
      composedPath.push(currentTarget);
      let currentTargetIndex = 0;
      let currentTargetHiddenSubtreeLevel = 0;
      let index = path2.length - 1;
      while (index >= 0) {
        if (path2[index].rootOfClosedTree) {
          currentTargetHiddenSubtreeLevel++;
        }
        if (path2[index].invocationTarget === currentTarget) {
          currentTargetIndex = index;
          break;
        }
        if (path2[index].slotInClosedTree) {
          currentTargetHiddenSubtreeLevel--;
        }
        index--;
      }
      let currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      let maxHiddenLevel = currentTargetHiddenSubtreeLevel;
      index = currentTargetIndex - 1;
      while (index >= 0) {
        if (path2[index].rootOfClosedTree) {
          currentHiddenLevel++;
        }
        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.unshift(path2[index].invocationTarget);
        }
        if (path2[index].slotInClosedTree) {
          currentHiddenLevel--;
          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
        index--;
      }
      currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      maxHiddenLevel = currentTargetHiddenSubtreeLevel;
      index = currentTargetIndex + 1;
      while (index < path2.length) {
        if (path2[index].slotInClosedTree) {
          currentHiddenLevel++;
        }
        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.push(path2[index].invocationTarget);
        }
        if (path2[index].rootOfClosedTree) {
          currentHiddenLevel--;
          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
        index++;
      }
      return composedPath;
    }
    /** @inheritdoc */
    get eventPhase() {
      return this._eventPhase;
    }
    /** @inheritdoc */
    stopPropagation() {
      this._stopPropagationFlag = true;
    }
    /** @inheritdoc */
    get cancelBubble() {
      return this._stopPropagationFlag;
    }
    set cancelBubble(value) {
      if (value)
        this.stopPropagation();
    }
    /** @inheritdoc */
    stopImmediatePropagation() {
      this._stopPropagationFlag = true;
      this._stopImmediatePropagationFlag = true;
    }
    /** @inheritdoc */
    get bubbles() {
      return this._bubbles;
    }
    /** @inheritdoc */
    get cancelable() {
      return this._cancelable;
    }
    /** @inheritdoc */
    get returnValue() {
      return !this._canceledFlag;
    }
    set returnValue(value) {
      if (!value) {
        algorithm_1.event_setTheCanceledFlag(this);
      }
    }
    /** @inheritdoc */
    preventDefault() {
      algorithm_1.event_setTheCanceledFlag(this);
    }
    /** @inheritdoc */
    get defaultPrevented() {
      return this._canceledFlag;
    }
    /** @inheritdoc */
    get composed() {
      return this._composedFlag;
    }
    /** @inheritdoc */
    get isTrusted() {
      return this._isTrusted;
    }
    /** @inheritdoc */
    get timeStamp() {
      return this._timeStamp;
    }
    /** @inheritdoc */
    initEvent(type2, bubbles = false, cancelable = false) {
      if (this._dispatchFlag)
        return;
      algorithm_1.event_initialize(this, type2, bubbles, cancelable);
    }
  };
  EventImpl.EventImpl = EventImpl$1;
  EventImpl$1.NONE = 0;
  EventImpl$1.CAPTURING_PHASE = 1;
  EventImpl$1.AT_TARGET = 2;
  EventImpl$1.BUBBLING_PHASE = 3;
  WebIDLAlgorithm_1.idl_defineConst(EventImpl$1.prototype, "NONE", 0);
  WebIDLAlgorithm_1.idl_defineConst(EventImpl$1.prototype, "CAPTURING_PHASE", 1);
  WebIDLAlgorithm_1.idl_defineConst(EventImpl$1.prototype, "AT_TARGET", 2);
  WebIDLAlgorithm_1.idl_defineConst(EventImpl$1.prototype, "BUBBLING_PHASE", 3);
  return EventImpl;
}
var hasRequiredCustomEventImpl;
function requireCustomEventImpl() {
  if (hasRequiredCustomEventImpl) return CustomEventImpl;
  hasRequiredCustomEventImpl = 1;
  Object.defineProperty(CustomEventImpl, "__esModule", { value: true });
  const EventImpl_1 = requireEventImpl();
  const algorithm_1 = requireAlgorithm();
  let CustomEventImpl$1 = class CustomEventImpl extends EventImpl_1.EventImpl {
    /**
     * Initializes a new instance of `CustomEvent`.
     */
    constructor(type2, eventInit) {
      super(type2, eventInit);
      this._detail = null;
      this._detail = eventInit && eventInit.detail || null;
    }
    /** @inheritdoc */
    get detail() {
      return this._detail;
    }
    /** @inheritdoc */
    initCustomEvent(type2, bubbles = false, cancelable = false, detail = null) {
      if (this._dispatchFlag)
        return;
      algorithm_1.event_initialize(this, type2, bubbles, cancelable);
      this._detail = detail;
    }
  };
  CustomEventImpl.CustomEventImpl = CustomEventImpl$1;
  return CustomEventImpl;
}
var DocumentFragmentImpl = {};
var hasRequiredDocumentFragmentImpl;
function requireDocumentFragmentImpl() {
  if (hasRequiredDocumentFragmentImpl) return DocumentFragmentImpl;
  hasRequiredDocumentFragmentImpl = 1;
  Object.defineProperty(DocumentFragmentImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const NodeImpl_1 = requireNodeImpl();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let DocumentFragmentImpl$1 = class DocumentFragmentImpl2 extends NodeImpl_1.NodeImpl {
    /**
     * Initializes a new instance of `DocumentFragment`.
     *
     * @param host - shadow root's host element
     */
    constructor(host = null) {
      super();
      this._children = /* @__PURE__ */ new Set();
      this._host = host;
    }
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */
    getElementById(elementId) {
      throw new Error("Mixin: NonElementParentNode not implemented.");
    }
    // MIXIN: ParentNode
    /* istanbul ignore next */
    get children() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get firstElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get lastElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get childElementCount() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    prepend(...nodes2) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    append(...nodes2) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    querySelector(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    querySelectorAll(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /**
     * Creates a new `DocumentFragment`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */
    static _create(document2, host = null) {
      const node2 = new DocumentFragmentImpl2(host);
      node2._nodeDocument = document2;
      return node2;
    }
  };
  DocumentFragmentImpl.DocumentFragmentImpl = DocumentFragmentImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(DocumentFragmentImpl$1.prototype, "_nodeType", interfaces_1.NodeType.DocumentFragment);
  return DocumentFragmentImpl;
}
var DocumentImpl = {};
var hasRequiredDocumentImpl;
function requireDocumentImpl() {
  if (hasRequiredDocumentImpl) return DocumentImpl;
  hasRequiredDocumentImpl = 1;
  Object.defineProperty(DocumentImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const interfaces_1 = requireInterfaces$2();
  const DOMException_1 = requireDOMException();
  const NodeImpl_1 = requireNodeImpl();
  const util_1 = requireUtil$1();
  const util_2 = requireLib$9();
  const infra_1 = requireLib$8();
  const URLAlgorithm_1 = requireURLAlgorithm();
  const algorithm_1 = requireAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let DocumentImpl$1 = class DocumentImpl extends NodeImpl_1.NodeImpl {
    /**
     * Initializes a new instance of `Document`.
     */
    constructor() {
      super();
      this._children = /* @__PURE__ */ new Set();
      this._encoding = {
        name: "UTF-8",
        labels: ["unicode-1-1-utf-8", "utf-8", "utf8"]
      };
      this._contentType = "application/xml";
      this._URL = {
        scheme: "about",
        username: "",
        password: "",
        host: null,
        port: null,
        path: ["blank"],
        query: null,
        fragment: null,
        _cannotBeABaseURLFlag: true,
        _blobURLEntry: null
      };
      this._origin = null;
      this._type = "xml";
      this._mode = "no-quirks";
      this._documentElement = null;
      this._hasNamespaces = false;
      this._nodeDocumentOverwrite = null;
    }
    get _nodeDocument() {
      return this._nodeDocumentOverwrite || this;
    }
    set _nodeDocument(val) {
      this._nodeDocumentOverwrite = val;
    }
    /** @inheritdoc */
    get implementation() {
      return this._implementation || (this._implementation = algorithm_1.create_domImplementation(this));
    }
    /** @inheritdoc */
    get URL() {
      return URLAlgorithm_1.urlSerializer(this._URL);
    }
    /** @inheritdoc */
    get documentURI() {
      return this.URL;
    }
    /** @inheritdoc */
    get origin() {
      return "null";
    }
    /** @inheritdoc */
    get compatMode() {
      return this._mode === "quirks" ? "BackCompat" : "CSS1Compat";
    }
    /** @inheritdoc */
    get characterSet() {
      return this._encoding.name;
    }
    /** @inheritdoc */
    get charset() {
      return this._encoding.name;
    }
    /** @inheritdoc */
    get inputEncoding() {
      return this._encoding.name;
    }
    /** @inheritdoc */
    get contentType() {
      return this._contentType;
    }
    /** @inheritdoc */
    get doctype() {
      for (const child of this._children) {
        if (util_1.Guard.isDocumentTypeNode(child))
          return child;
      }
      return null;
    }
    /** @inheritdoc */
    get documentElement() {
      return this._documentElement;
    }
    /** @inheritdoc */
    getElementsByTagName(qualifiedName) {
      return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    }
    /** @inheritdoc */
    getElementsByTagNameNS(namespace, localName) {
      return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    }
    /** @inheritdoc */
    getElementsByClassName(classNames) {
      return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    }
    /** @inheritdoc */
    createElement(localName, options) {
      if (!algorithm_1.xml_isName(localName))
        throw new DOMException_1.InvalidCharacterError();
      if (this._type === "html")
        localName = localName.toLowerCase();
      let is = null;
      if (options !== void 0) {
        if (util_2.isString(options)) {
          is = options;
        } else {
          is = options.is;
        }
      }
      const namespace = this._type === "html" || this._contentType === "application/xhtml+xml" ? infra_1.namespace.HTML : null;
      return algorithm_1.element_createAnElement(this, localName, namespace, null, is, true);
    }
    /** @inheritdoc */
    createElementNS(namespace, qualifiedName, options) {
      return algorithm_1.document_internalCreateElementNS(this, namespace, qualifiedName, options);
    }
    /** @inheritdoc */
    createDocumentFragment() {
      return algorithm_1.create_documentFragment(this);
    }
    /** @inheritdoc */
    createTextNode(data) {
      return algorithm_1.create_text(this, data);
    }
    /** @inheritdoc */
    createCDATASection(data) {
      if (this._type === "html")
        throw new DOMException_1.NotSupportedError();
      if (data.indexOf("]]>") !== -1)
        throw new DOMException_1.InvalidCharacterError();
      return algorithm_1.create_cdataSection(this, data);
    }
    /** @inheritdoc */
    createComment(data) {
      return algorithm_1.create_comment(this, data);
    }
    /** @inheritdoc */
    createProcessingInstruction(target2, data) {
      if (!algorithm_1.xml_isName(target2))
        throw new DOMException_1.InvalidCharacterError();
      if (data.indexOf("?>") !== -1)
        throw new DOMException_1.InvalidCharacterError();
      return algorithm_1.create_processingInstruction(this, target2, data);
    }
    /** @inheritdoc */
    importNode(node2, deep = false) {
      if (util_1.Guard.isDocumentNode(node2) || util_1.Guard.isShadowRoot(node2))
        throw new DOMException_1.NotSupportedError();
      return algorithm_1.node_clone(node2, this, deep);
    }
    /** @inheritdoc */
    adoptNode(node2) {
      if (util_1.Guard.isDocumentNode(node2))
        throw new DOMException_1.NotSupportedError();
      if (util_1.Guard.isShadowRoot(node2))
        throw new DOMException_1.HierarchyRequestError();
      algorithm_1.document_adopt(node2, this);
      return node2;
    }
    /** @inheritdoc */
    createAttribute(localName) {
      if (!algorithm_1.xml_isName(localName))
        throw new DOMException_1.InvalidCharacterError();
      if (this._type === "html") {
        localName = localName.toLowerCase();
      }
      const attr = algorithm_1.create_attr(this, localName);
      return attr;
    }
    /** @inheritdoc */
    createAttributeNS(namespace, qualifiedName) {
      const [ns, prefix, localName] = algorithm_1.namespace_validateAndExtract(namespace, qualifiedName);
      const attr = algorithm_1.create_attr(this, localName);
      attr._namespace = ns;
      attr._namespacePrefix = prefix;
      return attr;
    }
    /** @inheritdoc */
    createEvent(eventInterface) {
      return algorithm_1.event_createLegacyEvent(eventInterface);
    }
    /** @inheritdoc */
    createRange() {
      const range2 = algorithm_1.create_range();
      range2._start = [this, 0];
      range2._end = [this, 0];
      return range2;
    }
    /** @inheritdoc */
    createNodeIterator(root, whatToShow = interfaces_1.WhatToShow.All, filter2 = null) {
      const iterator = algorithm_1.create_nodeIterator(root, root, true);
      iterator._whatToShow = whatToShow;
      iterator._iteratorCollection = algorithm_1.create_nodeList(root);
      if (util_2.isFunction(filter2)) {
        iterator._filter = algorithm_1.create_nodeFilter();
        iterator._filter.acceptNode = filter2;
      } else {
        iterator._filter = filter2;
      }
      return iterator;
    }
    /** @inheritdoc */
    createTreeWalker(root, whatToShow = interfaces_1.WhatToShow.All, filter2 = null) {
      const walker = algorithm_1.create_treeWalker(root, root);
      walker._whatToShow = whatToShow;
      if (util_2.isFunction(filter2)) {
        walker._filter = algorithm_1.create_nodeFilter();
        walker._filter.acceptNode = filter2;
      } else {
        walker._filter = filter2;
      }
      return walker;
    }
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    _getTheParent(event) {
      if (event._type === "load") {
        return null;
      } else {
        return _1.dom.window;
      }
    }
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */
    getElementById(elementId) {
      throw new Error("Mixin: NonElementParentNode not implemented.");
    }
    // MIXIN: DocumentOrShadowRoot
    // No elements
    // MIXIN: ParentNode
    /* istanbul ignore next */
    get children() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get firstElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get lastElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get childElementCount() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    prepend(...nodes2) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    append(...nodes2) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    querySelector(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    querySelectorAll(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
  };
  DocumentImpl.DocumentImpl = DocumentImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(DocumentImpl$1.prototype, "_nodeType", interfaces_1.NodeType.Document);
  return DocumentImpl;
}
var DocumentOrShadowRootImpl = {};
var hasRequiredDocumentOrShadowRootImpl;
function requireDocumentOrShadowRootImpl() {
  if (hasRequiredDocumentOrShadowRootImpl) return DocumentOrShadowRootImpl;
  hasRequiredDocumentOrShadowRootImpl = 1;
  Object.defineProperty(DocumentOrShadowRootImpl, "__esModule", { value: true });
  let DocumentOrShadowRootImpl$1 = class DocumentOrShadowRootImpl {
  };
  DocumentOrShadowRootImpl.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl$1;
  return DocumentOrShadowRootImpl;
}
var DocumentTypeImpl = {};
var hasRequiredDocumentTypeImpl;
function requireDocumentTypeImpl() {
  if (hasRequiredDocumentTypeImpl) return DocumentTypeImpl;
  hasRequiredDocumentTypeImpl = 1;
  Object.defineProperty(DocumentTypeImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const NodeImpl_1 = requireNodeImpl();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let DocumentTypeImpl$1 = class DocumentTypeImpl2 extends NodeImpl_1.NodeImpl {
    /**
     * Initializes a new instance of `DocumentType`.
     *
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */
    constructor(name, publicId, systemId) {
      super();
      this._name = "";
      this._publicId = "";
      this._systemId = "";
      this._name = name;
      this._publicId = publicId;
      this._systemId = systemId;
    }
    /** @inheritdoc */
    get name() {
      return this._name;
    }
    /** @inheritdoc */
    get publicId() {
      return this._publicId;
    }
    /** @inheritdoc */
    get systemId() {
      return this._systemId;
    }
    // MIXIN: ChildNode
    /* istanbul ignore next */
    before(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    after(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    replaceWith(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    remove() {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /**
     * Creates a new `DocumentType`.
     *
     * @param document - owner document
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */
    static _create(document2, name, publicId = "", systemId = "") {
      const node2 = new DocumentTypeImpl2(name, publicId, systemId);
      node2._nodeDocument = document2;
      return node2;
    }
  };
  DocumentTypeImpl.DocumentTypeImpl = DocumentTypeImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(DocumentTypeImpl$1.prototype, "_nodeType", interfaces_1.NodeType.DocumentType);
  return DocumentTypeImpl;
}
var DOMImpl = {};
var hasRequiredDOMImpl;
function requireDOMImpl() {
  if (hasRequiredDOMImpl) return DOMImpl;
  hasRequiredDOMImpl = 1;
  Object.defineProperty(DOMImpl, "__esModule", { value: true });
  const util_1 = requireLib$9();
  const algorithm_1 = requireAlgorithm();
  let DOMImpl$1 = class DOMImpl2 {
    /**
     * Initializes a new instance of `DOM`.
     */
    constructor() {
      this._features = {
        mutationObservers: true,
        customElements: true,
        slots: true,
        steps: true
      };
      this._window = null;
      this._compareCache = new util_1.CompareCache();
      this._rangeList = new util_1.FixedSizeSet();
    }
    /**
     * Sets DOM algorithm features.
     *
     * @param features - DOM features supported by algorithms. All features are
     * enabled by default unless explicity disabled.
     */
    setFeatures(features) {
      if (features === void 0)
        features = true;
      if (util_1.isObject(features)) {
        for (const key in features) {
          this._features[key] = features[key] || false;
        }
      } else {
        for (const key in this._features) {
          this._features[key] = features;
        }
      }
    }
    /**
     * Gets DOM algorithm features.
     */
    get features() {
      return this._features;
    }
    /**
     * Gets the DOM window.
     */
    get window() {
      if (this._window === null) {
        this._window = algorithm_1.create_window();
      }
      return this._window;
    }
    /**
     * Gets the global node compare cache.
     */
    get compareCache() {
      return this._compareCache;
    }
    /**
     * Gets the global range list.
     */
    get rangeList() {
      return this._rangeList;
    }
    /**
     * Returns the instance of `DOM`.
     */
    static get instance() {
      if (!DOMImpl2._instance) {
        DOMImpl2._instance = new DOMImpl2();
      }
      return DOMImpl2._instance;
    }
  };
  DOMImpl.dom = DOMImpl$1.instance;
  return DOMImpl;
}
var DOMImplementationImpl = {};
var hasRequiredDOMImplementationImpl;
function requireDOMImplementationImpl() {
  if (hasRequiredDOMImplementationImpl) return DOMImplementationImpl;
  hasRequiredDOMImplementationImpl = 1;
  Object.defineProperty(DOMImplementationImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const infra_1 = requireLib$8();
  const algorithm_1 = requireAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let DOMImplementationImpl$1 = class DOMImplementationImpl2 {
    /**
     * Initializes a new instance of `DOMImplementation`.
     *
     * @param document - the associated document
     */
    constructor(document2) {
      this._associatedDocument = document2 || _1.dom.window.document;
    }
    /** @inheritdoc */
    createDocumentType(qualifiedName, publicId, systemId) {
      algorithm_1.namespace_validate(qualifiedName);
      return algorithm_1.create_documentType(this._associatedDocument, qualifiedName, publicId, systemId);
    }
    /** @inheritdoc */
    createDocument(namespace, qualifiedName, doctype = null) {
      const document2 = algorithm_1.create_xmlDocument();
      let element2 = null;
      if (qualifiedName) {
        element2 = algorithm_1.document_internalCreateElementNS(document2, namespace, qualifiedName);
      }
      if (doctype)
        document2.appendChild(doctype);
      if (element2)
        document2.appendChild(element2);
      document2._origin = this._associatedDocument._origin;
      if (namespace === infra_1.namespace.HTML)
        document2._contentType = "application/xhtml+xml";
      else if (namespace === infra_1.namespace.SVG)
        document2._contentType = "image/svg+xml";
      else
        document2._contentType = "application/xml";
      return document2;
    }
    /** @inheritdoc */
    createHTMLDocument(title) {
      const doc = algorithm_1.create_document();
      doc._type = "html";
      doc._contentType = "text/html";
      doc.appendChild(algorithm_1.create_documentType(doc, "html", "", ""));
      const htmlElement = algorithm_1.element_createAnElement(doc, "html", infra_1.namespace.HTML);
      doc.appendChild(htmlElement);
      const headElement = algorithm_1.element_createAnElement(doc, "head", infra_1.namespace.HTML);
      htmlElement.appendChild(headElement);
      if (title !== void 0) {
        const titleElement = algorithm_1.element_createAnElement(doc, "title", infra_1.namespace.HTML);
        headElement.appendChild(titleElement);
        const textElement = algorithm_1.create_text(doc, title);
        titleElement.appendChild(textElement);
      }
      const bodyElement = algorithm_1.element_createAnElement(doc, "body", infra_1.namespace.HTML);
      htmlElement.appendChild(bodyElement);
      doc._origin = this._associatedDocument._origin;
      return doc;
    }
    /** @inheritdoc */
    hasFeature() {
      return true;
    }
    /**
     * Creates a new `DOMImplementation`.
     *
     * @param document - owner document
     */
    static _create(document2) {
      return new DOMImplementationImpl2(document2);
    }
  };
  DOMImplementationImpl.DOMImplementationImpl = DOMImplementationImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(DOMImplementationImpl$1.prototype, "_ID", "@oozcitak/dom");
  return DOMImplementationImpl;
}
var DOMTokenListImpl = {};
var hasRequiredDOMTokenListImpl;
function requireDOMTokenListImpl() {
  if (hasRequiredDOMTokenListImpl) return DOMTokenListImpl;
  hasRequiredDOMTokenListImpl = 1;
  Object.defineProperty(DOMTokenListImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const DOMException_1 = requireDOMException();
  const infra_1 = requireLib$8();
  const algorithm_1 = requireAlgorithm();
  let DOMTokenListImpl$1 = class DOMTokenListImpl2 {
    /**
     * Initializes a new instance of `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */
    constructor(element2, attribute2) {
      this._element = element2;
      this._attribute = attribute2;
      this._tokenSet = /* @__PURE__ */ new Set();
      const localName = attribute2._localName;
      const value = algorithm_1.element_getAnAttributeValue(element2, localName);
      const thisObj = this;
      function updateTokenSet(element3, localName2, oldValue, value2, namespace) {
        if (localName2 === thisObj._attribute._localName && namespace === null) {
          if (!value2)
            thisObj._tokenSet.clear();
          else
            thisObj._tokenSet = algorithm_1.orderedSet_parse(value2);
        }
      }
      this._element._attributeChangeSteps.push(updateTokenSet);
      if (_1.dom.features.steps) {
        algorithm_1.dom_runAttributeChangeSteps(element2, localName, value, value, null);
      }
    }
    /** @inheritdoc */
    get length() {
      return this._tokenSet.size;
    }
    /** @inheritdoc */
    item(index) {
      let i = 0;
      for (const token of this._tokenSet) {
        if (i === index)
          return token;
        i++;
      }
      return null;
    }
    /** @inheritdoc */
    contains(token) {
      return this._tokenSet.has(token);
    }
    /** @inheritdoc */
    add(...tokens) {
      for (const token of tokens) {
        if (token === "") {
          throw new DOMException_1.SyntaxError("Cannot add an empty token.");
        } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
          throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        } else {
          this._tokenSet.add(token);
        }
      }
      algorithm_1.tokenList_updateSteps(this);
    }
    /** @inheritdoc */
    remove(...tokens) {
      for (const token of tokens) {
        if (token === "") {
          throw new DOMException_1.SyntaxError("Cannot remove an empty token.");
        } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
          throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        } else {
          this._tokenSet.delete(token);
        }
      }
      algorithm_1.tokenList_updateSteps(this);
    }
    /** @inheritdoc */
    toggle(token, force = void 0) {
      if (token === "") {
        throw new DOMException_1.SyntaxError("Cannot toggle an empty token.");
      } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
        throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
      }
      if (this._tokenSet.has(token)) {
        if (force === void 0 || force === false) {
          this._tokenSet.delete(token);
          algorithm_1.tokenList_updateSteps(this);
          return false;
        }
        return true;
      }
      if (force === void 0 || force === true) {
        this._tokenSet.add(token);
        algorithm_1.tokenList_updateSteps(this);
        return true;
      }
      return false;
    }
    /** @inheritdoc */
    replace(token, newToken) {
      if (token === "" || newToken === "") {
        throw new DOMException_1.SyntaxError("Cannot replace an empty token.");
      } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {
        throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
      }
      if (!this._tokenSet.has(token))
        return false;
      infra_1.set.replace(this._tokenSet, token, newToken);
      algorithm_1.tokenList_updateSteps(this);
      return true;
    }
    /** @inheritdoc */
    supports(token) {
      return algorithm_1.tokenList_validationSteps(this, token);
    }
    /** @inheritdoc */
    get value() {
      return algorithm_1.tokenList_serializeSteps(this);
    }
    set value(value) {
      algorithm_1.element_setAnAttributeValue(this._element, this._attribute._localName, value);
    }
    /**
     * Returns an iterator for the token set.
     */
    [Symbol.iterator]() {
      const it2 = this._tokenSet[Symbol.iterator]();
      return {
        next() {
          return it2.next();
        }
      };
    }
    /**
     * Creates a new `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */
    static _create(element2, attribute2) {
      return new DOMTokenListImpl2(element2, attribute2);
    }
  };
  DOMTokenListImpl.DOMTokenListImpl = DOMTokenListImpl$1;
  return DOMTokenListImpl;
}
var ElementImpl = {};
var hasRequiredElementImpl;
function requireElementImpl() {
  if (hasRequiredElementImpl) return ElementImpl;
  hasRequiredElementImpl = 1;
  Object.defineProperty(ElementImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const NodeImpl_1 = requireNodeImpl();
  const DOMException_1 = requireDOMException();
  const infra_1 = requireLib$8();
  const algorithm_1 = requireAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let ElementImpl$1 = class ElementImpl2 extends NodeImpl_1.NodeImpl {
    /**
     * Initializes a new instance of `Element`.
     */
    constructor() {
      super();
      this._children = /* @__PURE__ */ new Set();
      this._namespace = null;
      this._namespacePrefix = null;
      this._localName = "";
      this._customElementState = "undefined";
      this._customElementDefinition = null;
      this._is = null;
      this._shadowRoot = null;
      this._attributeList = algorithm_1.create_namedNodeMap(this);
      this._attributeChangeSteps = [];
      this._name = "";
      this._assignedSlot = null;
    }
    /** @inheritdoc */
    get namespaceURI() {
      return this._namespace;
    }
    /** @inheritdoc */
    get prefix() {
      return this._namespacePrefix;
    }
    /** @inheritdoc */
    get localName() {
      return this._localName;
    }
    /** @inheritdoc */
    get tagName() {
      return this._htmlUppercasedQualifiedName;
    }
    /** @inheritdoc */
    get id() {
      return algorithm_1.element_getAnAttributeValue(this, "id");
    }
    set id(value) {
      algorithm_1.element_setAnAttributeValue(this, "id", value);
    }
    /** @inheritdoc */
    get className() {
      return algorithm_1.element_getAnAttributeValue(this, "class");
    }
    set className(value) {
      algorithm_1.element_setAnAttributeValue(this, "class", value);
    }
    /** @inheritdoc */
    get classList() {
      let attr = algorithm_1.element_getAnAttributeByName("class", this);
      if (attr === null) {
        attr = algorithm_1.create_attr(this._nodeDocument, "class");
      }
      return algorithm_1.create_domTokenList(this, attr);
    }
    /** @inheritdoc */
    get slot() {
      return algorithm_1.element_getAnAttributeValue(this, "slot");
    }
    set slot(value) {
      algorithm_1.element_setAnAttributeValue(this, "slot", value);
    }
    /** @inheritdoc */
    hasAttributes() {
      return this._attributeList.length !== 0;
    }
    /** @inheritdoc */
    get attributes() {
      return this._attributeList;
    }
    /** @inheritdoc */
    getAttributeNames() {
      const names = [];
      for (const attr of this._attributeList) {
        names.push(attr._qualifiedName);
      }
      return names;
    }
    /** @inheritdoc */
    getAttribute(qualifiedName) {
      const attr = algorithm_1.element_getAnAttributeByName(qualifiedName, this);
      return attr ? attr._value : null;
    }
    /** @inheritdoc */
    getAttributeNS(namespace, localName) {
      const attr = algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
      return attr ? attr._value : null;
    }
    /** @inheritdoc */
    setAttribute(qualifiedName, value) {
      if (!algorithm_1.xml_isName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError();
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      let attribute2 = null;
      for (let i = 0; i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          attribute2 = attr;
          break;
        }
      }
      if (attribute2 === null) {
        attribute2 = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
        attribute2._value = value;
        algorithm_1.element_append(attribute2, this);
        return;
      }
      algorithm_1.element_change(attribute2, this, value);
    }
    /** @inheritdoc */
    setAttributeNS(namespace, qualifiedName, value) {
      const [ns, prefix, localName] = algorithm_1.namespace_validateAndExtract(namespace, qualifiedName);
      algorithm_1.element_setAnAttributeValue(this, localName, value, prefix, ns);
    }
    /** @inheritdoc */
    removeAttribute(qualifiedName) {
      algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
    }
    /** @inheritdoc */
    removeAttributeNS(namespace, localName) {
      algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    }
    /** @inheritdoc */
    hasAttribute(qualifiedName) {
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      for (let i = 0; i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          return true;
        }
      }
      return false;
    }
    /** @inheritdoc */
    toggleAttribute(qualifiedName, force) {
      if (!algorithm_1.xml_isName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError();
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
      }
      let attribute2 = null;
      for (let i = 0; i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._qualifiedName === qualifiedName) {
          attribute2 = attr;
          break;
        }
      }
      if (attribute2 === null) {
        if (force === void 0 || force === true) {
          attribute2 = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
          attribute2._value = "";
          algorithm_1.element_append(attribute2, this);
          return true;
        }
        return false;
      } else if (force === void 0 || force === false) {
        algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
        return false;
      }
      return true;
    }
    /** @inheritdoc */
    hasAttributeNS(namespace, localName) {
      const ns = namespace || null;
      for (let i = 0; i < this._attributeList.length; i++) {
        const attr = this._attributeList[i];
        if (attr._namespace === ns && attr._localName === localName) {
          return true;
        }
      }
      return false;
    }
    /** @inheritdoc */
    getAttributeNode(qualifiedName) {
      return algorithm_1.element_getAnAttributeByName(qualifiedName, this);
    }
    /** @inheritdoc */
    getAttributeNodeNS(namespace, localName) {
      return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    }
    /** @inheritdoc */
    setAttributeNode(attr) {
      return algorithm_1.element_setAnAttribute(attr, this);
    }
    /** @inheritdoc */
    setAttributeNodeNS(attr) {
      return algorithm_1.element_setAnAttribute(attr, this);
    }
    /** @inheritdoc */
    removeAttributeNode(attr) {
      let found = false;
      for (let i = 0; i < this._attributeList.length; i++) {
        const attribute2 = this._attributeList[i];
        if (attribute2 === attr) {
          found = true;
          break;
        }
      }
      if (!found)
        throw new DOMException_1.NotFoundError();
      algorithm_1.element_remove(attr, this);
      return attr;
    }
    /** @inheritdoc */
    attachShadow(init) {
      if (this._namespace !== infra_1.namespace.HTML)
        throw new DOMException_1.NotSupportedError();
      if (!algorithm_1.customElement_isValidCustomElementName(this._localName) && !algorithm_1.customElement_isValidShadowHostName(this._localName))
        throw new DOMException_1.NotSupportedError();
      if (algorithm_1.customElement_isValidCustomElementName(this._localName) || this._is !== null) {
        const definition = algorithm_1.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);
        if (definition !== null && definition.disableShadow === true) {
          throw new DOMException_1.NotSupportedError();
        }
      }
      if (this._shadowRoot !== null)
        throw new DOMException_1.NotSupportedError();
      const shadow = algorithm_1.create_shadowRoot(this._nodeDocument, this);
      shadow._mode = init.mode;
      this._shadowRoot = shadow;
      return shadow;
    }
    /** @inheritdoc */
    get shadowRoot() {
      const shadow = this._shadowRoot;
      if (shadow === null || shadow.mode === "closed")
        return null;
      else
        return shadow;
    }
    /** @inheritdoc */
    closest(selectors) {
      throw new DOMException_1.NotImplementedError();
    }
    /** @inheritdoc */
    matches(selectors) {
      throw new DOMException_1.NotImplementedError();
    }
    /** @inheritdoc */
    webkitMatchesSelector(selectors) {
      return this.matches(selectors);
    }
    /** @inheritdoc */
    getElementsByTagName(qualifiedName) {
      return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    }
    /** @inheritdoc */
    getElementsByTagNameNS(namespace, localName) {
      return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    }
    /** @inheritdoc */
    getElementsByClassName(classNames) {
      return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    }
    /** @inheritdoc */
    insertAdjacentElement(where, element2) {
      return algorithm_1.element_insertAdjacent(this, where, element2);
    }
    /** @inheritdoc */
    insertAdjacentText(where, data) {
      const text = algorithm_1.create_text(this._nodeDocument, data);
      algorithm_1.element_insertAdjacent(this, where, text);
    }
    /**
     * Returns the qualified name.
     */
    get _qualifiedName() {
      return this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
    }
    /**
     * Returns the upper-cased qualified name for a html element.
     */
    get _htmlUppercasedQualifiedName() {
      let qualifiedName = this._qualifiedName;
      if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toUpperCase();
      }
      return qualifiedName;
    }
    // MIXIN: ParentNode
    /* istanbul ignore next */
    get children() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get firstElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get lastElementChild() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    get childElementCount() {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    prepend(...nodes2) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    append(...nodes2) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    querySelector(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    /* istanbul ignore next */
    querySelectorAll(selectors) {
      throw new Error("Mixin: ParentNode not implemented.");
    }
    // MIXIN: NonDocumentTypeChildNode
    /* istanbul ignore next */
    get previousElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    /* istanbul ignore next */
    get nextElementSibling() {
      throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
    }
    // MIXIN: ChildNode
    /* istanbul ignore next */
    before(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    after(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    replaceWith(...nodes2) {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    /* istanbul ignore next */
    remove() {
      throw new Error("Mixin: ChildNode not implemented.");
    }
    // MIXIN: Slotable
    /* istanbul ignore next */
    get assignedSlot() {
      throw new Error("Mixin: Slotable not implemented.");
    }
    /**
     * Creates a new `Element`.
     *
     * @param document - owner document
     * @param localName - local name
     * @param namespace - namespace
     * @param prefix - namespace prefix
     */
    static _create(document2, localName, namespace = null, namespacePrefix = null) {
      const node2 = new ElementImpl2();
      node2._localName = localName;
      node2._namespace = namespace;
      node2._namespacePrefix = namespacePrefix;
      node2._nodeDocument = document2;
      return node2;
    }
  };
  ElementImpl.ElementImpl = ElementImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(ElementImpl$1.prototype, "_nodeType", interfaces_1.NodeType.Element);
  return ElementImpl;
}
var HTMLCollectionImpl = {};
var hasRequiredHTMLCollectionImpl;
function requireHTMLCollectionImpl() {
  if (hasRequiredHTMLCollectionImpl) return HTMLCollectionImpl;
  hasRequiredHTMLCollectionImpl = 1;
  Object.defineProperty(HTMLCollectionImpl, "__esModule", { value: true });
  const infra_1 = requireLib$8();
  const algorithm_1 = requireAlgorithm();
  const util_1 = requireUtil$1();
  const util_2 = requireLib$9();
  let HTMLCollectionImpl$1 = class HTMLCollectionImpl2 {
    /**
     * Initializes a new instance of `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */
    constructor(root, filter2) {
      this._live = true;
      this._root = root;
      this._filter = filter2;
      return new Proxy(this, this);
    }
    /** @inheritdoc */
    get length() {
      let count = 0;
      let node2 = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      while (node2 !== null) {
        count++;
        node2 = algorithm_1.tree_getNextDescendantNode(this._root, node2, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      }
      return count;
    }
    /** @inheritdoc */
    item(index) {
      let i = 0;
      let node2 = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      while (node2 !== null) {
        if (i === index)
          return node2;
        else
          i++;
        node2 = algorithm_1.tree_getNextDescendantNode(this._root, node2, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      }
      return null;
    }
    /** @inheritdoc */
    namedItem(key) {
      if (key === "")
        return null;
      let ele = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      while (ele != null) {
        if (ele._uniqueIdentifier === key) {
          return ele;
        } else if (ele._namespace === infra_1.namespace.HTML) {
          for (let i = 0; i < ele._attributeList.length; i++) {
            const attr = ele._attributeList[i];
            if (attr._localName === "name" && attr._namespace === null && attr._namespacePrefix === null && attr._value === key)
              return ele;
          }
        }
        ele = algorithm_1.tree_getNextDescendantNode(this._root, ele, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
      }
      return null;
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
      const root = this._root;
      const filter2 = this._filter;
      let currentNode = algorithm_1.tree_getFirstDescendantNode(root, false, false, (e) => util_1.Guard.isElementNode(e) && filter2(e));
      return {
        next() {
          if (currentNode === null) {
            return { done: true, value: null };
          } else {
            const result = { done: false, value: currentNode };
            currentNode = algorithm_1.tree_getNextDescendantNode(root, currentNode, false, false, (e) => util_1.Guard.isElementNode(e) && filter2(e));
            return result;
          }
        }
      };
    }
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    get(target2, key, receiver) {
      if (!util_2.isString(key) || HTMLCollectionImpl2.reservedNames.indexOf(key) !== -1) {
        return Reflect.get(target2, key, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return target2.namedItem(key) || void 0;
      } else {
        return target2.item(index) || void 0;
      }
    }
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    set(target2, key, value, receiver) {
      if (!util_2.isString(key) || HTMLCollectionImpl2.reservedNames.indexOf(key) !== -1) {
        return Reflect.set(target2, key, value, receiver);
      }
      const index = Number(key);
      const node2 = isNaN(index) ? target2.namedItem(key) || void 0 : target2.item(index) || void 0;
      if (node2 && node2._parent) {
        algorithm_1.mutation_replace(node2, value, node2._parent);
        return true;
      } else {
        return false;
      }
    }
    /**
     * Creates a new `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */
    static _create(root, filter2 = (() => true)) {
      return new HTMLCollectionImpl2(root, filter2);
    }
  };
  HTMLCollectionImpl.HTMLCollectionImpl = HTMLCollectionImpl$1;
  HTMLCollectionImpl$1.reservedNames = [
    "_root",
    "_live",
    "_filter",
    "length",
    "item",
    "namedItem",
    "get",
    "set"
  ];
  return HTMLCollectionImpl;
}
var MutationObserverImpl = {};
var hasRequiredMutationObserverImpl;
function requireMutationObserverImpl() {
  if (hasRequiredMutationObserverImpl) return MutationObserverImpl;
  hasRequiredMutationObserverImpl = 1;
  Object.defineProperty(MutationObserverImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const util_1 = requireUtil$1();
  const infra_1 = requireLib$8();
  let MutationObserverImpl$1 = class MutationObserverImpl {
    /**
     * Initializes a new instance of `MutationObserver`.
     *
     * @param callback - the callback function
     */
    constructor(callback) {
      this._nodeList = [];
      this._recordQueue = [];
      this._callback = callback;
      const window2 = _1.dom.window;
      infra_1.set.append(window2._mutationObservers, this);
    }
    /** @inheritdoc */
    observe(target2, options) {
      options = options || {
        childList: false,
        subtree: false
      };
      if ((options.attributeOldValue !== void 0 || options.attributeFilter !== void 0) && options.attributes === void 0) {
        options.attributes = true;
      }
      if (options.characterDataOldValue !== void 0 && options.characterData === void 0) {
        options.characterData = true;
      }
      if (!options.childList && !options.attributes && !options.characterData) {
        throw new TypeError();
      }
      if (options.attributeOldValue && !options.attributes) {
        throw new TypeError();
      }
      if (options.attributeFilter !== void 0 && !options.attributes) {
        throw new TypeError();
      }
      if (options.characterDataOldValue && !options.characterData) {
        throw new TypeError();
      }
      let isRegistered = false;
      const coptions = options;
      for (const registered of target2._registeredObserverList) {
        if (registered.observer === this) {
          isRegistered = true;
          for (const node2 of this._nodeList) {
            infra_1.list.remove(node2._registeredObserverList, (ob) => util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered);
          }
          registered.options = coptions;
        }
      }
      if (!isRegistered) {
        target2._registeredObserverList.push({ observer: this, options });
        this._nodeList.push(target2);
      }
    }
    /** @inheritdoc */
    disconnect() {
      for (const node2 of this._nodeList) {
        infra_1.list.remove(node2._registeredObserverList, (ob) => ob.observer === this);
      }
      this._recordQueue = [];
    }
    /** @inheritdoc */
    takeRecords() {
      const records = this._recordQueue;
      this._recordQueue = [];
      return records;
    }
  };
  MutationObserverImpl.MutationObserverImpl = MutationObserverImpl$1;
  return MutationObserverImpl;
}
var MutationRecordImpl = {};
var hasRequiredMutationRecordImpl;
function requireMutationRecordImpl() {
  if (hasRequiredMutationRecordImpl) return MutationRecordImpl;
  hasRequiredMutationRecordImpl = 1;
  Object.defineProperty(MutationRecordImpl, "__esModule", { value: true });
  let MutationRecordImpl$1 = class MutationRecordImpl2 {
    /**
     * Initializes a new instance of `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */
    constructor(type2, target2, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
      this._type = type2;
      this._target = target2;
      this._addedNodes = addedNodes;
      this._removedNodes = removedNodes;
      this._previousSibling = previousSibling;
      this._nextSibling = nextSibling;
      this._attributeName = attributeName;
      this._attributeNamespace = attributeNamespace;
      this._oldValue = oldValue;
    }
    /** @inheritdoc */
    get type() {
      return this._type;
    }
    /** @inheritdoc */
    get target() {
      return this._target;
    }
    /** @inheritdoc */
    get addedNodes() {
      return this._addedNodes;
    }
    /** @inheritdoc */
    get removedNodes() {
      return this._removedNodes;
    }
    /** @inheritdoc */
    get previousSibling() {
      return this._previousSibling;
    }
    /** @inheritdoc */
    get nextSibling() {
      return this._nextSibling;
    }
    /** @inheritdoc */
    get attributeName() {
      return this._attributeName;
    }
    /** @inheritdoc */
    get attributeNamespace() {
      return this._attributeNamespace;
    }
    /** @inheritdoc */
    get oldValue() {
      return this._oldValue;
    }
    /**
     * Creates a new `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */
    static _create(type2, target2, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
      return new MutationRecordImpl2(type2, target2, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
    }
  };
  MutationRecordImpl.MutationRecordImpl = MutationRecordImpl$1;
  return MutationRecordImpl;
}
var NamedNodeMapImpl = {};
var hasRequiredNamedNodeMapImpl;
function requireNamedNodeMapImpl() {
  if (hasRequiredNamedNodeMapImpl) return NamedNodeMapImpl;
  hasRequiredNamedNodeMapImpl = 1;
  Object.defineProperty(NamedNodeMapImpl, "__esModule", { value: true });
  const DOMException_1 = requireDOMException();
  const algorithm_1 = requireAlgorithm();
  let NamedNodeMapImpl$1 = class NamedNodeMapImpl2 extends Array {
    /**
     * Initializes a new instance of `NamedNodeMap`.
     *
     * @param element - parent element
     */
    constructor(element2) {
      super();
      this._element = element2;
    }
    _asArray() {
      return this;
    }
    /** @inheritdoc */
    item(index) {
      return this[index] || null;
    }
    /** @inheritdoc */
    getNamedItem(qualifiedName) {
      return algorithm_1.element_getAnAttributeByName(qualifiedName, this._element);
    }
    /** @inheritdoc */
    getNamedItemNS(namespace, localName) {
      return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, this._element);
    }
    /** @inheritdoc */
    setNamedItem(attr) {
      return algorithm_1.element_setAnAttribute(attr, this._element);
    }
    /** @inheritdoc */
    setNamedItemNS(attr) {
      return algorithm_1.element_setAnAttribute(attr, this._element);
    }
    /** @inheritdoc */
    removeNamedItem(qualifiedName) {
      const attr = algorithm_1.element_removeAnAttributeByName(qualifiedName, this._element);
      if (attr === null)
        throw new DOMException_1.NotFoundError();
      return attr;
    }
    /** @inheritdoc */
    removeNamedItemNS(namespace, localName) {
      const attr = algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace || "", localName, this._element);
      if (attr === null)
        throw new DOMException_1.NotFoundError();
      return attr;
    }
    /**
     * Creates a new `NamedNodeMap`.
     *
     * @param element - parent element
     */
    static _create(element2) {
      return new NamedNodeMapImpl2(element2);
    }
  };
  NamedNodeMapImpl.NamedNodeMapImpl = NamedNodeMapImpl$1;
  return NamedNodeMapImpl;
}
var NodeFilterImpl = {};
var hasRequiredNodeFilterImpl;
function requireNodeFilterImpl() {
  if (hasRequiredNodeFilterImpl) return NodeFilterImpl;
  hasRequiredNodeFilterImpl = 1;
  Object.defineProperty(NodeFilterImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let NodeFilterImpl$1 = class NodeFilterImpl2 {
    /**
     * Initializes a new instance of `NodeFilter`.
     */
    constructor() {
    }
    /**
     * Callback function.
     */
    acceptNode(node2) {
      return interfaces_1.FilterResult.Accept;
    }
    /**
     * Creates a new `NodeFilter`.
     */
    static _create() {
      return new NodeFilterImpl2();
    }
  };
  NodeFilterImpl.NodeFilterImpl = NodeFilterImpl$1;
  NodeFilterImpl$1.FILTER_ACCEPT = 1;
  NodeFilterImpl$1.FILTER_REJECT = 2;
  NodeFilterImpl$1.FILTER_SKIP = 3;
  NodeFilterImpl$1.SHOW_ALL = 4294967295;
  NodeFilterImpl$1.SHOW_ELEMENT = 1;
  NodeFilterImpl$1.SHOW_ATTRIBUTE = 2;
  NodeFilterImpl$1.SHOW_TEXT = 4;
  NodeFilterImpl$1.SHOW_CDATA_SECTION = 8;
  NodeFilterImpl$1.SHOW_ENTITY_REFERENCE = 16;
  NodeFilterImpl$1.SHOW_ENTITY = 32;
  NodeFilterImpl$1.SHOW_PROCESSING_INSTRUCTION = 64;
  NodeFilterImpl$1.SHOW_COMMENT = 128;
  NodeFilterImpl$1.SHOW_DOCUMENT = 256;
  NodeFilterImpl$1.SHOW_DOCUMENT_TYPE = 512;
  NodeFilterImpl$1.SHOW_DOCUMENT_FRAGMENT = 1024;
  NodeFilterImpl$1.SHOW_NOTATION = 2048;
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "FILTER_ACCEPT", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "FILTER_REJECT", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "FILTER_SKIP", 3);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_ALL", 4294967295);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_ELEMENT", 1);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_ATTRIBUTE", 2);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_TEXT", 4);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_CDATA_SECTION", 8);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_ENTITY_REFERENCE", 16);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_ENTITY", 32);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_PROCESSING_INSTRUCTION", 64);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_COMMENT", 128);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_DOCUMENT", 256);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_DOCUMENT_TYPE", 512);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_DOCUMENT_FRAGMENT", 1024);
  WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl$1.prototype, "SHOW_NOTATION", 2048);
  return NodeFilterImpl;
}
var NodeIteratorImpl = {};
var TraverserImpl = {};
var hasRequiredTraverserImpl;
function requireTraverserImpl() {
  if (hasRequiredTraverserImpl) return TraverserImpl;
  hasRequiredTraverserImpl = 1;
  Object.defineProperty(TraverserImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  let TraverserImpl$1 = class TraverserImpl {
    /**
     * Initializes a new instance of `Traverser`.
     *
     * @param root - root node
     */
    constructor(root) {
      this._activeFlag = false;
      this._root = root;
      this._whatToShow = interfaces_1.WhatToShow.All;
      this._filter = null;
    }
    /** @inheritdoc */
    get root() {
      return this._root;
    }
    /** @inheritdoc */
    get whatToShow() {
      return this._whatToShow;
    }
    /** @inheritdoc */
    get filter() {
      return this._filter;
    }
  };
  TraverserImpl.TraverserImpl = TraverserImpl$1;
  return TraverserImpl;
}
var hasRequiredNodeIteratorImpl;
function requireNodeIteratorImpl() {
  if (hasRequiredNodeIteratorImpl) return NodeIteratorImpl;
  hasRequiredNodeIteratorImpl = 1;
  Object.defineProperty(NodeIteratorImpl, "__esModule", { value: true });
  const TraverserImpl_1 = requireTraverserImpl();
  const algorithm_1 = requireAlgorithm();
  let NodeIteratorImpl$1 = class NodeIteratorImpl2 extends TraverserImpl_1.TraverserImpl {
    /**
     * Initializes a new instance of `NodeIterator`.
     */
    constructor(root, reference, pointerBeforeReference) {
      super(root);
      this._iteratorCollection = void 0;
      this._reference = reference;
      this._pointerBeforeReference = pointerBeforeReference;
      algorithm_1.nodeIterator_iteratorList().add(this);
    }
    /** @inheritdoc */
    get referenceNode() {
      return this._reference;
    }
    /** @inheritdoc */
    get pointerBeforeReferenceNode() {
      return this._pointerBeforeReference;
    }
    /** @inheritdoc */
    nextNode() {
      return algorithm_1.nodeIterator_traverse(this, true);
    }
    /** @inheritdoc */
    previousNode() {
      return algorithm_1.nodeIterator_traverse(this, false);
    }
    /** @inheritdoc */
    detach() {
      algorithm_1.nodeIterator_iteratorList().delete(this);
    }
    /**
     * Creates a new `NodeIterator`.
     *
     * @param root - iterator's root node
     * @param reference - reference node
     * @param pointerBeforeReference - whether the iterator is before or after the
     * reference node
     */
    static _create(root, reference, pointerBeforeReference) {
      return new NodeIteratorImpl2(root, reference, pointerBeforeReference);
    }
  };
  NodeIteratorImpl.NodeIteratorImpl = NodeIteratorImpl$1;
  return NodeIteratorImpl;
}
var NodeListImpl = {};
var hasRequiredNodeListImpl;
function requireNodeListImpl() {
  if (hasRequiredNodeListImpl) return NodeListImpl;
  hasRequiredNodeListImpl = 1;
  Object.defineProperty(NodeListImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const util_1 = requireLib$9();
  const algorithm_1 = requireAlgorithm();
  let NodeListImpl$1 = class NodeListImpl2 {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */
    constructor(root) {
      this._live = true;
      this._filter = null;
      this._length = 0;
      this._root = root;
      return new Proxy(this, this);
    }
    /** @inheritdoc */
    get length() {
      return this._root._children.size;
    }
    /** @inheritdoc */
    item(index) {
      if (index < 0 || index > this.length - 1)
        return null;
      if (index < this.length / 2) {
        let i = 0;
        let node2 = this._root._firstChild;
        while (node2 !== null && i !== index) {
          node2 = node2._nextSibling;
          i++;
        }
        return node2;
      } else {
        let i = this.length - 1;
        let node2 = this._root._lastChild;
        while (node2 !== null && i !== index) {
          node2 = node2._previousSibling;
          i--;
        }
        return node2;
      }
    }
    /** @inheritdoc */
    keys() {
      return {
        [Symbol.iterator]: (function() {
          let index = 0;
          return {
            next: (function() {
              if (index === this.length) {
                return { done: true, value: null };
              } else {
                return { done: false, value: index++ };
              }
            }).bind(this)
          };
        }).bind(this)
      };
    }
    /** @inheritdoc */
    values() {
      return {
        [Symbol.iterator]: (function() {
          const it2 = this[Symbol.iterator]();
          return {
            next() {
              return it2.next();
            }
          };
        }).bind(this)
      };
    }
    /** @inheritdoc */
    entries() {
      return {
        [Symbol.iterator]: (function() {
          const it2 = this[Symbol.iterator]();
          let index = 0;
          return {
            next() {
              const itResult = it2.next();
              if (itResult.done) {
                return { done: true, value: null };
              } else {
                return { done: false, value: [index++, itResult.value] };
              }
            }
          };
        }).bind(this)
      };
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
      return this._root._children[Symbol.iterator]();
    }
    /** @inheritdoc */
    forEach(callback, thisArg) {
      if (thisArg === void 0) {
        thisArg = _1.dom.window;
      }
      let index = 0;
      for (const node2 of this._root._children) {
        callback.call(thisArg, node2, index++, this);
      }
    }
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    get(target2, key, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.get(target2, key, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.get(target2, key, receiver);
      }
      return target2.item(index) || void 0;
    }
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    set(target2, key, value, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.set(target2, key, value, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.set(target2, key, value, receiver);
      }
      const node2 = target2.item(index) || void 0;
      if (!node2)
        return false;
      if (node2._parent) {
        algorithm_1.mutation_replace(node2, value, node2._parent);
        return true;
      } else {
        return false;
      }
    }
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     */
    static _create(root) {
      return new NodeListImpl2(root);
    }
  };
  NodeListImpl.NodeListImpl = NodeListImpl$1;
  return NodeListImpl;
}
var NodeListStaticImpl = {};
var hasRequiredNodeListStaticImpl;
function requireNodeListStaticImpl() {
  if (hasRequiredNodeListStaticImpl) return NodeListStaticImpl;
  hasRequiredNodeListStaticImpl = 1;
  Object.defineProperty(NodeListStaticImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const util_1 = requireLib$9();
  let NodeListStaticImpl$1 = class NodeListStaticImpl2 {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */
    constructor(root) {
      this._live = false;
      this._items = [];
      this._length = 0;
      this._root = root;
      this._items = [];
      this._filter = function(node2) {
        return true;
      };
      return new Proxy(this, this);
    }
    /** @inheritdoc */
    get length() {
      return this._items.length;
    }
    /** @inheritdoc */
    item(index) {
      if (index < 0 || index > this.length - 1)
        return null;
      return this._items[index];
    }
    /** @inheritdoc */
    keys() {
      return {
        [Symbol.iterator]: (function() {
          let index = 0;
          return {
            next: (function() {
              if (index === this.length) {
                return { done: true, value: null };
              } else {
                return { done: false, value: index++ };
              }
            }).bind(this)
          };
        }).bind(this)
      };
    }
    /** @inheritdoc */
    values() {
      return {
        [Symbol.iterator]: (function() {
          const it2 = this[Symbol.iterator]();
          return {
            next() {
              return it2.next();
            }
          };
        }).bind(this)
      };
    }
    /** @inheritdoc */
    entries() {
      return {
        [Symbol.iterator]: (function() {
          const it2 = this[Symbol.iterator]();
          let index = 0;
          return {
            next() {
              const itResult = it2.next();
              if (itResult.done) {
                return { done: true, value: null };
              } else {
                return { done: false, value: [index++, itResult.value] };
              }
            }
          };
        }).bind(this)
      };
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
      const it2 = this._items[Symbol.iterator]();
      return {
        next() {
          return it2.next();
        }
      };
    }
    /** @inheritdoc */
    forEach(callback, thisArg) {
      if (thisArg === void 0) {
        thisArg = _1.dom.window;
      }
      let index = 0;
      for (const node2 of this._items) {
        callback.call(thisArg, node2, index++, this);
      }
    }
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    get(target2, key, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.get(target2, key, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.get(target2, key, receiver);
      }
      return target2._items[index] || void 0;
    }
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    set(target2, key, value, receiver) {
      if (!util_1.isString(key)) {
        return Reflect.set(target2, key, value, receiver);
      }
      const index = Number(key);
      if (isNaN(index)) {
        return Reflect.set(target2, key, value, receiver);
      }
      if (index >= 0 && index < target2._items.length) {
        target2._items[index] = value;
        return true;
      } else {
        return false;
      }
    }
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     * @param items - a list of items to initialize the list
     */
    static _create(root, items) {
      const list = new NodeListStaticImpl2(root);
      list._items = items;
      return list;
    }
  };
  NodeListStaticImpl.NodeListStaticImpl = NodeListStaticImpl$1;
  return NodeListStaticImpl;
}
var NonDocumentTypeChildNodeImpl = {};
var hasRequiredNonDocumentTypeChildNodeImpl;
function requireNonDocumentTypeChildNodeImpl() {
  if (hasRequiredNonDocumentTypeChildNodeImpl) return NonDocumentTypeChildNodeImpl;
  hasRequiredNonDocumentTypeChildNodeImpl = 1;
  Object.defineProperty(NonDocumentTypeChildNodeImpl, "__esModule", { value: true });
  const util_1 = requireUtil$1();
  let NonDocumentTypeChildNodeImpl$1 = class NonDocumentTypeChildNodeImpl {
    /** @inheritdoc */
    get previousElementSibling() {
      let node2 = util_1.Cast.asNode(this)._previousSibling;
      while (node2) {
        if (util_1.Guard.isElementNode(node2))
          return node2;
        else
          node2 = node2._previousSibling;
      }
      return null;
    }
    /** @inheritdoc */
    get nextElementSibling() {
      let node2 = util_1.Cast.asNode(this)._nextSibling;
      while (node2) {
        if (util_1.Guard.isElementNode(node2))
          return node2;
        else
          node2 = node2._nextSibling;
      }
      return null;
    }
  };
  NonDocumentTypeChildNodeImpl.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl$1;
  return NonDocumentTypeChildNodeImpl;
}
var NonElementParentNodeImpl = {};
var hasRequiredNonElementParentNodeImpl;
function requireNonElementParentNodeImpl() {
  if (hasRequiredNonElementParentNodeImpl) return NonElementParentNodeImpl;
  hasRequiredNonElementParentNodeImpl = 1;
  Object.defineProperty(NonElementParentNodeImpl, "__esModule", { value: true });
  const util_1 = requireUtil$1();
  const algorithm_1 = requireAlgorithm();
  let NonElementParentNodeImpl$1 = class NonElementParentNodeImpl {
    /** @inheritdoc */
    getElementById(id) {
      let ele = algorithm_1.tree_getFirstDescendantNode(util_1.Cast.asNode(this), false, false, (e) => util_1.Guard.isElementNode(e));
      while (ele !== null) {
        if (ele._uniqueIdentifier === id) {
          return ele;
        }
        ele = algorithm_1.tree_getNextDescendantNode(util_1.Cast.asNode(this), ele, false, false, (e) => util_1.Guard.isElementNode(e));
      }
      return null;
    }
  };
  NonElementParentNodeImpl.NonElementParentNodeImpl = NonElementParentNodeImpl$1;
  return NonElementParentNodeImpl;
}
var ParentNodeImpl = {};
var hasRequiredParentNodeImpl;
function requireParentNodeImpl() {
  if (hasRequiredParentNodeImpl) return ParentNodeImpl;
  hasRequiredParentNodeImpl = 1;
  Object.defineProperty(ParentNodeImpl, "__esModule", { value: true });
  const util_1 = requireUtil$1();
  const algorithm_1 = requireAlgorithm();
  let ParentNodeImpl$1 = class ParentNodeImpl {
    /** @inheritdoc */
    get children() {
      return algorithm_1.create_htmlCollection(util_1.Cast.asNode(this));
    }
    /** @inheritdoc */
    get firstElementChild() {
      let node2 = util_1.Cast.asNode(this)._firstChild;
      while (node2) {
        if (util_1.Guard.isElementNode(node2))
          return node2;
        else
          node2 = node2._nextSibling;
      }
      return null;
    }
    /** @inheritdoc */
    get lastElementChild() {
      let node2 = util_1.Cast.asNode(this)._lastChild;
      while (node2) {
        if (util_1.Guard.isElementNode(node2))
          return node2;
        else
          node2 = node2._previousSibling;
      }
      return null;
    }
    /** @inheritdoc */
    get childElementCount() {
      let count = 0;
      for (const childNode of util_1.Cast.asNode(this)._children) {
        if (util_1.Guard.isElementNode(childNode))
          count++;
      }
      return count;
    }
    /** @inheritdoc */
    prepend(...nodes2) {
      const node2 = util_1.Cast.asNode(this);
      const childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes2, node2._nodeDocument);
      algorithm_1.mutation_preInsert(childNode, node2, node2._firstChild);
    }
    /** @inheritdoc */
    append(...nodes2) {
      const node2 = util_1.Cast.asNode(this);
      const childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes2, node2._nodeDocument);
      algorithm_1.mutation_append(childNode, node2);
    }
    /** @inheritdoc */
    querySelector(selectors) {
      const node2 = util_1.Cast.asNode(this);
      const result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node2);
      return result.length === 0 ? null : result[0];
    }
    /** @inheritdoc */
    querySelectorAll(selectors) {
      const node2 = util_1.Cast.asNode(this);
      const result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node2);
      return algorithm_1.create_nodeListStatic(node2, result);
    }
  };
  ParentNodeImpl.ParentNodeImpl = ParentNodeImpl$1;
  return ParentNodeImpl;
}
var ProcessingInstructionImpl = {};
var hasRequiredProcessingInstructionImpl;
function requireProcessingInstructionImpl() {
  if (hasRequiredProcessingInstructionImpl) return ProcessingInstructionImpl;
  hasRequiredProcessingInstructionImpl = 1;
  Object.defineProperty(ProcessingInstructionImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const CharacterDataImpl_1 = requireCharacterDataImpl();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  let ProcessingInstructionImpl$1 = class ProcessingInstructionImpl2 extends CharacterDataImpl_1.CharacterDataImpl {
    /**
     * Initializes a new instance of `ProcessingInstruction`.
     */
    constructor(target2, data) {
      super(data);
      this._target = target2;
    }
    /**
     * Gets the target of the {@link ProcessingInstruction} node.
     */
    get target() {
      return this._target;
    }
    /**
     * Creates a new `ProcessingInstruction`.
     *
     * @param document - owner document
     * @param target - instruction target
     * @param data - node contents
     */
    static _create(document2, target2, data) {
      const node2 = new ProcessingInstructionImpl2(target2, data);
      node2._nodeDocument = document2;
      return node2;
    }
  };
  ProcessingInstructionImpl.ProcessingInstructionImpl = ProcessingInstructionImpl$1;
  WebIDLAlgorithm_1.idl_defineConst(ProcessingInstructionImpl$1.prototype, "_nodeType", interfaces_1.NodeType.ProcessingInstruction);
  return ProcessingInstructionImpl;
}
var RangeImpl = {};
var hasRequiredRangeImpl;
function requireRangeImpl() {
  if (hasRequiredRangeImpl) return RangeImpl;
  hasRequiredRangeImpl = 1;
  Object.defineProperty(RangeImpl, "__esModule", { value: true });
  const _1 = requireDom$1();
  const interfaces_1 = requireInterfaces$2();
  const AbstractRangeImpl_1 = requireAbstractRangeImpl();
  const DOMException_1 = requireDOMException();
  const algorithm_1 = requireAlgorithm();
  const WebIDLAlgorithm_1 = requireWebIDLAlgorithm();
  const util_1 = requireUtil$1();
  let RangeImpl$1 = class RangeImpl2 extends AbstractRangeImpl_1.AbstractRangeImpl {
    /**
     * Initializes a new instance of `Range`.
     */
    constructor() {
      super();
      const doc = _1.dom.window._associatedDocument;
      this._start = [doc, 0];
      this._end = [doc, 0];
      _1.dom.rangeList.add(this);
    }
    /** @inheritdoc */
    get commonAncestorContainer() {
      let container = this._start[0];
      while (!algorithm_1.tree_isAncestorOf(this._end[0], container, true)) {
        if (container._parent === null) {
          throw new Error("Parent node  is null.");
        }
        container = container._parent;
      }
      return container;
    }
    /** @inheritdoc */
    setStart(node2, offset) {
      algorithm_1.range_setTheStart(this, node2, offset);
    }
    /** @inheritdoc */
    setEnd(node2, offset) {
      algorithm_1.range_setTheEnd(this, node2, offset);
    }
    /** @inheritdoc */
    setStartBefore(node2) {
      let parent = node2._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError();
      algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node2));
    }
    /** @inheritdoc */
    setStartAfter(node2) {
      let parent = node2._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError();
      algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node2) + 1);
    }
    /** @inheritdoc */
    setEndBefore(node2) {
      let parent = node2._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError();
      algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node2));
    }
    /** @inheritdoc */
    setEndAfter(node2) {
      let parent = node2._parent;
      if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError();
      algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node2) + 1);
    }
    /** @inheritdoc */
    collapse(toStart) {
      if (toStart) {
        this._end = this._start;
      } else {
        this._start = this._end;
      }
    }
    /** @inheritdoc */
    selectNode(node2) {
      algorithm_1.range_select(node2, this);
    }
    /** @inheritdoc */
    selectNodeContents(node2) {
      if (util_1.Guard.isDocumentTypeNode(node2))
        throw new DOMException_1.InvalidNodeTypeError();
      const length = algorithm_1.tree_nodeLength(node2);
      this._start = [node2, 0];
      this._end = [node2, length];
    }
    /** @inheritdoc */
    compareBoundaryPoints(how, sourceRange) {
      if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd && how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart)
        throw new DOMException_1.NotSupportedError();
      if (algorithm_1.range_root(this) !== algorithm_1.range_root(sourceRange))
        throw new DOMException_1.WrongDocumentError();
      let thisPoint;
      let otherPoint;
      switch (how) {
        case interfaces_1.HowToCompare.StartToStart:
          thisPoint = this._start;
          otherPoint = sourceRange._start;
          break;
        case interfaces_1.HowToCompare.StartToEnd:
          thisPoint = this._end;
          otherPoint = sourceRange._start;
          break;
        case interfaces_1.HowToCompare.EndToEnd:
          thisPoint = this._end;
          otherPoint = sourceRange._end;
          break;
        case interfaces_1.HowToCompare.EndToStart:
          thisPoint = this._start;
          otherPoint = sourceRange._end;
          break;
        /* istanbul ignore next */
        default:
          throw new DOMException_1.NotSupportedError();
      }
      const position = algorithm_1.boundaryPoint_position(thisPoint, otherPoint);
      if (position === interfaces_1.BoundaryPosition.Before) {
        return -1;
      } else if (position === interfaces_1.BoundaryPosition.After) {
        return 1;
      } else {
        return 0;
      }
    }
    /** @inheritdoc */
    deleteContents() {
      if (algorithm_1.range_collapsed(this))
        return;
      const originalStartNode = this._startNode;
      const originalStartOffset = this._startOffset;
      const originalEndNode = this._endNode;
      const originalEndOffset = this._endOffset;
      if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
        algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
        return;
      }
      const nodesToRemove = [];
      for (const node2 of algorithm_1.range_getContainedNodes(this)) {
        const parent = node2._parent;
        if (parent !== null && algorithm_1.range_isContained(parent, this)) {
          continue;
        }
        nodesToRemove.push(node2);
      }
      let newNode;
      let newOffset;
      if (algorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        newNode = originalStartNode;
        newOffset = originalStartOffset;
      } else {
        let referenceNode = originalStartNode;
        while (referenceNode._parent !== null && !algorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent, true)) {
          referenceNode = referenceNode._parent;
        }
        if (referenceNode._parent === null) {
          throw new Error("Parent node is null.");
        }
        newNode = referenceNode._parent;
        newOffset = algorithm_1.tree_index(referenceNode) + 1;
      }
      if (util_1.Guard.isCharacterDataNode(originalStartNode)) {
        algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, algorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, "");
      }
      for (const node2 of nodesToRemove) {
        if (node2._parent) {
          algorithm_1.mutation_remove(node2, node2._parent);
        }
      }
      if (util_1.Guard.isCharacterDataNode(originalEndNode)) {
        algorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, "");
      }
      this._start = [newNode, newOffset];
      this._end = [newNode, newOffset];
    }
    /** @inheritdoc */
    extractContents() {
      return algorithm_1.range_extract(this);
    }
    /** @inheritdoc */
    cloneContents() {
      return algorithm_1.range_cloneTheContents(this);
    }
    /** @inheritdoc */
    insertNode(node2) {
      return algorithm_1.range_insert(node2, this);
    }
    /** @inheritdoc */
    surroundContents(newParent) {
      for (const node2 of algorithm_1.range_getPartiallyContainedNodes(this)) {
        if (!util_1.Guard.isTextNode(node2)) {
          throw new DOMException_1.InvalidStateError();
        }
      }
      if (util_1.Guard.isDocumentNode(newParent) || util_1.Guard.isDocumentTypeNode(newParent) || util_1.Guard.isDocumentFragmentNode(newParent)) {
        throw new DOMException_1.InvalidNodeTypeError();
      }
      const fragment = algorithm_1.range_extract(this);
      if (newParent._children.size !== 0) {
        algorithm_1.mutation_replaceAll(null, newParent);
      }
      algorithm_1.range_insert(newParent, this);
      algorithm_1.mutation_append(fragment, newParent);
      algorithm_1.range_select(newParent, this);
    }
    /** @inheritdoc */
    cloneRange() {
      return algorithm_1.create_range(this._start, this._end);
    }
    /** @inheritdoc */
    detach() {
      _1.dom.rangeList.delete(this);
    }
    /** @inheritdoc */
    isPointInRange(node2, offset) {
      if (algorithm_1.tree_rootNode(node2) !== algorithm_1.range_root(this)) {
        return false;
      }
      if (util_1.Guard.isDocumentTypeNode(node2))
        throw new DOMException_1.InvalidNodeTypeError();
      if (offset > algorithm_1.tree_nodeLength(node2))
        throw new DOMException_1.IndexSizeError();
      const bp = [node2, offset];
      if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before || algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
        return false;
      }
      return true;
    }
    /** @inheritdoc */
    comparePoint(node2, offset) {
      if (algorithm_1.tree_rootNode(node2) !== algorithm_1.range_root(this))
        throw new DOMException_1.WrongDocumentError();
      if (util_1.Guard.isDocumentTypeNode(node2))
        throw new DOMException_1.InvalidNodeTypeError();
      if (offset > algorithm_1.tree_nodeLength(node2))
        throw new DOMException_1.IndexSizeError();
      const bp = [node2, offset];
      if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before) {
        return -1;
      } else if (algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
        return 1;
      } else {
        return 0;
      }
    }
    /** @inheritdoc */
    intersectsNode(node2) {
      if (algorithm_1.tree_rootNode(node2) !== algorithm_1.range_root(this)) {
        return false;
      }
      const parent = node2._parent;
      if (parent === null)
        return true;
      const offset = algorithm_1.tree_index(node2);
      if (algorithm_1.boundaryPoint_position([parent, offset], this._end) === interfaces_1.BoundaryPosition.Before && algorithm_1.boundaryPoint_position([parent, offset + 1], this._start) === interfaces_1.BoundaryPosition.After) {
        return true;
      }
      return false;
    }
    toString() {
      let s = "";
      if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {
        return this._startNode._data.substring(this._startOffset, this._endOffset);
      }
      if (util_1.Guard.isTextNode(this._startNode)) {
        s += this._startNode._data.substring(this._startOffset);
      }
      for (const child of algorithm_1.range_getContainedNodes(this)) {
        if (util_1.Guard.isTextNode(child)) {
          s += child._data;
        }
      }
      if (util_1.Guard.isTextNode(this._endNode)) {
        s += this._endNode._data.substring(0, this._endOffset);
      }
      return s;
    }
    /**
     * Creates a new `Range`.
     *
     * @param start - start point
     * @param end - end point
     */
    static _create(start, end) {
      const range2 = new RangeImpl2();
      if (start)
        range2._start = start;
      if (end)
        range2._end = end;
      return range2;
    }
  };
  RangeImpl.RangeImpl = RangeImpl$1;
  RangeImpl$1.START_TO_START = 0;
  RangeImpl$1.START_TO_END = 1;
  RangeImpl$1.END_TO_END = 2;
  RangeImpl$1.END_TO_START = 3;
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl$1.prototype, "START_TO_START", 0);
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl$1.prototype, "START_TO_END", 1);
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl$1.prototype, "END_TO_END", 2);
  WebIDLAlgorithm_1.idl_defineConst(RangeImpl$1.prototype, "END_TO_START", 3);
  return RangeImpl;
}
var ShadowRootImpl = {};
var hasRequiredShadowRootImpl;
function requireShadowRootImpl() {
  if (hasRequiredShadowRootImpl) return ShadowRootImpl;
  hasRequiredShadowRootImpl = 1;
  Object.defineProperty(ShadowRootImpl, "__esModule", { value: true });
  const DocumentFragmentImpl_1 = requireDocumentFragmentImpl();
  const util_1 = requireLib$9();
  const algorithm_1 = requireAlgorithm();
  let ShadowRootImpl$1 = class ShadowRootImpl2 extends DocumentFragmentImpl_1.DocumentFragmentImpl {
    /**
     * Initializes a new instance of `ShadowRoot`.
     *
     * @param host - shadow root's host element
     * @param mode - shadow root's mode
     */
    constructor(host, mode) {
      super();
      this._host = host;
      this._mode = mode;
    }
    /** @inheritdoc */
    get mode() {
      return this._mode;
    }
    /** @inheritdoc */
    get host() {
      return this._host;
    }
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    _getTheParent(event) {
      if (!event._composedFlag && !util_1.isEmpty(event._path) && algorithm_1.tree_rootNode(event._path[0].invocationTarget) === this) {
        return null;
      } else {
        return this._host;
      }
    }
    // MIXIN: DocumentOrShadowRoot
    // No elements
    /**
     * Creates a new `ShadowRoot`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */
    static _create(document2, host) {
      return new ShadowRootImpl2(host, "closed");
    }
  };
  ShadowRootImpl.ShadowRootImpl = ShadowRootImpl$1;
  return ShadowRootImpl;
}
var SlotableImpl = {};
var hasRequiredSlotableImpl;
function requireSlotableImpl() {
  if (hasRequiredSlotableImpl) return SlotableImpl;
  hasRequiredSlotableImpl = 1;
  Object.defineProperty(SlotableImpl, "__esModule", { value: true });
  const algorithm_1 = requireAlgorithm();
  let SlotableImpl$1 = class SlotableImpl {
    get _name() {
      return this.__name || "";
    }
    set _name(val) {
      this.__name = val;
    }
    get _assignedSlot() {
      return this.__assignedSlot || null;
    }
    set _assignedSlot(val) {
      this.__assignedSlot = val;
    }
    /** @inheritdoc */
    get assignedSlot() {
      return algorithm_1.shadowTree_findASlot(this, true);
    }
  };
  SlotableImpl.SlotableImpl = SlotableImpl$1;
  return SlotableImpl;
}
var StaticRangeImpl = {};
var hasRequiredStaticRangeImpl;
function requireStaticRangeImpl() {
  if (hasRequiredStaticRangeImpl) return StaticRangeImpl;
  hasRequiredStaticRangeImpl = 1;
  Object.defineProperty(StaticRangeImpl, "__esModule", { value: true });
  const AbstractRangeImpl_1 = requireAbstractRangeImpl();
  const DOMException_1 = requireDOMException();
  const util_1 = requireUtil$1();
  let StaticRangeImpl$1 = class StaticRangeImpl extends AbstractRangeImpl_1.AbstractRangeImpl {
    /**
     * Initializes a new instance of `StaticRange`.
     */
    constructor(init) {
      super();
      if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) || util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {
        throw new DOMException_1.InvalidNodeTypeError();
      }
      this._start = [init.startContainer, init.startOffset];
      this._end = [init.endContainer, init.endOffset];
    }
  };
  StaticRangeImpl.StaticRangeImpl = StaticRangeImpl$1;
  return StaticRangeImpl;
}
var TreeWalkerImpl = {};
var hasRequiredTreeWalkerImpl;
function requireTreeWalkerImpl() {
  if (hasRequiredTreeWalkerImpl) return TreeWalkerImpl;
  hasRequiredTreeWalkerImpl = 1;
  Object.defineProperty(TreeWalkerImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const TraverserImpl_1 = requireTraverserImpl();
  const algorithm_1 = requireAlgorithm();
  let TreeWalkerImpl$1 = class TreeWalkerImpl2 extends TraverserImpl_1.TraverserImpl {
    /**
     * Initializes a new instance of `TreeWalker`.
     */
    constructor(root, current) {
      super(root);
      this._current = current;
    }
    /** @inheritdoc */
    get currentNode() {
      return this._current;
    }
    set currentNode(value) {
      this._current = value;
    }
    /** @inheritdoc */
    parentNode() {
      let node2 = this._current;
      while (node2 !== null && node2 !== this._root) {
        node2 = node2._parent;
        if (node2 !== null && algorithm_1.traversal_filter(this, node2) === interfaces_1.FilterResult.Accept) {
          this._current = node2;
          return node2;
        }
      }
      return null;
    }
    /** @inheritdoc */
    firstChild() {
      return algorithm_1.treeWalker_traverseChildren(this, true);
    }
    /** @inheritdoc */
    lastChild() {
      return algorithm_1.treeWalker_traverseChildren(this, false);
    }
    /** @inheritdoc */
    nextSibling() {
      return algorithm_1.treeWalker_traverseSiblings(this, true);
    }
    /** @inheritdoc */
    previousNode() {
      let node2 = this._current;
      while (node2 !== this._root) {
        let sibling = node2._previousSibling;
        while (sibling) {
          node2 = sibling;
          let result = algorithm_1.traversal_filter(this, node2);
          while (result !== interfaces_1.FilterResult.Reject && node2._lastChild) {
            node2 = node2._lastChild;
            result = algorithm_1.traversal_filter(this, node2);
          }
          if (result === interfaces_1.FilterResult.Accept) {
            this._current = node2;
            return node2;
          }
          sibling = node2._previousSibling;
        }
        if (node2 === this._root || node2._parent === null) {
          return null;
        }
        node2 = node2._parent;
        if (algorithm_1.traversal_filter(this, node2) === interfaces_1.FilterResult.Accept) {
          this._current = node2;
          return node2;
        }
      }
      return null;
    }
    /** @inheritdoc */
    previousSibling() {
      return algorithm_1.treeWalker_traverseSiblings(this, false);
    }
    /** @inheritdoc */
    nextNode() {
      let node2 = this._current;
      let result = interfaces_1.FilterResult.Accept;
      while (true) {
        while (result !== interfaces_1.FilterResult.Reject && node2._firstChild) {
          node2 = node2._firstChild;
          result = algorithm_1.traversal_filter(this, node2);
          if (result === interfaces_1.FilterResult.Accept) {
            this._current = node2;
            return node2;
          }
        }
        let sibling = null;
        let temporary = node2;
        while (temporary !== null) {
          if (temporary === this._root) {
            return null;
          }
          sibling = temporary._nextSibling;
          if (sibling !== null) {
            node2 = sibling;
            break;
          }
          temporary = temporary._parent;
        }
        result = algorithm_1.traversal_filter(this, node2);
        if (result === interfaces_1.FilterResult.Accept) {
          this._current = node2;
          return node2;
        }
      }
    }
    /**
     * Creates a new `TreeWalker`.
     *
     * @param root - iterator's root node
     * @param current - current node
     */
    static _create(root, current) {
      return new TreeWalkerImpl2(root, current);
    }
  };
  TreeWalkerImpl.TreeWalkerImpl = TreeWalkerImpl$1;
  return TreeWalkerImpl;
}
var WindowImpl = {};
var hasRequiredWindowImpl;
function requireWindowImpl() {
  if (hasRequiredWindowImpl) return WindowImpl;
  hasRequiredWindowImpl = 1;
  Object.defineProperty(WindowImpl, "__esModule", { value: true });
  const EventTargetImpl_1 = requireEventTargetImpl();
  const util_1 = requireLib$9();
  const algorithm_1 = requireAlgorithm();
  let WindowImpl$1 = class WindowImpl2 extends EventTargetImpl_1.EventTargetImpl {
    /**
     * Initializes a new instance of `Window`.
     */
    constructor() {
      super();
      this._signalSlots = /* @__PURE__ */ new Set();
      this._mutationObserverMicrotaskQueued = false;
      this._mutationObservers = /* @__PURE__ */ new Set();
      this._iteratorList = new util_1.FixedSizeSet();
      this._associatedDocument = algorithm_1.create_document();
    }
    /** @inheritdoc */
    get document() {
      return this._associatedDocument;
    }
    /** @inheritdoc */
    get event() {
      return this._currentEvent;
    }
    /**
     * Creates a new window with a blank document.
     */
    static _create() {
      return new WindowImpl2();
    }
  };
  WindowImpl.WindowImpl = WindowImpl$1;
  return WindowImpl;
}
var XMLDocumentImpl = {};
var hasRequiredXMLDocumentImpl;
function requireXMLDocumentImpl() {
  if (hasRequiredXMLDocumentImpl) return XMLDocumentImpl;
  hasRequiredXMLDocumentImpl = 1;
  Object.defineProperty(XMLDocumentImpl, "__esModule", { value: true });
  const DocumentImpl_1 = requireDocumentImpl();
  let XMLDocumentImpl$1 = class XMLDocumentImpl extends DocumentImpl_1.DocumentImpl {
    /**
     * Initializes a new instance of `XMLDocument`.
     */
    constructor() {
      super();
    }
  };
  XMLDocumentImpl.XMLDocumentImpl = XMLDocumentImpl$1;
  return XMLDocumentImpl;
}
var hasRequiredDom$1;
function requireDom$1() {
  if (hasRequiredDom$1) return dom$1;
  hasRequiredDom$1 = 1;
  Object.defineProperty(dom$1, "__esModule", { value: true });
  const util_1 = requireLib$9();
  const AbortControllerImpl_1 = requireAbortControllerImpl();
  dom$1.AbortController = AbortControllerImpl_1.AbortControllerImpl;
  const AbortSignalImpl_1 = requireAbortSignalImpl();
  dom$1.AbortSignal = AbortSignalImpl_1.AbortSignalImpl;
  const AbstractRangeImpl_1 = requireAbstractRangeImpl();
  dom$1.AbstractRange = AbstractRangeImpl_1.AbstractRangeImpl;
  const AttrImpl_1 = requireAttrImpl();
  dom$1.Attr = AttrImpl_1.AttrImpl;
  const CDATASectionImpl_1 = requireCDATASectionImpl();
  dom$1.CDATASection = CDATASectionImpl_1.CDATASectionImpl;
  const CharacterDataImpl_1 = requireCharacterDataImpl();
  dom$1.CharacterData = CharacterDataImpl_1.CharacterDataImpl;
  const ChildNodeImpl_1 = requireChildNodeImpl();
  const CommentImpl_1 = requireCommentImpl();
  dom$1.Comment = CommentImpl_1.CommentImpl;
  const CustomEventImpl_1 = requireCustomEventImpl();
  dom$1.CustomEvent = CustomEventImpl_1.CustomEventImpl;
  const DocumentFragmentImpl_1 = requireDocumentFragmentImpl();
  dom$1.DocumentFragment = DocumentFragmentImpl_1.DocumentFragmentImpl;
  const DocumentImpl_1 = requireDocumentImpl();
  dom$1.Document = DocumentImpl_1.DocumentImpl;
  const DocumentOrShadowRootImpl_1 = requireDocumentOrShadowRootImpl();
  const DocumentTypeImpl_1 = requireDocumentTypeImpl();
  dom$1.DocumentType = DocumentTypeImpl_1.DocumentTypeImpl;
  const DOMImpl_1 = requireDOMImpl();
  dom$1.dom = DOMImpl_1.dom;
  const DOMImplementationImpl_1 = requireDOMImplementationImpl();
  dom$1.DOMImplementation = DOMImplementationImpl_1.DOMImplementationImpl;
  const DOMTokenListImpl_1 = requireDOMTokenListImpl();
  dom$1.DOMTokenList = DOMTokenListImpl_1.DOMTokenListImpl;
  const ElementImpl_1 = requireElementImpl();
  dom$1.Element = ElementImpl_1.ElementImpl;
  const EventImpl_1 = requireEventImpl();
  dom$1.Event = EventImpl_1.EventImpl;
  const EventTargetImpl_1 = requireEventTargetImpl();
  dom$1.EventTarget = EventTargetImpl_1.EventTargetImpl;
  const HTMLCollectionImpl_1 = requireHTMLCollectionImpl();
  dom$1.HTMLCollection = HTMLCollectionImpl_1.HTMLCollectionImpl;
  const MutationObserverImpl_1 = requireMutationObserverImpl();
  dom$1.MutationObserver = MutationObserverImpl_1.MutationObserverImpl;
  const MutationRecordImpl_1 = requireMutationRecordImpl();
  dom$1.MutationRecord = MutationRecordImpl_1.MutationRecordImpl;
  const NamedNodeMapImpl_1 = requireNamedNodeMapImpl();
  dom$1.NamedNodeMap = NamedNodeMapImpl_1.NamedNodeMapImpl;
  const NodeFilterImpl_1 = requireNodeFilterImpl();
  dom$1.NodeFilter = NodeFilterImpl_1.NodeFilterImpl;
  const NodeImpl_1 = requireNodeImpl();
  dom$1.Node = NodeImpl_1.NodeImpl;
  const NodeIteratorImpl_1 = requireNodeIteratorImpl();
  dom$1.NodeIterator = NodeIteratorImpl_1.NodeIteratorImpl;
  const NodeListImpl_1 = requireNodeListImpl();
  dom$1.NodeList = NodeListImpl_1.NodeListImpl;
  const NodeListStaticImpl_1 = requireNodeListStaticImpl();
  dom$1.NodeListStatic = NodeListStaticImpl_1.NodeListStaticImpl;
  const NonDocumentTypeChildNodeImpl_1 = requireNonDocumentTypeChildNodeImpl();
  const NonElementParentNodeImpl_1 = requireNonElementParentNodeImpl();
  const ParentNodeImpl_1 = requireParentNodeImpl();
  const ProcessingInstructionImpl_1 = requireProcessingInstructionImpl();
  dom$1.ProcessingInstruction = ProcessingInstructionImpl_1.ProcessingInstructionImpl;
  const RangeImpl_1 = requireRangeImpl();
  dom$1.Range = RangeImpl_1.RangeImpl;
  const ShadowRootImpl_1 = requireShadowRootImpl();
  dom$1.ShadowRoot = ShadowRootImpl_1.ShadowRootImpl;
  const SlotableImpl_1 = requireSlotableImpl();
  const StaticRangeImpl_1 = requireStaticRangeImpl();
  dom$1.StaticRange = StaticRangeImpl_1.StaticRangeImpl;
  const TextImpl_1 = requireTextImpl();
  dom$1.Text = TextImpl_1.TextImpl;
  const TraverserImpl_1 = requireTraverserImpl();
  dom$1.Traverser = TraverserImpl_1.TraverserImpl;
  const TreeWalkerImpl_1 = requireTreeWalkerImpl();
  dom$1.TreeWalker = TreeWalkerImpl_1.TreeWalkerImpl;
  const WindowImpl_1 = requireWindowImpl();
  dom$1.Window = WindowImpl_1.WindowImpl;
  const XMLDocumentImpl_1 = requireXMLDocumentImpl();
  dom$1.XMLDocument = XMLDocumentImpl_1.XMLDocumentImpl;
  util_1.applyMixin(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);
  util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);
  util_1.applyMixin(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);
  util_1.applyMixin(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
  util_1.applyMixin(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
  util_1.applyMixin(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
  util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
  util_1.applyMixin(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
  util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
  util_1.applyMixin(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);
  util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);
  util_1.applyMixin(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);
  util_1.applyMixin(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);
  util_1.applyMixin(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl);
  return dom$1;
}
var TreeAlgorithm = {};
var hasRequiredTreeAlgorithm;
function requireTreeAlgorithm() {
  if (hasRequiredTreeAlgorithm) return TreeAlgorithm;
  hasRequiredTreeAlgorithm = 1;
  Object.defineProperty(TreeAlgorithm, "__esModule", { value: true });
  const util_1 = requireUtil$1();
  const interfaces_1 = requireInterfaces$2();
  function _getNextDescendantNode(root, node2, shadow = false) {
    if (shadow && util_1.Guard.isElementNode(node2) && util_1.Guard.isShadowRoot(node2.shadowRoot)) {
      if (node2.shadowRoot._firstChild)
        return node2.shadowRoot._firstChild;
    }
    if (node2._firstChild)
      return node2._firstChild;
    if (node2 === root)
      return null;
    if (node2._nextSibling)
      return node2._nextSibling;
    let parent = node2._parent;
    while (parent && parent !== root) {
      if (parent._nextSibling)
        return parent._nextSibling;
      parent = parent._parent;
    }
    return null;
  }
  function _emptyIterator() {
    return {
      [Symbol.iterator]: () => {
        return {
          next: () => {
            return { done: true, value: null };
          }
        };
      }
    };
  }
  function tree_getFirstDescendantNode(node2, self2 = false, shadow = false, filter2) {
    let firstNode = self2 ? node2 : _getNextDescendantNode(node2, node2, shadow);
    while (firstNode && filter2 && !filter2(firstNode)) {
      firstNode = _getNextDescendantNode(node2, firstNode, shadow);
    }
    return firstNode;
  }
  TreeAlgorithm.tree_getFirstDescendantNode = tree_getFirstDescendantNode;
  function tree_getNextDescendantNode(node2, currentNode, self2 = false, shadow = false, filter2) {
    let nextNode = _getNextDescendantNode(node2, currentNode, shadow);
    while (nextNode && filter2 && !filter2(nextNode)) {
      nextNode = _getNextDescendantNode(node2, nextNode, shadow);
    }
    return nextNode;
  }
  TreeAlgorithm.tree_getNextDescendantNode = tree_getNextDescendantNode;
  function tree_getDescendantNodes(node2, self2 = false, shadow = false, filter2) {
    if (!self2 && node2._children.size === 0) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]: () => {
        let currentNode = self2 ? node2 : _getNextDescendantNode(node2, node2, shadow);
        return {
          next: () => {
            while (currentNode && filter2 && !filter2(currentNode)) {
              currentNode = _getNextDescendantNode(node2, currentNode, shadow);
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = _getNextDescendantNode(node2, currentNode, shadow);
              return result;
            }
          }
        };
      }
    };
  }
  TreeAlgorithm.tree_getDescendantNodes = tree_getDescendantNodes;
  function tree_getDescendantElements(node2, self2 = false, shadow = false, filter2) {
    if (!self2 && node2._children.size === 0) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]: () => {
        const it2 = tree_getDescendantNodes(node2, self2, shadow, (e) => util_1.Guard.isElementNode(e))[Symbol.iterator]();
        let currentNode = it2.next().value;
        return {
          next() {
            while (currentNode && filter2 && !filter2(currentNode)) {
              currentNode = it2.next().value;
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = it2.next().value;
              return result;
            }
          }
        };
      }
    };
  }
  TreeAlgorithm.tree_getDescendantElements = tree_getDescendantElements;
  function tree_getSiblingNodes(node2, self2 = false, filter2) {
    if (!node2._parent || node2._parent._children.size === 0) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]() {
        let currentNode = node2._parent ? node2._parent._firstChild : null;
        return {
          next() {
            while (currentNode && (filter2 && !filter2(currentNode) || !self2 && currentNode === node2)) {
              currentNode = currentNode._nextSibling;
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = currentNode._nextSibling;
              return result;
            }
          }
        };
      }
    };
  }
  TreeAlgorithm.tree_getSiblingNodes = tree_getSiblingNodes;
  function tree_getFirstAncestorNode(node2, self2 = false, filter2) {
    let firstNode = self2 ? node2 : node2._parent;
    while (firstNode && filter2 && !filter2(firstNode)) {
      firstNode = firstNode._parent;
    }
    return firstNode;
  }
  TreeAlgorithm.tree_getFirstAncestorNode = tree_getFirstAncestorNode;
  function tree_getNextAncestorNode(node2, currentNode, self2 = false, filter2) {
    let nextNode = currentNode._parent;
    while (nextNode && filter2 && !filter2(nextNode)) {
      nextNode = nextNode._parent;
    }
    return nextNode;
  }
  TreeAlgorithm.tree_getNextAncestorNode = tree_getNextAncestorNode;
  function tree_getAncestorNodes(node2, self2 = false, filter2) {
    if (!self2 && !node2._parent) {
      return _emptyIterator();
    }
    return {
      [Symbol.iterator]() {
        let currentNode = tree_getFirstAncestorNode(node2, self2, filter2);
        return {
          next() {
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = tree_getNextAncestorNode(node2, currentNode, self2, filter2);
              return result;
            }
          }
        };
      }
    };
  }
  TreeAlgorithm.tree_getAncestorNodes = tree_getAncestorNodes;
  function tree_getCommonAncestor(nodeA, nodeB) {
    if (nodeA === nodeB) {
      return nodeA._parent;
    }
    const parentsA = [];
    const parentsB = [];
    let pA = tree_getFirstAncestorNode(nodeA, true);
    while (pA !== null) {
      parentsA.push(pA);
      pA = tree_getNextAncestorNode(nodeA, pA, true);
    }
    let pB = tree_getFirstAncestorNode(nodeB, true);
    while (pB !== null) {
      parentsB.push(pB);
      pB = tree_getNextAncestorNode(nodeB, pB, true);
    }
    let pos1 = parentsA.length;
    let pos2 = parentsB.length;
    let parent = null;
    for (let i = Math.min(pos1, pos2); i > 0; i--) {
      const parent1 = parentsA[--pos1];
      const parent2 = parentsB[--pos2];
      if (parent1 !== parent2) {
        break;
      }
      parent = parent1;
    }
    return parent;
  }
  TreeAlgorithm.tree_getCommonAncestor = tree_getCommonAncestor;
  function tree_getFollowingNode(root, node2) {
    if (node2._firstChild) {
      return node2._firstChild;
    } else if (node2._nextSibling) {
      return node2._nextSibling;
    } else {
      while (true) {
        const parent = node2._parent;
        if (parent === null || parent === root) {
          return null;
        } else if (parent._nextSibling) {
          return parent._nextSibling;
        } else {
          node2 = parent;
        }
      }
    }
  }
  TreeAlgorithm.tree_getFollowingNode = tree_getFollowingNode;
  function tree_getPrecedingNode(root, node2) {
    if (node2 === root) {
      return null;
    }
    if (node2._previousSibling) {
      node2 = node2._previousSibling;
      if (node2._lastChild) {
        return node2._lastChild;
      } else {
        return node2;
      }
    } else {
      return node2._parent;
    }
  }
  TreeAlgorithm.tree_getPrecedingNode = tree_getPrecedingNode;
  function tree_isConstrained(node2) {
    switch (node2._nodeType) {
      case interfaces_1.NodeType.Document:
        let hasDocType = false;
        let hasElement = false;
        for (const childNode of node2._children) {
          switch (childNode._nodeType) {
            case interfaces_1.NodeType.ProcessingInstruction:
            case interfaces_1.NodeType.Comment:
              break;
            case interfaces_1.NodeType.DocumentType:
              if (hasDocType || hasElement)
                return false;
              hasDocType = true;
              break;
            case interfaces_1.NodeType.Element:
              if (hasElement)
                return false;
              hasElement = true;
              break;
            default:
              return false;
          }
        }
        break;
      case interfaces_1.NodeType.DocumentFragment:
      case interfaces_1.NodeType.Element:
        for (const childNode of node2._children) {
          switch (childNode._nodeType) {
            case interfaces_1.NodeType.Element:
            case interfaces_1.NodeType.Text:
            case interfaces_1.NodeType.ProcessingInstruction:
            case interfaces_1.NodeType.CData:
            case interfaces_1.NodeType.Comment:
              break;
            default:
              return false;
          }
        }
        break;
      case interfaces_1.NodeType.DocumentType:
      case interfaces_1.NodeType.Text:
      case interfaces_1.NodeType.ProcessingInstruction:
      case interfaces_1.NodeType.CData:
      case interfaces_1.NodeType.Comment:
        return !node2.hasChildNodes();
    }
    for (const childNode of node2._children) {
      if (!tree_isConstrained(childNode))
        return false;
    }
    return true;
  }
  TreeAlgorithm.tree_isConstrained = tree_isConstrained;
  function tree_nodeLength(node2) {
    if (util_1.Guard.isDocumentTypeNode(node2)) {
      return 0;
    } else if (util_1.Guard.isCharacterDataNode(node2)) {
      return node2._data.length;
    } else {
      return node2._children.size;
    }
  }
  TreeAlgorithm.tree_nodeLength = tree_nodeLength;
  function tree_isEmpty(node2) {
    return tree_nodeLength(node2) === 0;
  }
  TreeAlgorithm.tree_isEmpty = tree_isEmpty;
  function tree_rootNode(node2, shadow = false) {
    if (shadow) {
      const root = tree_rootNode(node2, false);
      if (util_1.Guard.isShadowRoot(root))
        return tree_rootNode(root._host, true);
      else
        return root;
    } else {
      if (!node2._parent)
        return node2;
      else
        return tree_rootNode(node2._parent);
    }
  }
  TreeAlgorithm.tree_rootNode = tree_rootNode;
  function tree_isDescendantOf(node2, other, self2 = false, shadow = false) {
    let child = tree_getFirstDescendantNode(node2, self2, shadow);
    while (child !== null) {
      if (child === other) {
        return true;
      }
      child = tree_getNextDescendantNode(node2, child, self2, shadow);
    }
    return false;
  }
  TreeAlgorithm.tree_isDescendantOf = tree_isDescendantOf;
  function tree_isAncestorOf(node2, other, self2 = false, shadow = false) {
    let ancestor = self2 ? node2 : shadow && util_1.Guard.isShadowRoot(node2) ? node2._host : node2._parent;
    while (ancestor !== null) {
      if (ancestor === other)
        return true;
      ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ? ancestor._host : ancestor._parent;
    }
    return false;
  }
  TreeAlgorithm.tree_isAncestorOf = tree_isAncestorOf;
  function tree_isHostIncludingAncestorOf(node2, other, self2 = false) {
    if (tree_isAncestorOf(node2, other, self2))
      return true;
    const root = tree_rootNode(node2);
    if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null && tree_isHostIncludingAncestorOf(root._host, other, self2))
      return true;
    return false;
  }
  TreeAlgorithm.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;
  function tree_isSiblingOf(node2, other, self2 = false) {
    if (node2 === other) {
      if (self2)
        return true;
    } else {
      return node2._parent !== null && node2._parent === other._parent;
    }
    return false;
  }
  TreeAlgorithm.tree_isSiblingOf = tree_isSiblingOf;
  function tree_isPreceding(node2, other) {
    const nodePos = tree_treePosition(node2);
    const otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
      return false;
    else if (tree_rootNode(node2) !== tree_rootNode(other))
      return false;
    else
      return otherPos < nodePos;
  }
  TreeAlgorithm.tree_isPreceding = tree_isPreceding;
  function tree_isFollowing(node2, other) {
    const nodePos = tree_treePosition(node2);
    const otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
      return false;
    else if (tree_rootNode(node2) !== tree_rootNode(other))
      return false;
    else
      return otherPos > nodePos;
  }
  TreeAlgorithm.tree_isFollowing = tree_isFollowing;
  function tree_isParentOf(node2, other) {
    return node2._parent === other;
  }
  TreeAlgorithm.tree_isParentOf = tree_isParentOf;
  function tree_isChildOf(node2, other) {
    return other._parent === node2;
  }
  TreeAlgorithm.tree_isChildOf = tree_isChildOf;
  function tree_previousSibling(node2) {
    return node2._previousSibling;
  }
  TreeAlgorithm.tree_previousSibling = tree_previousSibling;
  function tree_nextSibling(node2) {
    return node2._nextSibling;
  }
  TreeAlgorithm.tree_nextSibling = tree_nextSibling;
  function tree_firstChild(node2) {
    return node2._firstChild;
  }
  TreeAlgorithm.tree_firstChild = tree_firstChild;
  function tree_lastChild(node2) {
    return node2._lastChild;
  }
  TreeAlgorithm.tree_lastChild = tree_lastChild;
  function tree_treePosition(node2) {
    const root = tree_rootNode(node2);
    let pos = 0;
    let childNode = tree_getFirstDescendantNode(root);
    while (childNode !== null) {
      pos++;
      if (childNode === node2)
        return pos;
      childNode = tree_getNextDescendantNode(root, childNode);
    }
    return -1;
  }
  TreeAlgorithm.tree_treePosition = tree_treePosition;
  function tree_index(node2) {
    let n = 0;
    while (node2._previousSibling !== null) {
      n++;
      node2 = node2._previousSibling;
    }
    return n;
  }
  TreeAlgorithm.tree_index = tree_index;
  function tree_retarget(a, b) {
    while (true) {
      if (!a || !util_1.Guard.isNode(a)) {
        return a;
      }
      const rootOfA = tree_rootNode(a);
      if (!util_1.Guard.isShadowRoot(rootOfA)) {
        return a;
      }
      if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {
        return a;
      }
      a = rootOfA.host;
    }
  }
  TreeAlgorithm.tree_retarget = tree_retarget;
  return TreeAlgorithm;
}
var ShadowTreeAlgorithm = {};
var MutationObserverAlgorithm = {};
var CreateAlgorithm = {};
var hasRequiredCreateAlgorithm;
function requireCreateAlgorithm() {
  if (hasRequiredCreateAlgorithm) return CreateAlgorithm;
  hasRequiredCreateAlgorithm = 1;
  Object.defineProperty(CreateAlgorithm, "__esModule", { value: true });
  const DOMImplementationImpl_1 = requireDOMImplementationImpl();
  const WindowImpl_1 = requireWindowImpl();
  const XMLDocumentImpl_1 = requireXMLDocumentImpl();
  const DocumentImpl_1 = requireDocumentImpl();
  const AbortControllerImpl_1 = requireAbortControllerImpl();
  const AbortSignalImpl_1 = requireAbortSignalImpl();
  const DocumentTypeImpl_1 = requireDocumentTypeImpl();
  const ElementImpl_1 = requireElementImpl();
  const DocumentFragmentImpl_1 = requireDocumentFragmentImpl();
  const ShadowRootImpl_1 = requireShadowRootImpl();
  const AttrImpl_1 = requireAttrImpl();
  const TextImpl_1 = requireTextImpl();
  const CDATASectionImpl_1 = requireCDATASectionImpl();
  const CommentImpl_1 = requireCommentImpl();
  const ProcessingInstructionImpl_1 = requireProcessingInstructionImpl();
  const HTMLCollectionImpl_1 = requireHTMLCollectionImpl();
  const NodeListImpl_1 = requireNodeListImpl();
  const NodeListStaticImpl_1 = requireNodeListStaticImpl();
  const NamedNodeMapImpl_1 = requireNamedNodeMapImpl();
  const RangeImpl_1 = requireRangeImpl();
  const NodeIteratorImpl_1 = requireNodeIteratorImpl();
  const TreeWalkerImpl_1 = requireTreeWalkerImpl();
  const NodeFilterImpl_1 = requireNodeFilterImpl();
  const MutationRecordImpl_1 = requireMutationRecordImpl();
  const DOMTokenListImpl_1 = requireDOMTokenListImpl();
  function create_domImplementation(document2) {
    return DOMImplementationImpl_1.DOMImplementationImpl._create(document2);
  }
  CreateAlgorithm.create_domImplementation = create_domImplementation;
  function create_window() {
    return WindowImpl_1.WindowImpl._create();
  }
  CreateAlgorithm.create_window = create_window;
  function create_xmlDocument() {
    return new XMLDocumentImpl_1.XMLDocumentImpl();
  }
  CreateAlgorithm.create_xmlDocument = create_xmlDocument;
  function create_document() {
    return new DocumentImpl_1.DocumentImpl();
  }
  CreateAlgorithm.create_document = create_document;
  function create_abortController() {
    return new AbortControllerImpl_1.AbortControllerImpl();
  }
  CreateAlgorithm.create_abortController = create_abortController;
  function create_abortSignal() {
    return AbortSignalImpl_1.AbortSignalImpl._create();
  }
  CreateAlgorithm.create_abortSignal = create_abortSignal;
  function create_documentType(document2, name, publicId, systemId) {
    return DocumentTypeImpl_1.DocumentTypeImpl._create(document2, name, publicId, systemId);
  }
  CreateAlgorithm.create_documentType = create_documentType;
  function create_element(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  CreateAlgorithm.create_element = create_element;
  function create_htmlElement(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  CreateAlgorithm.create_htmlElement = create_htmlElement;
  function create_htmlUnknownElement(document2, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
  }
  CreateAlgorithm.create_htmlUnknownElement = create_htmlUnknownElement;
  function create_documentFragment(document2) {
    return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document2);
  }
  CreateAlgorithm.create_documentFragment = create_documentFragment;
  function create_shadowRoot(document2, host) {
    return ShadowRootImpl_1.ShadowRootImpl._create(document2, host);
  }
  CreateAlgorithm.create_shadowRoot = create_shadowRoot;
  function create_attr(document2, localName) {
    return AttrImpl_1.AttrImpl._create(document2, localName);
  }
  CreateAlgorithm.create_attr = create_attr;
  function create_text(document2, data) {
    return TextImpl_1.TextImpl._create(document2, data);
  }
  CreateAlgorithm.create_text = create_text;
  function create_cdataSection(document2, data) {
    return CDATASectionImpl_1.CDATASectionImpl._create(document2, data);
  }
  CreateAlgorithm.create_cdataSection = create_cdataSection;
  function create_comment(document2, data) {
    return CommentImpl_1.CommentImpl._create(document2, data);
  }
  CreateAlgorithm.create_comment = create_comment;
  function create_processingInstruction(document2, target2, data) {
    return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document2, target2, data);
  }
  CreateAlgorithm.create_processingInstruction = create_processingInstruction;
  function create_htmlCollection(root, filter2 = (() => true)) {
    return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter2);
  }
  CreateAlgorithm.create_htmlCollection = create_htmlCollection;
  function create_nodeList(root) {
    return NodeListImpl_1.NodeListImpl._create(root);
  }
  CreateAlgorithm.create_nodeList = create_nodeList;
  function create_nodeListStatic(root, items) {
    return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);
  }
  CreateAlgorithm.create_nodeListStatic = create_nodeListStatic;
  function create_namedNodeMap(element2) {
    return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element2);
  }
  CreateAlgorithm.create_namedNodeMap = create_namedNodeMap;
  function create_range(start, end) {
    return RangeImpl_1.RangeImpl._create(start, end);
  }
  CreateAlgorithm.create_range = create_range;
  function create_nodeIterator(root, reference, pointerBeforeReference) {
    return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);
  }
  CreateAlgorithm.create_nodeIterator = create_nodeIterator;
  function create_treeWalker(root, current) {
    return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);
  }
  CreateAlgorithm.create_treeWalker = create_treeWalker;
  function create_nodeFilter() {
    return NodeFilterImpl_1.NodeFilterImpl._create();
  }
  CreateAlgorithm.create_nodeFilter = create_nodeFilter;
  function create_mutationRecord(type2, target2, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
    return MutationRecordImpl_1.MutationRecordImpl._create(type2, target2, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
  }
  CreateAlgorithm.create_mutationRecord = create_mutationRecord;
  function create_domTokenList(element2, attribute2) {
    return DOMTokenListImpl_1.DOMTokenListImpl._create(element2, attribute2);
  }
  CreateAlgorithm.create_domTokenList = create_domTokenList;
  return CreateAlgorithm;
}
var hasRequiredMutationObserverAlgorithm;
function requireMutationObserverAlgorithm() {
  if (hasRequiredMutationObserverAlgorithm) return MutationObserverAlgorithm;
  hasRequiredMutationObserverAlgorithm = 1;
  Object.defineProperty(MutationObserverAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const util_1 = requireUtil$1();
  const infra_1 = requireLib$8();
  const CreateAlgorithm_1 = requireCreateAlgorithm();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const EventAlgorithm_1 = requireEventAlgorithm();
  function observer_queueAMutationObserverMicrotask() {
    const window2 = dom_1.dom.window;
    if (window2._mutationObserverMicrotaskQueued)
      return;
    window2._mutationObserverMicrotaskQueued = true;
    Promise.resolve().then(() => {
      observer_notifyMutationObservers();
    });
  }
  MutationObserverAlgorithm.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;
  function observer_notifyMutationObservers() {
    const window2 = dom_1.dom.window;
    window2._mutationObserverMicrotaskQueued = false;
    const notifySet = infra_1.set.clone(window2._mutationObservers);
    const signalSet = infra_1.set.clone(window2._signalSlots);
    infra_1.set.empty(window2._signalSlots);
    for (const mo of notifySet) {
      const records = infra_1.list.clone(mo._recordQueue);
      infra_1.list.empty(mo._recordQueue);
      for (let i = 0; i < mo._nodeList.length; i++) {
        const node2 = mo._nodeList[i];
        infra_1.list.remove(node2._registeredObserverList, (observer) => {
          return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo;
        });
      }
      if (!infra_1.list.isEmpty(records)) {
        try {
          mo._callback.call(mo, records, mo);
        } catch (err) {
        }
      }
    }
    if (dom_1.dom.features.slots) {
      for (const slot of signalSet) {
        EventAlgorithm_1.event_fireAnEvent("slotchange", slot, void 0, { bubbles: true });
      }
    }
  }
  MutationObserverAlgorithm.observer_notifyMutationObservers = observer_notifyMutationObservers;
  function observer_queueMutationRecord(type2, target2, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {
    const interestedObservers = /* @__PURE__ */ new Map();
    let node2 = TreeAlgorithm_1.tree_getFirstAncestorNode(target2, true);
    while (node2 !== null) {
      for (let i = 0; i < node2._registeredObserverList.length; i++) {
        const registered = node2._registeredObserverList[i];
        const options = registered.options;
        if (node2 !== target2 && !options.subtree)
          continue;
        if (type2 === "attributes" && !options.attributes)
          continue;
        if (type2 === "attributes" && options.attributeFilter && (!options.attributeFilter.includes(name || "") || namespace !== null))
          continue;
        if (type2 === "characterData" && !options.characterData)
          continue;
        if (type2 === "childList" && !options.childList)
          continue;
        const mo = registered.observer;
        if (!interestedObservers.has(mo)) {
          interestedObservers.set(mo, null);
        }
        if (type2 === "attributes" && options.attributeOldValue || type2 === "characterData" && options.characterDataOldValue) {
          interestedObservers.set(mo, oldValue);
        }
      }
      node2 = TreeAlgorithm_1.tree_getNextAncestorNode(target2, node2, true);
    }
    for (const [observer, mappedOldValue] of interestedObservers) {
      const record = CreateAlgorithm_1.create_mutationRecord(type2, target2, CreateAlgorithm_1.create_nodeListStatic(target2, addedNodes), CreateAlgorithm_1.create_nodeListStatic(target2, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);
      const queue2 = observer._recordQueue;
      queue2.push(record);
    }
    observer_queueAMutationObserverMicrotask();
  }
  MutationObserverAlgorithm.observer_queueMutationRecord = observer_queueMutationRecord;
  function observer_queueTreeMutationRecord(target2, addedNodes, removedNodes, previousSibling, nextSibling) {
    observer_queueMutationRecord("childList", target2, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);
  }
  MutationObserverAlgorithm.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;
  function observer_queueAttributeMutationRecord(target2, name, namespace, oldValue) {
    observer_queueMutationRecord("attributes", target2, name, namespace, oldValue, [], [], null, null);
  }
  MutationObserverAlgorithm.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord;
  return MutationObserverAlgorithm;
}
var hasRequiredShadowTreeAlgorithm;
function requireShadowTreeAlgorithm() {
  if (hasRequiredShadowTreeAlgorithm) return ShadowTreeAlgorithm;
  hasRequiredShadowTreeAlgorithm = 1;
  Object.defineProperty(ShadowTreeAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const util_1 = requireUtil$1();
  const util_2 = requireLib$9();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const MutationObserverAlgorithm_1 = requireMutationObserverAlgorithm();
  function shadowTree_signalASlotChange(slot) {
    const window2 = dom_1.dom.window;
    window2._signalSlots.add(slot);
    MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask();
  }
  ShadowTreeAlgorithm.shadowTree_signalASlotChange = shadowTree_signalASlotChange;
  function shadowTree_isConnected(element2) {
    return util_1.Guard.isDocumentNode(TreeAlgorithm_1.tree_rootNode(element2, true));
  }
  ShadowTreeAlgorithm.shadowTree_isConnected = shadowTree_isConnected;
  function shadowTree_isAssigned(slotable) {
    return slotable._assignedSlot !== null;
  }
  ShadowTreeAlgorithm.shadowTree_isAssigned = shadowTree_isAssigned;
  function shadowTree_findASlot(slotable, openFlag = false) {
    const node2 = util_1.Cast.asNode(slotable);
    const parent = node2._parent;
    if (parent === null)
      return null;
    const shadow = parent._shadowRoot || null;
    if (shadow === null)
      return null;
    if (openFlag && shadow._mode !== "open")
      return null;
    let child = TreeAlgorithm_1.tree_getFirstDescendantNode(shadow, false, true, (e) => util_1.Guard.isSlot(e));
    while (child !== null) {
      if (child._name === slotable._name)
        return child;
      child = TreeAlgorithm_1.tree_getNextDescendantNode(shadow, child, false, true, (e) => util_1.Guard.isSlot(e));
    }
    return null;
  }
  ShadowTreeAlgorithm.shadowTree_findASlot = shadowTree_findASlot;
  function shadowTree_findSlotables(slot) {
    const result = [];
    const root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
      return result;
    const host = root._host;
    for (const slotable of host._children) {
      if (util_1.Guard.isSlotable(slotable)) {
        const foundSlot = shadowTree_findASlot(slotable);
        if (foundSlot === slot) {
          result.push(slotable);
        }
      }
    }
    return result;
  }
  ShadowTreeAlgorithm.shadowTree_findSlotables = shadowTree_findSlotables;
  function shadowTree_findFlattenedSlotables(slot) {
    const result = [];
    const root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
      return result;
    const slotables = shadowTree_findSlotables(slot);
    if (util_2.isEmpty(slotables)) {
      for (const slotable of slot._children) {
        if (util_1.Guard.isSlotable(slotable)) {
          slotables.push(slotable);
        }
      }
    }
    for (const node2 of slotables) {
      if (util_1.Guard.isSlot(node2) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(node2))) {
        const temporaryResult = shadowTree_findFlattenedSlotables(node2);
        result.push(...temporaryResult);
      } else {
        result.push(node2);
      }
    }
    return result;
  }
  ShadowTreeAlgorithm.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;
  function shadowTree_assignSlotables(slot) {
    const slotables = shadowTree_findSlotables(slot);
    if (slotables.length === slot._assignedNodes.length) {
      let nodesIdentical = true;
      for (let i = 0; i < slotables.length; i++) {
        if (slotables[i] !== slot._assignedNodes[i]) {
          nodesIdentical = false;
          break;
        }
      }
      if (!nodesIdentical) {
        shadowTree_signalASlotChange(slot);
      }
    }
    slot._assignedNodes = slotables;
    for (const slotable of slotables) {
      slotable._assignedSlot = slot;
    }
  }
  ShadowTreeAlgorithm.shadowTree_assignSlotables = shadowTree_assignSlotables;
  function shadowTree_assignSlotablesForATree(root) {
    let descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(root, true, false, (e) => util_1.Guard.isSlot(e));
    while (descendant !== null) {
      shadowTree_assignSlotables(descendant);
      descendant = TreeAlgorithm_1.tree_getNextDescendantNode(root, descendant, true, false, (e) => util_1.Guard.isSlot(e));
    }
  }
  ShadowTreeAlgorithm.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;
  function shadowTree_assignASlot(slotable) {
    const slot = shadowTree_findASlot(slotable);
    if (slot !== null) {
      shadowTree_assignSlotables(slot);
    }
  }
  ShadowTreeAlgorithm.shadowTree_assignASlot = shadowTree_assignASlot;
  return ShadowTreeAlgorithm;
}
var DOMAlgorithm = {};
var hasRequiredDOMAlgorithm;
function requireDOMAlgorithm() {
  if (hasRequiredDOMAlgorithm) return DOMAlgorithm;
  hasRequiredDOMAlgorithm = 1;
  Object.defineProperty(DOMAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const util_1 = requireUtil$1();
  const ShadowTreeAlgorithm_1 = requireShadowTreeAlgorithm();
  const supportedTokens = /* @__PURE__ */ new Map();
  function dom_runRemovingSteps(removedNode, oldParent) {
  }
  DOMAlgorithm.dom_runRemovingSteps = dom_runRemovingSteps;
  function dom_runCloningSteps(copy2, node2, document2, cloneChildrenFlag) {
  }
  DOMAlgorithm.dom_runCloningSteps = dom_runCloningSteps;
  function dom_runAdoptingSteps(node2, oldDocument) {
  }
  DOMAlgorithm.dom_runAdoptingSteps = dom_runAdoptingSteps;
  function dom_runAttributeChangeSteps(element2, localName, oldValue, value, namespace) {
    if (dom_1.dom.features.slots) {
      updateASlotablesName.call(element2, element2, localName, oldValue, value, namespace);
      updateASlotsName.call(element2, element2, localName, oldValue, value, namespace);
    }
    updateAnElementID.call(element2, element2, localName, value, namespace);
    for (const step of element2._attributeChangeSteps) {
      step.call(element2, element2, localName, oldValue, value, namespace);
    }
  }
  DOMAlgorithm.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;
  function dom_runInsertionSteps(insertedNode) {
  }
  DOMAlgorithm.dom_runInsertionSteps = dom_runInsertionSteps;
  function dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {
    removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);
  }
  DOMAlgorithm.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;
  function dom_hasSupportedTokens(attributeName) {
    return supportedTokens.has(attributeName);
  }
  DOMAlgorithm.dom_hasSupportedTokens = dom_hasSupportedTokens;
  function dom_getSupportedTokens(attributeName) {
    return supportedTokens.get(attributeName) || /* @__PURE__ */ new Set();
  }
  DOMAlgorithm.dom_getSupportedTokens = dom_getSupportedTokens;
  function dom_runEventConstructingSteps(event) {
  }
  DOMAlgorithm.dom_runEventConstructingSteps = dom_runEventConstructingSteps;
  function dom_runChildTextContentChangeSteps(parent) {
  }
  DOMAlgorithm.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;
  function removeNodeIterator(nodeIterator, toBeRemovedNode) {
    if (toBeRemovedNode === nodeIterator._root || !TreeAlgorithm_1.tree_isAncestorOf(nodeIterator._reference, toBeRemovedNode, true)) {
      return;
    }
    if (nodeIterator._pointerBeforeReference) {
      while (true) {
        const nextNode = TreeAlgorithm_1.tree_getFollowingNode(nodeIterator._root, toBeRemovedNode);
        if (nextNode !== null && TreeAlgorithm_1.tree_isDescendantOf(nodeIterator._root, nextNode, true) && !TreeAlgorithm_1.tree_isDescendantOf(toBeRemovedNode, nextNode, true)) {
          nodeIterator._reference = nextNode;
          return;
        } else if (nextNode === null) {
          nodeIterator._pointerBeforeReference = false;
          return;
        }
      }
    }
    if (toBeRemovedNode._previousSibling === null) {
      if (toBeRemovedNode._parent !== null) {
        nodeIterator._reference = toBeRemovedNode._parent;
      }
    } else {
      let referenceNode = toBeRemovedNode._previousSibling;
      let childNode = TreeAlgorithm_1.tree_getFirstDescendantNode(toBeRemovedNode._previousSibling, true, false);
      while (childNode !== null) {
        if (childNode !== null) {
          referenceNode = childNode;
        }
        childNode = TreeAlgorithm_1.tree_getNextDescendantNode(toBeRemovedNode._previousSibling, childNode, true, false);
      }
      nodeIterator._reference = referenceNode;
    }
  }
  function updateASlotsName(element2, localName, oldValue, value, namespace) {
    if (util_1.Guard.isSlot(element2) && localName === "name" && namespace === null) {
      if (value === oldValue)
        return;
      if (value === null && oldValue === "")
        return;
      if (value === "" && oldValue === null)
        return;
      if (value === null || value === "") {
        element2._name = "";
      } else {
        element2._name = value;
      }
      ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(element2));
    }
  }
  function updateASlotablesName(element2, localName, oldValue, value, namespace) {
    if (util_1.Guard.isSlotable(element2) && localName === "slot" && namespace === null) {
      if (value === oldValue)
        return;
      if (value === null && oldValue === "")
        return;
      if (value === "" && oldValue === null)
        return;
      if (value === null || value === "") {
        element2._name = "";
      } else {
        element2._name = value;
      }
      if (ShadowTreeAlgorithm_1.shadowTree_isAssigned(element2)) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotables(element2._assignedSlot);
      }
      ShadowTreeAlgorithm_1.shadowTree_assignASlot(element2);
    }
  }
  function updateAnElementID(element2, localName, value, namespace) {
    if (localName === "id" && namespace === null) {
      if (!value)
        element2._uniqueIdentifier = void 0;
      else
        element2._uniqueIdentifier = value;
    }
  }
  return DOMAlgorithm;
}
var hasRequiredEventAlgorithm;
function requireEventAlgorithm() {
  if (hasRequiredEventAlgorithm) return EventAlgorithm;
  hasRequiredEventAlgorithm = 1;
  Object.defineProperty(EventAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const interfaces_1 = requireInterfaces$2();
  const util_1 = requireUtil$1();
  const CustomEventImpl_1 = requireCustomEventImpl();
  const EventImpl_1 = requireEventImpl();
  const DOMException_1 = requireDOMException();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const ShadowTreeAlgorithm_1 = requireShadowTreeAlgorithm();
  const DOMAlgorithm_1 = requireDOMAlgorithm();
  function event_setTheCanceledFlag(event) {
    if (event._cancelable && !event._inPassiveListenerFlag) {
      event._canceledFlag = true;
    }
  }
  EventAlgorithm.event_setTheCanceledFlag = event_setTheCanceledFlag;
  function event_initialize(event, type2, bubbles, cancelable) {
    event._initializedFlag = true;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    event._canceledFlag = false;
    event._isTrusted = false;
    event._target = null;
    event._type = type2;
    event._bubbles = bubbles;
    event._cancelable = cancelable;
  }
  EventAlgorithm.event_initialize = event_initialize;
  function event_createAnEvent(eventInterface, realm = void 0) {
    if (realm === void 0)
      realm = null;
    const dictionary = {};
    const event = event_innerEventCreationSteps(eventInterface, realm, /* @__PURE__ */ new Date(), dictionary);
    event._isTrusted = true;
    return event;
  }
  EventAlgorithm.event_createAnEvent = event_createAnEvent;
  function event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {
    const event = new eventInterface("");
    event._initializedFlag = true;
    event._timeStamp = time.getTime();
    Object.assign(event, dictionary);
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runEventConstructingSteps(event);
    }
    return event;
  }
  EventAlgorithm.event_innerEventCreationSteps = event_innerEventCreationSteps;
  function event_dispatch(event, target2, legacyTargetOverrideFlag = false, legacyOutputDidListenersThrowFlag = { value: false }) {
    let clearTargets = false;
    event._dispatchFlag = true;
    let targetOverride = target2;
    if (legacyTargetOverrideFlag) {
      const doc = target2._associatedDocument;
      if (util_1.Guard.isDocumentNode(doc)) {
        targetOverride = doc;
      }
    }
    let activationTarget = null;
    let relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, target2);
    if (target2 !== relatedTarget || target2 === event._relatedTarget) {
      let touchTargets = [];
      for (const touchTarget of event._touchTargetList) {
        touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, target2));
      }
      event_appendToAnEventPath(event, target2, targetOverride, relatedTarget, touchTargets, false);
      const isActivationEvent = util_1.Guard.isMouseEvent(event) && event._type === "click";
      if (isActivationEvent && target2._activationBehavior !== void 0) {
        activationTarget = target2;
      }
      let slotable = util_1.Guard.isSlotable(target2) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(target2) ? target2 : null;
      let slotInClosedTree = false;
      let parent = target2._getTheParent(event);
      while (parent !== null && util_1.Guard.isNode(parent)) {
        if (slotable !== null) {
          if (!util_1.Guard.isSlot(parent)) {
            throw new Error("Parent node of a slotable should be a slot.");
          }
          slotable = null;
          const root = TreeAlgorithm_1.tree_rootNode(parent, true);
          if (util_1.Guard.isShadowRoot(root) && root._mode === "closed") {
            slotInClosedTree = true;
          }
        }
        if (util_1.Guard.isSlotable(parent) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(parent)) {
          slotable = parent;
        }
        relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, parent);
        touchTargets = [];
        for (const touchTarget of event._touchTargetList) {
          touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, parent));
        }
        if (util_1.Guard.isWindow(parent) || util_1.Guard.isNode(parent) && util_1.Guard.isNode(target2) && TreeAlgorithm_1.tree_isAncestorOf(TreeAlgorithm_1.tree_rootNode(target2, true), parent, true, true)) {
          if (isActivationEvent && event._bubbles && activationTarget === null && parent._activationBehavior) {
            activationTarget = parent;
          }
          event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);
        } else if (parent === relatedTarget) {
          parent = null;
        } else {
          target2 = parent;
          if (isActivationEvent && activationTarget === null && target2._activationBehavior) {
            activationTarget = target2;
          }
          event_appendToAnEventPath(event, parent, target2, relatedTarget, touchTargets, slotInClosedTree);
        }
        if (parent !== null) {
          parent = parent._getTheParent(event);
        }
        slotInClosedTree = false;
      }
      let clearTargetsStruct = null;
      const path2 = event._path;
      for (let i = path2.length - 1; i >= 0; i--) {
        const struct = path2[i];
        if (struct.shadowAdjustedTarget !== null) {
          clearTargetsStruct = struct;
          break;
        }
      }
      if (clearTargetsStruct !== null) {
        if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.shadowAdjustedTarget, true))) {
          clearTargets = true;
        } else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.relatedTarget, true))) {
          clearTargets = true;
        } else {
          for (let j = 0; j < clearTargetsStruct.touchTargetList.length; j++) {
            const struct = clearTargetsStruct.touchTargetList[j];
            if (util_1.Guard.isNode(struct) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(struct, true))) {
              clearTargets = true;
              break;
            }
          }
        }
      }
      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior !== void 0) {
        activationTarget._legacyPreActivationBehavior(event);
      }
      for (let i = path2.length - 1; i >= 0; i--) {
        const struct = path2[i];
        if (struct.shadowAdjustedTarget !== null) {
          event._eventPhase = interfaces_1.EventPhase.AtTarget;
        } else {
          event._eventPhase = interfaces_1.EventPhase.Capturing;
        }
        event_invoke(struct, event, "capturing", legacyOutputDidListenersThrowFlag);
      }
      for (let i = 0; i < path2.length; i++) {
        const struct = path2[i];
        if (struct.shadowAdjustedTarget !== null) {
          event._eventPhase = interfaces_1.EventPhase.AtTarget;
        } else {
          if (!event._bubbles)
            continue;
          event._eventPhase = interfaces_1.EventPhase.Bubbling;
        }
        event_invoke(struct, event, "bubbling", legacyOutputDidListenersThrowFlag);
      }
    }
    event._eventPhase = interfaces_1.EventPhase.None;
    event._currentTarget = null;
    event._path = [];
    event._dispatchFlag = false;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    if (clearTargets) {
      event._target = null;
      event._relatedTarget = null;
      event._touchTargetList = [];
    }
    if (activationTarget !== null) {
      if (!event._canceledFlag && activationTarget._activationBehavior !== void 0) {
        activationTarget._activationBehavior(event);
      } else if (activationTarget._legacyCanceledActivationBehavior !== void 0) {
        activationTarget._legacyCanceledActivationBehavior(event);
      }
    }
    return !event._canceledFlag;
  }
  EventAlgorithm.event_dispatch = event_dispatch;
  function event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {
    let invocationTargetInShadowTree = false;
    if (util_1.Guard.isNode(invocationTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(invocationTarget))) {
      invocationTargetInShadowTree = true;
    }
    let rootOfClosedTree = false;
    if (util_1.Guard.isShadowRoot(invocationTarget) && invocationTarget._mode === "closed") {
      rootOfClosedTree = true;
    }
    event._path.push({
      invocationTarget,
      invocationTargetInShadowTree,
      shadowAdjustedTarget,
      relatedTarget,
      touchTargetList: touchTargets,
      rootOfClosedTree,
      slotInClosedTree
    });
  }
  EventAlgorithm.event_appendToAnEventPath = event_appendToAnEventPath;
  function event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag = { value: false }) {
    const path2 = event._path;
    let index = -1;
    for (let i = 0; i < path2.length; i++) {
      if (path2[i] === struct) {
        index = i;
        break;
      }
    }
    if (index !== -1) {
      let item = path2[index];
      if (item.shadowAdjustedTarget !== null) {
        event._target = item.shadowAdjustedTarget;
      } else if (index > 0) {
        item = path2[index - 1];
        if (item.shadowAdjustedTarget !== null) {
          event._target = item.shadowAdjustedTarget;
        }
      }
    }
    event._relatedTarget = struct.relatedTarget;
    event._touchTargetList = struct.touchTargetList;
    if (event._stopPropagationFlag)
      return;
    event._currentTarget = struct.invocationTarget;
    const currentTarget = event._currentTarget;
    const targetListeners = currentTarget._eventListenerList;
    let listeners = new Array(...targetListeners);
    const found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
    if (!found && event._isTrusted) {
      const originalEventType = event._type;
      if (originalEventType === "animationend") {
        event._type = "webkitAnimationEnd";
      } else if (originalEventType === "animationiteration") {
        event._type = "webkitAnimationIteration";
      } else if (originalEventType === "animationstart") {
        event._type = "webkitAnimationStart";
      } else if (originalEventType === "transitionend") {
        event._type = "webkitTransitionEnd";
      }
      event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
      event._type = originalEventType;
    }
  }
  EventAlgorithm.event_invoke = event_invoke;
  function event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag = { value: false }) {
    let found = false;
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i];
      if (!listener.removed) {
        if (event._type !== listener.type)
          continue;
        found = true;
        if (phase === "capturing" && !listener.capture)
          continue;
        if (phase === "bubbling" && listener.capture)
          continue;
        if (listener.once && event._currentTarget !== null) {
          const impl = event._currentTarget;
          let index = -1;
          for (let i2 = 0; i2 < impl._eventListenerList.length; i2++) {
            if (impl._eventListenerList[i2] === listener) {
              index = i2;
              break;
            }
          }
          if (index !== -1) {
            impl._eventListenerList.splice(index, 1);
          }
        }
        const globalObject = void 0;
        let currentEvent = void 0;
        if (util_1.Guard.isWindow(globalObject)) {
          currentEvent = globalObject._currentEvent;
          if (struct.invocationTargetInShadowTree === false) {
            globalObject._currentEvent = event;
          }
        }
        if (listener.passive)
          event._inPassiveListenerFlag = true;
        try {
          listener.callback.handleEvent.call(event._currentTarget, event);
        } catch (err) {
          legacyOutputDidListenersThrowFlag.value = true;
        }
        if (listener.passive)
          event._inPassiveListenerFlag = false;
        if (util_1.Guard.isWindow(globalObject)) {
          globalObject._currentEvent = currentEvent;
        }
        if (event._stopImmediatePropagationFlag)
          return found;
      }
    }
    return found;
  }
  EventAlgorithm.event_innerInvoke = event_innerInvoke;
  function event_fireAnEvent(e, target2, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {
    if (eventConstructor === void 0) {
      eventConstructor = EventImpl_1.EventImpl;
    }
    const event = event_createAnEvent(eventConstructor);
    event._type = e;
    if (idlAttributes) {
      for (const key in idlAttributes) {
        const idlObj = event;
        idlObj[key] = idlAttributes[key];
      }
    }
    return event_dispatch(event, target2, legacyTargetOverrideFlag);
  }
  EventAlgorithm.event_fireAnEvent = event_fireAnEvent;
  function event_createLegacyEvent(eventInterface) {
    let constructor = null;
    switch (eventInterface.toLowerCase()) {
      case "beforeunloadevent":
        break;
      case "compositionevent":
        break;
      case "customevent":
        constructor = CustomEventImpl_1.CustomEventImpl;
        break;
      case "devicemotionevent":
        break;
      case "deviceorientationevent":
        break;
      case "dragevent":
        break;
      case "event":
      case "events":
        constructor = EventImpl_1.EventImpl;
        break;
    }
    if (constructor === null) {
      throw new DOMException_1.NotSupportedError(`Event constructor not found for interface ${eventInterface}.`);
    }
    const event = new constructor("");
    event._type = "";
    event._timeStamp = (/* @__PURE__ */ new Date()).getTime();
    event._isTrusted = false;
    event._initializedFlag = false;
    return event;
  }
  EventAlgorithm.event_createLegacyEvent = event_createLegacyEvent;
  function event_getterEventHandlerIDLAttribute(thisObj, name) {
    return null;
  }
  EventAlgorithm.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;
  function event_setterEventHandlerIDLAttribute(thisObj, name, value) {
    return;
  }
  EventAlgorithm.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;
  function event_determineTheTargetOfAnEventHandler(eventTarget, name) {
    return null;
  }
  EventAlgorithm.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;
  function event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {
    return null;
  }
  EventAlgorithm.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;
  function event_activateAnEventHandler(eventTarget, name) {
  }
  EventAlgorithm.event_activateAnEventHandler = event_activateAnEventHandler;
  function event_deactivateAnEventHandler(eventTarget, name) {
  }
  EventAlgorithm.event_deactivateAnEventHandler = event_deactivateAnEventHandler;
  return EventAlgorithm;
}
var hasRequiredAbortAlgorithm;
function requireAbortAlgorithm() {
  if (hasRequiredAbortAlgorithm) return AbortAlgorithm;
  hasRequiredAbortAlgorithm = 1;
  Object.defineProperty(AbortAlgorithm, "__esModule", { value: true });
  const EventAlgorithm_1 = requireEventAlgorithm();
  function abort_add(algorithm2, signal) {
    if (signal._abortedFlag)
      return;
    signal._abortAlgorithms.add(algorithm2);
  }
  AbortAlgorithm.abort_add = abort_add;
  function abort_remove(algorithm2, signal) {
    signal._abortAlgorithms.delete(algorithm2);
  }
  AbortAlgorithm.abort_remove = abort_remove;
  function abort_signalAbort(signal) {
    if (signal._abortedFlag)
      return;
    signal._abortedFlag = true;
    for (const algorithm2 of signal._abortAlgorithms) {
      algorithm2.call(signal);
    }
    signal._abortAlgorithms.clear();
    EventAlgorithm_1.event_fireAnEvent("abort", signal);
  }
  AbortAlgorithm.abort_signalAbort = abort_signalAbort;
  return AbortAlgorithm;
}
var AttrAlgorithm = {};
var ElementAlgorithm = {};
var CustomElementAlgorithm = {};
var hasRequiredCustomElementAlgorithm;
function requireCustomElementAlgorithm() {
  if (hasRequiredCustomElementAlgorithm) return CustomElementAlgorithm;
  hasRequiredCustomElementAlgorithm = 1;
  Object.defineProperty(CustomElementAlgorithm, "__esModule", { value: true });
  const PotentialCustomElementName = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/;
  const NamesWithHyphen = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  const ElementNames = /* @__PURE__ */ new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
  ]);
  const VoidElementNames = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  const ShadowHostNames = /* @__PURE__ */ new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
  ]);
  function customElement_isValidCustomElementName(name) {
    if (!PotentialCustomElementName.test(name))
      return false;
    if (NamesWithHyphen.has(name))
      return false;
    return true;
  }
  CustomElementAlgorithm.customElement_isValidCustomElementName = customElement_isValidCustomElementName;
  function customElement_isValidElementName(name) {
    return ElementNames.has(name);
  }
  CustomElementAlgorithm.customElement_isValidElementName = customElement_isValidElementName;
  function customElement_isVoidElementName(name) {
    return VoidElementNames.has(name);
  }
  CustomElementAlgorithm.customElement_isVoidElementName = customElement_isVoidElementName;
  function customElement_isValidShadowHostName(name) {
    return ShadowHostNames.has(name);
  }
  CustomElementAlgorithm.customElement_isValidShadowHostName = customElement_isValidShadowHostName;
  function customElement_enqueueACustomElementUpgradeReaction(element2, definition) {
  }
  CustomElementAlgorithm.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;
  function customElement_enqueueACustomElementCallbackReaction(element2, callbackName, args) {
  }
  CustomElementAlgorithm.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;
  function customElement_upgrade(definition, element2) {
  }
  CustomElementAlgorithm.customElement_upgrade = customElement_upgrade;
  function customElement_tryToUpgrade(element2) {
  }
  CustomElementAlgorithm.customElement_tryToUpgrade = customElement_tryToUpgrade;
  function customElement_lookUpACustomElementDefinition(document2, namespace, localName, is) {
    return null;
  }
  CustomElementAlgorithm.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition;
  return CustomElementAlgorithm;
}
var MutationAlgorithm = {};
var NodeIteratorAlgorithm = {};
var TraversalAlgorithm = {};
var hasRequiredTraversalAlgorithm;
function requireTraversalAlgorithm() {
  if (hasRequiredTraversalAlgorithm) return TraversalAlgorithm;
  hasRequiredTraversalAlgorithm = 1;
  Object.defineProperty(TraversalAlgorithm, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const DOMException_1 = requireDOMException();
  function traversal_filter(traverser, node2) {
    if (traverser._activeFlag) {
      throw new DOMException_1.InvalidStateError();
    }
    const n = node2._nodeType - 1;
    const mask = 1 << n;
    if ((traverser.whatToShow & mask) === 0) {
      return interfaces_1.FilterResult.Skip;
    }
    if (!traverser.filter) {
      return interfaces_1.FilterResult.Accept;
    }
    traverser._activeFlag = true;
    let result = interfaces_1.FilterResult.Reject;
    try {
      result = traverser.filter.acceptNode(node2);
    } catch (err) {
      traverser._activeFlag = false;
      throw err;
    }
    traverser._activeFlag = false;
    return result;
  }
  TraversalAlgorithm.traversal_filter = traversal_filter;
  return TraversalAlgorithm;
}
var hasRequiredNodeIteratorAlgorithm;
function requireNodeIteratorAlgorithm() {
  if (hasRequiredNodeIteratorAlgorithm) return NodeIteratorAlgorithm;
  hasRequiredNodeIteratorAlgorithm = 1;
  Object.defineProperty(NodeIteratorAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const interfaces_1 = requireInterfaces$2();
  const TraversalAlgorithm_1 = requireTraversalAlgorithm();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  function nodeIterator_traverse(iterator, forward) {
    let node2 = iterator._reference;
    let beforeNode = iterator._pointerBeforeReference;
    while (true) {
      if (forward) {
        if (!beforeNode) {
          const nextNode = TreeAlgorithm_1.tree_getFollowingNode(iterator._root, node2);
          if (nextNode) {
            node2 = nextNode;
          } else {
            return null;
          }
        } else {
          beforeNode = false;
        }
      } else {
        if (beforeNode) {
          const prevNode = TreeAlgorithm_1.tree_getPrecedingNode(iterator.root, node2);
          if (prevNode) {
            node2 = prevNode;
          } else {
            return null;
          }
        } else {
          beforeNode = true;
        }
      }
      const result = TraversalAlgorithm_1.traversal_filter(iterator, node2);
      if (result === interfaces_1.FilterResult.Accept) {
        break;
      }
    }
    iterator._reference = node2;
    iterator._pointerBeforeReference = beforeNode;
    return node2;
  }
  NodeIteratorAlgorithm.nodeIterator_traverse = nodeIterator_traverse;
  function nodeIterator_iteratorList() {
    return dom_1.dom.window._iteratorList;
  }
  NodeIteratorAlgorithm.nodeIterator_iteratorList = nodeIterator_iteratorList;
  return NodeIteratorAlgorithm;
}
var DocumentAlgorithm = {};
var NamespaceAlgorithm = {};
var XMLAlgorithm = {};
var hasRequiredXMLAlgorithm;
function requireXMLAlgorithm() {
  if (hasRequiredXMLAlgorithm) return XMLAlgorithm;
  hasRequiredXMLAlgorithm = 1;
  Object.defineProperty(XMLAlgorithm, "__esModule", { value: true });
  function xml_isName(name) {
    for (let i = 0; i < name.length; i++) {
      let n = name.charCodeAt(i);
      if (n >= 97 && n <= 122 || // [a-z]
      n >= 65 && n <= 90 || // [A-Z]
      n === 58 || n === 95 || // ':' or '_'
      n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
        continue;
      } else if (i !== 0 && (n === 45 || n === 46 || // '-' or '.'
      n >= 48 && n <= 57 || // [0-9]
      n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < name.length - 1) {
        const n2 = name.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 983039) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  XMLAlgorithm.xml_isName = xml_isName;
  function xml_isQName(name) {
    let colonFound = false;
    for (let i = 0; i < name.length; i++) {
      let n = name.charCodeAt(i);
      if (n >= 97 && n <= 122 || // [a-z]
      n >= 65 && n <= 90 || // [A-Z]
      n === 95 || // '_'
      n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
        continue;
      } else if (i !== 0 && (n === 45 || n === 46 || // '-' or '.'
      n >= 48 && n <= 57 || // [0-9]
      n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
        continue;
      } else if (i !== 0 && n === 58) {
        if (colonFound)
          return false;
        if (i === name.length - 1)
          return false;
        colonFound = true;
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < name.length - 1) {
        const n2 = name.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 983039) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  XMLAlgorithm.xml_isQName = xml_isQName;
  function xml_isLegalChar(chars) {
    for (let i = 0; i < chars.length; i++) {
      let n = chars.charCodeAt(i);
      if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
        continue;
      }
      if (n >= 55296 && n <= 56319 && i < chars.length - 1) {
        const n2 = chars.charCodeAt(i + 1);
        if (n2 >= 56320 && n2 <= 57343) {
          n = (n - 55296) * 1024 + n2 - 56320 + 65536;
          i++;
          if (n >= 65536 && n <= 1114111) {
            continue;
          }
        }
      }
      return false;
    }
    return true;
  }
  XMLAlgorithm.xml_isLegalChar = xml_isLegalChar;
  function xml_isPubidChar(chars) {
    for (let i = 0; i < chars.length; i++) {
      const n = chars.charCodeAt(i);
      if (n >= 97 && n <= 122 || // [a-z]
      n >= 65 && n <= 90 || // [A-Z]
      n >= 39 && n <= 59 || // ['()*+,-./] | [0-9] | [:;]
      n === 32 || n === 13 || n === 10 || // #x20 | #xD | #xA
      n >= 35 && n <= 37 || // [#$%]
      n === 33 || // !
      n === 61 || n === 63 || n === 64 || n === 95) {
        continue;
      } else {
        return false;
      }
    }
    return true;
  }
  XMLAlgorithm.xml_isPubidChar = xml_isPubidChar;
  return XMLAlgorithm;
}
var hasRequiredNamespaceAlgorithm;
function requireNamespaceAlgorithm() {
  if (hasRequiredNamespaceAlgorithm) return NamespaceAlgorithm;
  hasRequiredNamespaceAlgorithm = 1;
  Object.defineProperty(NamespaceAlgorithm, "__esModule", { value: true });
  const DOMException_1 = requireDOMException();
  const infra_1 = requireLib$8();
  const XMLAlgorithm_1 = requireXMLAlgorithm();
  function namespace_validate(qualifiedName) {
    if (!XMLAlgorithm_1.xml_isName(qualifiedName))
      throw new DOMException_1.InvalidCharacterError(`Invalid XML name: ${qualifiedName}`);
    if (!XMLAlgorithm_1.xml_isQName(qualifiedName))
      throw new DOMException_1.InvalidCharacterError(`Invalid XML qualified name: ${qualifiedName}.`);
  }
  NamespaceAlgorithm.namespace_validate = namespace_validate;
  function namespace_validateAndExtract(namespace, qualifiedName) {
    if (!namespace)
      namespace = null;
    namespace_validate(qualifiedName);
    const parts = qualifiedName.split(":");
    const prefix = parts.length === 2 ? parts[0] : null;
    const localName = parts.length === 2 ? parts[1] : qualifiedName;
    if (prefix && namespace === null)
      throw new DOMException_1.NamespaceError("Qualified name includes a prefix but the namespace is null.");
    if (prefix === "xml" && namespace !== infra_1.namespace.XML)
      throw new DOMException_1.NamespaceError(`Qualified name includes the "xml" prefix but the namespace is not the XML namespace.`);
    if (namespace !== infra_1.namespace.XMLNS && (prefix === "xmlns" || qualifiedName === "xmlns"))
      throw new DOMException_1.NamespaceError(`Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.`);
    if (namespace === infra_1.namespace.XMLNS && (prefix !== "xmlns" && qualifiedName !== "xmlns"))
      throw new DOMException_1.NamespaceError(`Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.`);
    return [namespace, prefix, localName];
  }
  NamespaceAlgorithm.namespace_validateAndExtract = namespace_validateAndExtract;
  function namespace_extractQName(qualifiedName) {
    namespace_validate(qualifiedName);
    const parts = qualifiedName.split(":");
    const prefix = parts.length === 2 ? parts[0] : null;
    const localName = parts.length === 2 ? parts[1] : qualifiedName;
    return [prefix, localName];
  }
  NamespaceAlgorithm.namespace_extractQName = namespace_extractQName;
  return NamespaceAlgorithm;
}
var hasRequiredDocumentAlgorithm;
function requireDocumentAlgorithm() {
  if (hasRequiredDocumentAlgorithm) return DocumentAlgorithm;
  hasRequiredDocumentAlgorithm = 1;
  Object.defineProperty(DocumentAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const util_1 = requireUtil$1();
  const util_2 = requireLib$9();
  const ElementImpl_1 = requireElementImpl();
  const CustomElementAlgorithm_1 = requireCustomElementAlgorithm();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const NamespaceAlgorithm_1 = requireNamespaceAlgorithm();
  const DOMAlgorithm_1 = requireDOMAlgorithm();
  const ElementAlgorithm_1 = requireElementAlgorithm();
  const MutationAlgorithm_1 = requireMutationAlgorithm();
  function document_elementInterface(name, namespace) {
    return ElementImpl_1.ElementImpl;
  }
  DocumentAlgorithm.document_elementInterface = document_elementInterface;
  function document_internalCreateElementNS(document2, namespace, qualifiedName, options) {
    const [ns, prefix, localName] = NamespaceAlgorithm_1.namespace_validateAndExtract(namespace, qualifiedName);
    let is = null;
    if (options !== void 0) {
      if (util_2.isString(options)) {
        is = options;
      } else {
        is = options.is;
      }
    }
    return ElementAlgorithm_1.element_createAnElement(document2, localName, ns, prefix, is, true);
  }
  DocumentAlgorithm.document_internalCreateElementNS = document_internalCreateElementNS;
  function document_adopt(node2, document2) {
    if (node2._nodeDocument === document2 && node2._parent === null) {
      return;
    }
    const oldDocument = node2._nodeDocument;
    if (node2._parent)
      MutationAlgorithm_1.mutation_remove(node2, node2._parent);
    if (document2 !== oldDocument) {
      let inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node2, true, true);
      while (inclusiveDescendant !== null) {
        inclusiveDescendant._nodeDocument = document2;
        if (util_1.Guard.isElementNode(inclusiveDescendant)) {
          for (const attr of inclusiveDescendant._attributeList._asArray()) {
            attr._nodeDocument = document2;
          }
        }
        if (dom_1.dom.features.customElements) {
          if (util_1.Guard.isElementNode(inclusiveDescendant) && inclusiveDescendant._customElementState === "custom") {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "adoptedCallback", [oldDocument, document2]);
          }
        }
        if (dom_1.dom.features.steps) {
          DOMAlgorithm_1.dom_runAdoptingSteps(inclusiveDescendant, oldDocument);
        }
        inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node2, inclusiveDescendant, true, true);
      }
    }
  }
  DocumentAlgorithm.document_adopt = document_adopt;
  return DocumentAlgorithm;
}
var hasRequiredMutationAlgorithm;
function requireMutationAlgorithm() {
  if (hasRequiredMutationAlgorithm) return MutationAlgorithm;
  hasRequiredMutationAlgorithm = 1;
  Object.defineProperty(MutationAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const DOMException_1 = requireDOMException();
  const interfaces_1 = requireInterfaces$2();
  const util_1 = requireUtil$1();
  const util_2 = requireLib$9();
  const infra_1 = requireLib$8();
  const CustomElementAlgorithm_1 = requireCustomElementAlgorithm();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const NodeIteratorAlgorithm_1 = requireNodeIteratorAlgorithm();
  const ShadowTreeAlgorithm_1 = requireShadowTreeAlgorithm();
  const MutationObserverAlgorithm_1 = requireMutationObserverAlgorithm();
  const DOMAlgorithm_1 = requireDOMAlgorithm();
  const DocumentAlgorithm_1 = requireDocumentAlgorithm();
  function mutation_ensurePreInsertionValidity(node2, parent, child) {
    const parentNodeType = parent._nodeType;
    const nodeNodeType = node2._nodeType;
    const childNodeType = child ? child._nodeType : null;
    if (parentNodeType !== interfaces_1.NodeType.Document && parentNodeType !== interfaces_1.NodeType.DocumentFragment && parentNodeType !== interfaces_1.NodeType.Element)
      throw new DOMException_1.HierarchyRequestError(`Only document, document fragment and element nodes can contain child nodes. Parent node is ${parent.nodeName}.`);
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node2, true))
      throw new DOMException_1.HierarchyRequestError(`The node to be inserted cannot be an inclusive ancestor of parent node. Node is ${node2.nodeName}, parent node is ${parent.nodeName}.`);
    if (child !== null && child._parent !== parent)
      throw new DOMException_1.NotFoundError(`The reference child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
    if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment && nodeNodeType !== interfaces_1.NodeType.DocumentType && nodeNodeType !== interfaces_1.NodeType.Element && nodeNodeType !== interfaces_1.NodeType.Text && nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction && nodeNodeType !== interfaces_1.NodeType.CData && nodeNodeType !== interfaces_1.NodeType.Comment)
      throw new DOMException_1.HierarchyRequestError(`Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is ${node2.nodeName}.`);
    if (nodeNodeType === interfaces_1.NodeType.Text && parentNodeType === interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`Cannot insert a text node as a child of a document node. Node is ${node2.nodeName}.`);
    if (nodeNodeType === interfaces_1.NodeType.DocumentType && parentNodeType !== interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`A document type node can only be inserted under a document node. Parent node is ${parent.nodeName}.`);
    if (parentNodeType === interfaces_1.NodeType.Document) {
      if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {
        let eleCount = 0;
        for (const childNode of node2._children) {
          if (childNode._nodeType === interfaces_1.NodeType.Element)
            eleCount++;
          else if (childNode._nodeType === interfaces_1.NodeType.Text)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert text a node as a child of a document node. Node is ${childNode.nodeName}.`);
        }
        if (eleCount > 1) {
          throw new DOMException_1.HierarchyRequestError(`A document node can only have one document element node. Document fragment to be inserted has ${eleCount} element nodes.`);
        } else if (eleCount === 1) {
          for (const ele of parent._children) {
            if (ele._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError(`The document node already has a document element node.`);
          }
          if (child) {
            if (childNodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
            let doctypeChild = child._nextSibling;
            while (doctypeChild) {
              if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
              doctypeChild = doctypeChild._nextSibling;
            }
          }
        }
      } else if (nodeNodeType === interfaces_1.NodeType.Element) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.Element)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document element node. Node is ${node2.nodeName}.`);
        }
        if (child) {
          if (childNodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node2.nodeName}.`);
          let doctypeChild = child._nextSibling;
          while (doctypeChild) {
            if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node2.nodeName}.`);
            doctypeChild = doctypeChild._nextSibling;
          }
        }
      } else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document type node. Node is ${node2.nodeName}.`);
        }
        if (child) {
          let elementChild = child._previousSibling;
          while (elementChild) {
            if (elementChild._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node2.nodeName}.`);
            elementChild = elementChild._previousSibling;
          }
        } else {
          let elementChild = parent._firstChild;
          while (elementChild) {
            if (elementChild._nodeType === interfaces_1.NodeType.Element)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node2.nodeName}.`);
            elementChild = elementChild._nextSibling;
          }
        }
      }
    }
  }
  MutationAlgorithm.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;
  function mutation_preInsert(node2, parent, child) {
    mutation_ensurePreInsertionValidity(node2, parent, child);
    let referenceChild = child;
    if (referenceChild === node2)
      referenceChild = node2._nextSibling;
    DocumentAlgorithm_1.document_adopt(node2, parent._nodeDocument);
    mutation_insert(node2, parent, referenceChild);
    return node2;
  }
  MutationAlgorithm.mutation_preInsert = mutation_preInsert;
  function mutation_insert(node2, parent, child, suppressObservers) {
    if (child === null && node2._nodeType !== interfaces_1.NodeType.DocumentFragment) {
      mutation_insert_single(node2, parent, suppressObservers);
      return;
    }
    const count = node2._nodeType === interfaces_1.NodeType.DocumentFragment ? node2._children.size : 1;
    if (child !== null) {
      if (dom_1.dom.rangeList.size !== 0) {
        const index2 = TreeAlgorithm_1.tree_index(child);
        for (const range2 of dom_1.dom.rangeList) {
          if (range2._start[0] === parent && range2._start[1] > index2) {
            range2._start[1] += count;
          }
          if (range2._end[0] === parent && range2._end[1] > index2) {
            range2._end[1] += count;
          }
        }
      }
    }
    const nodes2 = node2._nodeType === interfaces_1.NodeType.DocumentFragment ? new Array(...node2._children) : [node2];
    if (node2._nodeType === interfaces_1.NodeType.DocumentFragment) {
      while (node2._firstChild) {
        mutation_remove(node2._firstChild, node2, true);
      }
    }
    if (dom_1.dom.features.mutationObservers) {
      if (node2._nodeType === interfaces_1.NodeType.DocumentFragment) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(node2, [], nodes2, null, null);
      }
    }
    const previousSibling = child ? child._previousSibling : parent._lastChild;
    let index = child === null ? -1 : TreeAlgorithm_1.tree_index(child);
    for (let i = 0; i < nodes2.length; i++) {
      const node3 = nodes2[i];
      if (util_1.Guard.isElementNode(node3)) {
        if (util_1.Guard.isDocumentNode(parent)) {
          parent._documentElement = node3;
        }
        if (!node3._nodeDocument._hasNamespaces && (node3._namespace !== null || node3._namespacePrefix !== null)) {
          node3._nodeDocument._hasNamespaces = true;
        }
      }
      node3._parent = parent;
      if (child === null) {
        infra_1.set.append(parent._children, node3);
      } else {
        infra_1.set.insert(parent._children, node3, index);
        index++;
      }
      if (parent._firstChild === null) {
        node3._previousSibling = null;
        node3._nextSibling = null;
        parent._firstChild = node3;
        parent._lastChild = node3;
      } else {
        const prev = child ? child._previousSibling : parent._lastChild;
        const next = child ? child : null;
        node3._previousSibling = prev;
        node3._nextSibling = next;
        if (prev)
          prev._nextSibling = node3;
        if (next)
          next._previousSibling = node3;
        if (!prev)
          parent._firstChild = node3;
        if (!next)
          parent._lastChild = node3;
      }
      if (dom_1.dom.features.slots) {
        if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node3)) {
          ShadowTreeAlgorithm_1.shadowTree_assignASlot(node3);
        }
      }
      if (dom_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node3)) {
          DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
      }
      if (dom_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
          ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
      }
      if (dom_1.dom.features.slots) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node3));
      }
      let inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node3, true, true);
      while (inclusiveDescendant !== null) {
        if (dom_1.dom.features.steps) {
          DOMAlgorithm_1.dom_runInsertionSteps(inclusiveDescendant);
        }
        if (dom_1.dom.features.customElements) {
          if (util_1.Guard.isElementNode(inclusiveDescendant) && ShadowTreeAlgorithm_1.shadowTree_isConnected(inclusiveDescendant)) {
            if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {
              CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "connectedCallback", []);
            } else {
              CustomElementAlgorithm_1.customElement_tryToUpgrade(inclusiveDescendant);
            }
          }
        }
        inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node3, inclusiveDescendant, true, true);
      }
    }
    if (dom_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes2, [], previousSibling, child);
      }
    }
  }
  MutationAlgorithm.mutation_insert = mutation_insert;
  function mutation_insert_single(node2, parent, suppressObservers) {
    const previousSibling = parent._lastChild;
    if (util_1.Guard.isElementNode(node2)) {
      if (util_1.Guard.isDocumentNode(parent)) {
        parent._documentElement = node2;
      }
      if (!node2._nodeDocument._hasNamespaces && (node2._namespace !== null || node2._namespacePrefix !== null)) {
        node2._nodeDocument._hasNamespaces = true;
      }
    }
    node2._parent = parent;
    parent._children.add(node2);
    if (parent._firstChild === null) {
      node2._previousSibling = null;
      node2._nextSibling = null;
      parent._firstChild = node2;
      parent._lastChild = node2;
    } else {
      const prev = parent._lastChild;
      node2._previousSibling = prev;
      node2._nextSibling = null;
      if (prev)
        prev._nextSibling = node2;
      if (!prev)
        parent._firstChild = node2;
      parent._lastChild = node2;
    }
    if (dom_1.dom.features.slots) {
      if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node2)) {
        ShadowTreeAlgorithm_1.shadowTree_assignASlot(node2);
      }
    }
    if (dom_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node2)) {
        DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
      }
    }
    if (dom_1.dom.features.slots) {
      if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
        ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
      }
    }
    if (dom_1.dom.features.slots) {
      ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node2));
    }
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runInsertionSteps(node2);
    }
    if (dom_1.dom.features.customElements) {
      if (util_1.Guard.isElementNode(node2) && ShadowTreeAlgorithm_1.shadowTree_isConnected(node2)) {
        if (util_1.Guard.isCustomElementNode(node2)) {
          CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node2, "connectedCallback", []);
        } else {
          CustomElementAlgorithm_1.customElement_tryToUpgrade(node2);
        }
      }
    }
    if (dom_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [node2], [], previousSibling, null);
      }
    }
  }
  function mutation_append(node2, parent) {
    return mutation_preInsert(node2, parent, null);
  }
  MutationAlgorithm.mutation_append = mutation_append;
  function mutation_replace(child, node2, parent) {
    if (parent._nodeType !== interfaces_1.NodeType.Document && parent._nodeType !== interfaces_1.NodeType.DocumentFragment && parent._nodeType !== interfaces_1.NodeType.Element)
      throw new DOMException_1.HierarchyRequestError(`Only document, document fragment and element nodes can contain child nodes. Parent node is ${parent.nodeName}.`);
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node2, true))
      throw new DOMException_1.HierarchyRequestError(`The node to be inserted cannot be an ancestor of parent node. Node is ${node2.nodeName}, parent node is ${parent.nodeName}.`);
    if (child._parent !== parent)
      throw new DOMException_1.NotFoundError(`The reference child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
    if (node2._nodeType !== interfaces_1.NodeType.DocumentFragment && node2._nodeType !== interfaces_1.NodeType.DocumentType && node2._nodeType !== interfaces_1.NodeType.Element && node2._nodeType !== interfaces_1.NodeType.Text && node2._nodeType !== interfaces_1.NodeType.ProcessingInstruction && node2._nodeType !== interfaces_1.NodeType.CData && node2._nodeType !== interfaces_1.NodeType.Comment)
      throw new DOMException_1.HierarchyRequestError(`Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is ${node2.nodeName}.`);
    if (node2._nodeType === interfaces_1.NodeType.Text && parent._nodeType === interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`Cannot insert a text node as a child of a document node. Node is ${node2.nodeName}.`);
    if (node2._nodeType === interfaces_1.NodeType.DocumentType && parent._nodeType !== interfaces_1.NodeType.Document)
      throw new DOMException_1.HierarchyRequestError(`A document type node can only be inserted under a document node. Parent node is ${parent.nodeName}.`);
    if (parent._nodeType === interfaces_1.NodeType.Document) {
      if (node2._nodeType === interfaces_1.NodeType.DocumentFragment) {
        let eleCount = 0;
        for (const childNode of node2._children) {
          if (childNode._nodeType === interfaces_1.NodeType.Element)
            eleCount++;
          else if (childNode._nodeType === interfaces_1.NodeType.Text)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert text a node as a child of a document node. Node is ${childNode.nodeName}.`);
        }
        if (eleCount > 1) {
          throw new DOMException_1.HierarchyRequestError(`A document node can only have one document element node. Document fragment to be inserted has ${eleCount} element nodes.`);
        } else if (eleCount === 1) {
          for (const ele of parent._children) {
            if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
              throw new DOMException_1.HierarchyRequestError(`The document node already has a document element node.`);
          }
          let doctypeChild = child._nextSibling;
          while (doctypeChild) {
            if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
              throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
            doctypeChild = doctypeChild._nextSibling;
          }
        }
      } else if (node2._nodeType === interfaces_1.NodeType.Element) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document element node. Node is ${node2.nodeName}.`);
        }
        let doctypeChild = child._nextSibling;
        while (doctypeChild) {
          if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node2.nodeName}.`);
          doctypeChild = doctypeChild._nextSibling;
        }
      } else if (node2._nodeType === interfaces_1.NodeType.DocumentType) {
        for (const ele of parent._children) {
          if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child)
            throw new DOMException_1.HierarchyRequestError(`Document already has a document type node. Node is ${node2.nodeName}.`);
        }
        let elementChild = child._previousSibling;
        while (elementChild) {
          if (elementChild._nodeType === interfaces_1.NodeType.Element)
            throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node2.nodeName}.`);
          elementChild = elementChild._previousSibling;
        }
      }
    }
    let referenceChild = child._nextSibling;
    if (referenceChild === node2)
      referenceChild = node2._nextSibling;
    let previousSibling = child._previousSibling;
    DocumentAlgorithm_1.document_adopt(node2, parent._nodeDocument);
    const removedNodes = [];
    if (child._parent !== null) {
      removedNodes.push(child);
      mutation_remove(child, child._parent, true);
    }
    let nodes2 = [];
    if (node2._nodeType === interfaces_1.NodeType.DocumentFragment) {
      nodes2 = Array.from(node2._children);
    } else {
      nodes2.push(node2);
    }
    mutation_insert(node2, parent, referenceChild, true);
    if (dom_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes2, removedNodes, previousSibling, referenceChild);
    }
    return child;
  }
  MutationAlgorithm.mutation_replace = mutation_replace;
  function mutation_replaceAll(node2, parent) {
    if (node2 !== null) {
      DocumentAlgorithm_1.document_adopt(node2, parent._nodeDocument);
    }
    const removedNodes = Array.from(parent._children);
    let addedNodes = [];
    if (node2 && node2._nodeType === interfaces_1.NodeType.DocumentFragment) {
      addedNodes = Array.from(node2._children);
    } else if (node2 !== null) {
      addedNodes.push(node2);
    }
    for (const childNode of removedNodes) {
      mutation_remove(childNode, parent, true);
    }
    if (node2 !== null) {
      mutation_insert(node2, parent, null, true);
    }
    if (dom_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, addedNodes, removedNodes, null, null);
    }
  }
  MutationAlgorithm.mutation_replaceAll = mutation_replaceAll;
  function mutation_preRemove(child, parent) {
    if (child._parent !== parent)
      throw new DOMException_1.NotFoundError(`The child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
    mutation_remove(child, parent);
    return child;
  }
  MutationAlgorithm.mutation_preRemove = mutation_preRemove;
  function mutation_remove(node2, parent, suppressObservers) {
    if (dom_1.dom.rangeList.size !== 0) {
      const index = TreeAlgorithm_1.tree_index(node2);
      for (const range2 of dom_1.dom.rangeList) {
        if (TreeAlgorithm_1.tree_isDescendantOf(node2, range2._start[0], true)) {
          range2._start = [parent, index];
        }
        if (TreeAlgorithm_1.tree_isDescendantOf(node2, range2._end[0], true)) {
          range2._end = [parent, index];
        }
        if (range2._start[0] === parent && range2._start[1] > index) {
          range2._start[1]--;
        }
        if (range2._end[0] === parent && range2._end[1] > index) {
          range2._end[1]--;
        }
      }
      for (const range2 of dom_1.dom.rangeList) {
        if (range2._start[0] === parent && range2._start[1] > index) {
          range2._start[1] -= 1;
        }
        if (range2._end[0] === parent && range2._end[1] > index) {
          range2._end[1] -= 1;
        }
      }
    }
    if (dom_1.dom.features.steps) {
      for (const iterator of NodeIteratorAlgorithm_1.nodeIterator_iteratorList()) {
        if (iterator._root._nodeDocument === node2._nodeDocument) {
          DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps(iterator, node2);
        }
      }
    }
    const oldPreviousSibling = node2._previousSibling;
    const oldNextSibling = node2._nextSibling;
    if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node2)) {
      parent._documentElement = null;
    }
    node2._parent = null;
    parent._children.delete(node2);
    const prev = node2._previousSibling;
    const next = node2._nextSibling;
    node2._previousSibling = null;
    node2._nextSibling = null;
    if (prev)
      prev._nextSibling = next;
    if (next)
      next._previousSibling = prev;
    if (!prev)
      parent._firstChild = next;
    if (!next)
      parent._lastChild = prev;
    if (dom_1.dom.features.slots) {
      if (util_1.Guard.isSlotable(node2) && node2._assignedSlot !== null && ShadowTreeAlgorithm_1.shadowTree_isAssigned(node2)) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotables(node2._assignedSlot);
      }
    }
    if (dom_1.dom.features.slots) {
      if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
        ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
      }
    }
    if (dom_1.dom.features.slots) {
      const descendant2 = TreeAlgorithm_1.tree_getFirstDescendantNode(node2, true, false, (e) => util_1.Guard.isSlot(e));
      if (descendant2 !== null) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(parent));
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(node2);
      }
    }
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runRemovingSteps(node2, parent);
    }
    if (dom_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(node2)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node2, "disconnectedCallback", []);
      }
    }
    let descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node2, false, true);
    while (descendant !== null) {
      if (dom_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runRemovingSteps(descendant, node2);
      }
      if (dom_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(descendant)) {
          CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(descendant, "disconnectedCallback", []);
        }
      }
      descendant = TreeAlgorithm_1.tree_getNextDescendantNode(node2, descendant, false, true);
    }
    if (dom_1.dom.features.mutationObservers) {
      let inclusiveAncestor = TreeAlgorithm_1.tree_getFirstAncestorNode(parent, true);
      while (inclusiveAncestor !== null) {
        for (const registered of inclusiveAncestor._registeredObserverList) {
          if (registered.options.subtree) {
            node2._registeredObserverList.push({
              observer: registered.observer,
              options: registered.options,
              source: registered
            });
          }
        }
        inclusiveAncestor = TreeAlgorithm_1.tree_getNextAncestorNode(parent, inclusiveAncestor, true);
      }
    }
    if (dom_1.dom.features.mutationObservers) {
      if (!suppressObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [], [node2], oldPreviousSibling, oldNextSibling);
      }
    }
    if (dom_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node2)) {
        DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
      }
    }
  }
  MutationAlgorithm.mutation_remove = mutation_remove;
  return MutationAlgorithm;
}
var hasRequiredElementAlgorithm;
function requireElementAlgorithm() {
  if (hasRequiredElementAlgorithm) return ElementAlgorithm;
  hasRequiredElementAlgorithm = 1;
  Object.defineProperty(ElementAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const infra_1 = requireLib$8();
  const util_1 = requireUtil$1();
  const DOMException_1 = requireDOMException();
  const CreateAlgorithm_1 = requireCreateAlgorithm();
  const CustomElementAlgorithm_1 = requireCustomElementAlgorithm();
  const MutationObserverAlgorithm_1 = requireMutationObserverAlgorithm();
  const DOMAlgorithm_1 = requireDOMAlgorithm();
  const MutationAlgorithm_1 = requireMutationAlgorithm();
  const DocumentAlgorithm_1 = requireDocumentAlgorithm();
  function element_has(attribute2, element2) {
    return element2._attributeList._asArray().indexOf(attribute2) !== -1;
  }
  ElementAlgorithm.element_has = element_has;
  function element_change(attribute2, element2, value) {
    if (dom_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element2, attribute2._localName, attribute2._namespace, attribute2._value);
    }
    if (dom_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element2)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element2, "attributeChangedCallback", [attribute2._localName, attribute2._value, value, attribute2._namespace]);
      }
    }
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element2, attribute2._localName, attribute2._value, value, attribute2._namespace);
    }
    attribute2._value = value;
  }
  ElementAlgorithm.element_change = element_change;
  function element_append(attribute2, element2) {
    if (dom_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element2, attribute2._localName, attribute2._namespace, null);
    }
    if (dom_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element2)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element2, "attributeChangedCallback", [attribute2._localName, null, attribute2._value, attribute2._namespace]);
      }
    }
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element2, attribute2._localName, null, attribute2._value, attribute2._namespace);
    }
    element2._attributeList._asArray().push(attribute2);
    attribute2._element = element2;
    if (!element2._nodeDocument._hasNamespaces && (attribute2._namespace !== null || attribute2._namespacePrefix !== null || attribute2._localName === "xmlns")) {
      element2._nodeDocument._hasNamespaces = true;
    }
  }
  ElementAlgorithm.element_append = element_append;
  function element_remove(attribute2, element2) {
    if (dom_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element2, attribute2._localName, attribute2._namespace, attribute2._value);
    }
    if (dom_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element2)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element2, "attributeChangedCallback", [attribute2._localName, attribute2._value, null, attribute2._namespace]);
      }
    }
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element2, attribute2._localName, attribute2._value, null, attribute2._namespace);
    }
    const index = element2._attributeList._asArray().indexOf(attribute2);
    element2._attributeList._asArray().splice(index, 1);
    attribute2._element = null;
  }
  ElementAlgorithm.element_remove = element_remove;
  function element_replace(oldAttr, newAttr, element2) {
    if (dom_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element2, oldAttr._localName, oldAttr._namespace, oldAttr._value);
    }
    if (dom_1.dom.features.customElements) {
      if (util_1.Guard.isCustomElementNode(element2)) {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element2, "attributeChangedCallback", [oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace]);
      }
    }
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runAttributeChangeSteps(element2, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);
    }
    const index = element2._attributeList._asArray().indexOf(oldAttr);
    if (index !== -1) {
      element2._attributeList._asArray()[index] = newAttr;
    }
    oldAttr._element = null;
    newAttr._element = element2;
    if (!element2._nodeDocument._hasNamespaces && (newAttr._namespace !== null || newAttr._namespacePrefix !== null || newAttr._localName === "xmlns")) {
      element2._nodeDocument._hasNamespaces = true;
    }
  }
  ElementAlgorithm.element_replace = element_replace;
  function element_getAnAttributeByName(qualifiedName, element2) {
    if (element2._namespace === infra_1.namespace.HTML && element2._nodeDocument._type === "html") {
      qualifiedName = qualifiedName.toLowerCase();
    }
    return element2._attributeList._asArray().find((attr) => attr._qualifiedName === qualifiedName) || null;
  }
  ElementAlgorithm.element_getAnAttributeByName = element_getAnAttributeByName;
  function element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element2) {
    const ns = namespace || null;
    return element2._attributeList._asArray().find((attr) => attr._namespace === ns && attr._localName === localName) || null;
  }
  ElementAlgorithm.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;
  function element_getAnAttributeValue(element2, localName, namespace = "") {
    const attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element2);
    if (attr === null)
      return "";
    else
      return attr._value;
  }
  ElementAlgorithm.element_getAnAttributeValue = element_getAnAttributeValue;
  function element_setAnAttribute(attr, element2) {
    if (attr._element !== null && attr._element !== element2)
      throw new DOMException_1.InUseAttributeError(`This attribute already exists in the document: ${attr._qualifiedName} as a child of ${attr._element._qualifiedName}.`);
    const oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || "", attr._localName, element2);
    if (oldAttr === attr)
      return attr;
    if (oldAttr !== null) {
      element_replace(oldAttr, attr, element2);
    } else {
      element_append(attr, element2);
    }
    return oldAttr;
  }
  ElementAlgorithm.element_setAnAttribute = element_setAnAttribute;
  function element_setAnAttributeValue(element2, localName, value, prefix = null, namespace = null) {
    const attribute2 = element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, element2);
    if (attribute2 === null) {
      const newAttr = CreateAlgorithm_1.create_attr(element2._nodeDocument, localName);
      newAttr._namespace = namespace;
      newAttr._namespacePrefix = prefix;
      newAttr._value = value;
      element_append(newAttr, element2);
      return;
    }
    element_change(attribute2, element2, value);
  }
  ElementAlgorithm.element_setAnAttributeValue = element_setAnAttributeValue;
  function element_removeAnAttributeByName(qualifiedName, element2) {
    const attr = element_getAnAttributeByName(qualifiedName, element2);
    if (attr !== null) {
      element_remove(attr, element2);
    }
    return attr;
  }
  ElementAlgorithm.element_removeAnAttributeByName = element_removeAnAttributeByName;
  function element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element2) {
    const attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element2);
    if (attr !== null) {
      element_remove(attr, element2);
    }
    return attr;
  }
  ElementAlgorithm.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;
  function element_createAnElement(document2, localName, namespace, prefix = null, is = null, synchronousCustomElementsFlag = false) {
    let result = null;
    if (!dom_1.dom.features.customElements) {
      result = CreateAlgorithm_1.create_element(document2, localName, namespace, prefix);
      result._customElementState = "uncustomized";
      result._customElementDefinition = null;
      result._is = is;
      return result;
    }
    const definition = CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition(document2, namespace, localName, is);
    if (definition !== null && definition.name !== definition.localName) {
      const elemenInterface = DocumentAlgorithm_1.document_elementInterface(localName, infra_1.namespace.HTML);
      result = new elemenInterface();
      result._localName = localName;
      result._namespace = infra_1.namespace.HTML;
      result._namespacePrefix = prefix;
      result._customElementState = "undefined";
      result._customElementDefinition = null;
      result._is = is;
      result._nodeDocument = document2;
      if (synchronousCustomElementsFlag) {
        CustomElementAlgorithm_1.customElement_upgrade(definition, result);
      } else {
        CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
      }
    } else if (definition !== null) {
      if (synchronousCustomElementsFlag) {
        try {
          const C = definition.constructor;
          const result2 = new C();
          console.assert(result2._customElementState !== void 0);
          console.assert(result2._customElementDefinition !== void 0);
          console.assert(result2._namespace === infra_1.namespace.HTML);
          if (result2._attributeList.length !== 0)
            throw new DOMException_1.NotSupportedError("Custom element already has attributes.");
          if (result2._children.size !== 0)
            throw new DOMException_1.NotSupportedError("Custom element already has child nodes.");
          if (result2._parent !== null)
            throw new DOMException_1.NotSupportedError("Custom element already has a parent node.");
          if (result2._nodeDocument !== document2)
            throw new DOMException_1.NotSupportedError("Custom element is already in a document.");
          if (result2._localName !== localName)
            throw new DOMException_1.NotSupportedError("Custom element has a different local name.");
          result2._namespacePrefix = prefix;
          result2._is = null;
        } catch (e) {
          result = CreateAlgorithm_1.create_htmlUnknownElement(document2, localName, infra_1.namespace.HTML, prefix);
          result._customElementState = "failed";
          result._customElementDefinition = null;
          result._is = null;
        }
      } else {
        result = CreateAlgorithm_1.create_htmlElement(document2, localName, infra_1.namespace.HTML, prefix);
        result._customElementState = "undefined";
        result._customElementDefinition = null;
        result._is = null;
        CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
      }
    } else {
      const elementInterface = DocumentAlgorithm_1.document_elementInterface(localName, namespace);
      result = new elementInterface();
      result._localName = localName;
      result._namespace = namespace;
      result._namespacePrefix = prefix;
      result._customElementState = "uncustomized";
      result._customElementDefinition = null;
      result._is = is;
      result._nodeDocument = document2;
      if (namespace === infra_1.namespace.HTML && (is !== null || CustomElementAlgorithm_1.customElement_isValidCustomElementName(localName))) {
        result._customElementState = "undefined";
      }
    }
    if (result === null) {
      throw new Error("Unable to create element.");
    }
    return result;
  }
  ElementAlgorithm.element_createAnElement = element_createAnElement;
  function element_insertAdjacent(element2, where, node2) {
    switch (where.toLowerCase()) {
      case "beforebegin":
        if (element2._parent === null)
          return null;
        return MutationAlgorithm_1.mutation_preInsert(node2, element2._parent, element2);
      case "afterbegin":
        return MutationAlgorithm_1.mutation_preInsert(node2, element2, element2._firstChild);
      case "beforeend":
        return MutationAlgorithm_1.mutation_preInsert(node2, element2, null);
      case "afterend":
        if (element2._parent === null)
          return null;
        return MutationAlgorithm_1.mutation_preInsert(node2, element2._parent, element2._nextSibling);
      default:
        throw new DOMException_1.SyntaxError(`Invalid 'where' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected`);
    }
  }
  ElementAlgorithm.element_insertAdjacent = element_insertAdjacent;
  return ElementAlgorithm;
}
var hasRequiredAttrAlgorithm;
function requireAttrAlgorithm() {
  if (hasRequiredAttrAlgorithm) return AttrAlgorithm;
  hasRequiredAttrAlgorithm = 1;
  Object.defineProperty(AttrAlgorithm, "__esModule", { value: true });
  const ElementAlgorithm_1 = requireElementAlgorithm();
  function attr_setAnExistingAttributeValue(attribute2, value) {
    if (attribute2._element === null) {
      attribute2._value = value;
    } else {
      ElementAlgorithm_1.element_change(attribute2, attribute2._element, value);
    }
  }
  AttrAlgorithm.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue;
  return AttrAlgorithm;
}
var BoundaryPointAlgorithm = {};
var hasRequiredBoundaryPointAlgorithm;
function requireBoundaryPointAlgorithm() {
  if (hasRequiredBoundaryPointAlgorithm) return BoundaryPointAlgorithm;
  hasRequiredBoundaryPointAlgorithm = 1;
  Object.defineProperty(BoundaryPointAlgorithm, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  function boundaryPoint_position(bp, relativeTo) {
    const nodeA = bp[0];
    const offsetA = bp[1];
    const nodeB = relativeTo[0];
    const offsetB = relativeTo[1];
    console.assert(TreeAlgorithm_1.tree_rootNode(nodeA) === TreeAlgorithm_1.tree_rootNode(nodeB), "Boundary points must share the same root node.");
    if (nodeA === nodeB) {
      if (offsetA === offsetB) {
        return interfaces_1.BoundaryPosition.Equal;
      } else if (offsetA < offsetB) {
        return interfaces_1.BoundaryPosition.Before;
      } else {
        return interfaces_1.BoundaryPosition.After;
      }
    }
    if (TreeAlgorithm_1.tree_isFollowing(nodeB, nodeA)) {
      const pos = boundaryPoint_position([nodeB, offsetB], [nodeA, offsetA]);
      if (pos === interfaces_1.BoundaryPosition.Before) {
        return interfaces_1.BoundaryPosition.After;
      } else if (pos === interfaces_1.BoundaryPosition.After) {
        return interfaces_1.BoundaryPosition.Before;
      }
    }
    if (TreeAlgorithm_1.tree_isAncestorOf(nodeB, nodeA)) {
      let child = nodeB;
      while (!TreeAlgorithm_1.tree_isChildOf(nodeA, child)) {
        if (child._parent !== null) {
          child = child._parent;
        }
      }
      if (TreeAlgorithm_1.tree_index(child) < offsetA) {
        return interfaces_1.BoundaryPosition.After;
      }
    }
    return interfaces_1.BoundaryPosition.Before;
  }
  BoundaryPointAlgorithm.boundaryPoint_position = boundaryPoint_position;
  return BoundaryPointAlgorithm;
}
var CharacterDataAlgorithm = {};
var hasRequiredCharacterDataAlgorithm;
function requireCharacterDataAlgorithm() {
  if (hasRequiredCharacterDataAlgorithm) return CharacterDataAlgorithm;
  hasRequiredCharacterDataAlgorithm = 1;
  Object.defineProperty(CharacterDataAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const util_1 = requireUtil$1();
  const DOMException_1 = requireDOMException();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const MutationObserverAlgorithm_1 = requireMutationObserverAlgorithm();
  const DOMAlgorithm_1 = requireDOMAlgorithm();
  function characterData_replaceData(node2, offset, count, data) {
    const length = TreeAlgorithm_1.tree_nodeLength(node2);
    if (offset > length) {
      throw new DOMException_1.IndexSizeError(`Offset exceeds character data length. Offset: ${offset}, Length: ${length}, Node is ${node2.nodeName}.`);
    }
    if (offset + count > length) {
      count = length - offset;
    }
    if (dom_1.dom.features.mutationObservers) {
      MutationObserverAlgorithm_1.observer_queueMutationRecord("characterData", node2, null, null, node2._data, [], [], null, null);
    }
    const newData = node2._data.substring(0, offset) + data + node2._data.substring(offset + count);
    node2._data = newData;
    for (const range2 of dom_1.dom.rangeList) {
      if (range2._start[0] === node2 && range2._start[1] > offset && range2._start[1] <= offset + count) {
        range2._start[1] = offset;
      }
      if (range2._end[0] === node2 && range2._end[1] > offset && range2._end[1] <= offset + count) {
        range2._end[1] = offset;
      }
      if (range2._start[0] === node2 && range2._start[1] > offset + count) {
        range2._start[1] += data.length - count;
      }
      if (range2._end[0] === node2 && range2._end[1] > offset + count) {
        range2._end[1] += data.length - count;
      }
    }
    if (dom_1.dom.features.steps) {
      if (util_1.Guard.isTextNode(node2) && node2._parent !== null) {
        DOMAlgorithm_1.dom_runChildTextContentChangeSteps(node2._parent);
      }
    }
  }
  CharacterDataAlgorithm.characterData_replaceData = characterData_replaceData;
  function characterData_substringData(node2, offset, count) {
    const length = TreeAlgorithm_1.tree_nodeLength(node2);
    if (offset > length) {
      throw new DOMException_1.IndexSizeError(`Offset exceeds character data length. Offset: ${offset}, Length: ${length}, Node is ${node2.nodeName}.`);
    }
    if (offset + count > length) {
      return node2._data.substr(offset);
    } else {
      return node2._data.substr(offset, count);
    }
  }
  CharacterDataAlgorithm.characterData_substringData = characterData_substringData;
  return CharacterDataAlgorithm;
}
var DOMTokenListAlgorithm = {};
var OrderedSetAlgorithm = {};
var hasRequiredOrderedSetAlgorithm;
function requireOrderedSetAlgorithm() {
  if (hasRequiredOrderedSetAlgorithm) return OrderedSetAlgorithm;
  hasRequiredOrderedSetAlgorithm = 1;
  Object.defineProperty(OrderedSetAlgorithm, "__esModule", { value: true });
  const infra_1 = requireLib$8();
  function orderedSet_parse(value) {
    const inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);
    return new Set(inputTokens);
  }
  OrderedSetAlgorithm.orderedSet_parse = orderedSet_parse;
  function orderedSet_serialize(tokens) {
    return [...tokens].join(" ");
  }
  OrderedSetAlgorithm.orderedSet_serialize = orderedSet_serialize;
  function orderedSet_sanitize(value) {
    return orderedSet_serialize(orderedSet_parse(value));
  }
  OrderedSetAlgorithm.orderedSet_sanitize = orderedSet_sanitize;
  function orderedSet_contains(set1, set2, caseSensitive) {
    for (const val2 of set2) {
      let found = false;
      for (const val1 of set1) {
        if (caseSensitive) {
          if (val1 === val2) {
            found = true;
            break;
          }
        } else {
          if (val1.toUpperCase() === val2.toUpperCase()) {
            found = true;
            break;
          }
        }
      }
      if (!found)
        return false;
    }
    return true;
  }
  OrderedSetAlgorithm.orderedSet_contains = orderedSet_contains;
  return OrderedSetAlgorithm;
}
var hasRequiredDOMTokenListAlgorithm;
function requireDOMTokenListAlgorithm() {
  if (hasRequiredDOMTokenListAlgorithm) return DOMTokenListAlgorithm;
  hasRequiredDOMTokenListAlgorithm = 1;
  Object.defineProperty(DOMTokenListAlgorithm, "__esModule", { value: true });
  const OrderedSetAlgorithm_1 = requireOrderedSetAlgorithm();
  const DOMAlgorithm_1 = requireDOMAlgorithm();
  const ElementAlgorithm_1 = requireElementAlgorithm();
  function tokenList_validationSteps(tokenList, token) {
    if (!DOMAlgorithm_1.dom_hasSupportedTokens(tokenList._attribute._localName)) {
      throw new TypeError(`There are no supported tokens defined for attribute name: '${tokenList._attribute._localName}'.`);
    }
    return DOMAlgorithm_1.dom_getSupportedTokens(tokenList._attribute._localName).has(token.toLowerCase());
  }
  DOMTokenListAlgorithm.tokenList_validationSteps = tokenList_validationSteps;
  function tokenList_updateSteps(tokenList) {
    if (!tokenList._element.hasAttribute(tokenList._attribute._localName) && tokenList._tokenSet.size === 0) {
      return;
    }
    ElementAlgorithm_1.element_setAnAttributeValue(tokenList._element, tokenList._attribute._localName, OrderedSetAlgorithm_1.orderedSet_serialize(tokenList._tokenSet));
  }
  DOMTokenListAlgorithm.tokenList_updateSteps = tokenList_updateSteps;
  function tokenList_serializeSteps(tokenList) {
    return ElementAlgorithm_1.element_getAnAttributeValue(tokenList._element, tokenList._attribute._localName);
  }
  DOMTokenListAlgorithm.tokenList_serializeSteps = tokenList_serializeSteps;
  return DOMTokenListAlgorithm;
}
var EventTargetAlgorithm = {};
var hasRequiredEventTargetAlgorithm;
function requireEventTargetAlgorithm() {
  if (hasRequiredEventTargetAlgorithm) return EventTargetAlgorithm;
  hasRequiredEventTargetAlgorithm = 1;
  Object.defineProperty(EventTargetAlgorithm, "__esModule", { value: true });
  const util_1 = requireLib$9();
  function eventTarget_flatten(options) {
    if (util_1.isBoolean(options)) {
      return options;
    } else {
      return options.capture || false;
    }
  }
  EventTargetAlgorithm.eventTarget_flatten = eventTarget_flatten;
  function eventTarget_flattenMore(options) {
    const capture = eventTarget_flatten(options);
    let once = false;
    let passive = false;
    if (!util_1.isBoolean(options)) {
      once = options.once || false;
      passive = options.passive || false;
    }
    return [capture, passive, once];
  }
  EventTargetAlgorithm.eventTarget_flattenMore = eventTarget_flattenMore;
  function eventTarget_addEventListener(eventTarget, listener) {
    if (listener.callback === null)
      return;
    for (let i = 0; i < eventTarget._eventListenerList.length; i++) {
      const entry = eventTarget._eventListenerList[i];
      if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent && entry.capture === listener.capture) {
        return;
      }
    }
    eventTarget._eventListenerList.push(listener);
  }
  EventTargetAlgorithm.eventTarget_addEventListener = eventTarget_addEventListener;
  function eventTarget_removeEventListener(eventTarget, listener, index) {
    listener.removed = true;
    eventTarget._eventListenerList.splice(index, 1);
  }
  EventTargetAlgorithm.eventTarget_removeEventListener = eventTarget_removeEventListener;
  function eventTarget_removeAllEventListeners(eventTarget) {
    for (const e of eventTarget._eventListenerList) {
      e.removed = true;
    }
    eventTarget._eventListenerList.length = 0;
  }
  EventTargetAlgorithm.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners;
  return EventTargetAlgorithm;
}
var NodeAlgorithm = {};
var hasRequiredNodeAlgorithm;
function requireNodeAlgorithm() {
  if (hasRequiredNodeAlgorithm) return NodeAlgorithm;
  hasRequiredNodeAlgorithm = 1;
  Object.defineProperty(NodeAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const util_1 = requireUtil$1();
  const infra_1 = requireLib$8();
  const CreateAlgorithm_1 = requireCreateAlgorithm();
  const OrderedSetAlgorithm_1 = requireOrderedSetAlgorithm();
  const DOMAlgorithm_1 = requireDOMAlgorithm();
  const MutationAlgorithm_1 = requireMutationAlgorithm();
  const ElementAlgorithm_1 = requireElementAlgorithm();
  function node_stringReplaceAll(str, parent) {
    let node2 = null;
    if (str !== "") {
      node2 = CreateAlgorithm_1.create_text(parent._nodeDocument, str);
    }
    MutationAlgorithm_1.mutation_replaceAll(node2, parent);
  }
  NodeAlgorithm.node_stringReplaceAll = node_stringReplaceAll;
  function node_clone(node2, document2 = null, cloneChildrenFlag = false) {
    if (document2 === null)
      document2 = node2._nodeDocument;
    let copy2;
    if (util_1.Guard.isElementNode(node2)) {
      copy2 = ElementAlgorithm_1.element_createAnElement(document2, node2._localName, node2._namespace, node2._namespacePrefix, node2._is, false);
      for (const attribute2 of node2._attributeList) {
        const copyAttribute = node_clone(attribute2, document2);
        ElementAlgorithm_1.element_append(copyAttribute, copy2);
      }
    } else {
      if (util_1.Guard.isDocumentNode(node2)) {
        const doc = CreateAlgorithm_1.create_document();
        doc._encoding = node2._encoding;
        doc._contentType = node2._contentType;
        doc._URL = node2._URL;
        doc._origin = node2._origin;
        doc._type = node2._type;
        doc._mode = node2._mode;
        copy2 = doc;
      } else if (util_1.Guard.isDocumentTypeNode(node2)) {
        const doctype = CreateAlgorithm_1.create_documentType(document2, node2._name, node2._publicId, node2._systemId);
        copy2 = doctype;
      } else if (util_1.Guard.isAttrNode(node2)) {
        const attr = CreateAlgorithm_1.create_attr(document2, node2.localName);
        attr._namespace = node2._namespace;
        attr._namespacePrefix = node2._namespacePrefix;
        attr._value = node2._value;
        copy2 = attr;
      } else if (util_1.Guard.isExclusiveTextNode(node2)) {
        copy2 = CreateAlgorithm_1.create_text(document2, node2._data);
      } else if (util_1.Guard.isCDATASectionNode(node2)) {
        copy2 = CreateAlgorithm_1.create_cdataSection(document2, node2._data);
      } else if (util_1.Guard.isCommentNode(node2)) {
        copy2 = CreateAlgorithm_1.create_comment(document2, node2._data);
      } else if (util_1.Guard.isProcessingInstructionNode(node2)) {
        copy2 = CreateAlgorithm_1.create_processingInstruction(document2, node2._target, node2._data);
      } else if (util_1.Guard.isDocumentFragmentNode(node2)) {
        copy2 = CreateAlgorithm_1.create_documentFragment(document2);
      } else {
        copy2 = Object.create(node2);
      }
    }
    if (util_1.Guard.isDocumentNode(copy2)) {
      copy2._nodeDocument = copy2;
      document2 = copy2;
    } else {
      copy2._nodeDocument = document2;
    }
    if (dom_1.dom.features.steps) {
      DOMAlgorithm_1.dom_runCloningSteps(copy2, node2, document2, cloneChildrenFlag);
    }
    if (cloneChildrenFlag) {
      for (const child of node2._children) {
        const childCopy = node_clone(child, document2, true);
        MutationAlgorithm_1.mutation_append(childCopy, copy2);
      }
    }
    return copy2;
  }
  NodeAlgorithm.node_clone = node_clone;
  function node_equals(a, b) {
    if (a._nodeType !== b._nodeType)
      return false;
    if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {
      if (a._name !== b._name || a._publicId !== b._publicId || a._systemId !== b._systemId)
        return false;
    } else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
      if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix || a._localName !== b._localName || a._attributeList.length !== b._attributeList.length)
        return false;
    } else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {
      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value)
        return false;
    } else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {
      if (a._target !== b._target || a._data !== b._data)
        return false;
    } else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {
      if (a._data !== b._data)
        return false;
    }
    if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
      const attrMap = {};
      for (const attrA of a._attributeList) {
        attrMap[attrA._localName] = attrA;
      }
      for (const attrB of b._attributeList) {
        const attrA = attrMap[attrB._localName];
        if (!attrA)
          return false;
        if (!node_equals(attrA, attrB))
          return false;
      }
    }
    if (a._children.size !== b._children.size)
      return false;
    const itA = a._children[Symbol.iterator]();
    const itB = b._children[Symbol.iterator]();
    let resultA = itA.next();
    let resultB = itB.next();
    while (!resultA.done && !resultB.done) {
      const child1 = resultA.value;
      const child2 = resultB.value;
      if (!node_equals(child1, child2))
        return false;
      resultA = itA.next();
      resultB = itB.next();
    }
    return true;
  }
  NodeAlgorithm.node_equals = node_equals;
  function node_listOfElementsWithQualifiedName(qualifiedName, root) {
    if (qualifiedName === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root);
    } else if (root._nodeDocument._type === "html") {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        if (ele._namespace === infra_1.namespace.HTML && ele._qualifiedName === qualifiedName.toLowerCase()) {
          return true;
        } else if (ele._namespace !== infra_1.namespace.HTML && ele._qualifiedName === qualifiedName) {
          return true;
        } else {
          return false;
        }
      });
    } else {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._qualifiedName === qualifiedName;
      });
    }
  }
  NodeAlgorithm.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;
  function node_listOfElementsWithNamespace(namespace, localName, root) {
    if (namespace === "")
      namespace = null;
    if (namespace === "*" && localName === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root);
    } else if (namespace === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._localName === localName;
      });
    } else if (localName === "*") {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._namespace === namespace;
      });
    } else {
      return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        return ele._localName === localName && ele._namespace === namespace;
      });
    }
  }
  NodeAlgorithm.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;
  function node_listOfElementsWithClassNames(classNames, root) {
    const classes = OrderedSetAlgorithm_1.orderedSet_parse(classNames);
    if (classes.size === 0) {
      return CreateAlgorithm_1.create_htmlCollection(root, () => false);
    }
    const caseSensitive = root._nodeDocument._mode !== "quirks";
    return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
      const eleClasses = ele.classList;
      return OrderedSetAlgorithm_1.orderedSet_contains(eleClasses._tokenSet, classes, caseSensitive);
    });
  }
  NodeAlgorithm.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;
  function node_locateANamespacePrefix(element2, namespace) {
    if (element2._namespace === namespace && element2._namespacePrefix !== null) {
      return element2._namespacePrefix;
    }
    for (let i = 0; i < element2._attributeList.length; i++) {
      const attr = element2._attributeList[i];
      if (attr._namespacePrefix === "xmlns" && attr._value === namespace) {
        return attr._localName;
      }
    }
    if (element2._parent && util_1.Guard.isElementNode(element2._parent)) {
      return node_locateANamespacePrefix(element2._parent, namespace);
    }
    return null;
  }
  NodeAlgorithm.node_locateANamespacePrefix = node_locateANamespacePrefix;
  function node_locateANamespace(node2, prefix) {
    if (util_1.Guard.isElementNode(node2)) {
      if (node2._namespace !== null && node2._namespacePrefix === prefix) {
        return node2._namespace;
      }
      for (let i = 0; i < node2._attributeList.length; i++) {
        const attr = node2._attributeList[i];
        if (attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === "xmlns" && attr._localName === prefix) {
          return attr._value || null;
        }
        if (prefix === null && attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === null && attr._localName === "xmlns") {
          return attr._value || null;
        }
      }
      if (node2.parentElement === null)
        return null;
      return node_locateANamespace(node2.parentElement, prefix);
    } else if (util_1.Guard.isDocumentNode(node2)) {
      if (node2.documentElement === null)
        return null;
      return node_locateANamespace(node2.documentElement, prefix);
    } else if (util_1.Guard.isDocumentTypeNode(node2) || util_1.Guard.isDocumentFragmentNode(node2)) {
      return null;
    } else if (util_1.Guard.isAttrNode(node2)) {
      if (node2._element === null)
        return null;
      return node_locateANamespace(node2._element, prefix);
    } else {
      if (!node2._parent || !util_1.Guard.isElementNode(node2._parent))
        return null;
      return node_locateANamespace(node2._parent, prefix);
    }
  }
  NodeAlgorithm.node_locateANamespace = node_locateANamespace;
  return NodeAlgorithm;
}
var ParentNodeAlgorithm = {};
var hasRequiredParentNodeAlgorithm;
function requireParentNodeAlgorithm() {
  if (hasRequiredParentNodeAlgorithm) return ParentNodeAlgorithm;
  hasRequiredParentNodeAlgorithm = 1;
  Object.defineProperty(ParentNodeAlgorithm, "__esModule", { value: true });
  const util_1 = requireLib$9();
  const CreateAlgorithm_1 = requireCreateAlgorithm();
  function parentNode_convertNodesIntoANode(nodes2, document2) {
    let node2 = null;
    for (let i = 0; i < nodes2.length; i++) {
      const item = nodes2[i];
      if (util_1.isString(item)) {
        const text = CreateAlgorithm_1.create_text(document2, item);
        nodes2[i] = text;
      }
    }
    if (nodes2.length === 1) {
      node2 = nodes2[0];
    } else {
      node2 = CreateAlgorithm_1.create_documentFragment(document2);
      const ns = node2;
      for (const item of nodes2) {
        ns.appendChild(item);
      }
    }
    return node2;
  }
  ParentNodeAlgorithm.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode;
  return ParentNodeAlgorithm;
}
var RangeAlgorithm = {};
var TextAlgorithm = {};
var hasRequiredTextAlgorithm;
function requireTextAlgorithm() {
  if (hasRequiredTextAlgorithm) return TextAlgorithm;
  hasRequiredTextAlgorithm = 1;
  Object.defineProperty(TextAlgorithm, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  const util_1 = requireUtil$1();
  const DOMException_1 = requireDOMException();
  const CreateAlgorithm_1 = requireCreateAlgorithm();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const CharacterDataAlgorithm_1 = requireCharacterDataAlgorithm();
  const MutationAlgorithm_1 = requireMutationAlgorithm();
  function text_contiguousTextNodes(node2, self2 = false) {
    return {
      [Symbol.iterator]() {
        let currentNode = node2;
        while (currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)) {
          currentNode = currentNode._previousSibling;
        }
        return {
          next() {
            if (currentNode && (!self2 && currentNode === node2)) {
              if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
              return result;
            }
          }
        };
      }
    };
  }
  TextAlgorithm.text_contiguousTextNodes = text_contiguousTextNodes;
  function text_contiguousExclusiveTextNodes(node2, self2 = false) {
    return {
      [Symbol.iterator]() {
        let currentNode = node2;
        while (currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)) {
          currentNode = currentNode._previousSibling;
        }
        return {
          next() {
            if (currentNode && (!self2 && currentNode === node2)) {
              if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                currentNode = currentNode._nextSibling;
              } else {
                currentNode = null;
              }
              return result;
            }
          }
        };
      }
    };
  }
  TextAlgorithm.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;
  function text_descendantTextContent(node2) {
    let contents = "";
    let text = TreeAlgorithm_1.tree_getFirstDescendantNode(node2, false, false, (e) => util_1.Guard.isTextNode(e));
    while (text !== null) {
      contents += text._data;
      text = TreeAlgorithm_1.tree_getNextDescendantNode(node2, text, false, false, (e) => util_1.Guard.isTextNode(e));
    }
    return contents;
  }
  TextAlgorithm.text_descendantTextContent = text_descendantTextContent;
  function text_split(node2, offset) {
    const length = node2._data.length;
    if (offset > length) {
      throw new DOMException_1.IndexSizeError();
    }
    const count = length - offset;
    const newData = CharacterDataAlgorithm_1.characterData_substringData(node2, offset, count);
    const newNode = CreateAlgorithm_1.create_text(node2._nodeDocument, newData);
    const parent = node2._parent;
    if (parent !== null) {
      MutationAlgorithm_1.mutation_insert(newNode, parent, node2._nextSibling);
      for (const range2 of dom_1.dom.rangeList) {
        if (range2._start[0] === node2 && range2._start[1] > offset) {
          range2._start[0] = newNode;
          range2._start[1] -= offset;
        }
        if (range2._end[0] === node2 && range2._end[1] > offset) {
          range2._end[0] = newNode;
          range2._end[1] -= offset;
        }
        const index = TreeAlgorithm_1.tree_index(node2);
        if (range2._start[0] === parent && range2._start[1] === index + 1) {
          range2._start[1]++;
        }
        if (range2._end[0] === parent && range2._end[1] === index + 1) {
          range2._end[1]++;
        }
      }
    }
    CharacterDataAlgorithm_1.characterData_replaceData(node2, offset, count, "");
    return newNode;
  }
  TextAlgorithm.text_split = text_split;
  return TextAlgorithm;
}
var hasRequiredRangeAlgorithm;
function requireRangeAlgorithm() {
  if (hasRequiredRangeAlgorithm) return RangeAlgorithm;
  hasRequiredRangeAlgorithm = 1;
  Object.defineProperty(RangeAlgorithm, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const DOMException_1 = requireDOMException();
  const util_1 = requireUtil$1();
  const CreateAlgorithm_1 = requireCreateAlgorithm();
  const TreeAlgorithm_1 = requireTreeAlgorithm();
  const BoundaryPointAlgorithm_1 = requireBoundaryPointAlgorithm();
  const CharacterDataAlgorithm_1 = requireCharacterDataAlgorithm();
  const NodeAlgorithm_1 = requireNodeAlgorithm();
  const MutationAlgorithm_1 = requireMutationAlgorithm();
  const TextAlgorithm_1 = requireTextAlgorithm();
  function range_collapsed(range2) {
    return range2._startNode === range2._endNode && range2._startOffset === range2._endOffset;
  }
  RangeAlgorithm.range_collapsed = range_collapsed;
  function range_root(range2) {
    return TreeAlgorithm_1.tree_rootNode(range2._startNode);
  }
  RangeAlgorithm.range_root = range_root;
  function range_isContained(node2, range2) {
    return TreeAlgorithm_1.tree_rootNode(node2) === range_root(range2) && BoundaryPointAlgorithm_1.boundaryPoint_position([node2, 0], range2._start) === interfaces_1.BoundaryPosition.After && BoundaryPointAlgorithm_1.boundaryPoint_position([node2, TreeAlgorithm_1.tree_nodeLength(node2)], range2._end) === interfaces_1.BoundaryPosition.Before;
  }
  RangeAlgorithm.range_isContained = range_isContained;
  function range_isPartiallyContained(node2, range2) {
    const startCheck = TreeAlgorithm_1.tree_isAncestorOf(range2._startNode, node2, true);
    const endCheck = TreeAlgorithm_1.tree_isAncestorOf(range2._endNode, node2, true);
    return startCheck && !endCheck || !startCheck && endCheck;
  }
  RangeAlgorithm.range_isPartiallyContained = range_isPartiallyContained;
  function range_setTheStart(range2, node2, offset) {
    if (util_1.Guard.isDocumentTypeNode(node2)) {
      throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node2)) {
      throw new DOMException_1.IndexSizeError();
    }
    const bp = [node2, offset];
    if (range_root(range2) !== TreeAlgorithm_1.tree_rootNode(node2) || BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range2._end) === interfaces_1.BoundaryPosition.After) {
      range2._end = bp;
    }
    range2._start = bp;
  }
  RangeAlgorithm.range_setTheStart = range_setTheStart;
  function range_setTheEnd(range2, node2, offset) {
    if (util_1.Guard.isDocumentTypeNode(node2)) {
      throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node2)) {
      throw new DOMException_1.IndexSizeError();
    }
    const bp = [node2, offset];
    if (range_root(range2) !== TreeAlgorithm_1.tree_rootNode(node2) || BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range2._start) === interfaces_1.BoundaryPosition.Before) {
      range2._start = bp;
    }
    range2._end = bp;
  }
  RangeAlgorithm.range_setTheEnd = range_setTheEnd;
  function range_select(node2, range2) {
    const parent = node2._parent;
    if (parent === null)
      throw new DOMException_1.InvalidNodeTypeError();
    const index = TreeAlgorithm_1.tree_index(node2);
    range2._start = [parent, index];
    range2._end = [parent, index + 1];
  }
  RangeAlgorithm.range_select = range_select;
  function range_extract(range2) {
    const fragment = CreateAlgorithm_1.create_documentFragment(range2._startNode._nodeDocument);
    if (range_collapsed(range2))
      return fragment;
    const originalStartNode = range2._startNode;
    const originalStartOffset = range2._startOffset;
    const originalEndNode = range2._endNode;
    const originalEndOffset = range2._endOffset;
    if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
      const clone2 = NodeAlgorithm_1.node_clone(originalStartNode);
      clone2._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
      CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
      return fragment;
    }
    let commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
      if (commonAncestor._parent === null) {
        throw new Error("Parent node  is null.");
      }
      commonAncestor = commonAncestor._parent;
    }
    let firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
      for (const node2 of commonAncestor._children) {
        if (range_isPartiallyContained(node2, range2)) {
          firstPartiallyContainedChild = node2;
          break;
        }
      }
    }
    let lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
      const children = [...commonAncestor._children];
      for (let i = children.length - 1; i > 0; i--) {
        const node2 = children[i];
        if (range_isPartiallyContained(node2, range2)) {
          lastPartiallyContainedChild = node2;
          break;
        }
      }
    }
    const containedChildren = [];
    for (const child of commonAncestor._children) {
      if (range_isContained(child, range2)) {
        if (util_1.Guard.isDocumentTypeNode(child)) {
          throw new DOMException_1.HierarchyRequestError();
        }
        containedChildren.push(child);
      }
    }
    let newNode;
    let newOffset;
    if (TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
      newNode = originalStartNode;
      newOffset = originalStartOffset;
    } else {
      let referenceNode = originalStartNode;
      while (referenceNode._parent !== null && !TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent)) {
        referenceNode = referenceNode._parent;
      }
      if (referenceNode._parent === null) {
        throw new Error("Parent node is null.");
      }
      newNode = referenceNode._parent;
      newOffset = 1 + TreeAlgorithm_1.tree_index(referenceNode);
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
      const clone2 = NodeAlgorithm_1.node_clone(originalStartNode);
      clone2._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
      CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, "");
    } else if (firstPartiallyContainedChild !== null) {
      const clone2 = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
      const subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
      const subfragment = range_extract(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone2);
    }
    for (const child of containedChildren) {
      MutationAlgorithm_1.mutation_append(child, fragment);
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
      const clone2 = NodeAlgorithm_1.node_clone(originalEndNode);
      clone2._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
      CharacterDataAlgorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, "");
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
      const subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
      const subfragment = range_extract(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone2);
    }
    range2._start = [newNode, newOffset];
    range2._end = [newNode, newOffset];
    return fragment;
  }
  RangeAlgorithm.range_extract = range_extract;
  function range_cloneTheContents(range2) {
    const fragment = CreateAlgorithm_1.create_documentFragment(range2._startNode._nodeDocument);
    if (range_collapsed(range2))
      return fragment;
    const originalStartNode = range2._startNode;
    const originalStartOffset = range2._startOffset;
    const originalEndNode = range2._endNode;
    const originalEndOffset = range2._endOffset;
    if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
      const clone2 = NodeAlgorithm_1.node_clone(originalStartNode);
      clone2._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
    }
    let commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
      if (commonAncestor._parent === null) {
        throw new Error("Parent node  is null.");
      }
      commonAncestor = commonAncestor._parent;
    }
    let firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
      for (const node2 of commonAncestor._children) {
        if (range_isPartiallyContained(node2, range2)) {
          firstPartiallyContainedChild = node2;
          break;
        }
      }
    }
    let lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
      const children = [...commonAncestor._children];
      for (let i = children.length - 1; i > 0; i--) {
        const node2 = children[i];
        if (range_isPartiallyContained(node2, range2)) {
          lastPartiallyContainedChild = node2;
          break;
        }
      }
    }
    const containedChildren = [];
    for (const child of commonAncestor._children) {
      if (range_isContained(child, range2)) {
        if (util_1.Guard.isDocumentTypeNode(child)) {
          throw new DOMException_1.HierarchyRequestError();
        }
        containedChildren.push(child);
      }
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
      const clone2 = NodeAlgorithm_1.node_clone(originalStartNode);
      clone2._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
    } else if (firstPartiallyContainedChild !== null) {
      const clone2 = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
      const subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
      const subfragment = range_cloneTheContents(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone2);
    }
    for (const child of containedChildren) {
      const clone2 = NodeAlgorithm_1.node_clone(child);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
      const clone2 = NodeAlgorithm_1.node_clone(originalEndNode);
      clone2._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
      MutationAlgorithm_1.mutation_append(clone2, fragment);
    } else if (lastPartiallyContainedChild !== null) {
      const clone2 = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
      fragment.append(clone2);
      const subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
      const subfragment = range_extract(subrange);
      MutationAlgorithm_1.mutation_append(subfragment, clone2);
    }
    return fragment;
  }
  RangeAlgorithm.range_cloneTheContents = range_cloneTheContents;
  function range_insert(node2, range2) {
    if (util_1.Guard.isProcessingInstructionNode(range2._startNode) || util_1.Guard.isCommentNode(range2._startNode) || util_1.Guard.isTextNode(range2._startNode) && range2._startNode._parent === null || range2._startNode === node2) {
      throw new DOMException_1.HierarchyRequestError();
    }
    let referenceNode = null;
    if (util_1.Guard.isTextNode(range2._startNode)) {
      referenceNode = range2._startNode;
    } else {
      let index = 0;
      for (const child of range2._startNode._children) {
        if (index === range2._startOffset) {
          referenceNode = child;
          break;
        }
        index++;
      }
    }
    let parent;
    if (referenceNode === null) {
      parent = range2._startNode;
    } else {
      if (referenceNode._parent === null) {
        throw new Error("Parent node is null.");
      }
      parent = referenceNode._parent;
    }
    MutationAlgorithm_1.mutation_ensurePreInsertionValidity(node2, parent, referenceNode);
    if (util_1.Guard.isTextNode(range2._startNode)) {
      referenceNode = TextAlgorithm_1.text_split(range2._startNode, range2._startOffset);
    }
    if (node2 === referenceNode) {
      referenceNode = node2._nextSibling;
    }
    if (node2._parent !== null) {
      MutationAlgorithm_1.mutation_remove(node2, node2._parent);
    }
    let newOffset = referenceNode === null ? TreeAlgorithm_1.tree_nodeLength(parent) : TreeAlgorithm_1.tree_index(referenceNode);
    if (util_1.Guard.isDocumentFragmentNode(node2)) {
      newOffset += TreeAlgorithm_1.tree_nodeLength(node2);
    } else {
      newOffset++;
    }
    MutationAlgorithm_1.mutation_preInsert(node2, parent, referenceNode);
    if (range_collapsed(range2)) {
      range2._end = [parent, newOffset];
    }
  }
  RangeAlgorithm.range_insert = range_insert;
  function range_getContainedNodes(range2) {
    return {
      [Symbol.iterator]: () => {
        const container = range2.commonAncestorContainer;
        let currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
        return {
          next: () => {
            while (currentNode && !range_isContained(currentNode, range2)) {
              currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
              return result;
            }
          }
        };
      }
    };
  }
  RangeAlgorithm.range_getContainedNodes = range_getContainedNodes;
  function range_getPartiallyContainedNodes(range2) {
    return {
      [Symbol.iterator]: () => {
        const container = range2.commonAncestorContainer;
        let currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
        return {
          next: () => {
            while (currentNode && !range_isPartiallyContained(currentNode, range2)) {
              currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
            }
            if (currentNode === null) {
              return { done: true, value: null };
            } else {
              const result = { done: false, value: currentNode };
              currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
              return result;
            }
          }
        };
      }
    };
  }
  RangeAlgorithm.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes;
  return RangeAlgorithm;
}
var SelectorsAlgorithm = {};
var hasRequiredSelectorsAlgorithm;
function requireSelectorsAlgorithm() {
  if (hasRequiredSelectorsAlgorithm) return SelectorsAlgorithm;
  hasRequiredSelectorsAlgorithm = 1;
  Object.defineProperty(SelectorsAlgorithm, "__esModule", { value: true });
  const DOMException_1 = requireDOMException();
  function selectors_scopeMatchASelectorsString(selectors, node2) {
    throw new DOMException_1.NotSupportedError();
  }
  SelectorsAlgorithm.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString;
  return SelectorsAlgorithm;
}
var TreeWalkerAlgorithm = {};
var hasRequiredTreeWalkerAlgorithm;
function requireTreeWalkerAlgorithm() {
  if (hasRequiredTreeWalkerAlgorithm) return TreeWalkerAlgorithm;
  hasRequiredTreeWalkerAlgorithm = 1;
  Object.defineProperty(TreeWalkerAlgorithm, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const TraversalAlgorithm_1 = requireTraversalAlgorithm();
  function treeWalker_traverseChildren(walker, first) {
    let node2 = first ? walker._current._firstChild : walker._current._lastChild;
    while (node2 !== null) {
      const result = TraversalAlgorithm_1.traversal_filter(walker, node2);
      if (result === interfaces_1.FilterResult.Accept) {
        walker._current = node2;
        return node2;
      } else if (result === interfaces_1.FilterResult.Skip) {
        const child = first ? node2._firstChild : node2._lastChild;
        if (child !== null) {
          node2 = child;
          continue;
        }
      }
      while (node2 !== null) {
        const sibling = first ? node2._nextSibling : node2._previousSibling;
        if (sibling !== null) {
          node2 = sibling;
          break;
        }
        const parent = node2._parent;
        if (parent === null || parent === walker._root || parent === walker._current) {
          return null;
        }
        node2 = parent;
      }
    }
    return null;
  }
  TreeWalkerAlgorithm.treeWalker_traverseChildren = treeWalker_traverseChildren;
  function treeWalker_traverseSiblings(walker, next) {
    let node2 = walker._current;
    if (node2 === walker._root)
      return null;
    while (true) {
      let sibling = next ? node2._nextSibling : node2._previousSibling;
      while (sibling !== null) {
        node2 = sibling;
        const result = TraversalAlgorithm_1.traversal_filter(walker, node2);
        if (result === interfaces_1.FilterResult.Accept) {
          walker._current = node2;
          return node2;
        }
        sibling = next ? node2._firstChild : node2._lastChild;
        if (result === interfaces_1.FilterResult.Reject || sibling === null) {
          sibling = next ? node2._nextSibling : node2._previousSibling;
        }
      }
      node2 = node2._parent;
      if (node2 === null || node2 === walker._root) {
        return null;
      }
      if (TraversalAlgorithm_1.traversal_filter(walker, node2) === interfaces_1.FilterResult.Accept) {
        return null;
      }
    }
  }
  TreeWalkerAlgorithm.treeWalker_traverseSiblings = treeWalker_traverseSiblings;
  return TreeWalkerAlgorithm;
}
var hasRequiredAlgorithm;
function requireAlgorithm() {
  if (hasRequiredAlgorithm) return algorithm;
  hasRequiredAlgorithm = 1;
  (function(exports$1) {
    function __export(m) {
      for (var p in m) if (!exports$1.hasOwnProperty(p)) exports$1[p] = m[p];
    }
    Object.defineProperty(exports$1, "__esModule", { value: true });
    __export(requireAbortAlgorithm());
    __export(requireAttrAlgorithm());
    __export(requireBoundaryPointAlgorithm());
    __export(requireCharacterDataAlgorithm());
    __export(requireCreateAlgorithm());
    __export(requireCustomElementAlgorithm());
    __export(requireDocumentAlgorithm());
    __export(requireDOMAlgorithm());
    __export(requireDOMTokenListAlgorithm());
    __export(requireElementAlgorithm());
    __export(requireEventAlgorithm());
    __export(requireEventTargetAlgorithm());
    __export(requireMutationAlgorithm());
    __export(requireMutationObserverAlgorithm());
    __export(requireNamespaceAlgorithm());
    __export(requireNodeAlgorithm());
    __export(requireNodeIteratorAlgorithm());
    __export(requireOrderedSetAlgorithm());
    __export(requireParentNodeAlgorithm());
    __export(requireRangeAlgorithm());
    __export(requireSelectorsAlgorithm());
    __export(requireShadowTreeAlgorithm());
    __export(requireTextAlgorithm());
    __export(requireTraversalAlgorithm());
    __export(requireTreeAlgorithm());
    __export(requireTreeWalkerAlgorithm());
    __export(requireWebIDLAlgorithm());
    __export(requireXMLAlgorithm());
  })(algorithm);
  return algorithm;
}
var hasRequiredBaseWriter;
function requireBaseWriter() {
  if (hasRequiredBaseWriter) return BaseWriter;
  hasRequiredBaseWriter = 1;
  Object.defineProperty(BaseWriter, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const LocalNameSet_1 = requireLocalNameSet();
  const NamespacePrefixMap_1 = requireNamespacePrefixMap();
  const DOMException_1 = requireDOMException();
  const infra_1 = requireLib$8();
  const algorithm_1 = requireAlgorithm();
  let BaseWriter$1 = class BaseWriter2 {
    /**
     * Initializes a new instance of `BaseWriter`.
     *
     * @param builderOptions - XML builder options
     */
    constructor(builderOptions) {
      this.level = 0;
      this._builderOptions = builderOptions;
    }
    /**
     * Used by derived classes to serialize a DocType node.
     *
     * @param name - node name
     * @param publicId - public identifier
     * @param systemId - system identifier
     */
    docType(name, publicId, systemId) {
    }
    /**
     * Used by derived classes to serialize a comment node.
     *
     * @param data - node data
     */
    comment(data) {
    }
    /**
     * Used by derived classes to serialize a text node.
     *
     * @param data - node data
     */
    text(data) {
    }
    /**
     * Used by derived classes to serialize a processing instruction node.
     *
     * @param target - instruction target
     * @param data - node data
     */
    instruction(target2, data) {
    }
    /**
     * Used by derived classes to serialize a CData section node.
     *
     * @param data - node data
     */
    cdata(data) {
    }
    /**
     * Used by derived classes to serialize the beginning of the opening tag of an
     * element node.
     *
     * @param name - node name
     */
    openTagBegin(name) {
    }
    /**
     * Used by derived classes to serialize the ending of the opening tag of an
     * element node.
     *
     * @param name - node name
     * @param selfClosing - whether the element node is self closing
     * @param voidElement - whether the element node is a HTML void element
     */
    openTagEnd(name, selfClosing, voidElement) {
    }
    /**
     * Used by derived classes to serialize the closing tag of an element node.
     *
     * @param name - node name
     */
    closeTag(name) {
    }
    /**
     * Used by derived classes to serialize attributes or namespace declarations.
     *
     * @param attributes - attribute array
     */
    attributes(attributes) {
      for (const attr of attributes) {
        this.attribute(attr[1] === null ? attr[2] : attr[1] + ":" + attr[2], attr[3]);
      }
    }
    /**
     * Used by derived classes to serialize an attribute or namespace declaration.
     *
     * @param name - node name
     * @param value - node value
     */
    attribute(name, value) {
    }
    /**
     * Used by derived classes to perform any pre-processing steps before starting
     * serializing an element node.
     *
     * @param name - node name
     */
    beginElement(name) {
    }
    /**
     * Used by derived classes to perform any post-processing steps after
     * completing serializing an element node.
     *
     * @param name - node name
     */
    endElement(name) {
    }
    /**
     * Produces an XML serialization of the given node. The pre-serializer inserts
     * namespace declarations where necessary and produces qualified names for
     * nodes and attributes.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    serializeNode(node2, requireWellFormed, noDoubleEncoding) {
      const hasNamespaces = node2._nodeDocument !== void 0 && node2._nodeDocument._hasNamespaces;
      this.level = 0;
      this.currentNode = node2;
      if (hasNamespaces) {
        let namespace = null;
        const prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
        prefixMap.set("xml", infra_1.namespace.XML);
        const prefixIndex = { value: 1 };
        try {
          this._serializeNodeNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
        } catch (e) {
          throw new DOMException_1.InvalidStateError(e.message);
        }
      } else {
        try {
          this._serializeNode(node2, requireWellFormed, noDoubleEncoding);
        } catch (e) {
          throw new DOMException_1.InvalidStateError(e.message);
        }
      }
    }
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeNodeNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      this.currentNode = node2;
      switch (node2.nodeType) {
        case interfaces_1.NodeType.Element:
          this._serializeElementNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Document:
          this._serializeDocumentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Comment:
          this._serializeComment(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Text:
          this._serializeText(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentFragment:
          this._serializeDocumentFragmentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentType:
          this._serializeDocumentType(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.ProcessingInstruction:
          this._serializeProcessingInstruction(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.CData:
          this._serializeCData(node2, requireWellFormed, noDoubleEncoding);
          break;
        default:
          throw new Error(`Unknown node type: ${node2.nodeType}`);
      }
    }
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeNode(node2, requireWellFormed, noDoubleEncoding) {
      this.currentNode = node2;
      switch (node2.nodeType) {
        case interfaces_1.NodeType.Element:
          this._serializeElement(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Document:
          this._serializeDocument(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Comment:
          this._serializeComment(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.Text:
          this._serializeText(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentFragment:
          this._serializeDocumentFragment(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.DocumentType:
          this._serializeDocumentType(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.ProcessingInstruction:
          this._serializeProcessingInstruction(node2, requireWellFormed, noDoubleEncoding);
          break;
        case interfaces_1.NodeType.CData:
          this._serializeCData(node2, requireWellFormed, noDoubleEncoding);
          break;
        default:
          throw new Error(`Unknown node type: ${node2.nodeType}`);
      }
    }
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeElementNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      const attributes = [];
      if (requireWellFormed && (node2.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node2.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let qualifiedName = "";
      let skipEndTag = false;
      let ignoreNamespaceDefinitionAttribute = false;
      let map2 = prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node2, map2, localPrefixesMap);
      let inheritedNS = namespace;
      let ns = node2.namespaceURI;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node2.localName;
        } else {
          qualifiedName = node2.localName;
        }
        this.beginElement(qualifiedName);
        this.openTagBegin(qualifiedName);
      } else {
        let prefix = node2.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map2.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (requireWellFormed) {
            throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node2.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map2, prefixIndex);
          }
          map2.set(prefix, ns);
          qualifiedName += prefix + ":" + node2.localName;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
          attributes.push([
            null,
            "xmlns",
            prefix,
            this._serializeAttributeValue(ns, requireWellFormed, noDoubleEncoding)
          ]);
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node2.localName;
          inheritedNS = ns;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
          attributes.push([
            null,
            null,
            "xmlns",
            this._serializeAttributeValue(ns, requireWellFormed, noDoubleEncoding)
          ]);
        } else {
          qualifiedName += node2.localName;
          inheritedNS = ns;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
        }
      }
      attributes.push(...this._serializeAttributesNS(node2, map2, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, noDoubleEncoding));
      this.attributes(attributes);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && node2.childNodes.length === 0 && BaseWriter2._VoidElementNames.has(node2.localName)) {
        this.openTagEnd(qualifiedName, true, true);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else if (!isHTML && node2.childNodes.length === 0) {
        this.openTagEnd(qualifiedName, true, false);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else {
        this.openTagEnd(qualifiedName, false, false);
      }
      if (skipEndTag)
        return;
      if (isHTML && node2.localName === "template") ;
      else {
        for (const childNode of node2.childNodes) {
          this.level++;
          this._serializeNodeNS(childNode, inheritedNS, map2, prefixIndex, requireWellFormed, noDoubleEncoding);
          this.level--;
        }
      }
      this.closeTag(qualifiedName);
      this.endElement(qualifiedName);
    }
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeElement(node2, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && (node2.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node2.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let skipEndTag = false;
      const qualifiedName = node2.localName;
      this.beginElement(qualifiedName);
      this.openTagBegin(qualifiedName);
      const attributes = this._serializeAttributes(node2, requireWellFormed, noDoubleEncoding);
      this.attributes(attributes);
      if (!node2.hasChildNodes()) {
        this.openTagEnd(qualifiedName, true, false);
        this.endElement(qualifiedName);
        skipEndTag = true;
      } else {
        this.openTagEnd(qualifiedName, false, false);
      }
      if (skipEndTag)
        return;
      for (const childNode of node2._children) {
        this.level++;
        this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);
        this.level--;
      }
      this.closeTag(qualifiedName);
      this.endElement(qualifiedName);
    }
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && node2.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      for (const childNode of node2.childNodes) {
        this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
      }
    }
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocument(node2, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && node2.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      for (const childNode of node2._children) {
        this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);
      }
    }
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeComment(node2, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node2.data) || node2.data.indexOf("--") !== -1 || node2.data.endsWith("-"))) {
        throw new Error("Comment data contains invalid characters (well-formed required).");
      }
      this.comment(node2.data);
    }
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */
    _serializeText(node2, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && !algorithm_1.xml_isLegalChar(node2.data)) {
        throw new Error("Text data contains invalid characters (well-formed required).");
      }
      let markup = "";
      if (noDoubleEncoding) {
        markup = node2.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      } else {
        for (let i = 0; i < node2.data.length; i++) {
          const c = node2.data[i];
          if (c === "&")
            markup += "&amp;";
          else if (c === "<")
            markup += "&lt;";
          else if (c === ">")
            markup += "&gt;";
          else
            markup += c;
        }
      }
      this.text(markup);
    }
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentFragmentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding) {
      for (const childNode of node2.childNodes) {
        this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed, noDoubleEncoding);
      }
    }
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentFragment(node2, requireWellFormed, noDoubleEncoding) {
      for (const childNode of node2._children) {
        this._serializeNode(childNode, requireWellFormed, noDoubleEncoding);
      }
    }
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentType(node2, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && !algorithm_1.xml_isPubidChar(node2.publicId)) {
        throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node2.systemId) || node2.systemId.indexOf('"') !== -1 && node2.systemId.indexOf("'") !== -1)) {
        throw new Error("DocType system identifier contains invalid characters (well-formed required).");
      }
      this.docType(node2.name, node2.publicId, node2.systemId);
    }
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeProcessingInstruction(node2, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && (node2.target.indexOf(":") !== -1 || /^xml$/i.test(node2.target))) {
        throw new Error("Processing instruction target contains invalid characters (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node2.data) || node2.data.indexOf("?>") !== -1)) {
        throw new Error("Processing instruction data contains invalid characters (well-formed required).");
      }
      this.instruction(node2.target, node2.data);
    }
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeCData(node2, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && node2.data.indexOf("]]>") !== -1) {
        throw new Error("CDATA contains invalid characters (well-formed required).");
      }
      this.cdata(node2.data);
    }
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */
    _serializeAttributesNS(node2, map2, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, noDoubleEncoding) {
      const result = [];
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : void 0;
      for (const attr of node2.attributes) {
        if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
          result.push([
            null,
            null,
            attr.localName,
            this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
          ]);
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map2.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map2.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              throw new Error("XMLNS namespace is reserved (well-formed required).");
            }
            if (requireWellFormed && attr.value === "") {
              throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map2.hasPrefix(attr.prefix) || map2.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map2, prefixIndex);
            }
            result.push([
              null,
              "xmlns",
              candidatePrefix,
              this._serializeAttributeValue(attributeNamespace, requireWellFormed, noDoubleEncoding)
            ]);
          }
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result.push([
          attributeNamespace,
          candidatePrefix,
          attr.localName,
          this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
        ]);
      }
      return result;
    }
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
    */
    _serializeAttributes(node2, requireWellFormed, noDoubleEncoding) {
      const result = [];
      const localNameSet = requireWellFormed ? {} : void 0;
      for (const attr of node2.attributes) {
        if (!requireWellFormed) {
          result.push([
            null,
            null,
            attr.localName,
            this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
          ]);
          continue;
        }
        if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet[attr.localName] = true;
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName))) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result.push([
          null,
          null,
          attr.localName,
          this._serializeAttributeValue(attr.value, requireWellFormed, noDoubleEncoding)
        ]);
      }
      return result;
    }
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */
    _recordNamespaceInformation(node2, map2, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node2.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map2.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map2.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      const generatedPrefix = "ns" + prefixIndex.value.toString();
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    _serializeAttributeValue(value, requireWellFormed, noDoubleEncoding) {
      if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
        throw new Error("Invalid characters in attribute value.");
      }
      if (value === null)
        return "";
      if (noDoubleEncoding) {
        return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      } else {
        let result = "";
        for (let i = 0; i < value.length; i++) {
          const c = value[i];
          if (c === '"')
            result += "&quot;";
          else if (c === "&")
            result += "&amp;";
          else if (c === "<")
            result += "&lt;";
          else if (c === ">")
            result += "&gt;";
          else
            result += c;
        }
        return result;
      }
    }
  };
  BaseWriter.BaseWriter = BaseWriter$1;
  BaseWriter$1._VoidElementNames = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  return BaseWriter;
}
var hasRequiredObjectWriter;
function requireObjectWriter() {
  if (hasRequiredObjectWriter) return ObjectWriter;
  hasRequiredObjectWriter = 1;
  Object.defineProperty(ObjectWriter, "__esModule", { value: true });
  const util_1 = requireLib$a();
  const interfaces_1 = requireInterfaces$2();
  const BaseWriter_1 = requireBaseWriter();
  let ObjectWriter$1 = class ObjectWriter extends BaseWriter_1.BaseWriter {
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    serialize(node2, writerOptions) {
      const options = util_1.applyDefaults(writerOptions, {
        format: "object",
        wellFormed: false,
        noDoubleEncoding: false,
        group: false
      });
      this._currentList = [];
      this._currentIndex = 0;
      this._listRegister = [this._currentList];
      this.serializeNode(node2, options.wellFormed, options.noDoubleEncoding);
      return this._process(this._currentList, options);
    }
    _process(items, options) {
      if (items.length === 0)
        return {};
      const namesSeen = {};
      let hasNonUniqueNames = false;
      let textCount = 0;
      let commentCount = 0;
      let instructionCount = 0;
      let cdataCount = 0;
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const key = Object.keys(item)[0];
        switch (key) {
          case "@":
            continue;
          case "#":
            textCount++;
            break;
          case "!":
            commentCount++;
            break;
          case "?":
            instructionCount++;
            break;
          case "$":
            cdataCount++;
            break;
          default:
            if (namesSeen[key]) {
              hasNonUniqueNames = true;
            } else {
              namesSeen[key] = true;
            }
            break;
        }
      }
      const defAttrKey = this._getAttrKey();
      const defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);
      const defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);
      const defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);
      const defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);
      if (textCount === 1 && items.length === 1 && util_1.isString(items[0]["#"])) {
        return items[0]["#"];
      } else if (hasNonUniqueNames) {
        const result = [];
        const obj = { [defTextKey]: result };
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const key = Object.keys(item)[0];
          switch (key) {
            case "@":
              const attrs = item["@"];
              const attrKeys = Object.keys(attrs);
              if (attrKeys.length === 1) {
                result.push({ [defAttrKey + attrKeys[0]]: attrs[attrKeys[0]] });
              } else {
                result.push({ [defAttrKey]: item["@"] });
              }
              break;
            case "#":
              result.push({ [defTextKey]: item["#"] });
              break;
            case "!":
              result.push({ [defCommentKey]: item["!"] });
              break;
            case "?":
              result.push({ [defInstructionKey]: item["?"] });
              break;
            case "$":
              result.push({ [defCdataKey]: item["$"] });
              break;
            default:
              const ele = item;
              if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                const eleGroup = [];
                const listOfLists = ele[key];
                for (let i2 = 0; i2 < listOfLists.length; i2++) {
                  eleGroup.push(this._process(listOfLists[i2], options));
                }
                result.push({ [key]: eleGroup });
              } else {
                result.push({ [key]: this._process(ele[key], options) });
              }
              break;
          }
        }
        return obj;
      } else {
        let textId = 1;
        let commentId = 1;
        let instructionId = 1;
        let cdataId = 1;
        const obj = {};
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const key = Object.keys(item)[0];
          switch (key) {
            case "@":
              const attrs = item["@"];
              const attrKeys = Object.keys(attrs);
              if (!options.group || attrKeys.length === 1) {
                for (const attrName in attrs) {
                  obj[defAttrKey + attrName] = attrs[attrName];
                }
              } else {
                obj[defAttrKey] = attrs;
              }
              break;
            case "#":
              textId = this._processSpecItem(item["#"], obj, options.group, defTextKey, textCount, textId);
              break;
            case "!":
              commentId = this._processSpecItem(item["!"], obj, options.group, defCommentKey, commentCount, commentId);
              break;
            case "?":
              instructionId = this._processSpecItem(item["?"], obj, options.group, defInstructionKey, instructionCount, instructionId);
              break;
            case "$":
              cdataId = this._processSpecItem(item["$"], obj, options.group, defCdataKey, cdataCount, cdataId);
              break;
            default:
              const ele = item;
              if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                const eleGroup = [];
                const listOfLists = ele[key];
                for (let i2 = 0; i2 < listOfLists.length; i2++) {
                  eleGroup.push(this._process(listOfLists[i2], options));
                }
                obj[key] = eleGroup;
              } else {
                obj[key] = this._process(ele[key], options);
              }
              break;
          }
        }
        return obj;
      }
    }
    _processSpecItem(item, obj, group, defKey, count, id) {
      if (!group && util_1.isArray(item) && count + item.length > 2) {
        for (const subItem of item) {
          const key = defKey + (id++).toString();
          obj[key] = subItem;
        }
      } else {
        const key = count > 1 ? defKey + (id++).toString() : defKey;
        obj[key] = item;
      }
      return id;
    }
    /** @inheritdoc */
    beginElement(name) {
      const childItems = [];
      if (this._currentList.length === 0) {
        this._currentList.push({ [name]: childItems });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isElementNode(lastItem, name)) {
          if (lastItem[name].length !== 0 && util_1.isArray(lastItem[name][0])) {
            const listOfLists = lastItem[name];
            listOfLists.push(childItems);
          } else {
            lastItem[name] = [lastItem[name], childItems];
          }
        } else {
          this._currentList.push({ [name]: childItems });
        }
      }
      this._currentIndex++;
      if (this._listRegister.length > this._currentIndex) {
        this._listRegister[this._currentIndex] = childItems;
      } else {
        this._listRegister.push(childItems);
      }
      this._currentList = childItems;
    }
    /** @inheritdoc */
    endElement() {
      this._currentList = this._listRegister[--this._currentIndex];
    }
    /** @inheritdoc */
    attribute(name, value) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "@": { [name]: value } });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isAttrNode(lastItem)) {
          lastItem["@"][name] = value;
        } else {
          this._currentList.push({ "@": { [name]: value } });
        }
      }
    }
    /** @inheritdoc */
    comment(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "!": data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isCommentNode(lastItem)) {
          if (util_1.isArray(lastItem["!"])) {
            lastItem["!"].push(data);
          } else {
            lastItem["!"] = [lastItem["!"], data];
          }
        } else {
          this._currentList.push({ "!": data });
        }
      }
    }
    /** @inheritdoc */
    text(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "#": data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isTextNode(lastItem)) {
          if (util_1.isArray(lastItem["#"])) {
            lastItem["#"].push(data);
          } else {
            lastItem["#"] = [lastItem["#"], data];
          }
        } else {
          this._currentList.push({ "#": data });
        }
      }
    }
    /** @inheritdoc */
    instruction(target2, data) {
      const value = data === "" ? target2 : target2 + " " + data;
      if (this._currentList.length === 0) {
        this._currentList.push({ "?": value });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isInstructionNode(lastItem)) {
          if (util_1.isArray(lastItem["?"])) {
            lastItem["?"].push(value);
          } else {
            lastItem["?"] = [lastItem["?"], value];
          }
        } else {
          this._currentList.push({ "?": value });
        }
      }
    }
    /** @inheritdoc */
    cdata(data) {
      if (this._currentList.length === 0) {
        this._currentList.push({ "$": data });
      } else {
        const lastItem = this._currentList[this._currentList.length - 1];
        if (this._isCDATANode(lastItem)) {
          if (util_1.isArray(lastItem["$"])) {
            lastItem["$"].push(data);
          } else {
            lastItem["$"] = [lastItem["$"], data];
          }
        } else {
          this._currentList.push({ "$": data });
        }
      }
    }
    _isAttrNode(x) {
      return "@" in x;
    }
    _isTextNode(x) {
      return "#" in x;
    }
    _isCommentNode(x) {
      return "!" in x;
    }
    _isInstructionNode(x) {
      return "?" in x;
    }
    _isCDATANode(x) {
      return "$" in x;
    }
    _isElementNode(x, name) {
      return name in x;
    }
    /**
     * Returns an object key for an attribute or namespace declaration.
     */
    _getAttrKey() {
      return this._builderOptions.convert.att;
    }
    /**
     * Returns an object key for the given node type.
     *
     * @param nodeType - node type to get a key for
     */
    _getNodeKey(nodeType) {
      switch (nodeType) {
        case interfaces_1.NodeType.Comment:
          return this._builderOptions.convert.comment;
        case interfaces_1.NodeType.Text:
          return this._builderOptions.convert.text;
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._builderOptions.convert.ins;
        case interfaces_1.NodeType.CData:
          return this._builderOptions.convert.cdata;
        /* istanbul ignore next */
        default:
          throw new Error("Invalid node type.");
      }
    }
  };
  ObjectWriter.ObjectWriter = ObjectWriter$1;
  return ObjectWriter;
}
var hasRequiredMapWriter;
function requireMapWriter() {
  if (hasRequiredMapWriter) return MapWriter;
  hasRequiredMapWriter = 1;
  Object.defineProperty(MapWriter, "__esModule", { value: true });
  const util_1 = requireLib$a();
  const ObjectWriter_1 = requireObjectWriter();
  const BaseWriter_1 = requireBaseWriter();
  let MapWriter$1 = class MapWriter extends BaseWriter_1.BaseWriter {
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    serialize(node2, writerOptions) {
      const options = util_1.applyDefaults(writerOptions, {
        format: "map",
        wellFormed: false,
        noDoubleEncoding: false,
        group: false
      });
      const objectWriterOptions = util_1.applyDefaults(options, {
        format: "object",
        wellFormed: false,
        noDoubleEncoding: false
      });
      const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions);
      const val = objectWriter.serialize(node2, objectWriterOptions);
      return this._convertObject(val);
    }
    /**
     * Recursively converts a JS object into an ES5 map.
     *
     * @param obj - a JS object
     */
    _convertObject(obj) {
      if (util_1.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
          obj[i] = this._convertObject(obj[i]);
        }
        return obj;
      } else if (util_1.isObject(obj)) {
        const map2 = /* @__PURE__ */ new Map();
        for (const key in obj) {
          map2.set(key, this._convertObject(obj[key]));
        }
        return map2;
      } else {
        return obj;
      }
    }
  };
  MapWriter.MapWriter = MapWriter$1;
  return MapWriter;
}
var XMLWriter = {};
var hasRequiredXMLWriter;
function requireXMLWriter() {
  if (hasRequiredXMLWriter) return XMLWriter;
  hasRequiredXMLWriter = 1;
  Object.defineProperty(XMLWriter, "__esModule", { value: true });
  const util_1 = requireLib$a();
  const interfaces_1 = requireInterfaces$2();
  const BaseWriter_1 = requireBaseWriter();
  const util_2 = requireUtil$1();
  let XMLWriter$1 = class XMLWriter extends BaseWriter_1.BaseWriter {
    constructor() {
      super(...arguments);
      this._indentation = {};
      this._lengthToLastNewline = 0;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    serialize(node2, writerOptions) {
      this._options = util_1.applyDefaults(writerOptions, {
        wellFormed: false,
        noDoubleEncoding: false,
        headless: false,
        prettyPrint: false,
        indent: "  ",
        newline: "\n",
        offset: 0,
        width: 0,
        allowEmptyTags: false,
        indentTextOnlyNodes: false,
        spaceBeforeSlash: false
      });
      this._refs = { suppressPretty: false, emptyNode: false, markup: "" };
      if (node2.nodeType === interfaces_1.NodeType.Document && !this._options.headless) {
        this._beginLine();
        this._refs.markup = "<?xml";
        this._refs.markup += ' version="' + this._builderOptions.version + '"';
        if (this._builderOptions.encoding !== void 0) {
          this._refs.markup += ' encoding="' + this._builderOptions.encoding + '"';
        }
        if (this._builderOptions.standalone !== void 0) {
          this._refs.markup += ' standalone="' + (this._builderOptions.standalone ? "yes" : "no") + '"';
        }
        this._refs.markup += "?>";
        this._endLine();
      }
      this.serializeNode(node2, this._options.wellFormed, this._options.noDoubleEncoding);
      if (this._options.prettyPrint && this._refs.markup.slice(-this._options.newline.length) === this._options.newline) {
        this._refs.markup = this._refs.markup.slice(0, -this._options.newline.length);
      }
      return this._refs.markup;
    }
    /** @inheritdoc */
    docType(name, publicId, systemId) {
      this._beginLine();
      if (publicId && systemId) {
        this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
      } else if (publicId) {
        this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
      } else if (systemId) {
        this._refs.markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
      } else {
        this._refs.markup += "<!DOCTYPE " + name + ">";
      }
      this._endLine();
    }
    /** @inheritdoc */
    openTagBegin(name) {
      this._beginLine();
      this._refs.markup += "<" + name;
    }
    /** @inheritdoc */
    openTagEnd(name, selfClosing, voidElement) {
      this._refs.suppressPretty = false;
      this._refs.emptyNode = false;
      if (this._options.prettyPrint && !selfClosing && !voidElement) {
        let textOnlyNode = true;
        let emptyNode = true;
        let childNode = this.currentNode.firstChild;
        let cdataCount = 0;
        let textCount = 0;
        while (childNode) {
          if (util_2.Guard.isExclusiveTextNode(childNode)) {
            textCount++;
          } else if (util_2.Guard.isCDATASectionNode(childNode)) {
            cdataCount++;
          } else {
            textOnlyNode = false;
            emptyNode = false;
            break;
          }
          if (childNode.data !== "") {
            emptyNode = false;
          }
          childNode = childNode.nextSibling;
        }
        this._refs.suppressPretty = !this._options.indentTextOnlyNodes && textOnlyNode && (cdataCount <= 1 && textCount === 0 || cdataCount === 0);
        this._refs.emptyNode = emptyNode;
      }
      if ((voidElement || selfClosing || this._refs.emptyNode) && this._options.allowEmptyTags) {
        this._refs.markup += "></" + name + ">";
      } else {
        this._refs.markup += voidElement ? " />" : selfClosing || this._refs.emptyNode ? this._options.spaceBeforeSlash ? " />" : "/>" : ">";
      }
      this._endLine();
    }
    /** @inheritdoc */
    closeTag(name) {
      if (!this._refs.emptyNode) {
        this._beginLine();
        this._refs.markup += "</" + name + ">";
      }
      this._refs.suppressPretty = false;
      this._refs.emptyNode = false;
      this._endLine();
    }
    /** @inheritdoc */
    attribute(name, value) {
      const str = name + '="' + value + '"';
      if (this._options.prettyPrint && this._options.width > 0 && this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._options.width) {
        this._endLine();
        this._beginLine();
        this._refs.markup += this._indent(1) + str;
      } else {
        this._refs.markup += " " + str;
      }
    }
    /** @inheritdoc */
    text(data) {
      if (data !== "") {
        this._beginLine();
        this._refs.markup += data;
        this._endLine();
      }
    }
    /** @inheritdoc */
    cdata(data) {
      if (data !== "") {
        this._beginLine();
        this._refs.markup += "<![CDATA[" + data + "]]>";
        this._endLine();
      }
    }
    /** @inheritdoc */
    comment(data) {
      this._beginLine();
      this._refs.markup += "<!--" + data + "-->";
      this._endLine();
    }
    /** @inheritdoc */
    instruction(target2, data) {
      this._beginLine();
      this._refs.markup += "<?" + (data === "" ? target2 : target2 + " " + data) + "?>";
      this._endLine();
    }
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    _beginLine() {
      if (this._options.prettyPrint && !this._refs.suppressPretty) {
        this._refs.markup += this._indent(this._options.offset + this.level);
      }
    }
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     */
    _endLine() {
      if (this._options.prettyPrint && !this._refs.suppressPretty) {
        this._refs.markup += this._options.newline;
        this._lengthToLastNewline = this._refs.markup.length;
      }
    }
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    _indent(level) {
      if (level <= 0) {
        return "";
      } else if (this._indentation[level] !== void 0) {
        return this._indentation[level];
      } else {
        const str = this._options.indent.repeat(level);
        this._indentation[level] = str;
        return str;
      }
    }
  };
  XMLWriter.XMLWriter = XMLWriter$1;
  return XMLWriter;
}
var JSONWriter = {};
var hasRequiredJSONWriter;
function requireJSONWriter() {
  if (hasRequiredJSONWriter) return JSONWriter;
  hasRequiredJSONWriter = 1;
  Object.defineProperty(JSONWriter, "__esModule", { value: true });
  const ObjectWriter_1 = requireObjectWriter();
  const util_1 = requireLib$a();
  const BaseWriter_1 = requireBaseWriter();
  let JSONWriter$1 = class JSONWriter extends BaseWriter_1.BaseWriter {
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    serialize(node2, writerOptions) {
      const options = util_1.applyDefaults(writerOptions, {
        wellFormed: false,
        noDoubleEncoding: false,
        prettyPrint: false,
        indent: "  ",
        newline: "\n",
        offset: 0,
        group: false
      });
      const objectWriterOptions = util_1.applyDefaults(options, {
        format: "object",
        wellFormed: false,
        noDoubleEncoding: false
      });
      const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions);
      const val = objectWriter.serialize(node2, objectWriterOptions);
      return this._beginLine(options, 0) + this._convertObject(val, options);
    }
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     */
    _convertObject(obj, options, level = 0) {
      let markup = "";
      const isLeaf = this._isLeafNode(obj);
      if (util_1.isArray(obj)) {
        markup += "[";
        const len = obj.length;
        let i = 0;
        for (const val of obj) {
          markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1) + this._convertObject(val, options, level + 1);
          if (i < len - 1) {
            markup += ",";
          }
          i++;
        }
        markup += this._endLine(options, level) + this._beginLine(options, level);
        markup += "]";
      } else if (util_1.isObject(obj)) {
        markup += "{";
        const len = util_1.objectLength(obj);
        let i = 0;
        util_1.forEachObject(obj, (key, val) => {
          if (isLeaf && options.prettyPrint) {
            markup += " ";
          } else {
            markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1);
          }
          markup += '"' + key + '":';
          if (options.prettyPrint) {
            markup += " ";
          }
          markup += this._convertObject(val, options, level + 1);
          if (i < len - 1) {
            markup += ",";
          }
          i++;
        }, this);
        if (isLeaf && options.prettyPrint) {
          markup += " ";
        } else {
          markup += this._endLine(options, level) + this._beginLine(options, level);
        }
        markup += "}";
      } else {
        markup += '"' + obj + '"';
      }
      return markup;
    }
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    _beginLine(options, level) {
      if (!options.prettyPrint) {
        return "";
      } else {
        const indentLevel = options.offset + level + 1;
        if (indentLevel > 0) {
          return new Array(indentLevel).join(options.indent);
        }
      }
      return "";
    }
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    _endLine(options, level) {
      if (!options.prettyPrint) {
        return "";
      } else {
        return options.newline;
      }
    }
    /**
     * Determines if an object is a leaf node.
     *
     * @param obj
     */
    _isLeafNode(obj) {
      return this._descendantCount(obj) <= 1;
    }
    /**
     * Counts the number of descendants of the given object.
     *
     * @param obj
     * @param count
     */
    _descendantCount(obj, count = 0) {
      if (util_1.isArray(obj)) {
        util_1.forEachArray(obj, (val) => count += this._descendantCount(val, count), this);
      } else if (util_1.isObject(obj)) {
        util_1.forEachObject(obj, (key, val) => count += this._descendantCount(val, count), this);
      } else {
        count++;
      }
      return count;
    }
  };
  JSONWriter.JSONWriter = JSONWriter$1;
  return JSONWriter;
}
var hasRequiredWriters;
function requireWriters() {
  if (hasRequiredWriters) return writers;
  hasRequiredWriters = 1;
  Object.defineProperty(writers, "__esModule", { value: true });
  var MapWriter_1 = requireMapWriter();
  writers.MapWriter = MapWriter_1.MapWriter;
  var XMLWriter_1 = requireXMLWriter();
  writers.XMLWriter = XMLWriter_1.XMLWriter;
  var ObjectWriter_1 = requireObjectWriter();
  writers.ObjectWriter = ObjectWriter_1.ObjectWriter;
  var JSONWriter_1 = requireJSONWriter();
  writers.JSONWriter = JSONWriter_1.JSONWriter;
  return writers;
}
var dom = {};
var lib$4 = {};
var parser = {};
var DOMParserImpl = {};
var XMLParserImpl = {};
var XMLStringLexer = {};
var interfaces = {};
var hasRequiredInterfaces;
function requireInterfaces() {
  if (hasRequiredInterfaces) return interfaces;
  hasRequiredInterfaces = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    (function(TokenType) {
      TokenType[TokenType["EOF"] = 0] = "EOF";
      TokenType[TokenType["Declaration"] = 1] = "Declaration";
      TokenType[TokenType["DocType"] = 2] = "DocType";
      TokenType[TokenType["Element"] = 3] = "Element";
      TokenType[TokenType["Text"] = 4] = "Text";
      TokenType[TokenType["CDATA"] = 5] = "CDATA";
      TokenType[TokenType["PI"] = 6] = "PI";
      TokenType[TokenType["Comment"] = 7] = "Comment";
      TokenType[TokenType["ClosingTag"] = 8] = "ClosingTag";
    })(exports$1.TokenType || (exports$1.TokenType = {}));
  })(interfaces);
  return interfaces;
}
var hasRequiredXMLStringLexer;
function requireXMLStringLexer() {
  if (hasRequiredXMLStringLexer) return XMLStringLexer;
  hasRequiredXMLStringLexer = 1;
  Object.defineProperty(XMLStringLexer, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces();
  let XMLStringLexer$1 = class XMLStringLexer2 {
    /**
     * Initializes a new instance of `XMLStringLexer`.
     *
     * @param str - the string to tokenize and lex
     * @param options - lexer options
     */
    constructor(str, options) {
      this._options = {
        skipWhitespaceOnlyText: false
      };
      this.err = { line: -1, col: -1, index: -1, str: "" };
      this._str = str;
      this._index = 0;
      this._length = str.length;
      if (options) {
        this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;
      }
    }
    /**
     * Returns the next token.
     */
    nextToken() {
      if (this.eof()) {
        return { type: interfaces_1.TokenType.EOF };
      }
      let token = this.skipIfStartsWith("<") ? this.openBracket() : this.text();
      if (this._options.skipWhitespaceOnlyText) {
        if (token.type === interfaces_1.TokenType.Text && XMLStringLexer2.isWhiteSpaceToken(token)) {
          token = this.nextToken();
        }
      }
      return token;
    }
    /**
     * Branches from an opening bracket (`<`).
     */
    openBracket() {
      if (this.skipIfStartsWith("?")) {
        if (this.skipIfStartsWith("xml")) {
          if (XMLStringLexer2.isSpace(this._str[this._index])) {
            return this.declaration();
          } else {
            this.seek(-3);
            return this.pi();
          }
        } else {
          return this.pi();
        }
      } else if (this.skipIfStartsWith("!")) {
        if (this.skipIfStartsWith("--")) {
          return this.comment();
        } else if (this.skipIfStartsWith("[CDATA[")) {
          return this.cdata();
        } else if (this.skipIfStartsWith("DOCTYPE")) {
          return this.doctype();
        } else {
          this.throwError("Invalid '!' in opening tag.");
        }
      } else if (this.skipIfStartsWith("/")) {
        return this.closeTag();
      } else {
        return this.openTag();
      }
    }
    /**
     * Produces an XML declaration token.
     */
    declaration() {
      let version = "";
      let encoding = "";
      let standalone = "";
      while (!this.eof()) {
        this.skipSpace();
        if (this.skipIfStartsWith("?>")) {
          return { type: interfaces_1.TokenType.Declaration, version, encoding, standalone };
        } else {
          const [attName, attValue] = this.attribute();
          if (attName === "version")
            version = attValue;
          else if (attName === "encoding")
            encoding = attValue;
          else if (attName === "standalone")
            standalone = attValue;
          else
            this.throwError("Invalid attribute name: " + attName);
        }
      }
      this.throwError("Missing declaration end symbol `?>`");
    }
    /**
     * Produces a doc type token.
     */
    doctype() {
      let pubId = "";
      let sysId = "";
      this.skipSpace();
      const name = this.takeUntil2("[", ">", true);
      this.skipSpace();
      if (this.skipIfStartsWith("PUBLIC")) {
        pubId = this.quotedString();
        sysId = this.quotedString();
      } else if (this.skipIfStartsWith("SYSTEM")) {
        sysId = this.quotedString();
      }
      this.skipSpace();
      if (this.skipIfStartsWith("[")) {
        this.skipUntil("]");
        if (!this.skipIfStartsWith("]")) {
          this.throwError("Missing end bracket of DTD internal subset");
        }
      }
      this.skipSpace();
      if (!this.skipIfStartsWith(">")) {
        this.throwError("Missing doctype end symbol `>`");
      }
      return { type: interfaces_1.TokenType.DocType, name, pubId, sysId };
    }
    /**
     * Produces a processing instruction token.
     */
    pi() {
      const target2 = this.takeUntilStartsWith("?>", true);
      if (this.eof()) {
        this.throwError("Missing processing instruction end symbol `?>`");
      }
      this.skipSpace();
      if (this.skipIfStartsWith("?>")) {
        return { type: interfaces_1.TokenType.PI, target: target2, data: "" };
      }
      const data = this.takeUntilStartsWith("?>");
      if (this.eof()) {
        this.throwError("Missing processing instruction end symbol `?>`");
      }
      this.seek(2);
      return { type: interfaces_1.TokenType.PI, target: target2, data };
    }
    /**
     * Produces a text token.
     *
     */
    text() {
      const data = this.takeUntil("<");
      return { type: interfaces_1.TokenType.Text, data };
    }
    /**
     * Produces a comment token.
     *
     */
    comment() {
      const data = this.takeUntilStartsWith("-->");
      if (this.eof()) {
        this.throwError("Missing comment end symbol `-->`");
      }
      this.seek(3);
      return { type: interfaces_1.TokenType.Comment, data };
    }
    /**
     * Produces a CDATA token.
     *
     */
    cdata() {
      const data = this.takeUntilStartsWith("]]>");
      if (this.eof()) {
        this.throwError("Missing CDATA end symbol `]>`");
      }
      this.seek(3);
      return { type: interfaces_1.TokenType.CDATA, data };
    }
    /**
     * Produces an element token.
     */
    openTag() {
      this.skipSpace();
      const name = this.takeUntil2(">", "/", true);
      this.skipSpace();
      if (this.skipIfStartsWith(">")) {
        return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: false };
      } else if (this.skipIfStartsWith("/>")) {
        return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: true };
      }
      const attributes = [];
      while (!this.eof()) {
        this.skipSpace();
        if (this.skipIfStartsWith(">")) {
          return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: false };
        } else if (this.skipIfStartsWith("/>")) {
          return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: true };
        }
        const attr = this.attribute();
        attributes.push(attr);
      }
      this.throwError("Missing opening element tag end symbol `>`");
    }
    /**
     * Produces a closing tag token.
     *
     */
    closeTag() {
      this.skipSpace();
      const name = this.takeUntil(">", true);
      this.skipSpace();
      if (!this.skipIfStartsWith(">")) {
        this.throwError("Missing closing element tag end symbol `>`");
      }
      return { type: interfaces_1.TokenType.ClosingTag, name };
    }
    /**
     * Reads an attribute name, value pair
     */
    attribute() {
      this.skipSpace();
      const name = this.takeUntil("=", true);
      this.skipSpace();
      if (!this.skipIfStartsWith("=")) {
        this.throwError("Missing equals sign before attribute value");
      }
      const value = this.quotedString();
      return [name, value];
    }
    /**
     * Reads a string between double or single quotes.
     */
    quotedString() {
      this.skipSpace();
      const startQuote = this.take(1);
      if (!XMLStringLexer2.isQuote(startQuote)) {
        this.throwError("Missing start quote character before quoted value");
      }
      const value = this.takeUntil(startQuote);
      if (!this.skipIfStartsWith(startQuote)) {
        this.throwError("Missing end quote character after quoted value");
      }
      return value;
    }
    /**
     * Determines if the current index is at or past the end of input string.
     */
    eof() {
      return this._index >= this._length;
    }
    /**
     * Skips the length of the given string if the string from current position
     * starts with the given string.
     *
     * @param str - the string to match
     */
    skipIfStartsWith(str) {
      const strLength = str.length;
      if (strLength === 1) {
        if (this._str[this._index] === str) {
          this._index++;
          return true;
        } else {
          return false;
        }
      }
      for (let i = 0; i < strLength; i++) {
        if (this._str[this._index + i] !== str[i])
          return false;
      }
      this._index += strLength;
      return true;
    }
    /**
     * Seeks a number of character codes.
     *
     * @param count - number of characters to skip
     */
    seek(count) {
      this._index += count;
      if (this._index < 0)
        this._index = 0;
      if (this._index > this._length)
        this._index = this._length;
    }
    /**
     * Skips space characters.
     */
    skipSpace() {
      while (!this.eof() && XMLStringLexer2.isSpace(this._str[this._index])) {
        this._index++;
      }
    }
    /**
     * Takes a given number of characters.
     *
     * @param count - character count
     */
    take(count) {
      if (count === 1) {
        return this._str[this._index++];
      }
      const startIndex = this._index;
      this.seek(count);
      return this._str.slice(startIndex, this._index);
    }
    /**
     * Takes characters until the next character matches `char`.
     *
     * @param char - a character to match
     * @param space - whether a space character stops iteration
     */
    takeUntil(char, space = false) {
      const startIndex = this._index;
      while (this._index < this._length) {
        const c = this._str[this._index];
        if (c !== char && (!space || !XMLStringLexer2.isSpace(c))) {
          this._index++;
        } else {
          break;
        }
      }
      return this._str.slice(startIndex, this._index);
    }
    /**
     * Takes characters until the next character matches `char1` or `char1`.
     *
     * @param char1 - a character to match
     * @param char2 - a character to match
     * @param space - whether a space character stops iteration
     */
    takeUntil2(char1, char2, space = false) {
      const startIndex = this._index;
      while (this._index < this._length) {
        const c = this._str[this._index];
        if (c !== char1 && c !== char2 && (!space || !XMLStringLexer2.isSpace(c))) {
          this._index++;
        } else {
          break;
        }
      }
      return this._str.slice(startIndex, this._index);
    }
    /**
     * Takes characters until the next characters matches `str`.
     *
     * @param str - a string to match
     * @param space - whether a space character stops iteration
     */
    takeUntilStartsWith(str, space = false) {
      const startIndex = this._index;
      const strLength = str.length;
      while (this._index < this._length) {
        let match = true;
        for (let i = 0; i < strLength; i++) {
          const c = this._str[this._index + i];
          const char = str[i];
          if (space && XMLStringLexer2.isSpace(c)) {
            return this._str.slice(startIndex, this._index);
          } else if (c !== char) {
            this._index++;
            match = false;
            break;
          }
        }
        if (match)
          return this._str.slice(startIndex, this._index);
      }
      this._index = this._length;
      return this._str.slice(startIndex);
    }
    /**
     * Skips characters until the next character matches `char`.
     *
     * @param char - a character to match
     */
    skipUntil(char) {
      while (this._index < this._length) {
        const c = this._str[this._index];
        if (c !== char) {
          this._index++;
        } else {
          break;
        }
      }
    }
    /**
     * Determines if the given token is entirely whitespace.
     *
     * @param token - the token to check
     */
    static isWhiteSpaceToken(token) {
      const str = token.data;
      for (let i = 0; i < str.length; i++) {
        const c = str[i];
        if (c !== " " && c !== "\n" && c !== "\r" && c !== "	" && c !== "\f")
          return false;
      }
      return true;
    }
    /**
     * Determines if the given character is whitespace.
     *
     * @param char - the character to check
     */
    static isSpace(char) {
      return char === " " || char === "\n" || char === "\r" || char === "	";
    }
    /**
     * Determines if the given character is a quote character.
     *
     * @param char - the character to check
     */
    static isQuote(char) {
      return char === '"' || char === "'";
    }
    /**
     * Throws a parser error and records the line and column numbers in the parsed
     * string.
     *
     * @param msg - error message
     */
    throwError(msg) {
      const regexp = /\r\n|\r|\n/g;
      let match = null;
      let line = 0;
      let firstNewLineIndex = 0;
      let lastNewlineIndex = this._str.length;
      while ((match = regexp.exec(this._str)) !== null) {
        if (match === null)
          break;
        line++;
        if (match.index < this._index)
          firstNewLineIndex = regexp.lastIndex;
        if (match.index > this._index) {
          lastNewlineIndex = match.index;
          break;
        }
      }
      this.err = {
        line,
        col: this._index - firstNewLineIndex,
        index: this._index,
        str: this._str.substring(firstNewLineIndex, lastNewlineIndex)
      };
      throw new Error(msg + "\nIndex: " + this.err.index + "\nLn: " + this.err.line + ", Col: " + this.err.col + "\nInput: " + this.err.str);
    }
    /**
     * Returns an iterator for the lexer.
     */
    [Symbol.iterator]() {
      this._index = 0;
      return {
        next: (function() {
          const token = this.nextToken();
          if (token.type === interfaces_1.TokenType.EOF) {
            return { done: true, value: null };
          } else {
            return { done: false, value: token };
          }
        }).bind(this)
      };
    }
  };
  XMLStringLexer.XMLStringLexer = XMLStringLexer$1;
  return XMLStringLexer;
}
var hasRequiredXMLParserImpl;
function requireXMLParserImpl() {
  if (hasRequiredXMLParserImpl) return XMLParserImpl;
  hasRequiredXMLParserImpl = 1;
  Object.defineProperty(XMLParserImpl, "__esModule", { value: true });
  const XMLStringLexer_1 = requireXMLStringLexer();
  const interfaces_1 = requireInterfaces();
  const infra_1 = requireLib$8();
  const algorithm_1 = requireAlgorithm();
  const LocalNameSet_1 = requireLocalNameSet();
  let XMLParserImpl$1 = class XMLParserImpl {
    /**
     * Parses XML content.
     *
     * @param source - a string containing XML content
     */
    parse(source) {
      const lexer = new XMLStringLexer_1.XMLStringLexer(source, { skipWhitespaceOnlyText: true });
      const doc = algorithm_1.create_document();
      let context2 = doc;
      let token = lexer.nextToken();
      while (token.type !== interfaces_1.TokenType.EOF) {
        switch (token.type) {
          case interfaces_1.TokenType.Declaration:
            const declaration = token;
            if (declaration.version !== "1.0") {
              throw new Error("Invalid xml version: " + declaration.version);
            }
            break;
          case interfaces_1.TokenType.DocType:
            const doctype = token;
            if (!algorithm_1.xml_isPubidChar(doctype.pubId)) {
              throw new Error("DocType public identifier does not match PubidChar construct.");
            }
            if (!algorithm_1.xml_isLegalChar(doctype.sysId) || doctype.sysId.indexOf('"') !== -1 && doctype.sysId.indexOf("'") !== -1) {
              throw new Error("DocType system identifier contains invalid characters.");
            }
            context2.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));
            break;
          case interfaces_1.TokenType.CDATA:
            const cdata = token;
            if (!algorithm_1.xml_isLegalChar(cdata.data) || cdata.data.indexOf("]]>") !== -1) {
              throw new Error("CDATA contains invalid characters.");
            }
            context2.appendChild(doc.createCDATASection(cdata.data));
            break;
          case interfaces_1.TokenType.Comment:
            const comment = token;
            if (!algorithm_1.xml_isLegalChar(comment.data) || comment.data.indexOf("--") !== -1 || comment.data.endsWith("-")) {
              throw new Error("Comment data contains invalid characters.");
            }
            context2.appendChild(doc.createComment(comment.data));
            break;
          case interfaces_1.TokenType.PI:
            const pi2 = token;
            if (pi2.target.indexOf(":") !== -1 || /^xml$/i.test(pi2.target)) {
              throw new Error("Processing instruction target contains invalid characters.");
            }
            if (!algorithm_1.xml_isLegalChar(pi2.data) || pi2.data.indexOf("?>") !== -1) {
              throw new Error("Processing instruction data contains invalid characters.");
            }
            context2.appendChild(doc.createProcessingInstruction(pi2.target, pi2.data));
            break;
          case interfaces_1.TokenType.Text:
            const text = token;
            if (!algorithm_1.xml_isLegalChar(text.data)) {
              throw new Error("Text data contains invalid characters.");
            }
            context2.appendChild(doc.createTextNode(text.data));
            break;
          case interfaces_1.TokenType.Element:
            const element2 = token;
            const [prefix, localName] = algorithm_1.namespace_extractQName(element2.name);
            if (localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(localName)) {
              throw new Error("Node local name contains invalid characters.");
            }
            if (prefix === "xmlns") {
              throw new Error("An element cannot have the 'xmlns' prefix.");
            }
            let namespace = context2.lookupNamespaceURI(prefix);
            const nsDeclarations = {};
            for (const [attName, attValue] of element2.attributes) {
              if (attName === "xmlns") {
                namespace = attValue;
              } else {
                const [attPrefix, attLocalName] = algorithm_1.namespace_extractQName(attName);
                if (attPrefix === "xmlns") {
                  if (attLocalName === prefix) {
                    namespace = attValue;
                  }
                  nsDeclarations[attLocalName] = attValue;
                }
              }
            }
            const elementNode = namespace !== null ? doc.createElementNS(namespace, element2.name) : doc.createElement(element2.name);
            context2.appendChild(elementNode);
            const localNameSet = new LocalNameSet_1.LocalNameSet();
            for (const [attName, attValue] of element2.attributes) {
              const [attPrefix, attLocalName] = algorithm_1.namespace_extractQName(attName);
              let attNamespace = null;
              if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                attNamespace = infra_1.namespace.XMLNS;
              } else {
                attNamespace = elementNode.lookupNamespaceURI(attPrefix);
                if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {
                  attNamespace = null;
                } else if (attNamespace === null && attPrefix !== null) {
                  attNamespace = nsDeclarations[attPrefix] || null;
                }
              }
              if (localNameSet.has(attNamespace, attLocalName)) {
                throw new Error("Element contains duplicate attributes.");
              }
              localNameSet.set(attNamespace, attLocalName);
              if (attNamespace === infra_1.namespace.XMLNS) {
                if (attValue === infra_1.namespace.XMLNS) {
                  throw new Error("XMLNS namespace is reserved.");
                }
              }
              if (attLocalName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attLocalName)) {
                throw new Error("Attribute local name contains invalid characters.");
              }
              if (attPrefix === "xmlns" && attValue === "") {
                throw new Error("Empty XML namespace is not allowed.");
              }
              if (attNamespace !== null)
                elementNode.setAttributeNS(attNamespace, attName, attValue);
              else
                elementNode.setAttribute(attName, attValue);
            }
            if (!element2.selfClosing) {
              context2 = elementNode;
            }
            break;
          case interfaces_1.TokenType.ClosingTag:
            const closingTag = token;
            if (closingTag.name !== context2.nodeName) {
              throw new Error("Closing tag name does not match opening tag name.");
            }
            if (context2._parent) {
              context2 = context2._parent;
            }
            break;
        }
        token = lexer.nextToken();
      }
      return doc;
    }
  };
  XMLParserImpl.XMLParserImpl = XMLParserImpl$1;
  return XMLParserImpl;
}
var hasRequiredDOMParserImpl;
function requireDOMParserImpl() {
  if (hasRequiredDOMParserImpl) return DOMParserImpl;
  hasRequiredDOMParserImpl = 1;
  Object.defineProperty(DOMParserImpl, "__esModule", { value: true });
  const algorithm_1 = requireAlgorithm();
  const XMLParserImpl_1 = requireXMLParserImpl();
  let DOMParserImpl$1 = class DOMParserImpl {
    /** @inheritdoc */
    parseFromString(source, mimeType) {
      if (mimeType === "text/html")
        throw new Error("HTML parser not implemented.");
      try {
        const parser2 = new XMLParserImpl_1.XMLParserImpl();
        const doc = parser2.parse(source);
        doc._contentType = mimeType;
        return doc;
      } catch (e) {
        const errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
        const doc = algorithm_1.create_xmlDocument();
        const root = doc.createElementNS(errorNS, "parsererror");
        const ele = doc.createElementNS(errorNS, "error");
        ele.setAttribute("message", e.message);
        root.appendChild(ele);
        doc.appendChild(root);
        return doc;
      }
    }
  };
  DOMParserImpl.DOMParserImpl = DOMParserImpl$1;
  return DOMParserImpl;
}
var hasRequiredParser$1;
function requireParser$1() {
  if (hasRequiredParser$1) return parser;
  hasRequiredParser$1 = 1;
  Object.defineProperty(parser, "__esModule", { value: true });
  var DOMParserImpl_1 = requireDOMParserImpl();
  parser.DOMParser = DOMParserImpl_1.DOMParserImpl;
  return parser;
}
var serializer = {};
var XMLSerializerImpl = {};
var hasRequiredXMLSerializerImpl;
function requireXMLSerializerImpl() {
  if (hasRequiredXMLSerializerImpl) return XMLSerializerImpl;
  hasRequiredXMLSerializerImpl = 1;
  Object.defineProperty(XMLSerializerImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$2();
  const LocalNameSet_1 = requireLocalNameSet();
  const NamespacePrefixMap_1 = requireNamespacePrefixMap();
  const DOMException_1 = requireDOMException();
  const infra_1 = requireLib$8();
  const algorithm_1 = requireAlgorithm();
  let XMLSerializerImpl$1 = class XMLSerializerImpl2 {
    /** @inheritdoc */
    serializeToString(root) {
      return this._xmlSerialization(root, false);
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _xmlSerialization(node2, requireWellFormed) {
      if (node2._nodeDocument === void 0 || node2._nodeDocument._hasNamespaces) {
        const namespace = null;
        const prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
        prefixMap.set("xml", infra_1.namespace.XML);
        const prefixIndex = { value: 1 };
        try {
          return this._serializeNodeNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed);
        } catch (_a) {
          throw new DOMException_1.InvalidStateError();
        }
      } else {
        try {
          return this._serializeNode(node2, requireWellFormed);
        } catch (_b) {
          throw new DOMException_1.InvalidStateError();
        }
      }
    }
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeNodeNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed) {
      switch (node2.nodeType) {
        case interfaces_1.NodeType.Element:
          return this._serializeElementNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.Document:
          return this._serializeDocumentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.Comment:
          return this._serializeComment(node2, requireWellFormed);
        case interfaces_1.NodeType.Text:
          return this._serializeText(node2, requireWellFormed);
        case interfaces_1.NodeType.DocumentFragment:
          return this._serializeDocumentFragmentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed);
        case interfaces_1.NodeType.DocumentType:
          return this._serializeDocumentType(node2, requireWellFormed);
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._serializeProcessingInstruction(node2, requireWellFormed);
        case interfaces_1.NodeType.CData:
          return this._serializeCData(node2, requireWellFormed);
        default:
          throw new Error(`Unknown node type: ${node2.nodeType}`);
      }
    }
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeNode(node2, requireWellFormed) {
      switch (node2.nodeType) {
        case interfaces_1.NodeType.Element:
          return this._serializeElement(node2, requireWellFormed);
        case interfaces_1.NodeType.Document:
          return this._serializeDocument(node2, requireWellFormed);
        case interfaces_1.NodeType.Comment:
          return this._serializeComment(node2, requireWellFormed);
        case interfaces_1.NodeType.Text:
          return this._serializeText(node2, requireWellFormed);
        case interfaces_1.NodeType.DocumentFragment:
          return this._serializeDocumentFragment(node2, requireWellFormed);
        case interfaces_1.NodeType.DocumentType:
          return this._serializeDocumentType(node2, requireWellFormed);
        case interfaces_1.NodeType.ProcessingInstruction:
          return this._serializeProcessingInstruction(node2, requireWellFormed);
        case interfaces_1.NodeType.CData:
          return this._serializeCData(node2, requireWellFormed);
        default:
          throw new Error(`Unknown node type: ${node2.nodeType}`);
      }
    }
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeElementNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed) {
      if (requireWellFormed && (node2.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node2.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let markup = "<";
      let qualifiedName = "";
      let skipEndTag = false;
      let ignoreNamespaceDefinitionAttribute = false;
      let map2 = prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node2, map2, localPrefixesMap);
      let inheritedNS = namespace;
      let ns = node2.namespaceURI;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node2.localName;
        } else {
          qualifiedName = node2.localName;
        }
        markup += qualifiedName;
      } else {
        let prefix = node2.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map2.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (requireWellFormed) {
            throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node2.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          markup += qualifiedName;
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map2, prefixIndex);
          }
          map2.set(prefix, ns);
          qualifiedName += prefix + ":" + node2.localName;
          markup += qualifiedName;
          markup += " xmlns:" + prefix + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node2.localName;
          inheritedNS = ns;
          markup += qualifiedName;
          markup += ' xmlns="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
        } else {
          qualifiedName += node2.localName;
          inheritedNS = ns;
          markup += qualifiedName;
        }
      }
      markup += this._serializeAttributesNS(node2, map2, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && node2.childNodes.length === 0 && XMLSerializerImpl2._VoidElementNames.has(node2.localName)) {
        markup += " /";
        skipEndTag = true;
      } else if (!isHTML && node2.childNodes.length === 0) {
        markup += "/";
        skipEndTag = true;
      }
      markup += ">";
      if (skipEndTag)
        return markup;
      if (isHTML && node2.localName === "template") ;
      else {
        for (const childNode of node2._children || node2.childNodes) {
          markup += this._serializeNodeNS(childNode, inheritedNS, map2, prefixIndex, requireWellFormed);
        }
      }
      markup += "</" + qualifiedName + ">";
      return markup;
    }
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed) {
      if (requireWellFormed && node2.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      let serializedDocument = "";
      for (const childNode of node2._children || node2.childNodes) {
        serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
      }
      return serializedDocument;
    }
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeComment(node2, requireWellFormed) {
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node2.data) || node2.data.indexOf("--") !== -1 || node2.data.endsWith("-"))) {
        throw new Error("Comment data contains invalid characters (well-formed required).");
      }
      return "<!--" + node2.data + "-->";
    }
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */
    _serializeText(node2, requireWellFormed) {
      if (requireWellFormed && !algorithm_1.xml_isLegalChar(node2.data)) {
        throw new Error("Text data contains invalid characters (well-formed required).");
      }
      let result = "";
      for (let i = 0; i < node2.data.length; i++) {
        const c = node2.data[i];
        if (c === "&")
          result += "&amp;";
        else if (c === "<")
          result += "&lt;";
        else if (c === ">")
          result += "&gt;";
        else
          result += c;
      }
      return result;
    }
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentFragmentNS(node2, namespace, prefixMap, prefixIndex, requireWellFormed) {
      let markup = "";
      for (const childNode of node2._children || node2.childNodes) {
        markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
      }
      return markup;
    }
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentType(node2, requireWellFormed) {
      if (requireWellFormed && !algorithm_1.xml_isPubidChar(node2.publicId)) {
        throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node2.systemId) || node2.systemId.indexOf('"') !== -1 && node2.systemId.indexOf("'") !== -1)) {
        throw new Error("DocType system identifier contains invalid characters (well-formed required).");
      }
      return node2.publicId && node2.systemId ? "<!DOCTYPE " + node2.name + ' PUBLIC "' + node2.publicId + '" "' + node2.systemId + '">' : node2.publicId ? "<!DOCTYPE " + node2.name + ' PUBLIC "' + node2.publicId + '">' : node2.systemId ? "<!DOCTYPE " + node2.name + ' SYSTEM "' + node2.systemId + '">' : "<!DOCTYPE " + node2.name + ">";
    }
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeProcessingInstruction(node2, requireWellFormed) {
      if (requireWellFormed && (node2.target.indexOf(":") !== -1 || /^xml$/i.test(node2.target))) {
        throw new Error("Processing instruction target contains invalid characters (well-formed required).");
      }
      if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node2.data) || node2.data.indexOf("?>") !== -1)) {
        throw new Error("Processing instruction data contains invalid characters (well-formed required).");
      }
      return "<?" + (node2.data === "" ? node2.target : node2.target + " " + node2.data) + "?>";
    }
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeCData(node2, requireWellFormed) {
      if (requireWellFormed && node2.data.indexOf("]]>") !== -1) {
        throw new Error("CDATA contains invalid characters (well-formed required).");
      }
      return "<![CDATA[" + node2.data + "]]>";
    }
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */
    _serializeAttributesNS(node2, map2, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
      let result = "";
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : void 0;
      for (const attr of node2.attributes) {
        if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {
          result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map2.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map2.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              throw new Error("XMLNS namespace is reserved (well-formed required).");
            }
            if (requireWellFormed && attr.value === "") {
              throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map2.hasPrefix(attr.prefix) || map2.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map2, prefixIndex);
            }
            result += " xmlns:" + candidatePrefix + '="' + this._serializeAttributeValue(attributeNamespace, requireWellFormed) + '"';
          }
        }
        result += " ";
        if (candidatePrefix !== null) {
          result += candidatePrefix + ":";
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result += attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
      }
      return result;
    }
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */
    _recordNamespaceInformation(node2, map2, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node2.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map2.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map2.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      let generatedPrefix = "ns" + prefixIndex.value;
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    _serializeAttributeValue(value, requireWellFormed) {
      if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
        throw new Error("Invalid characters in attribute value.");
      }
      if (value === null)
        return "";
      let result = "";
      for (let i = 0; i < value.length; i++) {
        const c = value[i];
        if (c === '"')
          result += "&quot;";
        else if (c === "&")
          result += "&amp;";
        else if (c === "<")
          result += "&lt;";
        else if (c === ">")
          result += "&gt;";
        else
          result += c;
      }
      return result;
    }
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeElement(node2, requireWellFormed) {
      if (requireWellFormed && (node2.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node2.localName))) {
        throw new Error("Node local name contains invalid characters (well-formed required).");
      }
      let skipEndTag = false;
      const qualifiedName = node2.localName;
      let markup = "<" + qualifiedName;
      markup += this._serializeAttributes(node2, requireWellFormed);
      if (node2._children.size === 0) {
        markup += "/";
        skipEndTag = true;
      }
      markup += ">";
      if (skipEndTag)
        return markup;
      for (const childNode of node2._children) {
        markup += this._serializeNode(childNode, requireWellFormed);
      }
      markup += "</" + qualifiedName + ">";
      return markup;
    }
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocument(node2, requireWellFormed) {
      if (requireWellFormed && node2.documentElement === null) {
        throw new Error("Missing document element (well-formed required).");
      }
      let serializedDocument = "";
      for (const childNode of node2._children) {
        serializedDocument += this._serializeNode(childNode, requireWellFormed);
      }
      return serializedDocument;
    }
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeDocumentFragment(node2, requireWellFormed) {
      let markup = "";
      for (const childNode of node2._children) {
        markup += this._serializeNode(childNode, requireWellFormed);
      }
      return markup;
    }
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    _serializeAttributes(node2, requireWellFormed) {
      let result = "";
      const localNameSet = requireWellFormed ? {} : void 0;
      for (const attr of node2.attributes) {
        if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
          throw new Error("Element contains duplicate attributes (well-formed required).");
        }
        if (requireWellFormed && localNameSet)
          localNameSet[attr.localName] = true;
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName))) {
          throw new Error("Attribute local name contains invalid characters (well-formed required).");
        }
        result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
      }
      return result;
    }
  };
  XMLSerializerImpl.XMLSerializerImpl = XMLSerializerImpl$1;
  XMLSerializerImpl$1._VoidElementNames = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  return XMLSerializerImpl;
}
var hasRequiredSerializer;
function requireSerializer() {
  if (hasRequiredSerializer) return serializer;
  hasRequiredSerializer = 1;
  Object.defineProperty(serializer, "__esModule", { value: true });
  var XMLSerializerImpl_1 = requireXMLSerializerImpl();
  serializer.XMLSerializer = XMLSerializerImpl_1.XMLSerializerImpl;
  return serializer;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$4;
  hasRequiredLib$4 = 1;
  Object.defineProperty(lib$4, "__esModule", { value: true });
  const dom_1 = requireDom$1();
  dom_1.dom.setFeatures(true);
  var dom_2 = requireDom$1();
  lib$4.DOMImplementation = dom_2.DOMImplementation;
  var parser_1 = requireParser$1();
  lib$4.DOMParser = parser_1.DOMParser;
  var serializer_1 = requireSerializer();
  lib$4.XMLSerializer = serializer_1.XMLSerializer;
  return lib$4;
}
var hasRequiredDom;
function requireDom() {
  if (hasRequiredDom) return dom;
  hasRequiredDom = 1;
  Object.defineProperty(dom, "__esModule", { value: true });
  const dom_1 = requireLib$4();
  const dom_2 = requireDom$1();
  const util_1 = require$$1$3;
  dom_2.dom.setFeatures(false);
  function throwIfParserError(doc) {
    const root = doc.documentElement;
    if (root !== null && root.localName === "parsererror" && root.namespaceURI === "http://www.mozilla.org/newlayout/xml/parsererror.xml") {
      const msgElement = root.firstElementChild;
      if (msgElement === null)
        throw new Error("Error parsing XML string.");
      const msg = msgElement.getAttribute("message");
      if (msg === null)
        throw new Error("Error parsing XML string.");
      throw new Error(msg);
    }
  }
  dom.throwIfParserError = throwIfParserError;
  function createDocument() {
    const impl = new dom_1.DOMImplementation();
    const doc = impl.createDocument(null, "root", null);
    if (doc.documentElement) {
      doc.removeChild(doc.documentElement);
    }
    return doc;
  }
  dom.createDocument = createDocument;
  function createParser() {
    return new dom_1.DOMParser();
  }
  dom.createParser = createParser;
  function sanitizeInput(str, replacement) {
    if (str == null) {
      return str;
    } else if (replacement === void 0) {
      return str + "";
    } else {
      let result = "";
      str = str + "";
      for (let i = 0; i < str.length; i++) {
        let n = str.charCodeAt(i);
        if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
          result += str.charAt(i);
        } else if (n >= 55296 && n <= 56319 && i < str.length - 1) {
          const n2 = str.charCodeAt(i + 1);
          if (n2 >= 56320 && n2 <= 57343) {
            n = (n - 55296) * 1024 + n2 - 56320 + 65536;
            if (n >= 65536 && n <= 1114111) {
              result += String.fromCodePoint(n);
            } else {
              result += util_1.isString(replacement) ? replacement : replacement(String.fromCodePoint(n), i, str);
            }
            i++;
          } else {
            result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
          }
        } else {
          result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
        }
      }
      return result;
    }
  }
  dom.sanitizeInput = sanitizeInput;
  return dom;
}
var hasRequiredXMLBuilderImpl;
function requireXMLBuilderImpl() {
  if (hasRequiredXMLBuilderImpl) return XMLBuilderImpl;
  hasRequiredXMLBuilderImpl = 1;
  Object.defineProperty(XMLBuilderImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$3();
  const util_1 = requireLib$a();
  const writers_1 = requireWriters();
  const interfaces_2 = requireInterfaces$2();
  const util_2 = requireUtil$1();
  const algorithm_1 = requireAlgorithm();
  const dom_1 = requireDom();
  const infra_1 = requireLib$8();
  let XMLBuilderImpl$1 = class XMLBuilderImpl2 {
    /**
     * Initializes a new instance of `XMLBuilderNodeImpl`.
     *
     * @param domNode - the DOM node to wrap
     */
    constructor(domNode) {
      this._domNode = domNode;
    }
    /** @inheritdoc */
    get node() {
      return this._domNode;
    }
    /** @inheritdoc */
    set(options) {
      this._options = util_1.applyDefaults(
        util_1.applyDefaults(this._options, options, true),
        // apply user settings
        interfaces_1.DefaultBuilderOptions
      );
      return this;
    }
    /** @inheritdoc */
    ele(p1, p2, p3) {
      let namespace;
      let name;
      let attributes;
      let lastChild = null;
      if (util_1.isString(p1) && /^\s*</.test(p1)) {
        const contents = "<TEMP_ROOT>" + p1 + "</TEMP_ROOT>";
        const domParser2 = dom_1.createParser();
        const doc = domParser2.parseFromString(dom_1.sanitizeInput(contents, this._options.invalidCharReplacement), "text/xml");
        if (doc.documentElement === null) {
          throw new Error("Document element is null.");
        }
        dom_1.throwIfParserError(doc);
        for (const child of doc.documentElement.childNodes) {
          const newChild = doc.importNode(child, true);
          lastChild = new XMLBuilderImpl2(newChild);
          this._domNode.appendChild(newChild);
        }
        if (lastChild === null) {
          throw new Error("Could not create any elements with: " + p1.toString() + ". " + this._debugInfo());
        }
        return lastChild;
      } else if (util_1.isString(p1) && /^\s*[\{\[]/.test(p1)) {
        const obj = JSON.parse(p1);
        return this.ele(obj);
      } else if (util_1.isObject(p1)) {
        [namespace, name, attributes] = [void 0, p1, void 0];
      } else if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2)) {
        [namespace, name, attributes] = [p1, p2, p3];
      } else if (p1 !== null) {
        [namespace, name, attributes] = [void 0, p1, util_1.isObject(p2) ? p2 : void 0];
      } else {
        throw new Error("Element name cannot be null. " + this._debugInfo());
      }
      if (attributes) {
        attributes = util_1.getValue(attributes);
      }
      if (util_1.isFunction(name)) {
        lastChild = this.ele(name.apply(this));
      } else if (util_1.isArray(name) || util_1.isSet(name)) {
        util_1.forEachArray(name, (item) => lastChild = this.ele(item), this);
      } else if (util_1.isMap(name) || util_1.isObject(name)) {
        util_1.forEachObject(name, (key, val) => {
          if (util_1.isFunction(val)) {
            val = val.apply(this);
          }
          if (!this._options.ignoreConverters && key.indexOf(this._options.convert.att) === 0) {
            if (key === this._options.convert.att) {
              lastChild = this.att(val);
            } else {
              lastChild = this.att(key.substr(this._options.convert.att.length), val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.text) === 0) {
            if (util_1.isMap(val) || util_1.isObject(val)) {
              lastChild = this.ele(val);
            } else {
              lastChild = this.txt(val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.cdata) === 0) {
            if (util_1.isArray(val) || util_1.isSet(val)) {
              util_1.forEachArray(val, (item) => lastChild = this.dat(item), this);
            } else {
              lastChild = this.dat(val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.comment) === 0) {
            if (util_1.isArray(val) || util_1.isSet(val)) {
              util_1.forEachArray(val, (item) => lastChild = this.com(item), this);
            } else {
              lastChild = this.com(val);
            }
          } else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.ins) === 0) {
            if (util_1.isString(val)) {
              const insIndex = val.indexOf(" ");
              const insTarget = insIndex === -1 ? val : val.substr(0, insIndex);
              const insValue = insIndex === -1 ? "" : val.substr(insIndex + 1);
              lastChild = this.ins(insTarget, insValue);
            } else {
              lastChild = this.ins(val);
            }
          } else if ((util_1.isArray(val) || util_1.isSet(val)) && util_1.isEmpty(val)) {
            lastChild = this._dummy();
          } else if ((util_1.isMap(val) || util_1.isObject(val)) && util_1.isEmpty(val)) {
            lastChild = this.ele(key);
          } else if (!this._options.keepNullNodes && val == null) {
            lastChild = this._dummy();
          } else if (util_1.isArray(val) || util_1.isSet(val)) {
            util_1.forEachArray(val, (item) => {
              const childNode = {};
              childNode[key] = item;
              lastChild = this.ele(childNode);
            }, this);
          } else if (util_1.isMap(val) || util_1.isObject(val)) {
            lastChild = this.ele(key);
            lastChild.ele(val);
          } else if (val) {
            lastChild = this.ele(key);
            lastChild.txt(val);
          } else {
            lastChild = this.ele(key);
          }
        }, this);
      } else {
        [namespace, name] = this._extractNamespace(dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement), dom_1.sanitizeInput(name, this._options.invalidCharReplacement), true);
        if (namespace === void 0) {
          const [prefix] = algorithm_1.namespace_extractQName(name);
          namespace = this.node.lookupNamespaceURI(prefix);
        }
        const childNode = namespace !== void 0 && namespace !== null ? this._doc.createElementNS(namespace, name) : this._doc.createElement(name);
        this.node.appendChild(childNode);
        lastChild = new XMLBuilderImpl2(childNode);
        const oldDocType = this._doc.doctype;
        if (childNode === this._doc.documentElement && oldDocType !== null) {
          const docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
          this._doc.replaceChild(docType, oldDocType);
        }
        if (attributes && !util_1.isEmpty(attributes)) {
          lastChild.att(attributes);
        }
      }
      if (lastChild === null) {
        throw new Error("Could not create any elements with: " + name.toString() + ". " + this._debugInfo());
      }
      return lastChild;
    }
    /** @inheritdoc */
    remove() {
      const parent = this.up();
      parent.node.removeChild(this.node);
      return parent;
    }
    /** @inheritdoc */
    att(p1, p2, p3) {
      if (util_1.isMap(p1) || util_1.isObject(p1)) {
        util_1.forEachObject(p1, (attName, attValue) => this.att(attName, attValue), this);
        return this;
      }
      if (p1 !== void 0 && p1 !== null)
        p1 = util_1.getValue(p1 + "");
      if (p2 !== void 0 && p2 !== null)
        p2 = util_1.getValue(p2 + "");
      if (p3 !== void 0 && p3 !== null)
        p3 = util_1.getValue(p3 + "");
      let namespace;
      let name;
      let value;
      if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2) && (p3 === null || util_1.isString(p3))) {
        [namespace, name, value] = [p1, p2, p3];
      } else if (util_1.isString(p1) && (p2 == null || util_1.isString(p2))) {
        [namespace, name, value] = [void 0, p1, p2];
      } else {
        throw new Error("Attribute name and value not specified. " + this._debugInfo());
      }
      if (this._options.keepNullAttributes && value == null) {
        value = "";
      } else if (value == null) {
        return this;
      }
      if (!util_2.Guard.isElementNode(this.node)) {
        throw new Error("An attribute can only be assigned to an element node.");
      }
      let ele = this.node;
      [namespace, name] = this._extractNamespace(namespace, name, false);
      name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
      namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
      value = dom_1.sanitizeInput(value, this._options.invalidCharReplacement);
      const [prefix, localName] = algorithm_1.namespace_extractQName(name);
      const [elePrefix, eleLocalName] = algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName);
      let eleNamespace = null;
      if (prefix === "xmlns") {
        namespace = infra_1.namespace.XMLNS;
        if (ele.namespaceURI === null && elePrefix === localName) {
          eleNamespace = value;
        }
      } else if (prefix === null && localName === "xmlns" && elePrefix === null) {
        namespace = infra_1.namespace.XMLNS;
        eleNamespace = value;
      }
      if (eleNamespace !== null) {
        const newEle = algorithm_1.create_element(this._doc, eleLocalName, eleNamespace, elePrefix);
        for (const attr of ele.attributes) {
          newEle.setAttributeNodeNS(attr.cloneNode());
        }
        for (const childNode of ele.childNodes) {
          newEle.appendChild(childNode.cloneNode());
        }
        const parent = ele.parentNode;
        if (parent === null) {
          throw new Error("Parent node is null." + this._debugInfo());
        }
        parent.replaceChild(newEle, ele);
        this._domNode = newEle;
        ele = newEle;
      }
      if (namespace !== void 0) {
        ele.setAttributeNS(namespace, name, value);
      } else {
        ele.setAttribute(name, value);
      }
      return this;
    }
    /** @inheritdoc */
    removeAtt(p1, p2) {
      if (!util_2.Guard.isElementNode(this.node)) {
        throw new Error("An attribute can only be removed from an element node.");
      }
      p1 = util_1.getValue(p1);
      if (p2 !== void 0) {
        p2 = util_1.getValue(p2);
      }
      let namespace;
      let name;
      if (p1 !== null && p2 === void 0) {
        name = p1;
      } else if ((p1 === null || util_1.isString(p1)) && p2 !== void 0) {
        namespace = p1;
        name = p2;
      } else {
        throw new Error("Attribute namespace must be a string. " + this._debugInfo());
      }
      if (util_1.isArray(name) || util_1.isSet(name)) {
        util_1.forEachArray(name, (attName) => namespace === void 0 ? this.removeAtt(attName) : this.removeAtt(namespace, attName), this);
      } else if (namespace !== void 0) {
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
        this.node.removeAttributeNS(namespace, name);
      } else {
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        this.node.removeAttribute(name);
      }
      return this;
    }
    /** @inheritdoc */
    txt(content) {
      const child = this._doc.createTextNode(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    /** @inheritdoc */
    com(content) {
      const child = this._doc.createComment(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    /** @inheritdoc */
    dat(content) {
      const child = this._doc.createCDATASection(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
      this.node.appendChild(child);
      return this;
    }
    /** @inheritdoc */
    ins(target2, content = "") {
      if (util_1.isArray(target2) || util_1.isSet(target2)) {
        util_1.forEachArray(target2, (item) => {
          item += "";
          const insIndex = item.indexOf(" ");
          const insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
          const insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
          this.ins(insTarget, insValue);
        }, this);
      } else if (util_1.isMap(target2) || util_1.isObject(target2)) {
        util_1.forEachObject(target2, (insTarget, insValue) => this.ins(insTarget, insValue), this);
      } else {
        const child = this._doc.createProcessingInstruction(dom_1.sanitizeInput(target2, this._options.invalidCharReplacement), dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
      }
      return this;
    }
    /** @inheritdoc */
    dec(options) {
      this._options.version = options.version || "1.0";
      this._options.encoding = options.encoding;
      this._options.standalone = options.standalone;
      return this;
    }
    /** @inheritdoc */
    dtd(options) {
      const name = dom_1.sanitizeInput(options && options.name || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
      const pubID = dom_1.sanitizeInput(options && options.pubID || "", this._options.invalidCharReplacement);
      const sysID = dom_1.sanitizeInput(options && options.sysID || "", this._options.invalidCharReplacement);
      if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
        throw new Error("DocType name does not match document element name.");
      }
      const docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
      if (this._doc.doctype !== null) {
        this._doc.replaceChild(docType, this._doc.doctype);
      } else {
        this._doc.insertBefore(docType, this._doc.documentElement);
      }
      return this;
    }
    /** @inheritdoc */
    import(node2) {
      const hostNode = this._domNode;
      const hostDoc = this._doc;
      const importedNode = node2.node;
      if (util_2.Guard.isDocumentNode(importedNode)) {
        const elementNode = importedNode.documentElement;
        if (elementNode === null) {
          throw new Error("Imported document has no document element node. " + this._debugInfo());
        }
        const clone2 = hostDoc.importNode(elementNode, true);
        hostNode.appendChild(clone2);
      } else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
        for (const childNode of importedNode.childNodes) {
          const clone2 = hostDoc.importNode(childNode, true);
          hostNode.appendChild(clone2);
        }
      } else {
        const clone2 = hostDoc.importNode(importedNode, true);
        hostNode.appendChild(clone2);
      }
      return this;
    }
    /** @inheritdoc */
    doc() {
      if (this._doc._isFragment) {
        let node2 = this.node;
        while (node2 && node2.nodeType !== interfaces_2.NodeType.DocumentFragment) {
          node2 = node2.parentNode;
        }
        if (node2 === null) {
          throw new Error("Node has no parent node while searching for document fragment ancestor.");
        }
        return new XMLBuilderImpl2(node2);
      } else {
        return new XMLBuilderImpl2(this._doc);
      }
    }
    /** @inheritdoc */
    root() {
      const ele = this._doc.documentElement;
      if (!ele) {
        throw new Error("Document root element is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl2(ele);
    }
    /** @inheritdoc */
    up() {
      const parent = this._domNode.parentNode;
      if (!parent) {
        throw new Error("Parent node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl2(parent);
    }
    /** @inheritdoc */
    prev() {
      const node2 = this._domNode.previousSibling;
      if (!node2) {
        throw new Error("Previous sibling node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl2(node2);
    }
    /** @inheritdoc */
    next() {
      const node2 = this._domNode.nextSibling;
      if (!node2) {
        throw new Error("Next sibling node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl2(node2);
    }
    /** @inheritdoc */
    first() {
      const node2 = this._domNode.firstChild;
      if (!node2) {
        throw new Error("First child node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl2(node2);
    }
    /** @inheritdoc */
    last() {
      const node2 = this._domNode.lastChild;
      if (!node2) {
        throw new Error("Last child node is null. " + this._debugInfo());
      }
      return new XMLBuilderImpl2(node2);
    }
    /** @inheritdoc */
    each(callback, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        callback.call(thisArg, new XMLBuilderImpl2(result[0]), result[1], result[2]);
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return this;
    }
    /** @inheritdoc */
    map(callback, self2 = false, recursive = false, thisArg) {
      let result = [];
      this.each((node2, index, level) => result.push(callback.call(thisArg, node2, index, level)), self2, recursive);
      return result;
    }
    /** @inheritdoc */
    reduce(callback, initialValue, self2 = false, recursive = false, thisArg) {
      let value = initialValue;
      this.each((node2, index, level) => value = callback.call(thisArg, value, node2, index, level), self2, recursive);
      return value;
    }
    /** @inheritdoc */
    find(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder2 = new XMLBuilderImpl2(result[0]);
        if (predicate.call(thisArg, builder2, result[1], result[2])) {
          return builder2;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return void 0;
    }
    /** @inheritdoc */
    filter(predicate, self2 = false, recursive = false, thisArg) {
      let result = [];
      this.each((node2, index, level) => {
        if (predicate.call(thisArg, node2, index, level)) {
          result.push(node2);
        }
      }, self2, recursive);
      return result;
    }
    /** @inheritdoc */
    every(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder2 = new XMLBuilderImpl2(result[0]);
        if (!predicate.call(thisArg, builder2, result[1], result[2])) {
          return false;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return true;
    }
    /** @inheritdoc */
    some(predicate, self2 = false, recursive = false, thisArg) {
      let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
      while (result[0]) {
        const builder2 = new XMLBuilderImpl2(result[0]);
        if (predicate.call(thisArg, builder2, result[1], result[2])) {
          return true;
        }
        result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
      }
      return false;
    }
    /** @inheritdoc */
    toArray(self2 = false, recursive = false) {
      let result = [];
      this.each((node2) => result.push(node2), self2, recursive);
      return result;
    }
    /** @inheritdoc */
    toString(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === void 0) {
        writerOptions.format = "xml";
      }
      return this._serialize(writerOptions);
    }
    /** @inheritdoc */
    toObject(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === void 0) {
        writerOptions.format = "object";
      }
      return this._serialize(writerOptions);
    }
    /** @inheritdoc */
    end(writerOptions) {
      writerOptions = writerOptions || {};
      if (writerOptions.format === void 0) {
        writerOptions.format = "xml";
      }
      return this.doc()._serialize(writerOptions);
    }
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param self - whether to visit the current node along with child nodes
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     */
    _getFirstDescendantNode(root, self2, recursive) {
      if (self2)
        return [this._domNode, 0, 0];
      else if (recursive)
        return this._getNextDescendantNode(root, root, recursive, 0, 0);
      else
        return [this._domNode.firstChild, 0, 1];
    }
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param node - current node
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     * @param index - child node index
     * @param level - current depth of the XML tree
     */
    _getNextDescendantNode(root, node2, recursive, index, level) {
      if (recursive) {
        if (node2.firstChild)
          return [node2.firstChild, 0, level + 1];
        if (node2 === root)
          return [null, -1, -1];
        if (node2.nextSibling)
          return [node2.nextSibling, index + 1, level];
        let parent = node2.parentNode;
        while (parent && parent !== root) {
          if (parent.nextSibling)
            return [parent.nextSibling, algorithm_1.tree_index(parent.nextSibling), level - 1];
          parent = parent.parentNode;
          level--;
        }
      } else {
        if (root === node2)
          return [node2.firstChild, 0, level + 1];
        else
          return [node2.nextSibling, index + 1, level];
      }
      return [null, -1, -1];
    }
    /**
     * Converts the node into its string or object representation.
     *
     * @param options - serialization options
     */
    _serialize(writerOptions) {
      if (writerOptions.format === "xml") {
        const writer2 = new writers_1.XMLWriter(this._options);
        return writer2.serialize(this.node, writerOptions);
      } else if (writerOptions.format === "map") {
        const writer2 = new writers_1.MapWriter(this._options);
        return writer2.serialize(this.node, writerOptions);
      } else if (writerOptions.format === "object") {
        const writer2 = new writers_1.ObjectWriter(this._options);
        return writer2.serialize(this.node, writerOptions);
      } else if (writerOptions.format === "json") {
        const writer2 = new writers_1.JSONWriter(this._options);
        return writer2.serialize(this.node, writerOptions);
      } else {
        throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
      }
    }
    /**
     * Creates a dummy element node without adding it to the list of child nodes.
     *
     * Dummy nodes are special nodes representing a node with a `null` value.
     * Dummy nodes are created while recursively building the XML tree. Simply
     * skipping `null` values doesn't work because that would break the recursive
     * chain.
     *
     * @returns the new dummy element node
     */
    _dummy() {
      return new XMLBuilderImpl2(this._doc.createElement("dummy_node"));
    }
    /**
     * Extracts a namespace and name from the given string.
     *
     * @param namespace - namespace
     * @param name - a string containing both a name and namespace separated by an
     * '@' character
     * @param ele - `true` if this is an element namespace; otherwise `false`
     */
    _extractNamespace(namespace, name, ele) {
      const atIndex = name.indexOf("@");
      if (atIndex > 0) {
        if (namespace === void 0)
          namespace = name.slice(atIndex + 1);
        name = name.slice(0, atIndex);
      }
      if (namespace === void 0) {
        namespace = ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att;
      } else if (namespace !== null && namespace[0] === "@") {
        const alias = namespace.slice(1);
        namespace = this._options.namespaceAlias[alias];
        if (namespace === void 0) {
          throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
        }
      }
      return [namespace, name];
    }
    /**
     * Returns the document owning this node.
     */
    get _doc() {
      const node2 = this.node;
      if (util_2.Guard.isDocumentNode(node2)) {
        return node2;
      } else {
        const docNode = node2.ownerDocument;
        if (!docNode)
          throw new Error("Owner document is null. " + this._debugInfo());
        return docNode;
      }
    }
    /**
     * Returns debug information for this node.
     *
     * @param name - node name
     */
    _debugInfo(name) {
      const node2 = this.node;
      const parentNode = node2.parentNode;
      name = name || node2.nodeName;
      const parentName = parentNode ? parentNode.nodeName : "";
      if (!parentName) {
        return "node: <" + name + ">";
      } else {
        return "node: <" + name + ">, parent: <" + parentName + ">";
      }
    }
    /**
     * Gets or sets builder options.
     */
    get _options() {
      const doc = this._doc;
      if (doc._xmlBuilderOptions === void 0) {
        throw new Error("Builder options is not set.");
      }
      return doc._xmlBuilderOptions;
    }
    set _options(value) {
      const doc = this._doc;
      doc._xmlBuilderOptions = value;
    }
  };
  XMLBuilderImpl.XMLBuilderImpl = XMLBuilderImpl$1;
  return XMLBuilderImpl;
}
var XMLBuilderCBImpl = {};
var XMLCBWriter = {};
var BaseCBWriter = {};
var hasRequiredBaseCBWriter;
function requireBaseCBWriter() {
  if (hasRequiredBaseCBWriter) return BaseCBWriter;
  hasRequiredBaseCBWriter = 1;
  Object.defineProperty(BaseCBWriter, "__esModule", { value: true });
  let BaseCBWriter$1 = class BaseCBWriter {
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    constructor(builderOptions) {
      this.level = 0;
      this._builderOptions = builderOptions;
      this._writerOptions = builderOptions;
    }
  };
  BaseCBWriter.BaseCBWriter = BaseCBWriter$1;
  return BaseCBWriter;
}
var hasRequiredXMLCBWriter;
function requireXMLCBWriter() {
  if (hasRequiredXMLCBWriter) return XMLCBWriter;
  hasRequiredXMLCBWriter = 1;
  Object.defineProperty(XMLCBWriter, "__esModule", { value: true });
  const BaseCBWriter_1 = requireBaseCBWriter();
  let XMLCBWriter$1 = class XMLCBWriter extends BaseCBWriter_1.BaseCBWriter {
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    constructor(builderOptions) {
      super(builderOptions);
      this._lineLength = 0;
    }
    /** @inheritdoc */
    declaration(version, encoding, standalone) {
      let markup = this._beginLine() + "<?xml";
      markup += ' version="' + version + '"';
      if (encoding !== void 0) {
        markup += ' encoding="' + encoding + '"';
      }
      if (standalone !== void 0) {
        markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
      }
      markup += "?>";
      return markup;
    }
    /** @inheritdoc */
    docType(name, publicId, systemId) {
      let markup = this._beginLine();
      if (publicId && systemId) {
        markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
      } else if (publicId) {
        markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
      } else if (systemId) {
        markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
      } else {
        markup += "<!DOCTYPE " + name + ">";
      }
      return markup;
    }
    /** @inheritdoc */
    comment(data) {
      return this._beginLine() + "<!--" + data + "-->";
    }
    /** @inheritdoc */
    text(data) {
      return this._beginLine() + data;
    }
    /** @inheritdoc */
    instruction(target2, data) {
      if (data) {
        return this._beginLine() + "<?" + target2 + " " + data + "?>";
      } else {
        return this._beginLine() + "<?" + target2 + "?>";
      }
    }
    /** @inheritdoc */
    cdata(data) {
      return this._beginLine() + "<![CDATA[" + data + "]]>";
    }
    /** @inheritdoc */
    openTagBegin(name) {
      this._lineLength += 1 + name.length;
      return this._beginLine() + "<" + name;
    }
    /** @inheritdoc */
    openTagEnd(name, selfClosing, voidElement) {
      if (voidElement) {
        return " />";
      } else if (selfClosing) {
        if (this._writerOptions.allowEmptyTags) {
          return "></" + name + ">";
        } else if (this._writerOptions.spaceBeforeSlash) {
          return " />";
        } else {
          return "/>";
        }
      } else {
        return ">";
      }
    }
    /** @inheritdoc */
    closeTag(name) {
      return this._beginLine() + "</" + name + ">";
    }
    /** @inheritdoc */
    attribute(name, value) {
      let str = name + '="' + value + '"';
      if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._lineLength + 1 + str.length > this._writerOptions.width) {
        str = this._beginLine() + this._indent(1) + str;
        this._lineLength = str.length;
        return str;
      } else {
        this._lineLength += 1 + str.length;
        return " " + str;
      }
    }
    /** @inheritdoc */
    beginElement(name) {
    }
    /** @inheritdoc */
    endElement(name) {
    }
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    _beginLine() {
      if (this._writerOptions.prettyPrint) {
        const str = (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level);
        this._lineLength = str.length;
        return str;
      } else {
        return "";
      }
    }
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    _indent(level) {
      if (level <= 0) {
        return "";
      } else {
        return this._writerOptions.indent.repeat(level);
      }
    }
  };
  XMLCBWriter.XMLCBWriter = XMLCBWriter$1;
  return XMLCBWriter;
}
var JSONCBWriter = {};
var hasRequiredJSONCBWriter;
function requireJSONCBWriter() {
  if (hasRequiredJSONCBWriter) return JSONCBWriter;
  hasRequiredJSONCBWriter = 1;
  Object.defineProperty(JSONCBWriter, "__esModule", { value: true });
  const BaseCBWriter_1 = requireBaseCBWriter();
  let JSONCBWriter$1 = class JSONCBWriter extends BaseCBWriter_1.BaseCBWriter {
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    constructor(builderOptions) {
      super(builderOptions);
      this._hasChildren = [];
      this._additionalLevel = 0;
    }
    /** @inheritdoc */
    declaration(version, encoding, standalone) {
      return "";
    }
    /** @inheritdoc */
    docType(name, publicId, systemId) {
      return "";
    }
    /** @inheritdoc */
    comment(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.comment) + this._sep() + this._val(data) + this._sep() + "}";
    }
    /** @inheritdoc */
    text(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.text) + this._sep() + this._val(data) + this._sep() + "}";
    }
    /** @inheritdoc */
    instruction(target2, data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.ins) + this._sep() + this._val(data ? target2 + " " + data : target2) + this._sep() + "}";
    }
    /** @inheritdoc */
    cdata(data) {
      return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.cdata) + this._sep() + this._val(data) + this._sep() + "}";
    }
    /** @inheritdoc */
    attribute(name, value) {
      return this._comma() + this._beginLine(1) + "{" + this._sep() + this._key(this._builderOptions.convert.att + name) + this._sep() + this._val(value) + this._sep() + "}";
    }
    /** @inheritdoc */
    openTagBegin(name) {
      let str = this._comma() + this._beginLine() + "{" + this._sep() + this._key(name) + this._sep() + "{";
      this._additionalLevel++;
      this.hasData = true;
      str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[";
      this._hasChildren.push(false);
      return str;
    }
    /** @inheritdoc */
    openTagEnd(name, selfClosing, voidElement) {
      if (selfClosing) {
        let str = this._sep() + "]";
        this._additionalLevel--;
        str += this._beginLine() + "}" + this._sep() + "}";
        return str;
      } else {
        return "";
      }
    }
    /** @inheritdoc */
    closeTag(name) {
      let str = this._beginLine() + "]";
      this._additionalLevel--;
      str += this._beginLine() + "}" + this._sep() + "}";
      return str;
    }
    /** @inheritdoc */
    beginElement(name) {
    }
    /** @inheritdoc */
    endElement(name) {
      this._hasChildren.pop();
    }
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    _beginLine(additionalOffset = 0) {
      if (this._writerOptions.prettyPrint) {
        return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level + additionalOffset);
      } else {
        return "";
      }
    }
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    _indent(level) {
      if (level + this._additionalLevel <= 0) {
        return "";
      } else {
        return this._writerOptions.indent.repeat(level + this._additionalLevel);
      }
    }
    /**
     * Produces a comma before a child node if it has previous siblings.
     */
    _comma() {
      const str = this._hasChildren[this._hasChildren.length - 1] ? "," : "";
      if (this._hasChildren.length > 0) {
        this._hasChildren[this._hasChildren.length - 1] = true;
      }
      return str;
    }
    /**
     * Produces a separator string.
     */
    _sep() {
      return this._writerOptions.prettyPrint ? " " : "";
    }
    /**
     * Produces a JSON key string delimited with double quotes.
     */
    _key(key) {
      return '"' + key + '":';
    }
    /**
     * Produces a JSON value string delimited with double quotes.
     */
    _val(val) {
      return '"' + val + '"';
    }
  };
  JSONCBWriter.JSONCBWriter = JSONCBWriter$1;
  return JSONCBWriter;
}
var hasRequiredXMLBuilderCBImpl;
function requireXMLBuilderCBImpl() {
  if (hasRequiredXMLBuilderCBImpl) return XMLBuilderCBImpl;
  hasRequiredXMLBuilderCBImpl = 1;
  Object.defineProperty(XMLBuilderCBImpl, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$3();
  const util_1 = requireLib$a();
  const __1 = requireLib$3();
  const algorithm_1 = requireAlgorithm();
  const infra_1 = requireLib$8();
  const NamespacePrefixMap_1 = requireNamespacePrefixMap();
  const LocalNameSet_1 = requireLocalNameSet();
  const util_2 = requireUtil$1();
  const XMLCBWriter_1 = requireXMLCBWriter();
  const JSONCBWriter_1 = requireJSONCBWriter();
  const events_1 = require$$2$3;
  let XMLBuilderCBImpl$1 = class XMLBuilderCBImpl2 extends events_1.EventEmitter {
    /**
     * Initializes a new instance of `XMLStream`.
     *
     * @param options - stream writer options
     * @param fragment - whether to create fragment stream or a document stream
     *
     * @returns XML stream
     */
    constructor(options, fragment = false) {
      super();
      this._hasDeclaration = false;
      this._docTypeName = "";
      this._hasDocumentElement = false;
      this._currentElementSerialized = false;
      this._openTags = [];
      this._ended = false;
      this._fragment = fragment;
      this._options = util_1.applyDefaults(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);
      this._builderOptions = {
        defaultNamespace: this._options.defaultNamespace,
        namespaceAlias: this._options.namespaceAlias
      };
      this._writer = this._options.format === "xml" ? new XMLCBWriter_1.XMLCBWriter(this._options) : new JSONCBWriter_1.JSONCBWriter(this._options);
      if (this._options.data !== void 0) {
        this.on("data", this._options.data);
      }
      if (this._options.end !== void 0) {
        this.on("end", this._options.end);
      }
      if (this._options.error !== void 0) {
        this.on("error", this._options.error);
      }
      this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
      this._prefixMap.set("xml", infra_1.namespace.XML);
      this._prefixIndex = { value: 1 };
    }
    /** @inheritdoc */
    ele(p1, p2, p3) {
      if (util_1.isObject(p1) || util_1.isString(p1) && (/^\s*</.test(p1) || /^\s*[\{\[]/.test(p1))) {
        const frag = __1.fragment().set(this._options);
        try {
          frag.ele(p1);
        } catch (err) {
          this.emit("error", err);
          return this;
        }
        for (const node2 of frag.node.childNodes) {
          this._fromNode(node2);
        }
        return this;
      }
      this._serializeOpenTag(true);
      if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {
        this.emit("error", new Error("Document cannot have multiple document element nodes."));
        return this;
      }
      try {
        this._currentElement = __1.fragment(this._builderOptions).ele(p1, p2, p3);
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== "" && this._currentElement.node._qualifiedName !== this._docTypeName) {
        this.emit("error", new Error("Document element name does not match DocType declaration name."));
        return this;
      }
      this._currentElementSerialized = false;
      if (!this._fragment) {
        this._hasDocumentElement = true;
      }
      return this;
    }
    /** @inheritdoc */
    att(p1, p2, p3) {
      if (this._currentElement === void 0) {
        this.emit("error", new Error("Cannot insert an attribute node as child of a document node."));
        return this;
      }
      try {
        this._currentElement.att(p1, p2, p3);
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      return this;
    }
    /** @inheritdoc */
    com(content) {
      this._serializeOpenTag(true);
      let node2;
      try {
        node2 = __1.fragment(this._builderOptions).com(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node2.data) || node2.data.indexOf("--") !== -1 || node2.data.endsWith("-"))) {
        this.emit("error", new Error("Comment data contains invalid characters (well-formed required)."));
        return this;
      }
      this._push(this._writer.comment(node2.data));
      return this;
    }
    /** @inheritdoc */
    txt(content) {
      if (!this._fragment && this._currentElement === void 0) {
        this.emit("error", new Error("Cannot insert a text node as child of a document node."));
        return this;
      }
      this._serializeOpenTag(true);
      let node2;
      try {
        node2 = __1.fragment(this._builderOptions).txt(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node2.data)) {
        this.emit("error", new Error("Text data contains invalid characters (well-formed required)."));
        return this;
      }
      let markup = "";
      if (this._options.noDoubleEncoding) {
        markup = node2.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      } else {
        for (let i = 0; i < node2.data.length; i++) {
          const c = node2.data[i];
          if (c === "&")
            markup += "&amp;";
          else if (c === "<")
            markup += "&lt;";
          else if (c === ">")
            markup += "&gt;";
          else
            markup += c;
        }
      }
      this._push(this._writer.text(markup));
      return this;
    }
    /** @inheritdoc */
    ins(target2, content = "") {
      this._serializeOpenTag(true);
      let node2;
      try {
        node2 = __1.fragment(this._builderOptions).ins(target2, content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && (node2.target.indexOf(":") !== -1 || /^xml$/i.test(node2.target))) {
        this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required)."));
        return this;
      }
      if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node2.data)) {
        this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required)."));
        return this;
      }
      this._push(this._writer.instruction(node2.target, node2.data));
      return this;
    }
    /** @inheritdoc */
    dat(content) {
      this._serializeOpenTag(true);
      let node2;
      try {
        node2 = __1.fragment(this._builderOptions).dat(content).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      this._push(this._writer.cdata(node2.data));
      return this;
    }
    /** @inheritdoc */
    dec(options = { version: "1.0" }) {
      if (this._fragment) {
        this.emit("error", Error("Cannot insert an XML declaration into a document fragment."));
        return this;
      }
      if (this._hasDeclaration) {
        this.emit("error", Error("XML declaration is already inserted."));
        return this;
      }
      this._push(this._writer.declaration(options.version || "1.0", options.encoding, options.standalone));
      this._hasDeclaration = true;
      return this;
    }
    /** @inheritdoc */
    dtd(options) {
      if (this._fragment) {
        this.emit("error", Error("Cannot insert a DocType declaration into a document fragment."));
        return this;
      }
      if (this._docTypeName !== "") {
        this.emit("error", new Error("DocType declaration is already inserted."));
        return this;
      }
      if (this._hasDocumentElement) {
        this.emit("error", new Error("Cannot insert DocType declaration after document element."));
        return this;
      }
      let node2;
      try {
        node2 = __1.create().dtd(options).first().node;
      } catch (err) {
        this.emit("error", err);
        return this;
      }
      if (this._options.wellFormed && !algorithm_1.xml_isPubidChar(node2.publicId)) {
        this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required)."));
        return this;
      }
      if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node2.systemId) || node2.systemId.indexOf('"') !== -1 && node2.systemId.indexOf("'") !== -1)) {
        this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required)."));
        return this;
      }
      this._docTypeName = options.name;
      this._push(this._writer.docType(options.name, node2.publicId, node2.systemId));
      return this;
    }
    /** @inheritdoc */
    up() {
      this._serializeOpenTag(false);
      this._serializeCloseTag();
      return this;
    }
    /** @inheritdoc */
    end() {
      this._serializeOpenTag(false);
      while (this._openTags.length > 0) {
        this._serializeCloseTag();
      }
      this._push(null);
      return this;
    }
    /**
     * Serializes the opening tag of an element node.
     *
     * @param hasChildren - whether the element node has child nodes
     */
    _serializeOpenTag(hasChildren) {
      if (this._currentElementSerialized)
        return;
      if (this._currentElement === void 0)
        return;
      const node2 = this._currentElement.node;
      if (this._options.wellFormed && (node2.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node2.localName))) {
        this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
        return;
      }
      let qualifiedName = "";
      let ignoreNamespaceDefinitionAttribute = false;
      let map2 = this._prefixMap.copy();
      let localPrefixesMap = {};
      let localDefaultNamespace = this._recordNamespaceInformation(node2, map2, localPrefixesMap);
      let inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];
      let ns = node2.namespaceURI;
      if (ns === null)
        ns = inheritedNS;
      if (inheritedNS === ns) {
        if (localDefaultNamespace !== null) {
          ignoreNamespaceDefinitionAttribute = true;
        }
        if (ns === infra_1.namespace.XML) {
          qualifiedName = "xml:" + node2.localName;
        } else {
          qualifiedName = node2.localName;
        }
        this._writer.beginElement(qualifiedName);
        this._push(this._writer.openTagBegin(qualifiedName));
      } else {
        let prefix = node2.prefix;
        let candidatePrefix = null;
        if (prefix !== null || ns !== localDefaultNamespace) {
          candidatePrefix = map2.get(prefix, ns);
        }
        if (prefix === "xmlns") {
          if (this._options.wellFormed) {
            this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
            return;
          }
          candidatePrefix = prefix;
        }
        if (candidatePrefix !== null) {
          qualifiedName = candidatePrefix + ":" + node2.localName;
          if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
            inheritedNS = localDefaultNamespace || null;
          }
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
        } else if (prefix !== null) {
          if (prefix in localPrefixesMap) {
            prefix = this._generatePrefix(ns, map2, this._prefixIndex);
          }
          map2.set(prefix, ns);
          qualifiedName += prefix + ":" + node2.localName;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
          this._push(this._writer.attribute("xmlns:" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));
          if (localDefaultNamespace !== null) {
            inheritedNS = localDefaultNamespace || null;
          }
        } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
          ignoreNamespaceDefinitionAttribute = true;
          qualifiedName += node2.localName;
          inheritedNS = ns;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
          this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(ns, this._options.wellFormed)));
        } else {
          qualifiedName += node2.localName;
          inheritedNS = ns;
          this._writer.beginElement(qualifiedName);
          this._push(this._writer.openTagBegin(qualifiedName));
        }
      }
      this._serializeAttributes(node2, map2, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);
      const isHTML = ns === infra_1.namespace.HTML;
      if (isHTML && !hasChildren && XMLBuilderCBImpl2._VoidElementNames.has(node2.localName)) {
        this._push(this._writer.openTagEnd(qualifiedName, true, true));
        this._writer.endElement(qualifiedName);
      } else if (!isHTML && !hasChildren) {
        this._push(this._writer.openTagEnd(qualifiedName, true, false));
        this._writer.endElement(qualifiedName);
      } else {
        this._push(this._writer.openTagEnd(qualifiedName, false, false));
      }
      this._currentElementSerialized = true;
      this._openTags.push([qualifiedName, inheritedNS, this._prefixMap, hasChildren]);
      if (this._isPrefixMapModified(this._prefixMap, map2)) {
        this._prefixMap = map2;
      }
      this._writer.level++;
    }
    /**
     * Serializes the closing tag of an element node.
     */
    _serializeCloseTag() {
      this._writer.level--;
      const lastEle = this._openTags.pop();
      if (lastEle === void 0) {
        this.emit("error", new Error("Last element is undefined."));
        return;
      }
      const [qualifiedName, ns, map2, hasChildren] = lastEle;
      this._prefixMap = map2;
      if (!hasChildren)
        return;
      this._push(this._writer.closeTag(qualifiedName));
      this._writer.endElement(qualifiedName);
    }
    /**
     * Pushes data to internal buffer.
     *
     * @param data - data
     */
    _push(data) {
      if (data === null) {
        this._ended = true;
        this.emit("end");
      } else if (this._ended) {
        this.emit("error", new Error("Cannot push to ended stream."));
      } else if (data.length !== 0) {
        this._writer.hasData = true;
        this.emit("data", data, this._writer.level);
      }
    }
    /**
     * Reads and serializes an XML tree.
     *
     * @param node - root node
     */
    _fromNode(node2) {
      if (util_2.Guard.isElementNode(node2)) {
        const name = node2.prefix ? node2.prefix + ":" + node2.localName : node2.localName;
        if (node2.namespaceURI !== null) {
          this.ele(node2.namespaceURI, name);
        } else {
          this.ele(name);
        }
        for (const attr of node2.attributes) {
          const name2 = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
          if (attr.namespaceURI !== null) {
            this.att(attr.namespaceURI, name2, attr.value);
          } else {
            this.att(name2, attr.value);
          }
        }
        for (const child of node2.childNodes) {
          this._fromNode(child);
        }
        this.up();
      } else if (util_2.Guard.isExclusiveTextNode(node2) && node2.data) {
        this.txt(node2.data);
      } else if (util_2.Guard.isCommentNode(node2)) {
        this.com(node2.data);
      } else if (util_2.Guard.isCDATASectionNode(node2)) {
        this.dat(node2.data);
      } else if (util_2.Guard.isProcessingInstructionNode(node2)) {
        this.ins(node2.target, node2.data);
      }
    }
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
     */
    _serializeAttributes(node2, map2, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
      const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : void 0;
      for (const attr of node2.attributes) {
        if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
          this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
          continue;
        }
        if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
          this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
          return;
        }
        if (requireWellFormed && localNameSet)
          localNameSet.set(attr.namespaceURI, attr.localName);
        let attributeNamespace = attr.namespaceURI;
        let candidatePrefix = null;
        if (attributeNamespace !== null) {
          candidatePrefix = map2.get(attr.prefix, attributeNamespace);
          if (attributeNamespace === infra_1.namespace.XMLNS) {
            if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map2.has(attr.localName, attr.value))
              continue;
            if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
              this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
              return;
            }
            if (requireWellFormed && attr.value === "") {
              this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
              return;
            }
            if (attr.prefix === "xmlns")
              candidatePrefix = "xmlns";
          } else if (candidatePrefix === null) {
            if (attr.prefix !== null && (!map2.hasPrefix(attr.prefix) || map2.has(attr.prefix, attributeNamespace))) {
              candidatePrefix = attr.prefix;
            } else {
              candidatePrefix = this._generatePrefix(attributeNamespace, map2, prefixIndex);
            }
            this._push(this._writer.attribute("xmlns:" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));
          }
        }
        if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
          this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
          return;
        }
        this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + ":" : "") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
      }
    }
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    _serializeAttributeValue(value, requireWellFormed) {
      if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
        this.emit("error", new Error("Invalid characters in attribute value."));
        return "";
      }
      if (value === null)
        return "";
      if (this._options.noDoubleEncoding) {
        return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      } else {
        let result = "";
        for (let i = 0; i < value.length; i++) {
          const c = value[i];
          if (c === '"')
            result += "&quot;";
          else if (c === "&")
            result += "&amp;";
          else if (c === "<")
            result += "&lt;";
          else if (c === ">")
            result += "&gt;";
          else
            result += c;
        }
        return result;
      }
    }
    /**
     * Records namespace information for the given element and returns the
     * default namespace attribute value.
     *
     * @param node - element node to process
     * @param map - namespace prefix map
     * @param localPrefixesMap - local prefixes map
     */
    _recordNamespaceInformation(node2, map2, localPrefixesMap) {
      let defaultNamespaceAttrValue = null;
      for (const attr of node2.attributes) {
        let attributeNamespace = attr.namespaceURI;
        let attributePrefix = attr.prefix;
        if (attributeNamespace === infra_1.namespace.XMLNS) {
          if (attributePrefix === null) {
            defaultNamespaceAttrValue = attr.value;
            continue;
          } else {
            let prefixDefinition = attr.localName;
            let namespaceDefinition = attr.value;
            if (namespaceDefinition === infra_1.namespace.XML) {
              continue;
            }
            if (namespaceDefinition === "") {
              namespaceDefinition = null;
            }
            if (map2.has(prefixDefinition, namespaceDefinition)) {
              continue;
            }
            map2.set(prefixDefinition, namespaceDefinition);
            localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
          }
        }
      }
      return defaultNamespaceAttrValue;
    }
    /**
     * Generates a new prefix for the given namespace.
     *
     * @param newNamespace - a namespace to generate prefix for
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     */
    _generatePrefix(newNamespace, prefixMap, prefixIndex) {
      let generatedPrefix = "ns" + prefixIndex.value;
      prefixIndex.value++;
      prefixMap.set(generatedPrefix, newNamespace);
      return generatedPrefix;
    }
    /**
     * Determines if the namespace prefix map was modified from its original.
     *
     * @param originalMap - original namespace prefix map
     * @param newMap - new namespace prefix map
     */
    _isPrefixMapModified(originalMap, newMap) {
      const items1 = originalMap._items;
      const items2 = newMap._items;
      const nullItems1 = originalMap._nullItems;
      const nullItems2 = newMap._nullItems;
      for (const key in items2) {
        const arr1 = items1[key];
        if (arr1 === void 0)
          return true;
        const arr2 = items2[key];
        if (arr1.length !== arr2.length)
          return true;
        for (let i = 0; i < arr1.length; i++) {
          if (arr1[i] !== arr2[i])
            return true;
        }
      }
      if (nullItems1.length !== nullItems2.length)
        return true;
      for (let i = 0; i < nullItems1.length; i++) {
        if (nullItems1[i] !== nullItems2[i])
          return true;
      }
      return false;
    }
  };
  XMLBuilderCBImpl.XMLBuilderCBImpl = XMLBuilderCBImpl$1;
  XMLBuilderCBImpl$1._VoidElementNames = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  return XMLBuilderCBImpl;
}
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", { value: true });
  var XMLBuilderImpl_1 = requireXMLBuilderImpl();
  builder.XMLBuilderImpl = XMLBuilderImpl_1.XMLBuilderImpl;
  var XMLBuilderCBImpl_1 = requireXMLBuilderCBImpl();
  builder.XMLBuilderCBImpl = XMLBuilderCBImpl_1.XMLBuilderCBImpl;
  return builder;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$b;
  hasRequiredLib$3 = 1;
  Object.defineProperty(lib$b, "__esModule", { value: true });
  const interfaces_1 = requireInterfaces$3();
  const util_1 = requireLib$a();
  const util_2 = requireUtil$1();
  const builder_1 = requireBuilder();
  const dom_1 = requireDom();
  const util_3 = require$$1$3;
  const builder_2 = requireBuilder();
  function builder2(p1, p2) {
    const options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const nodes2 = util_2.Guard.isNode(p1) || util_3.isArray(p1) ? p1 : p2;
    if (nodes2 === void 0) {
      throw new Error("Invalid arguments.");
    }
    if (util_3.isArray(nodes2)) {
      const builders = [];
      for (let i = 0; i < nodes2.length; i++) {
        const builder3 = new builder_1.XMLBuilderImpl(nodes2[i]);
        builder3.set(options);
        builders.push(builder3);
      }
      return builders;
    } else {
      const builder3 = new builder_1.XMLBuilderImpl(nodes2);
      builder3.set(options);
      return builder3;
    }
  }
  lib$b.builder = builder2;
  function create(p1, p2) {
    const options = formatBuilderOptions(p1 === void 0 || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    let builder3;
    if (contents === void 0) {
      const doc = dom_1.createDocument();
      builder3 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
    } else if (util_1.isObject(contents)) {
      const doc = dom_1.createDocument();
      builder3 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
      builder3.ele(contents);
    } else if (/^\s*</.test(contents)) {
      const domParser2 = dom_1.createParser();
      const doc = domParser2.parseFromString(dom_1.sanitizeInput(contents, options.invalidCharReplacement), "text/xml");
      dom_1.throwIfParserError(doc);
      builder3 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
    } else {
      const doc = dom_1.createDocument();
      builder3 = new builder_1.XMLBuilderImpl(doc);
      setOptions(doc, options);
      const obj = JSON.parse(contents);
      builder3.ele(obj);
    }
    return builder3;
  }
  lib$b.create = create;
  function fragment(p1, p2) {
    const options = formatBuilderOptions(p1 === void 0 || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    let builder3;
    if (contents === void 0) {
      const doc = dom_1.createDocument();
      setOptions(doc, options, true);
      builder3 = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
    } else if (util_1.isObject(contents)) {
      const doc = dom_1.createDocument();
      setOptions(doc, options, true);
      builder3 = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
      builder3.ele(contents);
    } else if (/^\s*</.test(contents)) {
      const domParser2 = dom_1.createParser();
      const doc = domParser2.parseFromString("<TEMP_ROOT>" + dom_1.sanitizeInput(contents, options.invalidCharReplacement) + "</TEMP_ROOT>", "text/xml");
      dom_1.throwIfParserError(doc);
      setOptions(doc, options, true);
      if (doc.documentElement === null) {
        throw new Error("Document element is null.");
      }
      const frag = doc.createDocumentFragment();
      for (const child of doc.documentElement.childNodes) {
        const newChild = doc.importNode(child, true);
        frag.appendChild(newChild);
      }
      builder3 = new builder_1.XMLBuilderImpl(frag);
    } else {
      const doc = dom_1.createDocument();
      setOptions(doc, options, true);
      builder3 = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
      const obj = JSON.parse(contents);
      builder3.ele(obj);
    }
    return builder3;
  }
  lib$b.fragment = fragment;
  function convert2(p1, p2, p3) {
    let builderOptions;
    let contents;
    let convertOptions;
    if (isXMLBuilderCreateOptions(p1) && p2 !== void 0) {
      builderOptions = p1;
      contents = p2;
      convertOptions = p3;
    } else {
      builderOptions = interfaces_1.DefaultBuilderOptions;
      contents = p1;
      convertOptions = p2 || void 0;
    }
    return create(builderOptions, contents).end(convertOptions);
  }
  lib$b.convert = convert2;
  function createCB(options) {
    return new builder_2.XMLBuilderCBImpl(options);
  }
  lib$b.createCB = createCB;
  function fragmentCB(options) {
    return new builder_2.XMLBuilderCBImpl(options, true);
  }
  lib$b.fragmentCB = fragmentCB;
  function isXMLBuilderCreateOptions(obj) {
    if (!util_1.isPlainObject(obj))
      return false;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (!interfaces_1.XMLBuilderOptionKeys.has(key))
          return false;
      }
    }
    return true;
  }
  function formatBuilderOptions(createOptions = {}) {
    const options = util_1.applyDefaults(createOptions, interfaces_1.DefaultBuilderOptions);
    if (options.convert.att.length === 0 || options.convert.ins.length === 0 || options.convert.text.length === 0 || options.convert.cdata.length === 0 || options.convert.comment.length === 0) {
      throw new Error("JS object converter strings cannot be zero length.");
    }
    return options;
  }
  function setOptions(doc, options, isFragment) {
    const docWithSettings = doc;
    docWithSettings._xmlBuilderOptions = options;
    docWithSettings._isFragment = isFragment;
  }
  return lib$b;
}
var libExports = requireLib$3();
var ent = {};
var punycode$1 = { exports: {} };
var punycode = punycode$1.exports;
var hasRequiredPunycode;
function requirePunycode() {
  if (hasRequiredPunycode) return punycode$1.exports;
  hasRequiredPunycode = 1;
  (function(module, exports$1) {
    (function(root) {
      var freeExports = exports$1 && !exports$1.nodeType && exports$1;
      var freeModule = module && !module.nodeType && module;
      var freeGlobal = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors2 = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor2 = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type2) {
        throw new RangeError(errors2[type2]);
      }
      function map2(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map2(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta2, numPoints, firstTime) {
        var k = 0;
        delta2 = firstTime ? floor2(delta2 / damp) : delta2 >> 1;
        delta2 += floor2(delta2 / numPoints);
        for (; delta2 > baseMinusTMin * tMax >> 1; k += base) {
          delta2 = floor2(delta2 / baseMinusTMin);
        }
        return floor2(k + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
      }
      function decode2(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor2((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor2(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor2(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor2(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode2(input) {
        var n, delta2, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta2 = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor2((maxInt - delta2) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta2 += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta2 > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta2, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor2(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
              delta2 = 0;
              ++handledCPCount;
            }
          }
          ++delta2;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode2,
        "encode": encode2,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root.punycode = punycode2;
      }
    })(punycode);
  })(punycode$1, punycode$1.exports);
  return punycode$1.exports;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range$2;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range$2;
  hasRequiredRange = 1;
  range$2 = RangeError;
  return range$2;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign$1;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign$1;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign$1 = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign$1;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target2 = this;
    if (typeof target2 !== "function" || toStr.apply(target2) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target2);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target2.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target2.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target2.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target2.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target2.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part2 = parts[i];
      var first = $strSlice(part2, 0, 1);
      var last = $strSlice(part2, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part2 === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part2;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part2 in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part2);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part2];
          }
        } else {
          isOwn = hasOwn(value, part2);
          value = value[part2];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var hasToStringTag = requireShams()();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var fn;
  if (hasToStringTag) {
    var $exec = callBound2("RegExp.prototype.exec");
    var isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    var badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn = function isRegex2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD2(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      );
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    var $toString = callBound2("Object.prototype.toString");
    var regexClass = "[object RegExp]";
    fn = function isRegex2(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  isRegex = fn;
  return isRegex;
}
var safeRegexTest;
var hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var isRegex2 = requireIsRegex();
  var $exec = callBound2("RegExp.prototype.exec");
  var $TypeError = /* @__PURE__ */ requireType();
  safeRegexTest = function regexTester(regex) {
    if (!isRegex2(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
  return safeRegexTest;
}
const require$$3$1 = {
  "9": "Tab;",
  "10": "NewLine;",
  "33": "excl;",
  "34": "quot;",
  "35": "num;",
  "36": "dollar;",
  "37": "percnt;",
  "38": "amp;",
  "39": "apos;",
  "40": "lpar;",
  "41": "rpar;",
  "42": "midast;",
  "43": "plus;",
  "44": "comma;",
  "46": "period;",
  "47": "sol;",
  "58": "colon;",
  "59": "semi;",
  "60": "lt;",
  "61": "equals;",
  "62": "gt;",
  "63": "quest;",
  "64": "commat;",
  "91": "lsqb;",
  "92": "bsol;",
  "93": "rsqb;",
  "94": "Hat;",
  "95": "UnderBar;",
  "96": "grave;",
  "123": "lcub;",
  "124": "VerticalLine;",
  "125": "rcub;",
  "160": "NonBreakingSpace;",
  "161": "iexcl;",
  "162": "cent;",
  "163": "pound;",
  "164": "curren;",
  "165": "yen;",
  "166": "brvbar;",
  "167": "sect;",
  "168": "uml;",
  "169": "copy;",
  "170": "ordf;",
  "171": "laquo;",
  "172": "not;",
  "173": "shy;",
  "174": "reg;",
  "175": "strns;",
  "176": "deg;",
  "177": "pm;",
  "178": "sup2;",
  "179": "sup3;",
  "180": "DiacriticalAcute;",
  "181": "micro;",
  "182": "para;",
  "183": "middot;",
  "184": "Cedilla;",
  "185": "sup1;",
  "186": "ordm;",
  "187": "raquo;",
  "188": "frac14;",
  "189": "half;",
  "190": "frac34;",
  "191": "iquest;",
  "192": "Agrave;",
  "193": "Aacute;",
  "194": "Acirc;",
  "195": "Atilde;",
  "196": "Auml;",
  "197": "Aring;",
  "198": "AElig;",
  "199": "Ccedil;",
  "200": "Egrave;",
  "201": "Eacute;",
  "202": "Ecirc;",
  "203": "Euml;",
  "204": "Igrave;",
  "205": "Iacute;",
  "206": "Icirc;",
  "207": "Iuml;",
  "208": "ETH;",
  "209": "Ntilde;",
  "210": "Ograve;",
  "211": "Oacute;",
  "212": "Ocirc;",
  "213": "Otilde;",
  "214": "Ouml;",
  "215": "times;",
  "216": "Oslash;",
  "217": "Ugrave;",
  "218": "Uacute;",
  "219": "Ucirc;",
  "220": "Uuml;",
  "221": "Yacute;",
  "222": "THORN;",
  "223": "szlig;",
  "224": "agrave;",
  "225": "aacute;",
  "226": "acirc;",
  "227": "atilde;",
  "228": "auml;",
  "229": "aring;",
  "230": "aelig;",
  "231": "ccedil;",
  "232": "egrave;",
  "233": "eacute;",
  "234": "ecirc;",
  "235": "euml;",
  "236": "igrave;",
  "237": "iacute;",
  "238": "icirc;",
  "239": "iuml;",
  "240": "eth;",
  "241": "ntilde;",
  "242": "ograve;",
  "243": "oacute;",
  "244": "ocirc;",
  "245": "otilde;",
  "246": "ouml;",
  "247": "divide;",
  "248": "oslash;",
  "249": "ugrave;",
  "250": "uacute;",
  "251": "ucirc;",
  "252": "uuml;",
  "253": "yacute;",
  "254": "thorn;",
  "255": "yuml;",
  "256": "Amacr;",
  "257": "amacr;",
  "258": "Abreve;",
  "259": "abreve;",
  "260": "Aogon;",
  "261": "aogon;",
  "262": "Cacute;",
  "263": "cacute;",
  "264": "Ccirc;",
  "265": "ccirc;",
  "266": "Cdot;",
  "267": "cdot;",
  "268": "Ccaron;",
  "269": "ccaron;",
  "270": "Dcaron;",
  "271": "dcaron;",
  "272": "Dstrok;",
  "273": "dstrok;",
  "274": "Emacr;",
  "275": "emacr;",
  "278": "Edot;",
  "279": "edot;",
  "280": "Eogon;",
  "281": "eogon;",
  "282": "Ecaron;",
  "283": "ecaron;",
  "284": "Gcirc;",
  "285": "gcirc;",
  "286": "Gbreve;",
  "287": "gbreve;",
  "288": "Gdot;",
  "289": "gdot;",
  "290": "Gcedil;",
  "292": "Hcirc;",
  "293": "hcirc;",
  "294": "Hstrok;",
  "295": "hstrok;",
  "296": "Itilde;",
  "297": "itilde;",
  "298": "Imacr;",
  "299": "imacr;",
  "302": "Iogon;",
  "303": "iogon;",
  "304": "Idot;",
  "305": "inodot;",
  "306": "IJlig;",
  "307": "ijlig;",
  "308": "Jcirc;",
  "309": "jcirc;",
  "310": "Kcedil;",
  "311": "kcedil;",
  "312": "kgreen;",
  "313": "Lacute;",
  "314": "lacute;",
  "315": "Lcedil;",
  "316": "lcedil;",
  "317": "Lcaron;",
  "318": "lcaron;",
  "319": "Lmidot;",
  "320": "lmidot;",
  "321": "Lstrok;",
  "322": "lstrok;",
  "323": "Nacute;",
  "324": "nacute;",
  "325": "Ncedil;",
  "326": "ncedil;",
  "327": "Ncaron;",
  "328": "ncaron;",
  "329": "napos;",
  "330": "ENG;",
  "331": "eng;",
  "332": "Omacr;",
  "333": "omacr;",
  "336": "Odblac;",
  "337": "odblac;",
  "338": "OElig;",
  "339": "oelig;",
  "340": "Racute;",
  "341": "racute;",
  "342": "Rcedil;",
  "343": "rcedil;",
  "344": "Rcaron;",
  "345": "rcaron;",
  "346": "Sacute;",
  "347": "sacute;",
  "348": "Scirc;",
  "349": "scirc;",
  "350": "Scedil;",
  "351": "scedil;",
  "352": "Scaron;",
  "353": "scaron;",
  "354": "Tcedil;",
  "355": "tcedil;",
  "356": "Tcaron;",
  "357": "tcaron;",
  "358": "Tstrok;",
  "359": "tstrok;",
  "360": "Utilde;",
  "361": "utilde;",
  "362": "Umacr;",
  "363": "umacr;",
  "364": "Ubreve;",
  "365": "ubreve;",
  "366": "Uring;",
  "367": "uring;",
  "368": "Udblac;",
  "369": "udblac;",
  "370": "Uogon;",
  "371": "uogon;",
  "372": "Wcirc;",
  "373": "wcirc;",
  "374": "Ycirc;",
  "375": "ycirc;",
  "376": "Yuml;",
  "377": "Zacute;",
  "378": "zacute;",
  "379": "Zdot;",
  "380": "zdot;",
  "381": "Zcaron;",
  "382": "zcaron;",
  "402": "fnof;",
  "437": "imped;",
  "501": "gacute;",
  "567": "jmath;",
  "710": "circ;",
  "711": "Hacek;",
  "728": "breve;",
  "729": "dot;",
  "730": "ring;",
  "731": "ogon;",
  "732": "tilde;",
  "733": "DiacriticalDoubleAcute;",
  "785": "DownBreve;",
  "913": "Alpha;",
  "914": "Beta;",
  "915": "Gamma;",
  "916": "Delta;",
  "917": "Epsilon;",
  "918": "Zeta;",
  "919": "Eta;",
  "920": "Theta;",
  "921": "Iota;",
  "922": "Kappa;",
  "923": "Lambda;",
  "924": "Mu;",
  "925": "Nu;",
  "926": "Xi;",
  "927": "Omicron;",
  "928": "Pi;",
  "929": "Rho;",
  "931": "Sigma;",
  "932": "Tau;",
  "933": "Upsilon;",
  "934": "Phi;",
  "935": "Chi;",
  "936": "Psi;",
  "937": "Omega;",
  "945": "alpha;",
  "946": "beta;",
  "947": "gamma;",
  "948": "delta;",
  "949": "epsilon;",
  "950": "zeta;",
  "951": "eta;",
  "952": "theta;",
  "953": "iota;",
  "954": "kappa;",
  "955": "lambda;",
  "956": "mu;",
  "957": "nu;",
  "958": "xi;",
  "959": "omicron;",
  "960": "pi;",
  "961": "rho;",
  "962": "varsigma;",
  "963": "sigma;",
  "964": "tau;",
  "965": "upsilon;",
  "966": "phi;",
  "967": "chi;",
  "968": "psi;",
  "969": "omega;",
  "977": "vartheta;",
  "978": "upsih;",
  "981": "varphi;",
  "982": "varpi;",
  "988": "Gammad;",
  "989": "gammad;",
  "1008": "varkappa;",
  "1009": "varrho;",
  "1013": "varepsilon;",
  "1014": "bepsi;",
  "1025": "IOcy;",
  "1026": "DJcy;",
  "1027": "GJcy;",
  "1028": "Jukcy;",
  "1029": "DScy;",
  "1030": "Iukcy;",
  "1031": "YIcy;",
  "1032": "Jsercy;",
  "1033": "LJcy;",
  "1034": "NJcy;",
  "1035": "TSHcy;",
  "1036": "KJcy;",
  "1038": "Ubrcy;",
  "1039": "DZcy;",
  "1040": "Acy;",
  "1041": "Bcy;",
  "1042": "Vcy;",
  "1043": "Gcy;",
  "1044": "Dcy;",
  "1045": "IEcy;",
  "1046": "ZHcy;",
  "1047": "Zcy;",
  "1048": "Icy;",
  "1049": "Jcy;",
  "1050": "Kcy;",
  "1051": "Lcy;",
  "1052": "Mcy;",
  "1053": "Ncy;",
  "1054": "Ocy;",
  "1055": "Pcy;",
  "1056": "Rcy;",
  "1057": "Scy;",
  "1058": "Tcy;",
  "1059": "Ucy;",
  "1060": "Fcy;",
  "1061": "KHcy;",
  "1062": "TScy;",
  "1063": "CHcy;",
  "1064": "SHcy;",
  "1065": "SHCHcy;",
  "1066": "HARDcy;",
  "1067": "Ycy;",
  "1068": "SOFTcy;",
  "1069": "Ecy;",
  "1070": "YUcy;",
  "1071": "YAcy;",
  "1072": "acy;",
  "1073": "bcy;",
  "1074": "vcy;",
  "1075": "gcy;",
  "1076": "dcy;",
  "1077": "iecy;",
  "1078": "zhcy;",
  "1079": "zcy;",
  "1080": "icy;",
  "1081": "jcy;",
  "1082": "kcy;",
  "1083": "lcy;",
  "1084": "mcy;",
  "1085": "ncy;",
  "1086": "ocy;",
  "1087": "pcy;",
  "1088": "rcy;",
  "1089": "scy;",
  "1090": "tcy;",
  "1091": "ucy;",
  "1092": "fcy;",
  "1093": "khcy;",
  "1094": "tscy;",
  "1095": "chcy;",
  "1096": "shcy;",
  "1097": "shchcy;",
  "1098": "hardcy;",
  "1099": "ycy;",
  "1100": "softcy;",
  "1101": "ecy;",
  "1102": "yucy;",
  "1103": "yacy;",
  "1105": "iocy;",
  "1106": "djcy;",
  "1107": "gjcy;",
  "1108": "jukcy;",
  "1109": "dscy;",
  "1110": "iukcy;",
  "1111": "yicy;",
  "1112": "jsercy;",
  "1113": "ljcy;",
  "1114": "njcy;",
  "1115": "tshcy;",
  "1116": "kjcy;",
  "1118": "ubrcy;",
  "1119": "dzcy;",
  "8194": "ensp;",
  "8195": "emsp;",
  "8196": "emsp13;",
  "8197": "emsp14;",
  "8199": "numsp;",
  "8200": "puncsp;",
  "8201": "ThinSpace;",
  "8202": "VeryThinSpace;",
  "8203": "ZeroWidthSpace;",
  "8204": "zwnj;",
  "8205": "zwj;",
  "8206": "lrm;",
  "8207": "rlm;",
  "8208": "hyphen;",
  "8211": "ndash;",
  "8212": "mdash;",
  "8213": "horbar;",
  "8214": "Vert;",
  "8216": "OpenCurlyQuote;",
  "8217": "rsquor;",
  "8218": "sbquo;",
  "8220": "OpenCurlyDoubleQuote;",
  "8221": "rdquor;",
  "8222": "ldquor;",
  "8224": "dagger;",
  "8225": "ddagger;",
  "8226": "bullet;",
  "8229": "nldr;",
  "8230": "mldr;",
  "8240": "permil;",
  "8241": "pertenk;",
  "8242": "prime;",
  "8243": "Prime;",
  "8244": "tprime;",
  "8245": "bprime;",
  "8249": "lsaquo;",
  "8250": "rsaquo;",
  "8254": "OverBar;",
  "8257": "caret;",
  "8259": "hybull;",
  "8260": "frasl;",
  "8271": "bsemi;",
  "8279": "qprime;",
  "8287": "MediumSpace;",
  "8288": "NoBreak;",
  "8289": "ApplyFunction;",
  "8290": "it;",
  "8291": "InvisibleComma;",
  "8364": "euro;",
  "8411": "TripleDot;",
  "8412": "DotDot;",
  "8450": "Copf;",
  "8453": "incare;",
  "8458": "gscr;",
  "8459": "Hscr;",
  "8460": "Poincareplane;",
  "8461": "quaternions;",
  "8462": "planckh;",
  "8463": "plankv;",
  "8464": "Iscr;",
  "8465": "imagpart;",
  "8466": "Lscr;",
  "8467": "ell;",
  "8469": "Nopf;",
  "8470": "numero;",
  "8471": "copysr;",
  "8472": "wp;",
  "8473": "primes;",
  "8474": "rationals;",
  "8475": "Rscr;",
  "8476": "Rfr;",
  "8477": "Ropf;",
  "8478": "rx;",
  "8482": "trade;",
  "8484": "Zopf;",
  "8487": "mho;",
  "8488": "Zfr;",
  "8489": "iiota;",
  "8492": "Bscr;",
  "8493": "Cfr;",
  "8495": "escr;",
  "8496": "expectation;",
  "8497": "Fscr;",
  "8499": "phmmat;",
  "8500": "oscr;",
  "8501": "aleph;",
  "8502": "beth;",
  "8503": "gimel;",
  "8504": "daleth;",
  "8517": "DD;",
  "8518": "DifferentialD;",
  "8519": "exponentiale;",
  "8520": "ImaginaryI;",
  "8531": "frac13;",
  "8532": "frac23;",
  "8533": "frac15;",
  "8534": "frac25;",
  "8535": "frac35;",
  "8536": "frac45;",
  "8537": "frac16;",
  "8538": "frac56;",
  "8539": "frac18;",
  "8540": "frac38;",
  "8541": "frac58;",
  "8542": "frac78;",
  "8592": "slarr;",
  "8593": "uparrow;",
  "8594": "srarr;",
  "8595": "ShortDownArrow;",
  "8596": "leftrightarrow;",
  "8597": "varr;",
  "8598": "UpperLeftArrow;",
  "8599": "UpperRightArrow;",
  "8600": "searrow;",
  "8601": "swarrow;",
  "8602": "nleftarrow;",
  "8603": "nrightarrow;",
  "8605": "rightsquigarrow;",
  "8606": "twoheadleftarrow;",
  "8607": "Uarr;",
  "8608": "twoheadrightarrow;",
  "8609": "Darr;",
  "8610": "leftarrowtail;",
  "8611": "rightarrowtail;",
  "8612": "mapstoleft;",
  "8613": "UpTeeArrow;",
  "8614": "RightTeeArrow;",
  "8615": "mapstodown;",
  "8617": "larrhk;",
  "8618": "rarrhk;",
  "8619": "looparrowleft;",
  "8620": "rarrlp;",
  "8621": "leftrightsquigarrow;",
  "8622": "nleftrightarrow;",
  "8624": "lsh;",
  "8625": "rsh;",
  "8626": "ldsh;",
  "8627": "rdsh;",
  "8629": "crarr;",
  "8630": "curvearrowleft;",
  "8631": "curvearrowright;",
  "8634": "olarr;",
  "8635": "orarr;",
  "8636": "lharu;",
  "8637": "lhard;",
  "8638": "upharpoonright;",
  "8639": "upharpoonleft;",
  "8640": "RightVector;",
  "8641": "rightharpoondown;",
  "8642": "RightDownVector;",
  "8643": "LeftDownVector;",
  "8644": "rlarr;",
  "8645": "UpArrowDownArrow;",
  "8646": "lrarr;",
  "8647": "llarr;",
  "8648": "uuarr;",
  "8649": "rrarr;",
  "8650": "downdownarrows;",
  "8651": "ReverseEquilibrium;",
  "8652": "rlhar;",
  "8653": "nLeftarrow;",
  "8654": "nLeftrightarrow;",
  "8655": "nRightarrow;",
  "8656": "Leftarrow;",
  "8657": "Uparrow;",
  "8658": "Rightarrow;",
  "8659": "Downarrow;",
  "8660": "Leftrightarrow;",
  "8661": "vArr;",
  "8662": "nwArr;",
  "8663": "neArr;",
  "8664": "seArr;",
  "8665": "swArr;",
  "8666": "Lleftarrow;",
  "8667": "Rrightarrow;",
  "8669": "zigrarr;",
  "8676": "LeftArrowBar;",
  "8677": "RightArrowBar;",
  "8693": "duarr;",
  "8701": "loarr;",
  "8702": "roarr;",
  "8703": "hoarr;",
  "8704": "forall;",
  "8705": "complement;",
  "8706": "PartialD;",
  "8707": "Exists;",
  "8708": "NotExists;",
  "8709": "varnothing;",
  "8711": "nabla;",
  "8712": "isinv;",
  "8713": "notinva;",
  "8715": "SuchThat;",
  "8716": "NotReverseElement;",
  "8719": "Product;",
  "8720": "Coproduct;",
  "8721": "sum;",
  "8722": "minus;",
  "8723": "mp;",
  "8724": "plusdo;",
  "8726": "ssetmn;",
  "8727": "lowast;",
  "8728": "SmallCircle;",
  "8730": "Sqrt;",
  "8733": "vprop;",
  "8734": "infin;",
  "8735": "angrt;",
  "8736": "angle;",
  "8737": "measuredangle;",
  "8738": "angsph;",
  "8739": "VerticalBar;",
  "8740": "nsmid;",
  "8741": "spar;",
  "8742": "nspar;",
  "8743": "wedge;",
  "8744": "vee;",
  "8745": "cap;",
  "8746": "cup;",
  "8747": "Integral;",
  "8748": "Int;",
  "8749": "tint;",
  "8750": "oint;",
  "8751": "DoubleContourIntegral;",
  "8752": "Cconint;",
  "8753": "cwint;",
  "8754": "cwconint;",
  "8755": "CounterClockwiseContourIntegral;",
  "8756": "therefore;",
  "8757": "because;",
  "8758": "ratio;",
  "8759": "Proportion;",
  "8760": "minusd;",
  "8762": "mDDot;",
  "8763": "homtht;",
  "8764": "Tilde;",
  "8765": "bsim;",
  "8766": "mstpos;",
  "8767": "acd;",
  "8768": "wreath;",
  "8769": "nsim;",
  "8770": "esim;",
  "8771": "TildeEqual;",
  "8772": "nsimeq;",
  "8773": "TildeFullEqual;",
  "8774": "simne;",
  "8775": "NotTildeFullEqual;",
  "8776": "TildeTilde;",
  "8777": "NotTildeTilde;",
  "8778": "approxeq;",
  "8779": "apid;",
  "8780": "bcong;",
  "8781": "CupCap;",
  "8782": "HumpDownHump;",
  "8783": "HumpEqual;",
  "8784": "esdot;",
  "8785": "eDot;",
  "8786": "fallingdotseq;",
  "8787": "risingdotseq;",
  "8788": "coloneq;",
  "8789": "eqcolon;",
  "8790": "eqcirc;",
  "8791": "cire;",
  "8793": "wedgeq;",
  "8794": "veeeq;",
  "8796": "trie;",
  "8799": "questeq;",
  "8800": "NotEqual;",
  "8801": "equiv;",
  "8802": "NotCongruent;",
  "8804": "leq;",
  "8805": "GreaterEqual;",
  "8806": "LessFullEqual;",
  "8807": "GreaterFullEqual;",
  "8808": "lneqq;",
  "8809": "gneqq;",
  "8810": "NestedLessLess;",
  "8811": "NestedGreaterGreater;",
  "8812": "twixt;",
  "8813": "NotCupCap;",
  "8814": "NotLess;",
  "8815": "NotGreater;",
  "8816": "NotLessEqual;",
  "8817": "NotGreaterEqual;",
  "8818": "lsim;",
  "8819": "gtrsim;",
  "8820": "NotLessTilde;",
  "8821": "NotGreaterTilde;",
  "8822": "lg;",
  "8823": "gtrless;",
  "8824": "ntlg;",
  "8825": "ntgl;",
  "8826": "Precedes;",
  "8827": "Succeeds;",
  "8828": "PrecedesSlantEqual;",
  "8829": "SucceedsSlantEqual;",
  "8830": "prsim;",
  "8831": "succsim;",
  "8832": "nprec;",
  "8833": "nsucc;",
  "8834": "subset;",
  "8835": "supset;",
  "8836": "nsub;",
  "8837": "nsup;",
  "8838": "SubsetEqual;",
  "8839": "supseteq;",
  "8840": "nsubseteq;",
  "8841": "nsupseteq;",
  "8842": "subsetneq;",
  "8843": "supsetneq;",
  "8845": "cupdot;",
  "8846": "uplus;",
  "8847": "SquareSubset;",
  "8848": "SquareSuperset;",
  "8849": "SquareSubsetEqual;",
  "8850": "SquareSupersetEqual;",
  "8851": "SquareIntersection;",
  "8852": "SquareUnion;",
  "8853": "oplus;",
  "8854": "ominus;",
  "8855": "otimes;",
  "8856": "osol;",
  "8857": "odot;",
  "8858": "ocir;",
  "8859": "oast;",
  "8861": "odash;",
  "8862": "plusb;",
  "8863": "minusb;",
  "8864": "timesb;",
  "8865": "sdotb;",
  "8866": "vdash;",
  "8867": "LeftTee;",
  "8868": "top;",
  "8869": "UpTee;",
  "8871": "models;",
  "8872": "vDash;",
  "8873": "Vdash;",
  "8874": "Vvdash;",
  "8875": "VDash;",
  "8876": "nvdash;",
  "8877": "nvDash;",
  "8878": "nVdash;",
  "8879": "nVDash;",
  "8880": "prurel;",
  "8882": "vltri;",
  "8883": "vrtri;",
  "8884": "trianglelefteq;",
  "8885": "trianglerighteq;",
  "8886": "origof;",
  "8887": "imof;",
  "8888": "mumap;",
  "8889": "hercon;",
  "8890": "intercal;",
  "8891": "veebar;",
  "8893": "barvee;",
  "8894": "angrtvb;",
  "8895": "lrtri;",
  "8896": "xwedge;",
  "8897": "xvee;",
  "8898": "xcap;",
  "8899": "xcup;",
  "8900": "diamond;",
  "8901": "sdot;",
  "8902": "Star;",
  "8903": "divonx;",
  "8904": "bowtie;",
  "8905": "ltimes;",
  "8906": "rtimes;",
  "8907": "lthree;",
  "8908": "rthree;",
  "8909": "bsime;",
  "8910": "cuvee;",
  "8911": "cuwed;",
  "8912": "Subset;",
  "8913": "Supset;",
  "8914": "Cap;",
  "8915": "Cup;",
  "8916": "pitchfork;",
  "8917": "epar;",
  "8918": "ltdot;",
  "8919": "gtrdot;",
  "8920": "Ll;",
  "8921": "ggg;",
  "8922": "LessEqualGreater;",
  "8923": "gtreqless;",
  "8926": "curlyeqprec;",
  "8927": "curlyeqsucc;",
  "8928": "nprcue;",
  "8929": "nsccue;",
  "8930": "nsqsube;",
  "8931": "nsqsupe;",
  "8934": "lnsim;",
  "8935": "gnsim;",
  "8936": "prnsim;",
  "8937": "succnsim;",
  "8938": "ntriangleleft;",
  "8939": "ntriangleright;",
  "8940": "ntrianglelefteq;",
  "8941": "ntrianglerighteq;",
  "8942": "vellip;",
  "8943": "ctdot;",
  "8944": "utdot;",
  "8945": "dtdot;",
  "8946": "disin;",
  "8947": "isinsv;",
  "8948": "isins;",
  "8949": "isindot;",
  "8950": "notinvc;",
  "8951": "notinvb;",
  "8953": "isinE;",
  "8954": "nisd;",
  "8955": "xnis;",
  "8956": "nis;",
  "8957": "notnivc;",
  "8958": "notnivb;",
  "8965": "barwedge;",
  "8966": "doublebarwedge;",
  "8968": "LeftCeiling;",
  "8969": "RightCeiling;",
  "8970": "lfloor;",
  "8971": "RightFloor;",
  "8972": "drcrop;",
  "8973": "dlcrop;",
  "8974": "urcrop;",
  "8975": "ulcrop;",
  "8976": "bnot;",
  "8978": "profline;",
  "8979": "profsurf;",
  "8981": "telrec;",
  "8982": "target;",
  "8988": "ulcorner;",
  "8989": "urcorner;",
  "8990": "llcorner;",
  "8991": "lrcorner;",
  "8994": "sfrown;",
  "8995": "ssmile;",
  "9005": "cylcty;",
  "9006": "profalar;",
  "9014": "topbot;",
  "9021": "ovbar;",
  "9023": "solbar;",
  "9084": "angzarr;",
  "9136": "lmoustache;",
  "9137": "rmoustache;",
  "9140": "tbrk;",
  "9141": "UnderBracket;",
  "9142": "bbrktbrk;",
  "9180": "OverParenthesis;",
  "9181": "UnderParenthesis;",
  "9182": "OverBrace;",
  "9183": "UnderBrace;",
  "9186": "trpezium;",
  "9191": "elinters;",
  "9251": "blank;",
  "9416": "oS;",
  "9472": "HorizontalLine;",
  "9474": "boxv;",
  "9484": "boxdr;",
  "9488": "boxdl;",
  "9492": "boxur;",
  "9496": "boxul;",
  "9500": "boxvr;",
  "9508": "boxvl;",
  "9516": "boxhd;",
  "9524": "boxhu;",
  "9532": "boxvh;",
  "9552": "boxH;",
  "9553": "boxV;",
  "9554": "boxdR;",
  "9555": "boxDr;",
  "9556": "boxDR;",
  "9557": "boxdL;",
  "9558": "boxDl;",
  "9559": "boxDL;",
  "9560": "boxuR;",
  "9561": "boxUr;",
  "9562": "boxUR;",
  "9563": "boxuL;",
  "9564": "boxUl;",
  "9565": "boxUL;",
  "9566": "boxvR;",
  "9567": "boxVr;",
  "9568": "boxVR;",
  "9569": "boxvL;",
  "9570": "boxVl;",
  "9571": "boxVL;",
  "9572": "boxHd;",
  "9573": "boxhD;",
  "9574": "boxHD;",
  "9575": "boxHu;",
  "9576": "boxhU;",
  "9577": "boxHU;",
  "9578": "boxvH;",
  "9579": "boxVh;",
  "9580": "boxVH;",
  "9600": "uhblk;",
  "9604": "lhblk;",
  "9608": "block;",
  "9617": "blk14;",
  "9618": "blk12;",
  "9619": "blk34;",
  "9633": "square;",
  "9642": "squf;",
  "9643": "EmptyVerySmallSquare;",
  "9645": "rect;",
  "9646": "marker;",
  "9649": "fltns;",
  "9651": "xutri;",
  "9652": "utrif;",
  "9653": "utri;",
  "9656": "rtrif;",
  "9657": "triangleright;",
  "9661": "xdtri;",
  "9662": "dtrif;",
  "9663": "triangledown;",
  "9666": "ltrif;",
  "9667": "triangleleft;",
  "9674": "lozenge;",
  "9675": "cir;",
  "9708": "tridot;",
  "9711": "xcirc;",
  "9720": "ultri;",
  "9721": "urtri;",
  "9722": "lltri;",
  "9723": "EmptySmallSquare;",
  "9724": "FilledSmallSquare;",
  "9733": "starf;",
  "9734": "star;",
  "9742": "phone;",
  "9792": "female;",
  "9794": "male;",
  "9824": "spadesuit;",
  "9827": "clubsuit;",
  "9829": "heartsuit;",
  "9830": "diams;",
  "9834": "sung;",
  "9837": "flat;",
  "9838": "natural;",
  "9839": "sharp;",
  "10003": "checkmark;",
  "10007": "cross;",
  "10016": "maltese;",
  "10038": "sext;",
  "10072": "VerticalSeparator;",
  "10098": "lbbrk;",
  "10099": "rbbrk;",
  "10184": "bsolhsub;",
  "10185": "suphsol;",
  "10214": "lobrk;",
  "10215": "robrk;",
  "10216": "LeftAngleBracket;",
  "10217": "RightAngleBracket;",
  "10218": "Lang;",
  "10219": "Rang;",
  "10220": "loang;",
  "10221": "roang;",
  "10229": "xlarr;",
  "10230": "xrarr;",
  "10231": "xharr;",
  "10232": "xlArr;",
  "10233": "xrArr;",
  "10234": "xhArr;",
  "10236": "xmap;",
  "10239": "dzigrarr;",
  "10498": "nvlArr;",
  "10499": "nvrArr;",
  "10500": "nvHarr;",
  "10501": "Map;",
  "10508": "lbarr;",
  "10509": "rbarr;",
  "10510": "lBarr;",
  "10511": "rBarr;",
  "10512": "RBarr;",
  "10513": "DDotrahd;",
  "10514": "UpArrowBar;",
  "10515": "DownArrowBar;",
  "10518": "Rarrtl;",
  "10521": "latail;",
  "10522": "ratail;",
  "10523": "lAtail;",
  "10524": "rAtail;",
  "10525": "larrfs;",
  "10526": "rarrfs;",
  "10527": "larrbfs;",
  "10528": "rarrbfs;",
  "10531": "nwarhk;",
  "10532": "nearhk;",
  "10533": "searhk;",
  "10534": "swarhk;",
  "10535": "nwnear;",
  "10536": "toea;",
  "10537": "tosa;",
  "10538": "swnwar;",
  "10547": "rarrc;",
  "10549": "cudarrr;",
  "10550": "ldca;",
  "10551": "rdca;",
  "10552": "cudarrl;",
  "10553": "larrpl;",
  "10556": "curarrm;",
  "10557": "cularrp;",
  "10565": "rarrpl;",
  "10568": "harrcir;",
  "10569": "Uarrocir;",
  "10570": "lurdshar;",
  "10571": "ldrushar;",
  "10574": "LeftRightVector;",
  "10575": "RightUpDownVector;",
  "10576": "DownLeftRightVector;",
  "10577": "LeftUpDownVector;",
  "10578": "LeftVectorBar;",
  "10579": "RightVectorBar;",
  "10580": "RightUpVectorBar;",
  "10581": "RightDownVectorBar;",
  "10582": "DownLeftVectorBar;",
  "10583": "DownRightVectorBar;",
  "10584": "LeftUpVectorBar;",
  "10585": "LeftDownVectorBar;",
  "10586": "LeftTeeVector;",
  "10587": "RightTeeVector;",
  "10588": "RightUpTeeVector;",
  "10589": "RightDownTeeVector;",
  "10590": "DownLeftTeeVector;",
  "10591": "DownRightTeeVector;",
  "10592": "LeftUpTeeVector;",
  "10593": "LeftDownTeeVector;",
  "10594": "lHar;",
  "10595": "uHar;",
  "10596": "rHar;",
  "10597": "dHar;",
  "10598": "luruhar;",
  "10599": "ldrdhar;",
  "10600": "ruluhar;",
  "10601": "rdldhar;",
  "10602": "lharul;",
  "10603": "llhard;",
  "10604": "rharul;",
  "10605": "lrhard;",
  "10606": "UpEquilibrium;",
  "10607": "ReverseUpEquilibrium;",
  "10608": "RoundImplies;",
  "10609": "erarr;",
  "10610": "simrarr;",
  "10611": "larrsim;",
  "10612": "rarrsim;",
  "10613": "rarrap;",
  "10614": "ltlarr;",
  "10616": "gtrarr;",
  "10617": "subrarr;",
  "10619": "suplarr;",
  "10620": "lfisht;",
  "10621": "rfisht;",
  "10622": "ufisht;",
  "10623": "dfisht;",
  "10629": "lopar;",
  "10630": "ropar;",
  "10635": "lbrke;",
  "10636": "rbrke;",
  "10637": "lbrkslu;",
  "10638": "rbrksld;",
  "10639": "lbrksld;",
  "10640": "rbrkslu;",
  "10641": "langd;",
  "10642": "rangd;",
  "10643": "lparlt;",
  "10644": "rpargt;",
  "10645": "gtlPar;",
  "10646": "ltrPar;",
  "10650": "vzigzag;",
  "10652": "vangrt;",
  "10653": "angrtvbd;",
  "10660": "ange;",
  "10661": "range;",
  "10662": "dwangle;",
  "10663": "uwangle;",
  "10664": "angmsdaa;",
  "10665": "angmsdab;",
  "10666": "angmsdac;",
  "10667": "angmsdad;",
  "10668": "angmsdae;",
  "10669": "angmsdaf;",
  "10670": "angmsdag;",
  "10671": "angmsdah;",
  "10672": "bemptyv;",
  "10673": "demptyv;",
  "10674": "cemptyv;",
  "10675": "raemptyv;",
  "10676": "laemptyv;",
  "10677": "ohbar;",
  "10678": "omid;",
  "10679": "opar;",
  "10681": "operp;",
  "10683": "olcross;",
  "10684": "odsold;",
  "10686": "olcir;",
  "10687": "ofcir;",
  "10688": "olt;",
  "10689": "ogt;",
  "10690": "cirscir;",
  "10691": "cirE;",
  "10692": "solb;",
  "10693": "bsolb;",
  "10697": "boxbox;",
  "10701": "trisb;",
  "10702": "rtriltri;",
  "10703": "LeftTriangleBar;",
  "10704": "RightTriangleBar;",
  "10716": "iinfin;",
  "10717": "infintie;",
  "10718": "nvinfin;",
  "10723": "eparsl;",
  "10724": "smeparsl;",
  "10725": "eqvparsl;",
  "10731": "lozf;",
  "10740": "RuleDelayed;",
  "10742": "dsol;",
  "10752": "xodot;",
  "10753": "xoplus;",
  "10754": "xotime;",
  "10756": "xuplus;",
  "10758": "xsqcup;",
  "10764": "qint;",
  "10765": "fpartint;",
  "10768": "cirfnint;",
  "10769": "awint;",
  "10770": "rppolint;",
  "10771": "scpolint;",
  "10772": "npolint;",
  "10773": "pointint;",
  "10774": "quatint;",
  "10775": "intlarhk;",
  "10786": "pluscir;",
  "10787": "plusacir;",
  "10788": "simplus;",
  "10789": "plusdu;",
  "10790": "plussim;",
  "10791": "plustwo;",
  "10793": "mcomma;",
  "10794": "minusdu;",
  "10797": "loplus;",
  "10798": "roplus;",
  "10799": "Cross;",
  "10800": "timesd;",
  "10801": "timesbar;",
  "10803": "smashp;",
  "10804": "lotimes;",
  "10805": "rotimes;",
  "10806": "otimesas;",
  "10807": "Otimes;",
  "10808": "odiv;",
  "10809": "triplus;",
  "10810": "triminus;",
  "10811": "tritime;",
  "10812": "iprod;",
  "10815": "amalg;",
  "10816": "capdot;",
  "10818": "ncup;",
  "10819": "ncap;",
  "10820": "capand;",
  "10821": "cupor;",
  "10822": "cupcap;",
  "10823": "capcup;",
  "10824": "cupbrcap;",
  "10825": "capbrcup;",
  "10826": "cupcup;",
  "10827": "capcap;",
  "10828": "ccups;",
  "10829": "ccaps;",
  "10832": "ccupssm;",
  "10835": "And;",
  "10836": "Or;",
  "10837": "andand;",
  "10838": "oror;",
  "10839": "orslope;",
  "10840": "andslope;",
  "10842": "andv;",
  "10843": "orv;",
  "10844": "andd;",
  "10845": "ord;",
  "10847": "wedbar;",
  "10854": "sdote;",
  "10858": "simdot;",
  "10861": "congdot;",
  "10862": "easter;",
  "10863": "apacir;",
  "10864": "apE;",
  "10865": "eplus;",
  "10866": "pluse;",
  "10867": "Esim;",
  "10868": "Colone;",
  "10869": "Equal;",
  "10871": "eDDot;",
  "10872": "equivDD;",
  "10873": "ltcir;",
  "10874": "gtcir;",
  "10875": "ltquest;",
  "10876": "gtquest;",
  "10877": "LessSlantEqual;",
  "10878": "GreaterSlantEqual;",
  "10879": "lesdot;",
  "10880": "gesdot;",
  "10881": "lesdoto;",
  "10882": "gesdoto;",
  "10883": "lesdotor;",
  "10884": "gesdotol;",
  "10885": "lessapprox;",
  "10886": "gtrapprox;",
  "10887": "lneq;",
  "10888": "gneq;",
  "10889": "lnapprox;",
  "10890": "gnapprox;",
  "10891": "lesseqqgtr;",
  "10892": "gtreqqless;",
  "10893": "lsime;",
  "10894": "gsime;",
  "10895": "lsimg;",
  "10896": "gsiml;",
  "10897": "lgE;",
  "10898": "glE;",
  "10899": "lesges;",
  "10900": "gesles;",
  "10901": "eqslantless;",
  "10902": "eqslantgtr;",
  "10903": "elsdot;",
  "10904": "egsdot;",
  "10905": "el;",
  "10906": "eg;",
  "10909": "siml;",
  "10910": "simg;",
  "10911": "simlE;",
  "10912": "simgE;",
  "10913": "LessLess;",
  "10914": "GreaterGreater;",
  "10916": "glj;",
  "10917": "gla;",
  "10918": "ltcc;",
  "10919": "gtcc;",
  "10920": "lescc;",
  "10921": "gescc;",
  "10922": "smt;",
  "10923": "lat;",
  "10924": "smte;",
  "10925": "late;",
  "10926": "bumpE;",
  "10927": "preceq;",
  "10928": "succeq;",
  "10931": "prE;",
  "10932": "scE;",
  "10933": "prnE;",
  "10934": "succneqq;",
  "10935": "precapprox;",
  "10936": "succapprox;",
  "10937": "prnap;",
  "10938": "succnapprox;",
  "10939": "Pr;",
  "10940": "Sc;",
  "10941": "subdot;",
  "10942": "supdot;",
  "10943": "subplus;",
  "10944": "supplus;",
  "10945": "submult;",
  "10946": "supmult;",
  "10947": "subedot;",
  "10948": "supedot;",
  "10949": "subseteqq;",
  "10950": "supseteqq;",
  "10951": "subsim;",
  "10952": "supsim;",
  "10955": "subsetneqq;",
  "10956": "supsetneqq;",
  "10959": "csub;",
  "10960": "csup;",
  "10961": "csube;",
  "10962": "csupe;",
  "10963": "subsup;",
  "10964": "supsub;",
  "10965": "subsub;",
  "10966": "supsup;",
  "10967": "suphsub;",
  "10968": "supdsub;",
  "10969": "forkv;",
  "10970": "topfork;",
  "10971": "mlcp;",
  "10980": "DoubleLeftTee;",
  "10982": "Vdashl;",
  "10983": "Barv;",
  "10984": "vBar;",
  "10985": "vBarv;",
  "10987": "Vbar;",
  "10988": "Not;",
  "10989": "bNot;",
  "10990": "rnmid;",
  "10991": "cirmid;",
  "10992": "midcir;",
  "10993": "topcir;",
  "10994": "nhpar;",
  "10995": "parsim;",
  "11005": "parsl;",
  "64256": "fflig;",
  "64257": "filig;",
  "64258": "fllig;",
  "64259": "ffilig;",
  "64260": "ffllig;"
};
var encode$1;
var hasRequiredEncode$1;
function requireEncode$1() {
  if (hasRequiredEncode$1) return encode$1;
  hasRequiredEncode$1 = 1;
  var punycode2 = requirePunycode();
  var $decode = punycode2.ucs2.decode;
  var $encode = punycode2.ucs2.encode;
  var $TypeError = /* @__PURE__ */ requireType();
  var regexTest = /* @__PURE__ */ requireSafeRegexTest();
  var revEntities = require$$3$1;
  var endsInSemicolon = regexTest(/;$/);
  var defaultSpecial = {
    '"': true,
    "'": true,
    "<": true,
    ">": true,
    "&": true
  };
  encode$1 = function encode2(str, opts) {
    if (typeof str !== "string") {
      throw new $TypeError("Expected a String");
    }
    var numeric = !opts || !opts.named;
    if (opts && typeof opts.numeric !== "undefined") {
      numeric = opts.numeric;
    }
    var special = opts && opts.special || defaultSpecial;
    var codePoints = $decode(str);
    var chars = [];
    for (var i = 0; i < codePoints.length; i++) {
      var cc = codePoints[i];
      var c = $encode([cc]);
      var e = revEntities[cc];
      if (e && (cc >= 127 || special[c]) && !numeric) {
        var hasSemi = endsInSemicolon(e);
        chars[chars.length] = "&" + (hasSemi ? e : e + ";");
      } else if (cc < 32 || cc >= 127 || special[c]) {
        chars[chars.length] = "&#" + cc + ";";
      } else {
        chars[chars.length] = c;
      }
    }
    return chars.join("");
  };
  return encode$1;
}
const Aacute$4 = "Ã";
const aacute$4 = "Ã¡";
const Acirc$4 = "Ã‚";
const acirc$4 = "Ã¢";
const acute$4 = "Â´";
const AElig$4 = "Ã†";
const aelig$4 = "Ã¦";
const Agrave$4 = "Ã€";
const agrave$4 = "Ã ";
const AMP$4 = "&";
const amp$6 = "&";
const Aring$4 = "Ã…";
const aring$4 = "Ã¥";
const Atilde$4 = "Ãƒ";
const atilde$4 = "Ã£";
const Auml$4 = "Ã„";
const auml$4 = "Ã¤";
const brvbar$4 = "Â¦";
const Ccedil$4 = "Ã‡";
const ccedil$4 = "Ã§";
const cedil$4 = "Â¸";
const cent$4 = "Â¢";
const COPY$4 = "Â©";
const copy$4 = "Â©";
const curren$4 = "Â¤";
const deg$4 = "Â°";
const divide$4 = "Ã·";
const Eacute$4 = "Ã‰";
const eacute$4 = "Ã©";
const Ecirc$4 = "ÃŠ";
const ecirc$4 = "Ãª";
const Egrave$4 = "Ãˆ";
const egrave$4 = "Ã¨";
const ETH$4 = "Ã";
const eth$4 = "Ã°";
const Euml$4 = "Ã‹";
const euml$4 = "Ã«";
const frac12$4 = "Â½";
const frac14$4 = "Â¼";
const frac34$4 = "Â¾";
const GT$4 = ">";
const gt$6 = ">";
const Iacute$4 = "Ã";
const iacute$4 = "Ã­";
const Icirc$4 = "ÃŽ";
const icirc$4 = "Ã®";
const iexcl$4 = "Â¡";
const Igrave$4 = "ÃŒ";
const igrave$4 = "Ã¬";
const iquest$4 = "Â¿";
const Iuml$4 = "Ã";
const iuml$4 = "Ã¯";
const laquo$4 = "Â«";
const LT$4 = "<";
const lt$6 = "<";
const macr$4 = "Â¯";
const micro$4 = "Âµ";
const middot$4 = "Â·";
const nbsp$4 = "Â ";
const not$4 = "Â¬";
const Ntilde$4 = "Ã‘";
const ntilde$4 = "Ã±";
const Oacute$4 = "Ã“";
const oacute$4 = "Ã³";
const Ocirc$4 = "Ã”";
const ocirc$4 = "Ã´";
const Ograve$4 = "Ã’";
const ograve$4 = "Ã²";
const ordf$4 = "Âª";
const ordm$4 = "Âº";
const Oslash$4 = "Ã˜";
const oslash$4 = "Ã¸";
const Otilde$4 = "Ã•";
const otilde$4 = "Ãµ";
const Ouml$4 = "Ã–";
const ouml$4 = "Ã¶";
const para$4 = "Â¶";
const plusmn$4 = "Â±";
const pound$4 = "Â£";
const QUOT$4 = '"';
const quot$6 = '"';
const raquo$4 = "Â»";
const REG$4 = "Â®";
const reg$4 = "Â®";
const sect$4 = "Â§";
const shy$4 = "Â­";
const sup1$4 = "Â¹";
const sup2$4 = "Â²";
const sup3$4 = "Â³";
const szlig$4 = "ÃŸ";
const THORN$4 = "Ãž";
const thorn$4 = "Ã¾";
const times$4 = "Ã—";
const Uacute$4 = "Ãš";
const uacute$4 = "Ãº";
const Ucirc$4 = "Ã›";
const ucirc$4 = "Ã»";
const Ugrave$4 = "Ã™";
const ugrave$4 = "Ã¹";
const uml$4 = "Â¨";
const Uuml$4 = "Ãœ";
const uuml$4 = "Ã¼";
const Yacute$4 = "Ã";
const yacute$4 = "Ã½";
const yen$4 = "Â¥";
const yuml$4 = "Ã¿";
const require$$4 = {
  "Aacute;": "Ã",
  Aacute: Aacute$4,
  "aacute;": "Ã¡",
  aacute: aacute$4,
  "Abreve;": "Ä‚",
  "abreve;": "Äƒ",
  "ac;": "âˆ¾",
  "acd;": "âˆ¿",
  "acE;": "âˆ¾Ì³",
  "Acirc;": "Ã‚",
  Acirc: Acirc$4,
  "acirc;": "Ã¢",
  acirc: acirc$4,
  "acute;": "Â´",
  acute: acute$4,
  "Acy;": "Ð",
  "acy;": "Ð°",
  "AElig;": "Ã†",
  AElig: AElig$4,
  "aelig;": "Ã¦",
  aelig: aelig$4,
  "af;": "â¡",
  "Afr;": "ð”„",
  "afr;": "ð”ž",
  "Agrave;": "Ã€",
  Agrave: Agrave$4,
  "agrave;": "Ã ",
  agrave: agrave$4,
  "alefsym;": "â„µ",
  "aleph;": "â„µ",
  "Alpha;": "Î‘",
  "alpha;": "Î±",
  "Amacr;": "Ä€",
  "amacr;": "Ä",
  "amalg;": "â¨¿",
  "AMP;": "&",
  AMP: AMP$4,
  "amp;": "&",
  amp: amp$6,
  "And;": "â©“",
  "and;": "âˆ§",
  "andand;": "â©•",
  "andd;": "â©œ",
  "andslope;": "â©˜",
  "andv;": "â©š",
  "ang;": "âˆ ",
  "ange;": "â¦¤",
  "angle;": "âˆ ",
  "angmsd;": "âˆ¡",
  "angmsdaa;": "â¦¨",
  "angmsdab;": "â¦©",
  "angmsdac;": "â¦ª",
  "angmsdad;": "â¦«",
  "angmsdae;": "â¦¬",
  "angmsdaf;": "â¦­",
  "angmsdag;": "â¦®",
  "angmsdah;": "â¦¯",
  "angrt;": "âˆŸ",
  "angrtvb;": "âŠ¾",
  "angrtvbd;": "â¦",
  "angsph;": "âˆ¢",
  "angst;": "Ã…",
  "angzarr;": "â¼",
  "Aogon;": "Ä„",
  "aogon;": "Ä…",
  "Aopf;": "ð”¸",
  "aopf;": "ð•’",
  "ap;": "â‰ˆ",
  "apacir;": "â©¯",
  "apE;": "â©°",
  "ape;": "â‰Š",
  "apid;": "â‰‹",
  "apos;": "'",
  "ApplyFunction;": "â¡",
  "approx;": "â‰ˆ",
  "approxeq;": "â‰Š",
  "Aring;": "Ã…",
  Aring: Aring$4,
  "aring;": "Ã¥",
  aring: aring$4,
  "Ascr;": "ð’œ",
  "ascr;": "ð’¶",
  "Assign;": "â‰”",
  "ast;": "*",
  "asymp;": "â‰ˆ",
  "asympeq;": "â‰",
  "Atilde;": "Ãƒ",
  Atilde: Atilde$4,
  "atilde;": "Ã£",
  atilde: atilde$4,
  "Auml;": "Ã„",
  Auml: Auml$4,
  "auml;": "Ã¤",
  auml: auml$4,
  "awconint;": "âˆ³",
  "awint;": "â¨‘",
  "backcong;": "â‰Œ",
  "backepsilon;": "Ï¶",
  "backprime;": "â€µ",
  "backsim;": "âˆ½",
  "backsimeq;": "â‹",
  "Backslash;": "âˆ–",
  "Barv;": "â«§",
  "barvee;": "âŠ½",
  "Barwed;": "âŒ†",
  "barwed;": "âŒ…",
  "barwedge;": "âŒ…",
  "bbrk;": "âŽµ",
  "bbrktbrk;": "âŽ¶",
  "bcong;": "â‰Œ",
  "Bcy;": "Ð‘",
  "bcy;": "Ð±",
  "bdquo;": "â€ž",
  "becaus;": "âˆµ",
  "Because;": "âˆµ",
  "because;": "âˆµ",
  "bemptyv;": "â¦°",
  "bepsi;": "Ï¶",
  "bernou;": "â„¬",
  "Bernoullis;": "â„¬",
  "Beta;": "Î’",
  "beta;": "Î²",
  "beth;": "â„¶",
  "between;": "â‰¬",
  "Bfr;": "ð”…",
  "bfr;": "ð”Ÿ",
  "bigcap;": "â‹‚",
  "bigcirc;": "â—¯",
  "bigcup;": "â‹ƒ",
  "bigodot;": "â¨€",
  "bigoplus;": "â¨",
  "bigotimes;": "â¨‚",
  "bigsqcup;": "â¨†",
  "bigstar;": "â˜…",
  "bigtriangledown;": "â–½",
  "bigtriangleup;": "â–³",
  "biguplus;": "â¨„",
  "bigvee;": "â‹",
  "bigwedge;": "â‹€",
  "bkarow;": "â¤",
  "blacklozenge;": "â§«",
  "blacksquare;": "â–ª",
  "blacktriangle;": "â–´",
  "blacktriangledown;": "â–¾",
  "blacktriangleleft;": "â—‚",
  "blacktriangleright;": "â–¸",
  "blank;": "â£",
  "blk12;": "â–’",
  "blk14;": "â–‘",
  "blk34;": "â–“",
  "block;": "â–ˆ",
  "bne;": "=âƒ¥",
  "bnequiv;": "â‰¡âƒ¥",
  "bNot;": "â«­",
  "bnot;": "âŒ",
  "Bopf;": "ð”¹",
  "bopf;": "ð•“",
  "bot;": "âŠ¥",
  "bottom;": "âŠ¥",
  "bowtie;": "â‹ˆ",
  "boxbox;": "â§‰",
  "boxDL;": "â•—",
  "boxDl;": "â•–",
  "boxdL;": "â••",
  "boxdl;": "â”",
  "boxDR;": "â•”",
  "boxDr;": "â•“",
  "boxdR;": "â•’",
  "boxdr;": "â”Œ",
  "boxH;": "â•",
  "boxh;": "â”€",
  "boxHD;": "â•¦",
  "boxHd;": "â•¤",
  "boxhD;": "â•¥",
  "boxhd;": "â”¬",
  "boxHU;": "â•©",
  "boxHu;": "â•§",
  "boxhU;": "â•¨",
  "boxhu;": "â”´",
  "boxminus;": "âŠŸ",
  "boxplus;": "âŠž",
  "boxtimes;": "âŠ ",
  "boxUL;": "â•",
  "boxUl;": "â•œ",
  "boxuL;": "â•›",
  "boxul;": "â”˜",
  "boxUR;": "â•š",
  "boxUr;": "â•™",
  "boxuR;": "â•˜",
  "boxur;": "â””",
  "boxV;": "â•‘",
  "boxv;": "â”‚",
  "boxVH;": "â•¬",
  "boxVh;": "â•«",
  "boxvH;": "â•ª",
  "boxvh;": "â”¼",
  "boxVL;": "â•£",
  "boxVl;": "â•¢",
  "boxvL;": "â•¡",
  "boxvl;": "â”¤",
  "boxVR;": "â• ",
  "boxVr;": "â•Ÿ",
  "boxvR;": "â•ž",
  "boxvr;": "â”œ",
  "bprime;": "â€µ",
  "Breve;": "Ë˜",
  "breve;": "Ë˜",
  "brvbar;": "Â¦",
  brvbar: brvbar$4,
  "Bscr;": "â„¬",
  "bscr;": "ð’·",
  "bsemi;": "â",
  "bsim;": "âˆ½",
  "bsime;": "â‹",
  "bsol;": "\\",
  "bsolb;": "â§…",
  "bsolhsub;": "âŸˆ",
  "bull;": "â€¢",
  "bullet;": "â€¢",
  "bump;": "â‰Ž",
  "bumpE;": "âª®",
  "bumpe;": "â‰",
  "Bumpeq;": "â‰Ž",
  "bumpeq;": "â‰",
  "Cacute;": "Ä†",
  "cacute;": "Ä‡",
  "Cap;": "â‹’",
  "cap;": "âˆ©",
  "capand;": "â©„",
  "capbrcup;": "â©‰",
  "capcap;": "â©‹",
  "capcup;": "â©‡",
  "capdot;": "â©€",
  "CapitalDifferentialD;": "â……",
  "caps;": "âˆ©ï¸€",
  "caret;": "â",
  "caron;": "Ë‡",
  "Cayleys;": "â„­",
  "ccaps;": "â©",
  "Ccaron;": "ÄŒ",
  "ccaron;": "Ä",
  "Ccedil;": "Ã‡",
  Ccedil: Ccedil$4,
  "ccedil;": "Ã§",
  ccedil: ccedil$4,
  "Ccirc;": "Äˆ",
  "ccirc;": "Ä‰",
  "Cconint;": "âˆ°",
  "ccups;": "â©Œ",
  "ccupssm;": "â©",
  "Cdot;": "ÄŠ",
  "cdot;": "Ä‹",
  "cedil;": "Â¸",
  cedil: cedil$4,
  "Cedilla;": "Â¸",
  "cemptyv;": "â¦²",
  "cent;": "Â¢",
  cent: cent$4,
  "CenterDot;": "Â·",
  "centerdot;": "Â·",
  "Cfr;": "â„­",
  "cfr;": "ð” ",
  "CHcy;": "Ð§",
  "chcy;": "Ñ‡",
  "check;": "âœ“",
  "checkmark;": "âœ“",
  "Chi;": "Î§",
  "chi;": "Ï‡",
  "cir;": "â—‹",
  "circ;": "Ë†",
  "circeq;": "â‰—",
  "circlearrowleft;": "â†º",
  "circlearrowright;": "â†»",
  "circledast;": "âŠ›",
  "circledcirc;": "âŠš",
  "circleddash;": "âŠ",
  "CircleDot;": "âŠ™",
  "circledR;": "Â®",
  "circledS;": "â“ˆ",
  "CircleMinus;": "âŠ–",
  "CirclePlus;": "âŠ•",
  "CircleTimes;": "âŠ—",
  "cirE;": "â§ƒ",
  "cire;": "â‰—",
  "cirfnint;": "â¨",
  "cirmid;": "â«¯",
  "cirscir;": "â§‚",
  "ClockwiseContourIntegral;": "âˆ²",
  "CloseCurlyDoubleQuote;": "â€",
  "CloseCurlyQuote;": "â€™",
  "clubs;": "â™£",
  "clubsuit;": "â™£",
  "Colon;": "âˆ·",
  "colon;": ":",
  "Colone;": "â©´",
  "colone;": "â‰”",
  "coloneq;": "â‰”",
  "comma;": ",",
  "commat;": "@",
  "comp;": "âˆ",
  "compfn;": "âˆ˜",
  "complement;": "âˆ",
  "complexes;": "â„‚",
  "cong;": "â‰…",
  "congdot;": "â©­",
  "Congruent;": "â‰¡",
  "Conint;": "âˆ¯",
  "conint;": "âˆ®",
  "ContourIntegral;": "âˆ®",
  "Copf;": "â„‚",
  "copf;": "ð•”",
  "coprod;": "âˆ",
  "Coproduct;": "âˆ",
  "COPY;": "Â©",
  COPY: COPY$4,
  "copy;": "Â©",
  copy: copy$4,
  "copysr;": "â„—",
  "CounterClockwiseContourIntegral;": "âˆ³",
  "crarr;": "â†µ",
  "Cross;": "â¨¯",
  "cross;": "âœ—",
  "Cscr;": "ð’ž",
  "cscr;": "ð’¸",
  "csub;": "â«",
  "csube;": "â«‘",
  "csup;": "â«",
  "csupe;": "â«’",
  "ctdot;": "â‹¯",
  "cudarrl;": "â¤¸",
  "cudarrr;": "â¤µ",
  "cuepr;": "â‹ž",
  "cuesc;": "â‹Ÿ",
  "cularr;": "â†¶",
  "cularrp;": "â¤½",
  "Cup;": "â‹“",
  "cup;": "âˆª",
  "cupbrcap;": "â©ˆ",
  "CupCap;": "â‰",
  "cupcap;": "â©†",
  "cupcup;": "â©Š",
  "cupdot;": "âŠ",
  "cupor;": "â©…",
  "cups;": "âˆªï¸€",
  "curarr;": "â†·",
  "curarrm;": "â¤¼",
  "curlyeqprec;": "â‹ž",
  "curlyeqsucc;": "â‹Ÿ",
  "curlyvee;": "â‹Ž",
  "curlywedge;": "â‹",
  "curren;": "Â¤",
  curren: curren$4,
  "curvearrowleft;": "â†¶",
  "curvearrowright;": "â†·",
  "cuvee;": "â‹Ž",
  "cuwed;": "â‹",
  "cwconint;": "âˆ²",
  "cwint;": "âˆ±",
  "cylcty;": "âŒ­",
  "Dagger;": "â€¡",
  "dagger;": "â€ ",
  "daleth;": "â„¸",
  "Darr;": "â†¡",
  "dArr;": "â‡“",
  "darr;": "â†“",
  "dash;": "â€",
  "Dashv;": "â«¤",
  "dashv;": "âŠ£",
  "dbkarow;": "â¤",
  "dblac;": "Ë",
  "Dcaron;": "ÄŽ",
  "dcaron;": "Ä",
  "Dcy;": "Ð”",
  "dcy;": "Ð´",
  "DD;": "â……",
  "dd;": "â…†",
  "ddagger;": "â€¡",
  "ddarr;": "â‡Š",
  "DDotrahd;": "â¤‘",
  "ddotseq;": "â©·",
  "deg;": "Â°",
  deg: deg$4,
  "Del;": "âˆ‡",
  "Delta;": "Î”",
  "delta;": "Î´",
  "demptyv;": "â¦±",
  "dfisht;": "â¥¿",
  "Dfr;": "ð”‡",
  "dfr;": "ð”¡",
  "dHar;": "â¥¥",
  "dharl;": "â‡ƒ",
  "dharr;": "â‡‚",
  "DiacriticalAcute;": "Â´",
  "DiacriticalDot;": "Ë™",
  "DiacriticalDoubleAcute;": "Ë",
  "DiacriticalGrave;": "`",
  "DiacriticalTilde;": "Ëœ",
  "diam;": "â‹„",
  "Diamond;": "â‹„",
  "diamond;": "â‹„",
  "diamondsuit;": "â™¦",
  "diams;": "â™¦",
  "die;": "Â¨",
  "DifferentialD;": "â…†",
  "digamma;": "Ï",
  "disin;": "â‹²",
  "div;": "Ã·",
  "divide;": "Ã·",
  divide: divide$4,
  "divideontimes;": "â‹‡",
  "divonx;": "â‹‡",
  "DJcy;": "Ð‚",
  "djcy;": "Ñ’",
  "dlcorn;": "âŒž",
  "dlcrop;": "âŒ",
  "dollar;": "$",
  "Dopf;": "ð”»",
  "dopf;": "ð••",
  "Dot;": "Â¨",
  "dot;": "Ë™",
  "DotDot;": "âƒœ",
  "doteq;": "â‰",
  "doteqdot;": "â‰‘",
  "DotEqual;": "â‰",
  "dotminus;": "âˆ¸",
  "dotplus;": "âˆ”",
  "dotsquare;": "âŠ¡",
  "doublebarwedge;": "âŒ†",
  "DoubleContourIntegral;": "âˆ¯",
  "DoubleDot;": "Â¨",
  "DoubleDownArrow;": "â‡“",
  "DoubleLeftArrow;": "â‡",
  "DoubleLeftRightArrow;": "â‡”",
  "DoubleLeftTee;": "â«¤",
  "DoubleLongLeftArrow;": "âŸ¸",
  "DoubleLongLeftRightArrow;": "âŸº",
  "DoubleLongRightArrow;": "âŸ¹",
  "DoubleRightArrow;": "â‡’",
  "DoubleRightTee;": "âŠ¨",
  "DoubleUpArrow;": "â‡‘",
  "DoubleUpDownArrow;": "â‡•",
  "DoubleVerticalBar;": "âˆ¥",
  "DownArrow;": "â†“",
  "Downarrow;": "â‡“",
  "downarrow;": "â†“",
  "DownArrowBar;": "â¤“",
  "DownArrowUpArrow;": "â‡µ",
  "DownBreve;": "Ì‘",
  "downdownarrows;": "â‡Š",
  "downharpoonleft;": "â‡ƒ",
  "downharpoonright;": "â‡‚",
  "DownLeftRightVector;": "â¥",
  "DownLeftTeeVector;": "â¥ž",
  "DownLeftVector;": "â†½",
  "DownLeftVectorBar;": "â¥–",
  "DownRightTeeVector;": "â¥Ÿ",
  "DownRightVector;": "â‡",
  "DownRightVectorBar;": "â¥—",
  "DownTee;": "âŠ¤",
  "DownTeeArrow;": "â†§",
  "drbkarow;": "â¤",
  "drcorn;": "âŒŸ",
  "drcrop;": "âŒŒ",
  "Dscr;": "ð’Ÿ",
  "dscr;": "ð’¹",
  "DScy;": "Ð…",
  "dscy;": "Ñ•",
  "dsol;": "â§¶",
  "Dstrok;": "Ä",
  "dstrok;": "Ä‘",
  "dtdot;": "â‹±",
  "dtri;": "â–¿",
  "dtrif;": "â–¾",
  "duarr;": "â‡µ",
  "duhar;": "â¥¯",
  "dwangle;": "â¦¦",
  "DZcy;": "Ð",
  "dzcy;": "ÑŸ",
  "dzigrarr;": "âŸ¿",
  "Eacute;": "Ã‰",
  Eacute: Eacute$4,
  "eacute;": "Ã©",
  eacute: eacute$4,
  "easter;": "â©®",
  "Ecaron;": "Äš",
  "ecaron;": "Ä›",
  "ecir;": "â‰–",
  "Ecirc;": "ÃŠ",
  Ecirc: Ecirc$4,
  "ecirc;": "Ãª",
  ecirc: ecirc$4,
  "ecolon;": "â‰•",
  "Ecy;": "Ð­",
  "ecy;": "Ñ",
  "eDDot;": "â©·",
  "Edot;": "Ä–",
  "eDot;": "â‰‘",
  "edot;": "Ä—",
  "ee;": "â…‡",
  "efDot;": "â‰’",
  "Efr;": "ð”ˆ",
  "efr;": "ð”¢",
  "eg;": "âªš",
  "Egrave;": "Ãˆ",
  Egrave: Egrave$4,
  "egrave;": "Ã¨",
  egrave: egrave$4,
  "egs;": "âª–",
  "egsdot;": "âª˜",
  "el;": "âª™",
  "Element;": "âˆˆ",
  "elinters;": "â§",
  "ell;": "â„“",
  "els;": "âª•",
  "elsdot;": "âª—",
  "Emacr;": "Ä’",
  "emacr;": "Ä“",
  "empty;": "âˆ…",
  "emptyset;": "âˆ…",
  "EmptySmallSquare;": "â—»",
  "emptyv;": "âˆ…",
  "EmptyVerySmallSquare;": "â–«",
  "emsp;": "â€ƒ",
  "emsp13;": "â€„",
  "emsp14;": "â€…",
  "ENG;": "ÅŠ",
  "eng;": "Å‹",
  "ensp;": "â€‚",
  "Eogon;": "Ä˜",
  "eogon;": "Ä™",
  "Eopf;": "ð”¼",
  "eopf;": "ð•–",
  "epar;": "â‹•",
  "eparsl;": "â§£",
  "eplus;": "â©±",
  "epsi;": "Îµ",
  "Epsilon;": "Î•",
  "epsilon;": "Îµ",
  "epsiv;": "Ïµ",
  "eqcirc;": "â‰–",
  "eqcolon;": "â‰•",
  "eqsim;": "â‰‚",
  "eqslantgtr;": "âª–",
  "eqslantless;": "âª•",
  "Equal;": "â©µ",
  "equals;": "=",
  "EqualTilde;": "â‰‚",
  "equest;": "â‰Ÿ",
  "Equilibrium;": "â‡Œ",
  "equiv;": "â‰¡",
  "equivDD;": "â©¸",
  "eqvparsl;": "â§¥",
  "erarr;": "â¥±",
  "erDot;": "â‰“",
  "Escr;": "â„°",
  "escr;": "â„¯",
  "esdot;": "â‰",
  "Esim;": "â©³",
  "esim;": "â‰‚",
  "Eta;": "Î—",
  "eta;": "Î·",
  "ETH;": "Ã",
  ETH: ETH$4,
  "eth;": "Ã°",
  eth: eth$4,
  "Euml;": "Ã‹",
  Euml: Euml$4,
  "euml;": "Ã«",
  euml: euml$4,
  "euro;": "â‚¬",
  "excl;": "!",
  "exist;": "âˆƒ",
  "Exists;": "âˆƒ",
  "expectation;": "â„°",
  "ExponentialE;": "â…‡",
  "exponentiale;": "â…‡",
  "fallingdotseq;": "â‰’",
  "Fcy;": "Ð¤",
  "fcy;": "Ñ„",
  "female;": "â™€",
  "ffilig;": "ï¬ƒ",
  "fflig;": "ï¬€",
  "ffllig;": "ï¬„",
  "Ffr;": "ð”‰",
  "ffr;": "ð”£",
  "filig;": "ï¬",
  "FilledSmallSquare;": "â—¼",
  "FilledVerySmallSquare;": "â–ª",
  "fjlig;": "fj",
  "flat;": "â™­",
  "fllig;": "ï¬‚",
  "fltns;": "â–±",
  "fnof;": "Æ’",
  "Fopf;": "ð”½",
  "fopf;": "ð•—",
  "ForAll;": "âˆ€",
  "forall;": "âˆ€",
  "fork;": "â‹”",
  "forkv;": "â«™",
  "Fouriertrf;": "â„±",
  "fpartint;": "â¨",
  "frac12;": "Â½",
  frac12: frac12$4,
  "frac13;": "â…“",
  "frac14;": "Â¼",
  frac14: frac14$4,
  "frac15;": "â…•",
  "frac16;": "â…™",
  "frac18;": "â…›",
  "frac23;": "â…”",
  "frac25;": "â…–",
  "frac34;": "Â¾",
  frac34: frac34$4,
  "frac35;": "â…—",
  "frac38;": "â…œ",
  "frac45;": "â…˜",
  "frac56;": "â…š",
  "frac58;": "â…",
  "frac78;": "â…ž",
  "frasl;": "â„",
  "frown;": "âŒ¢",
  "Fscr;": "â„±",
  "fscr;": "ð’»",
  "gacute;": "Çµ",
  "Gamma;": "Î“",
  "gamma;": "Î³",
  "Gammad;": "Ïœ",
  "gammad;": "Ï",
  "gap;": "âª†",
  "Gbreve;": "Äž",
  "gbreve;": "ÄŸ",
  "Gcedil;": "Ä¢",
  "Gcirc;": "Äœ",
  "gcirc;": "Ä",
  "Gcy;": "Ð“",
  "gcy;": "Ð³",
  "Gdot;": "Ä ",
  "gdot;": "Ä¡",
  "gE;": "â‰§",
  "ge;": "â‰¥",
  "gEl;": "âªŒ",
  "gel;": "â‹›",
  "geq;": "â‰¥",
  "geqq;": "â‰§",
  "geqslant;": "â©¾",
  "ges;": "â©¾",
  "gescc;": "âª©",
  "gesdot;": "âª€",
  "gesdoto;": "âª‚",
  "gesdotol;": "âª„",
  "gesl;": "â‹›ï¸€",
  "gesles;": "âª”",
  "Gfr;": "ð”Š",
  "gfr;": "ð”¤",
  "Gg;": "â‹™",
  "gg;": "â‰«",
  "ggg;": "â‹™",
  "gimel;": "â„·",
  "GJcy;": "Ðƒ",
  "gjcy;": "Ñ“",
  "gl;": "â‰·",
  "gla;": "âª¥",
  "glE;": "âª’",
  "glj;": "âª¤",
  "gnap;": "âªŠ",
  "gnapprox;": "âªŠ",
  "gnE;": "â‰©",
  "gne;": "âªˆ",
  "gneq;": "âªˆ",
  "gneqq;": "â‰©",
  "gnsim;": "â‹§",
  "Gopf;": "ð”¾",
  "gopf;": "ð•˜",
  "grave;": "`",
  "GreaterEqual;": "â‰¥",
  "GreaterEqualLess;": "â‹›",
  "GreaterFullEqual;": "â‰§",
  "GreaterGreater;": "âª¢",
  "GreaterLess;": "â‰·",
  "GreaterSlantEqual;": "â©¾",
  "GreaterTilde;": "â‰³",
  "Gscr;": "ð’¢",
  "gscr;": "â„Š",
  "gsim;": "â‰³",
  "gsime;": "âªŽ",
  "gsiml;": "âª",
  "GT;": ">",
  GT: GT$4,
  "Gt;": "â‰«",
  "gt;": ">",
  gt: gt$6,
  "gtcc;": "âª§",
  "gtcir;": "â©º",
  "gtdot;": "â‹—",
  "gtlPar;": "â¦•",
  "gtquest;": "â©¼",
  "gtrapprox;": "âª†",
  "gtrarr;": "â¥¸",
  "gtrdot;": "â‹—",
  "gtreqless;": "â‹›",
  "gtreqqless;": "âªŒ",
  "gtrless;": "â‰·",
  "gtrsim;": "â‰³",
  "gvertneqq;": "â‰©ï¸€",
  "gvnE;": "â‰©ï¸€",
  "Hacek;": "Ë‡",
  "hairsp;": "â€Š",
  "half;": "Â½",
  "hamilt;": "â„‹",
  "HARDcy;": "Ðª",
  "hardcy;": "ÑŠ",
  "hArr;": "â‡”",
  "harr;": "â†”",
  "harrcir;": "â¥ˆ",
  "harrw;": "â†­",
  "Hat;": "^",
  "hbar;": "â„",
  "Hcirc;": "Ä¤",
  "hcirc;": "Ä¥",
  "hearts;": "â™¥",
  "heartsuit;": "â™¥",
  "hellip;": "â€¦",
  "hercon;": "âŠ¹",
  "Hfr;": "â„Œ",
  "hfr;": "ð”¥",
  "HilbertSpace;": "â„‹",
  "hksearow;": "â¤¥",
  "hkswarow;": "â¤¦",
  "hoarr;": "â‡¿",
  "homtht;": "âˆ»",
  "hookleftarrow;": "â†©",
  "hookrightarrow;": "â†ª",
  "Hopf;": "â„",
  "hopf;": "ð•™",
  "horbar;": "â€•",
  "HorizontalLine;": "â”€",
  "Hscr;": "â„‹",
  "hscr;": "ð’½",
  "hslash;": "â„",
  "Hstrok;": "Ä¦",
  "hstrok;": "Ä§",
  "HumpDownHump;": "â‰Ž",
  "HumpEqual;": "â‰",
  "hybull;": "âƒ",
  "hyphen;": "â€",
  "Iacute;": "Ã",
  Iacute: Iacute$4,
  "iacute;": "Ã­",
  iacute: iacute$4,
  "ic;": "â£",
  "Icirc;": "ÃŽ",
  Icirc: Icirc$4,
  "icirc;": "Ã®",
  icirc: icirc$4,
  "Icy;": "Ð˜",
  "icy;": "Ð¸",
  "Idot;": "Ä°",
  "IEcy;": "Ð•",
  "iecy;": "Ðµ",
  "iexcl;": "Â¡",
  iexcl: iexcl$4,
  "iff;": "â‡”",
  "Ifr;": "â„‘",
  "ifr;": "ð”¦",
  "Igrave;": "ÃŒ",
  Igrave: Igrave$4,
  "igrave;": "Ã¬",
  igrave: igrave$4,
  "ii;": "â…ˆ",
  "iiiint;": "â¨Œ",
  "iiint;": "âˆ­",
  "iinfin;": "â§œ",
  "iiota;": "â„©",
  "IJlig;": "Ä²",
  "ijlig;": "Ä³",
  "Im;": "â„‘",
  "Imacr;": "Äª",
  "imacr;": "Ä«",
  "image;": "â„‘",
  "ImaginaryI;": "â…ˆ",
  "imagline;": "â„",
  "imagpart;": "â„‘",
  "imath;": "Ä±",
  "imof;": "âŠ·",
  "imped;": "Æµ",
  "Implies;": "â‡’",
  "in;": "âˆˆ",
  "incare;": "â„…",
  "infin;": "âˆž",
  "infintie;": "â§",
  "inodot;": "Ä±",
  "Int;": "âˆ¬",
  "int;": "âˆ«",
  "intcal;": "âŠº",
  "integers;": "â„¤",
  "Integral;": "âˆ«",
  "intercal;": "âŠº",
  "Intersection;": "â‹‚",
  "intlarhk;": "â¨—",
  "intprod;": "â¨¼",
  "InvisibleComma;": "â£",
  "InvisibleTimes;": "â¢",
  "IOcy;": "Ð",
  "iocy;": "Ñ‘",
  "Iogon;": "Ä®",
  "iogon;": "Ä¯",
  "Iopf;": "ð•€",
  "iopf;": "ð•š",
  "Iota;": "Î™",
  "iota;": "Î¹",
  "iprod;": "â¨¼",
  "iquest;": "Â¿",
  iquest: iquest$4,
  "Iscr;": "â„",
  "iscr;": "ð’¾",
  "isin;": "âˆˆ",
  "isindot;": "â‹µ",
  "isinE;": "â‹¹",
  "isins;": "â‹´",
  "isinsv;": "â‹³",
  "isinv;": "âˆˆ",
  "it;": "â¢",
  "Itilde;": "Ä¨",
  "itilde;": "Ä©",
  "Iukcy;": "Ð†",
  "iukcy;": "Ñ–",
  "Iuml;": "Ã",
  Iuml: Iuml$4,
  "iuml;": "Ã¯",
  iuml: iuml$4,
  "Jcirc;": "Ä´",
  "jcirc;": "Äµ",
  "Jcy;": "Ð™",
  "jcy;": "Ð¹",
  "Jfr;": "ð”",
  "jfr;": "ð”§",
  "jmath;": "È·",
  "Jopf;": "ð•",
  "jopf;": "ð•›",
  "Jscr;": "ð’¥",
  "jscr;": "ð’¿",
  "Jsercy;": "Ðˆ",
  "jsercy;": "Ñ˜",
  "Jukcy;": "Ð„",
  "jukcy;": "Ñ”",
  "Kappa;": "Îš",
  "kappa;": "Îº",
  "kappav;": "Ï°",
  "Kcedil;": "Ä¶",
  "kcedil;": "Ä·",
  "Kcy;": "Ðš",
  "kcy;": "Ðº",
  "Kfr;": "ð”Ž",
  "kfr;": "ð”¨",
  "kgreen;": "Ä¸",
  "KHcy;": "Ð¥",
  "khcy;": "Ñ…",
  "KJcy;": "ÐŒ",
  "kjcy;": "Ñœ",
  "Kopf;": "ð•‚",
  "kopf;": "ð•œ",
  "Kscr;": "ð’¦",
  "kscr;": "ð“€",
  "lAarr;": "â‡š",
  "Lacute;": "Ä¹",
  "lacute;": "Äº",
  "laemptyv;": "â¦´",
  "lagran;": "â„’",
  "Lambda;": "Î›",
  "lambda;": "Î»",
  "Lang;": "âŸª",
  "lang;": "âŸ¨",
  "langd;": "â¦‘",
  "langle;": "âŸ¨",
  "lap;": "âª…",
  "Laplacetrf;": "â„’",
  "laquo;": "Â«",
  laquo: laquo$4,
  "Larr;": "â†ž",
  "lArr;": "â‡",
  "larr;": "â†",
  "larrb;": "â‡¤",
  "larrbfs;": "â¤Ÿ",
  "larrfs;": "â¤",
  "larrhk;": "â†©",
  "larrlp;": "â†«",
  "larrpl;": "â¤¹",
  "larrsim;": "â¥³",
  "larrtl;": "â†¢",
  "lat;": "âª«",
  "lAtail;": "â¤›",
  "latail;": "â¤™",
  "late;": "âª­",
  "lates;": "âª­ï¸€",
  "lBarr;": "â¤Ž",
  "lbarr;": "â¤Œ",
  "lbbrk;": "â²",
  "lbrace;": "{",
  "lbrack;": "[",
  "lbrke;": "â¦‹",
  "lbrksld;": "â¦",
  "lbrkslu;": "â¦",
  "Lcaron;": "Ä½",
  "lcaron;": "Ä¾",
  "Lcedil;": "Ä»",
  "lcedil;": "Ä¼",
  "lceil;": "âŒˆ",
  "lcub;": "{",
  "Lcy;": "Ð›",
  "lcy;": "Ð»",
  "ldca;": "â¤¶",
  "ldquo;": "â€œ",
  "ldquor;": "â€ž",
  "ldrdhar;": "â¥§",
  "ldrushar;": "â¥‹",
  "ldsh;": "â†²",
  "lE;": "â‰¦",
  "le;": "â‰¤",
  "LeftAngleBracket;": "âŸ¨",
  "LeftArrow;": "â†",
  "Leftarrow;": "â‡",
  "leftarrow;": "â†",
  "LeftArrowBar;": "â‡¤",
  "LeftArrowRightArrow;": "â‡†",
  "leftarrowtail;": "â†¢",
  "LeftCeiling;": "âŒˆ",
  "LeftDoubleBracket;": "âŸ¦",
  "LeftDownTeeVector;": "â¥¡",
  "LeftDownVector;": "â‡ƒ",
  "LeftDownVectorBar;": "â¥™",
  "LeftFloor;": "âŒŠ",
  "leftharpoondown;": "â†½",
  "leftharpoonup;": "â†¼",
  "leftleftarrows;": "â‡‡",
  "LeftRightArrow;": "â†”",
  "Leftrightarrow;": "â‡”",
  "leftrightarrow;": "â†”",
  "leftrightarrows;": "â‡†",
  "leftrightharpoons;": "â‡‹",
  "leftrightsquigarrow;": "â†­",
  "LeftRightVector;": "â¥Ž",
  "LeftTee;": "âŠ£",
  "LeftTeeArrow;": "â†¤",
  "LeftTeeVector;": "â¥š",
  "leftthreetimes;": "â‹‹",
  "LeftTriangle;": "âŠ²",
  "LeftTriangleBar;": "â§",
  "LeftTriangleEqual;": "âŠ´",
  "LeftUpDownVector;": "â¥‘",
  "LeftUpTeeVector;": "â¥ ",
  "LeftUpVector;": "â†¿",
  "LeftUpVectorBar;": "â¥˜",
  "LeftVector;": "â†¼",
  "LeftVectorBar;": "â¥’",
  "lEg;": "âª‹",
  "leg;": "â‹š",
  "leq;": "â‰¤",
  "leqq;": "â‰¦",
  "leqslant;": "â©½",
  "les;": "â©½",
  "lescc;": "âª¨",
  "lesdot;": "â©¿",
  "lesdoto;": "âª",
  "lesdotor;": "âªƒ",
  "lesg;": "â‹šï¸€",
  "lesges;": "âª“",
  "lessapprox;": "âª…",
  "lessdot;": "â‹–",
  "lesseqgtr;": "â‹š",
  "lesseqqgtr;": "âª‹",
  "LessEqualGreater;": "â‹š",
  "LessFullEqual;": "â‰¦",
  "LessGreater;": "â‰¶",
  "lessgtr;": "â‰¶",
  "LessLess;": "âª¡",
  "lesssim;": "â‰²",
  "LessSlantEqual;": "â©½",
  "LessTilde;": "â‰²",
  "lfisht;": "â¥¼",
  "lfloor;": "âŒŠ",
  "Lfr;": "ð”",
  "lfr;": "ð”©",
  "lg;": "â‰¶",
  "lgE;": "âª‘",
  "lHar;": "â¥¢",
  "lhard;": "â†½",
  "lharu;": "â†¼",
  "lharul;": "â¥ª",
  "lhblk;": "â–„",
  "LJcy;": "Ð‰",
  "ljcy;": "Ñ™",
  "Ll;": "â‹˜",
  "ll;": "â‰ª",
  "llarr;": "â‡‡",
  "llcorner;": "âŒž",
  "Lleftarrow;": "â‡š",
  "llhard;": "â¥«",
  "lltri;": "â—º",
  "Lmidot;": "Ä¿",
  "lmidot;": "Å€",
  "lmoust;": "âŽ°",
  "lmoustache;": "âŽ°",
  "lnap;": "âª‰",
  "lnapprox;": "âª‰",
  "lnE;": "â‰¨",
  "lne;": "âª‡",
  "lneq;": "âª‡",
  "lneqq;": "â‰¨",
  "lnsim;": "â‹¦",
  "loang;": "âŸ¬",
  "loarr;": "â‡½",
  "lobrk;": "âŸ¦",
  "LongLeftArrow;": "âŸµ",
  "Longleftarrow;": "âŸ¸",
  "longleftarrow;": "âŸµ",
  "LongLeftRightArrow;": "âŸ·",
  "Longleftrightarrow;": "âŸº",
  "longleftrightarrow;": "âŸ·",
  "longmapsto;": "âŸ¼",
  "LongRightArrow;": "âŸ¶",
  "Longrightarrow;": "âŸ¹",
  "longrightarrow;": "âŸ¶",
  "looparrowleft;": "â†«",
  "looparrowright;": "â†¬",
  "lopar;": "â¦…",
  "Lopf;": "ð•ƒ",
  "lopf;": "ð•",
  "loplus;": "â¨­",
  "lotimes;": "â¨´",
  "lowast;": "âˆ—",
  "lowbar;": "_",
  "LowerLeftArrow;": "â†™",
  "LowerRightArrow;": "â†˜",
  "loz;": "â—Š",
  "lozenge;": "â—Š",
  "lozf;": "â§«",
  "lpar;": "(",
  "lparlt;": "â¦“",
  "lrarr;": "â‡†",
  "lrcorner;": "âŒŸ",
  "lrhar;": "â‡‹",
  "lrhard;": "â¥­",
  "lrm;": "â€Ž",
  "lrtri;": "âŠ¿",
  "lsaquo;": "â€¹",
  "Lscr;": "â„’",
  "lscr;": "ð“",
  "Lsh;": "â†°",
  "lsh;": "â†°",
  "lsim;": "â‰²",
  "lsime;": "âª",
  "lsimg;": "âª",
  "lsqb;": "[",
  "lsquo;": "â€˜",
  "lsquor;": "â€š",
  "Lstrok;": "Å",
  "lstrok;": "Å‚",
  "LT;": "<",
  LT: LT$4,
  "Lt;": "â‰ª",
  "lt;": "<",
  lt: lt$6,
  "ltcc;": "âª¦",
  "ltcir;": "â©¹",
  "ltdot;": "â‹–",
  "lthree;": "â‹‹",
  "ltimes;": "â‹‰",
  "ltlarr;": "â¥¶",
  "ltquest;": "â©»",
  "ltri;": "â—ƒ",
  "ltrie;": "âŠ´",
  "ltrif;": "â—‚",
  "ltrPar;": "â¦–",
  "lurdshar;": "â¥Š",
  "luruhar;": "â¥¦",
  "lvertneqq;": "â‰¨ï¸€",
  "lvnE;": "â‰¨ï¸€",
  "macr;": "Â¯",
  macr: macr$4,
  "male;": "â™‚",
  "malt;": "âœ ",
  "maltese;": "âœ ",
  "Map;": "â¤…",
  "map;": "â†¦",
  "mapsto;": "â†¦",
  "mapstodown;": "â†§",
  "mapstoleft;": "â†¤",
  "mapstoup;": "â†¥",
  "marker;": "â–®",
  "mcomma;": "â¨©",
  "Mcy;": "Ðœ",
  "mcy;": "Ð¼",
  "mdash;": "â€”",
  "mDDot;": "âˆº",
  "measuredangle;": "âˆ¡",
  "MediumSpace;": "âŸ",
  "Mellintrf;": "â„³",
  "Mfr;": "ð”",
  "mfr;": "ð”ª",
  "mho;": "â„§",
  "micro;": "Âµ",
  micro: micro$4,
  "mid;": "âˆ£",
  "midast;": "*",
  "midcir;": "â«°",
  "middot;": "Â·",
  middot: middot$4,
  "minus;": "âˆ’",
  "minusb;": "âŠŸ",
  "minusd;": "âˆ¸",
  "minusdu;": "â¨ª",
  "MinusPlus;": "âˆ“",
  "mlcp;": "â«›",
  "mldr;": "â€¦",
  "mnplus;": "âˆ“",
  "models;": "âŠ§",
  "Mopf;": "ð•„",
  "mopf;": "ð•ž",
  "mp;": "âˆ“",
  "Mscr;": "â„³",
  "mscr;": "ð“‚",
  "mstpos;": "âˆ¾",
  "Mu;": "Îœ",
  "mu;": "Î¼",
  "multimap;": "âŠ¸",
  "mumap;": "âŠ¸",
  "nabla;": "âˆ‡",
  "Nacute;": "Åƒ",
  "nacute;": "Å„",
  "nang;": "âˆ âƒ’",
  "nap;": "â‰‰",
  "napE;": "â©°Ì¸",
  "napid;": "â‰‹Ì¸",
  "napos;": "Å‰",
  "napprox;": "â‰‰",
  "natur;": "â™®",
  "natural;": "â™®",
  "naturals;": "â„•",
  "nbsp;": "Â ",
  nbsp: nbsp$4,
  "nbump;": "â‰ŽÌ¸",
  "nbumpe;": "â‰Ì¸",
  "ncap;": "â©ƒ",
  "Ncaron;": "Å‡",
  "ncaron;": "Åˆ",
  "Ncedil;": "Å…",
  "ncedil;": "Å†",
  "ncong;": "â‰‡",
  "ncongdot;": "â©­Ì¸",
  "ncup;": "â©‚",
  "Ncy;": "Ð",
  "ncy;": "Ð½",
  "ndash;": "â€“",
  "ne;": "â‰ ",
  "nearhk;": "â¤¤",
  "neArr;": "â‡—",
  "nearr;": "â†—",
  "nearrow;": "â†—",
  "nedot;": "â‰Ì¸",
  "NegativeMediumSpace;": "â€‹",
  "NegativeThickSpace;": "â€‹",
  "NegativeThinSpace;": "â€‹",
  "NegativeVeryThinSpace;": "â€‹",
  "nequiv;": "â‰¢",
  "nesear;": "â¤¨",
  "nesim;": "â‰‚Ì¸",
  "NestedGreaterGreater;": "â‰«",
  "NestedLessLess;": "â‰ª",
  "NewLine;": "\n",
  "nexist;": "âˆ„",
  "nexists;": "âˆ„",
  "Nfr;": "ð”‘",
  "nfr;": "ð”«",
  "ngE;": "â‰§Ì¸",
  "nge;": "â‰±",
  "ngeq;": "â‰±",
  "ngeqq;": "â‰§Ì¸",
  "ngeqslant;": "â©¾Ì¸",
  "nges;": "â©¾Ì¸",
  "nGg;": "â‹™Ì¸",
  "ngsim;": "â‰µ",
  "nGt;": "â‰«âƒ’",
  "ngt;": "â‰¯",
  "ngtr;": "â‰¯",
  "nGtv;": "â‰«Ì¸",
  "nhArr;": "â‡Ž",
  "nharr;": "â†®",
  "nhpar;": "â«²",
  "ni;": "âˆ‹",
  "nis;": "â‹¼",
  "nisd;": "â‹º",
  "niv;": "âˆ‹",
  "NJcy;": "ÐŠ",
  "njcy;": "Ñš",
  "nlArr;": "â‡",
  "nlarr;": "â†š",
  "nldr;": "â€¥",
  "nlE;": "â‰¦Ì¸",
  "nle;": "â‰°",
  "nLeftarrow;": "â‡",
  "nleftarrow;": "â†š",
  "nLeftrightarrow;": "â‡Ž",
  "nleftrightarrow;": "â†®",
  "nleq;": "â‰°",
  "nleqq;": "â‰¦Ì¸",
  "nleqslant;": "â©½Ì¸",
  "nles;": "â©½Ì¸",
  "nless;": "â‰®",
  "nLl;": "â‹˜Ì¸",
  "nlsim;": "â‰´",
  "nLt;": "â‰ªâƒ’",
  "nlt;": "â‰®",
  "nltri;": "â‹ª",
  "nltrie;": "â‹¬",
  "nLtv;": "â‰ªÌ¸",
  "nmid;": "âˆ¤",
  "NoBreak;": "â ",
  "NonBreakingSpace;": "Â ",
  "Nopf;": "â„•",
  "nopf;": "ð•Ÿ",
  "Not;": "â«¬",
  "not;": "Â¬",
  not: not$4,
  "NotCongruent;": "â‰¢",
  "NotCupCap;": "â‰­",
  "NotDoubleVerticalBar;": "âˆ¦",
  "NotElement;": "âˆ‰",
  "NotEqual;": "â‰ ",
  "NotEqualTilde;": "â‰‚Ì¸",
  "NotExists;": "âˆ„",
  "NotGreater;": "â‰¯",
  "NotGreaterEqual;": "â‰±",
  "NotGreaterFullEqual;": "â‰§Ì¸",
  "NotGreaterGreater;": "â‰«Ì¸",
  "NotGreaterLess;": "â‰¹",
  "NotGreaterSlantEqual;": "â©¾Ì¸",
  "NotGreaterTilde;": "â‰µ",
  "NotHumpDownHump;": "â‰ŽÌ¸",
  "NotHumpEqual;": "â‰Ì¸",
  "notin;": "âˆ‰",
  "notindot;": "â‹µÌ¸",
  "notinE;": "â‹¹Ì¸",
  "notinva;": "âˆ‰",
  "notinvb;": "â‹·",
  "notinvc;": "â‹¶",
  "NotLeftTriangle;": "â‹ª",
  "NotLeftTriangleBar;": "â§Ì¸",
  "NotLeftTriangleEqual;": "â‹¬",
  "NotLess;": "â‰®",
  "NotLessEqual;": "â‰°",
  "NotLessGreater;": "â‰¸",
  "NotLessLess;": "â‰ªÌ¸",
  "NotLessSlantEqual;": "â©½Ì¸",
  "NotLessTilde;": "â‰´",
  "NotNestedGreaterGreater;": "âª¢Ì¸",
  "NotNestedLessLess;": "âª¡Ì¸",
  "notni;": "âˆŒ",
  "notniva;": "âˆŒ",
  "notnivb;": "â‹¾",
  "notnivc;": "â‹½",
  "NotPrecedes;": "âŠ€",
  "NotPrecedesEqual;": "âª¯Ì¸",
  "NotPrecedesSlantEqual;": "â‹ ",
  "NotReverseElement;": "âˆŒ",
  "NotRightTriangle;": "â‹«",
  "NotRightTriangleBar;": "â§Ì¸",
  "NotRightTriangleEqual;": "â‹­",
  "NotSquareSubset;": "âŠÌ¸",
  "NotSquareSubsetEqual;": "â‹¢",
  "NotSquareSuperset;": "âŠÌ¸",
  "NotSquareSupersetEqual;": "â‹£",
  "NotSubset;": "âŠ‚âƒ’",
  "NotSubsetEqual;": "âŠˆ",
  "NotSucceeds;": "âŠ",
  "NotSucceedsEqual;": "âª°Ì¸",
  "NotSucceedsSlantEqual;": "â‹¡",
  "NotSucceedsTilde;": "â‰¿Ì¸",
  "NotSuperset;": "âŠƒâƒ’",
  "NotSupersetEqual;": "âŠ‰",
  "NotTilde;": "â‰",
  "NotTildeEqual;": "â‰„",
  "NotTildeFullEqual;": "â‰‡",
  "NotTildeTilde;": "â‰‰",
  "NotVerticalBar;": "âˆ¤",
  "npar;": "âˆ¦",
  "nparallel;": "âˆ¦",
  "nparsl;": "â«½âƒ¥",
  "npart;": "âˆ‚Ì¸",
  "npolint;": "â¨”",
  "npr;": "âŠ€",
  "nprcue;": "â‹ ",
  "npre;": "âª¯Ì¸",
  "nprec;": "âŠ€",
  "npreceq;": "âª¯Ì¸",
  "nrArr;": "â‡",
  "nrarr;": "â†›",
  "nrarrc;": "â¤³Ì¸",
  "nrarrw;": "â†Ì¸",
  "nRightarrow;": "â‡",
  "nrightarrow;": "â†›",
  "nrtri;": "â‹«",
  "nrtrie;": "â‹­",
  "nsc;": "âŠ",
  "nsccue;": "â‹¡",
  "nsce;": "âª°Ì¸",
  "Nscr;": "ð’©",
  "nscr;": "ð“ƒ",
  "nshortmid;": "âˆ¤",
  "nshortparallel;": "âˆ¦",
  "nsim;": "â‰",
  "nsime;": "â‰„",
  "nsimeq;": "â‰„",
  "nsmid;": "âˆ¤",
  "nspar;": "âˆ¦",
  "nsqsube;": "â‹¢",
  "nsqsupe;": "â‹£",
  "nsub;": "âŠ„",
  "nsubE;": "â«…Ì¸",
  "nsube;": "âŠˆ",
  "nsubset;": "âŠ‚âƒ’",
  "nsubseteq;": "âŠˆ",
  "nsubseteqq;": "â«…Ì¸",
  "nsucc;": "âŠ",
  "nsucceq;": "âª°Ì¸",
  "nsup;": "âŠ…",
  "nsupE;": "â«†Ì¸",
  "nsupe;": "âŠ‰",
  "nsupset;": "âŠƒâƒ’",
  "nsupseteq;": "âŠ‰",
  "nsupseteqq;": "â«†Ì¸",
  "ntgl;": "â‰¹",
  "Ntilde;": "Ã‘",
  Ntilde: Ntilde$4,
  "ntilde;": "Ã±",
  ntilde: ntilde$4,
  "ntlg;": "â‰¸",
  "ntriangleleft;": "â‹ª",
  "ntrianglelefteq;": "â‹¬",
  "ntriangleright;": "â‹«",
  "ntrianglerighteq;": "â‹­",
  "Nu;": "Î",
  "nu;": "Î½",
  "num;": "#",
  "numero;": "â„–",
  "numsp;": "â€‡",
  "nvap;": "â‰âƒ’",
  "nVDash;": "âŠ¯",
  "nVdash;": "âŠ®",
  "nvDash;": "âŠ­",
  "nvdash;": "âŠ¬",
  "nvge;": "â‰¥âƒ’",
  "nvgt;": ">âƒ’",
  "nvHarr;": "â¤„",
  "nvinfin;": "â§ž",
  "nvlArr;": "â¤‚",
  "nvle;": "â‰¤âƒ’",
  "nvlt;": "<âƒ’",
  "nvltrie;": "âŠ´âƒ’",
  "nvrArr;": "â¤ƒ",
  "nvrtrie;": "âŠµâƒ’",
  "nvsim;": "âˆ¼âƒ’",
  "nwarhk;": "â¤£",
  "nwArr;": "â‡–",
  "nwarr;": "â†–",
  "nwarrow;": "â†–",
  "nwnear;": "â¤§",
  "Oacute;": "Ã“",
  Oacute: Oacute$4,
  "oacute;": "Ã³",
  oacute: oacute$4,
  "oast;": "âŠ›",
  "ocir;": "âŠš",
  "Ocirc;": "Ã”",
  Ocirc: Ocirc$4,
  "ocirc;": "Ã´",
  ocirc: ocirc$4,
  "Ocy;": "Ðž",
  "ocy;": "Ð¾",
  "odash;": "âŠ",
  "Odblac;": "Å",
  "odblac;": "Å‘",
  "odiv;": "â¨¸",
  "odot;": "âŠ™",
  "odsold;": "â¦¼",
  "OElig;": "Å’",
  "oelig;": "Å“",
  "ofcir;": "â¦¿",
  "Ofr;": "ð”’",
  "ofr;": "ð”¬",
  "ogon;": "Ë›",
  "Ograve;": "Ã’",
  Ograve: Ograve$4,
  "ograve;": "Ã²",
  ograve: ograve$4,
  "ogt;": "â§",
  "ohbar;": "â¦µ",
  "ohm;": "Î©",
  "oint;": "âˆ®",
  "olarr;": "â†º",
  "olcir;": "â¦¾",
  "olcross;": "â¦»",
  "oline;": "â€¾",
  "olt;": "â§€",
  "Omacr;": "ÅŒ",
  "omacr;": "Å",
  "Omega;": "Î©",
  "omega;": "Ï‰",
  "Omicron;": "ÎŸ",
  "omicron;": "Î¿",
  "omid;": "â¦¶",
  "ominus;": "âŠ–",
  "Oopf;": "ð•†",
  "oopf;": "ð• ",
  "opar;": "â¦·",
  "OpenCurlyDoubleQuote;": "â€œ",
  "OpenCurlyQuote;": "â€˜",
  "operp;": "â¦¹",
  "oplus;": "âŠ•",
  "Or;": "â©”",
  "or;": "âˆ¨",
  "orarr;": "â†»",
  "ord;": "â©",
  "order;": "â„´",
  "orderof;": "â„´",
  "ordf;": "Âª",
  ordf: ordf$4,
  "ordm;": "Âº",
  ordm: ordm$4,
  "origof;": "âŠ¶",
  "oror;": "â©–",
  "orslope;": "â©—",
  "orv;": "â©›",
  "oS;": "â“ˆ",
  "Oscr;": "ð’ª",
  "oscr;": "â„´",
  "Oslash;": "Ã˜",
  Oslash: Oslash$4,
  "oslash;": "Ã¸",
  oslash: oslash$4,
  "osol;": "âŠ˜",
  "Otilde;": "Ã•",
  Otilde: Otilde$4,
  "otilde;": "Ãµ",
  otilde: otilde$4,
  "Otimes;": "â¨·",
  "otimes;": "âŠ—",
  "otimesas;": "â¨¶",
  "Ouml;": "Ã–",
  Ouml: Ouml$4,
  "ouml;": "Ã¶",
  ouml: ouml$4,
  "ovbar;": "âŒ½",
  "OverBar;": "â€¾",
  "OverBrace;": "âž",
  "OverBracket;": "âŽ´",
  "OverParenthesis;": "âœ",
  "par;": "âˆ¥",
  "para;": "Â¶",
  para: para$4,
  "parallel;": "âˆ¥",
  "parsim;": "â«³",
  "parsl;": "â«½",
  "part;": "âˆ‚",
  "PartialD;": "âˆ‚",
  "Pcy;": "ÐŸ",
  "pcy;": "Ð¿",
  "percnt;": "%",
  "period;": ".",
  "permil;": "â€°",
  "perp;": "âŠ¥",
  "pertenk;": "â€±",
  "Pfr;": "ð”“",
  "pfr;": "ð”­",
  "Phi;": "Î¦",
  "phi;": "Ï†",
  "phiv;": "Ï•",
  "phmmat;": "â„³",
  "phone;": "â˜Ž",
  "Pi;": "Î ",
  "pi;": "Ï€",
  "pitchfork;": "â‹”",
  "piv;": "Ï–",
  "planck;": "â„",
  "planckh;": "â„Ž",
  "plankv;": "â„",
  "plus;": "+",
  "plusacir;": "â¨£",
  "plusb;": "âŠž",
  "pluscir;": "â¨¢",
  "plusdo;": "âˆ”",
  "plusdu;": "â¨¥",
  "pluse;": "â©²",
  "PlusMinus;": "Â±",
  "plusmn;": "Â±",
  plusmn: plusmn$4,
  "plussim;": "â¨¦",
  "plustwo;": "â¨§",
  "pm;": "Â±",
  "Poincareplane;": "â„Œ",
  "pointint;": "â¨•",
  "Popf;": "â„™",
  "popf;": "ð•¡",
  "pound;": "Â£",
  pound: pound$4,
  "Pr;": "âª»",
  "pr;": "â‰º",
  "prap;": "âª·",
  "prcue;": "â‰¼",
  "prE;": "âª³",
  "pre;": "âª¯",
  "prec;": "â‰º",
  "precapprox;": "âª·",
  "preccurlyeq;": "â‰¼",
  "Precedes;": "â‰º",
  "PrecedesEqual;": "âª¯",
  "PrecedesSlantEqual;": "â‰¼",
  "PrecedesTilde;": "â‰¾",
  "preceq;": "âª¯",
  "precnapprox;": "âª¹",
  "precneqq;": "âªµ",
  "precnsim;": "â‹¨",
  "precsim;": "â‰¾",
  "Prime;": "â€³",
  "prime;": "â€²",
  "primes;": "â„™",
  "prnap;": "âª¹",
  "prnE;": "âªµ",
  "prnsim;": "â‹¨",
  "prod;": "âˆ",
  "Product;": "âˆ",
  "profalar;": "âŒ®",
  "profline;": "âŒ’",
  "profsurf;": "âŒ“",
  "prop;": "âˆ",
  "Proportion;": "âˆ·",
  "Proportional;": "âˆ",
  "propto;": "âˆ",
  "prsim;": "â‰¾",
  "prurel;": "âŠ°",
  "Pscr;": "ð’«",
  "pscr;": "ð“…",
  "Psi;": "Î¨",
  "psi;": "Ïˆ",
  "puncsp;": "â€ˆ",
  "Qfr;": "ð””",
  "qfr;": "ð”®",
  "qint;": "â¨Œ",
  "Qopf;": "â„š",
  "qopf;": "ð•¢",
  "qprime;": "â—",
  "Qscr;": "ð’¬",
  "qscr;": "ð“†",
  "quaternions;": "â„",
  "quatint;": "â¨–",
  "quest;": "?",
  "questeq;": "â‰Ÿ",
  "QUOT;": '"',
  QUOT: QUOT$4,
  "quot;": '"',
  quot: quot$6,
  "rAarr;": "â‡›",
  "race;": "âˆ½Ì±",
  "Racute;": "Å”",
  "racute;": "Å•",
  "radic;": "âˆš",
  "raemptyv;": "â¦³",
  "Rang;": "âŸ«",
  "rang;": "âŸ©",
  "rangd;": "â¦’",
  "range;": "â¦¥",
  "rangle;": "âŸ©",
  "raquo;": "Â»",
  raquo: raquo$4,
  "Rarr;": "â† ",
  "rArr;": "â‡’",
  "rarr;": "â†’",
  "rarrap;": "â¥µ",
  "rarrb;": "â‡¥",
  "rarrbfs;": "â¤ ",
  "rarrc;": "â¤³",
  "rarrfs;": "â¤ž",
  "rarrhk;": "â†ª",
  "rarrlp;": "â†¬",
  "rarrpl;": "â¥…",
  "rarrsim;": "â¥´",
  "Rarrtl;": "â¤–",
  "rarrtl;": "â†£",
  "rarrw;": "â†",
  "rAtail;": "â¤œ",
  "ratail;": "â¤š",
  "ratio;": "âˆ¶",
  "rationals;": "â„š",
  "RBarr;": "â¤",
  "rBarr;": "â¤",
  "rbarr;": "â¤",
  "rbbrk;": "â³",
  "rbrace;": "}",
  "rbrack;": "]",
  "rbrke;": "â¦Œ",
  "rbrksld;": "â¦Ž",
  "rbrkslu;": "â¦",
  "Rcaron;": "Å˜",
  "rcaron;": "Å™",
  "Rcedil;": "Å–",
  "rcedil;": "Å—",
  "rceil;": "âŒ‰",
  "rcub;": "}",
  "Rcy;": "Ð ",
  "rcy;": "Ñ€",
  "rdca;": "â¤·",
  "rdldhar;": "â¥©",
  "rdquo;": "â€",
  "rdquor;": "â€",
  "rdsh;": "â†³",
  "Re;": "â„œ",
  "real;": "â„œ",
  "realine;": "â„›",
  "realpart;": "â„œ",
  "reals;": "â„",
  "rect;": "â–­",
  "REG;": "Â®",
  REG: REG$4,
  "reg;": "Â®",
  reg: reg$4,
  "ReverseElement;": "âˆ‹",
  "ReverseEquilibrium;": "â‡‹",
  "ReverseUpEquilibrium;": "â¥¯",
  "rfisht;": "â¥½",
  "rfloor;": "âŒ‹",
  "Rfr;": "â„œ",
  "rfr;": "ð”¯",
  "rHar;": "â¥¤",
  "rhard;": "â‡",
  "rharu;": "â‡€",
  "rharul;": "â¥¬",
  "Rho;": "Î¡",
  "rho;": "Ï",
  "rhov;": "Ï±",
  "RightAngleBracket;": "âŸ©",
  "RightArrow;": "â†’",
  "Rightarrow;": "â‡’",
  "rightarrow;": "â†’",
  "RightArrowBar;": "â‡¥",
  "RightArrowLeftArrow;": "â‡„",
  "rightarrowtail;": "â†£",
  "RightCeiling;": "âŒ‰",
  "RightDoubleBracket;": "âŸ§",
  "RightDownTeeVector;": "â¥",
  "RightDownVector;": "â‡‚",
  "RightDownVectorBar;": "â¥•",
  "RightFloor;": "âŒ‹",
  "rightharpoondown;": "â‡",
  "rightharpoonup;": "â‡€",
  "rightleftarrows;": "â‡„",
  "rightleftharpoons;": "â‡Œ",
  "rightrightarrows;": "â‡‰",
  "rightsquigarrow;": "â†",
  "RightTee;": "âŠ¢",
  "RightTeeArrow;": "â†¦",
  "RightTeeVector;": "â¥›",
  "rightthreetimes;": "â‹Œ",
  "RightTriangle;": "âŠ³",
  "RightTriangleBar;": "â§",
  "RightTriangleEqual;": "âŠµ",
  "RightUpDownVector;": "â¥",
  "RightUpTeeVector;": "â¥œ",
  "RightUpVector;": "â†¾",
  "RightUpVectorBar;": "â¥”",
  "RightVector;": "â‡€",
  "RightVectorBar;": "â¥“",
  "ring;": "Ëš",
  "risingdotseq;": "â‰“",
  "rlarr;": "â‡„",
  "rlhar;": "â‡Œ",
  "rlm;": "â€",
  "rmoust;": "âŽ±",
  "rmoustache;": "âŽ±",
  "rnmid;": "â«®",
  "roang;": "âŸ­",
  "roarr;": "â‡¾",
  "robrk;": "âŸ§",
  "ropar;": "â¦†",
  "Ropf;": "â„",
  "ropf;": "ð•£",
  "roplus;": "â¨®",
  "rotimes;": "â¨µ",
  "RoundImplies;": "â¥°",
  "rpar;": ")",
  "rpargt;": "â¦”",
  "rppolint;": "â¨’",
  "rrarr;": "â‡‰",
  "Rrightarrow;": "â‡›",
  "rsaquo;": "â€º",
  "Rscr;": "â„›",
  "rscr;": "ð“‡",
  "Rsh;": "â†±",
  "rsh;": "â†±",
  "rsqb;": "]",
  "rsquo;": "â€™",
  "rsquor;": "â€™",
  "rthree;": "â‹Œ",
  "rtimes;": "â‹Š",
  "rtri;": "â–¹",
  "rtrie;": "âŠµ",
  "rtrif;": "â–¸",
  "rtriltri;": "â§Ž",
  "RuleDelayed;": "â§´",
  "ruluhar;": "â¥¨",
  "rx;": "â„ž",
  "Sacute;": "Åš",
  "sacute;": "Å›",
  "sbquo;": "â€š",
  "Sc;": "âª¼",
  "sc;": "â‰»",
  "scap;": "âª¸",
  "Scaron;": "Å ",
  "scaron;": "Å¡",
  "sccue;": "â‰½",
  "scE;": "âª´",
  "sce;": "âª°",
  "Scedil;": "Åž",
  "scedil;": "ÅŸ",
  "Scirc;": "Åœ",
  "scirc;": "Å",
  "scnap;": "âªº",
  "scnE;": "âª¶",
  "scnsim;": "â‹©",
  "scpolint;": "â¨“",
  "scsim;": "â‰¿",
  "Scy;": "Ð¡",
  "scy;": "Ñ",
  "sdot;": "â‹…",
  "sdotb;": "âŠ¡",
  "sdote;": "â©¦",
  "searhk;": "â¤¥",
  "seArr;": "â‡˜",
  "searr;": "â†˜",
  "searrow;": "â†˜",
  "sect;": "Â§",
  sect: sect$4,
  "semi;": ";",
  "seswar;": "â¤©",
  "setminus;": "âˆ–",
  "setmn;": "âˆ–",
  "sext;": "âœ¶",
  "Sfr;": "ð”–",
  "sfr;": "ð”°",
  "sfrown;": "âŒ¢",
  "sharp;": "â™¯",
  "SHCHcy;": "Ð©",
  "shchcy;": "Ñ‰",
  "SHcy;": "Ð¨",
  "shcy;": "Ñˆ",
  "ShortDownArrow;": "â†“",
  "ShortLeftArrow;": "â†",
  "shortmid;": "âˆ£",
  "shortparallel;": "âˆ¥",
  "ShortRightArrow;": "â†’",
  "ShortUpArrow;": "â†‘",
  "shy;": "Â­",
  shy: shy$4,
  "Sigma;": "Î£",
  "sigma;": "Ïƒ",
  "sigmaf;": "Ï‚",
  "sigmav;": "Ï‚",
  "sim;": "âˆ¼",
  "simdot;": "â©ª",
  "sime;": "â‰ƒ",
  "simeq;": "â‰ƒ",
  "simg;": "âªž",
  "simgE;": "âª ",
  "siml;": "âª",
  "simlE;": "âªŸ",
  "simne;": "â‰†",
  "simplus;": "â¨¤",
  "simrarr;": "â¥²",
  "slarr;": "â†",
  "SmallCircle;": "âˆ˜",
  "smallsetminus;": "âˆ–",
  "smashp;": "â¨³",
  "smeparsl;": "â§¤",
  "smid;": "âˆ£",
  "smile;": "âŒ£",
  "smt;": "âªª",
  "smte;": "âª¬",
  "smtes;": "âª¬ï¸€",
  "SOFTcy;": "Ð¬",
  "softcy;": "ÑŒ",
  "sol;": "/",
  "solb;": "â§„",
  "solbar;": "âŒ¿",
  "Sopf;": "ð•Š",
  "sopf;": "ð•¤",
  "spades;": "â™ ",
  "spadesuit;": "â™ ",
  "spar;": "âˆ¥",
  "sqcap;": "âŠ“",
  "sqcaps;": "âŠ“ï¸€",
  "sqcup;": "âŠ”",
  "sqcups;": "âŠ”ï¸€",
  "Sqrt;": "âˆš",
  "sqsub;": "âŠ",
  "sqsube;": "âŠ‘",
  "sqsubset;": "âŠ",
  "sqsubseteq;": "âŠ‘",
  "sqsup;": "âŠ",
  "sqsupe;": "âŠ’",
  "sqsupset;": "âŠ",
  "sqsupseteq;": "âŠ’",
  "squ;": "â–¡",
  "Square;": "â–¡",
  "square;": "â–¡",
  "SquareIntersection;": "âŠ“",
  "SquareSubset;": "âŠ",
  "SquareSubsetEqual;": "âŠ‘",
  "SquareSuperset;": "âŠ",
  "SquareSupersetEqual;": "âŠ’",
  "SquareUnion;": "âŠ”",
  "squarf;": "â–ª",
  "squf;": "â–ª",
  "srarr;": "â†’",
  "Sscr;": "ð’®",
  "sscr;": "ð“ˆ",
  "ssetmn;": "âˆ–",
  "ssmile;": "âŒ£",
  "sstarf;": "â‹†",
  "Star;": "â‹†",
  "star;": "â˜†",
  "starf;": "â˜…",
  "straightepsilon;": "Ïµ",
  "straightphi;": "Ï•",
  "strns;": "Â¯",
  "Sub;": "â‹",
  "sub;": "âŠ‚",
  "subdot;": "âª½",
  "subE;": "â«…",
  "sube;": "âŠ†",
  "subedot;": "â«ƒ",
  "submult;": "â«",
  "subnE;": "â«‹",
  "subne;": "âŠŠ",
  "subplus;": "âª¿",
  "subrarr;": "â¥¹",
  "Subset;": "â‹",
  "subset;": "âŠ‚",
  "subseteq;": "âŠ†",
  "subseteqq;": "â«…",
  "SubsetEqual;": "âŠ†",
  "subsetneq;": "âŠŠ",
  "subsetneqq;": "â«‹",
  "subsim;": "â«‡",
  "subsub;": "â«•",
  "subsup;": "â«“",
  "succ;": "â‰»",
  "succapprox;": "âª¸",
  "succcurlyeq;": "â‰½",
  "Succeeds;": "â‰»",
  "SucceedsEqual;": "âª°",
  "SucceedsSlantEqual;": "â‰½",
  "SucceedsTilde;": "â‰¿",
  "succeq;": "âª°",
  "succnapprox;": "âªº",
  "succneqq;": "âª¶",
  "succnsim;": "â‹©",
  "succsim;": "â‰¿",
  "SuchThat;": "âˆ‹",
  "Sum;": "âˆ‘",
  "sum;": "âˆ‘",
  "sung;": "â™ª",
  "Sup;": "â‹‘",
  "sup;": "âŠƒ",
  "sup1;": "Â¹",
  sup1: sup1$4,
  "sup2;": "Â²",
  sup2: sup2$4,
  "sup3;": "Â³",
  sup3: sup3$4,
  "supdot;": "âª¾",
  "supdsub;": "â«˜",
  "supE;": "â«†",
  "supe;": "âŠ‡",
  "supedot;": "â«„",
  "Superset;": "âŠƒ",
  "SupersetEqual;": "âŠ‡",
  "suphsol;": "âŸ‰",
  "suphsub;": "â«—",
  "suplarr;": "â¥»",
  "supmult;": "â«‚",
  "supnE;": "â«Œ",
  "supne;": "âŠ‹",
  "supplus;": "â«€",
  "Supset;": "â‹‘",
  "supset;": "âŠƒ",
  "supseteq;": "âŠ‡",
  "supseteqq;": "â«†",
  "supsetneq;": "âŠ‹",
  "supsetneqq;": "â«Œ",
  "supsim;": "â«ˆ",
  "supsub;": "â«”",
  "supsup;": "â«–",
  "swarhk;": "â¤¦",
  "swArr;": "â‡™",
  "swarr;": "â†™",
  "swarrow;": "â†™",
  "swnwar;": "â¤ª",
  "szlig;": "ÃŸ",
  szlig: szlig$4,
  "Tab;": "	",
  "target;": "âŒ–",
  "Tau;": "Î¤",
  "tau;": "Ï„",
  "tbrk;": "âŽ´",
  "Tcaron;": "Å¤",
  "tcaron;": "Å¥",
  "Tcedil;": "Å¢",
  "tcedil;": "Å£",
  "Tcy;": "Ð¢",
  "tcy;": "Ñ‚",
  "tdot;": "âƒ›",
  "telrec;": "âŒ•",
  "Tfr;": "ð”—",
  "tfr;": "ð”±",
  "there4;": "âˆ´",
  "Therefore;": "âˆ´",
  "therefore;": "âˆ´",
  "Theta;": "Î˜",
  "theta;": "Î¸",
  "thetasym;": "Ï‘",
  "thetav;": "Ï‘",
  "thickapprox;": "â‰ˆ",
  "thicksim;": "âˆ¼",
  "ThickSpace;": "âŸâ€Š",
  "thinsp;": "â€‰",
  "ThinSpace;": "â€‰",
  "thkap;": "â‰ˆ",
  "thksim;": "âˆ¼",
  "THORN;": "Ãž",
  THORN: THORN$4,
  "thorn;": "Ã¾",
  thorn: thorn$4,
  "Tilde;": "âˆ¼",
  "tilde;": "Ëœ",
  "TildeEqual;": "â‰ƒ",
  "TildeFullEqual;": "â‰…",
  "TildeTilde;": "â‰ˆ",
  "times;": "Ã—",
  times: times$4,
  "timesb;": "âŠ ",
  "timesbar;": "â¨±",
  "timesd;": "â¨°",
  "tint;": "âˆ­",
  "toea;": "â¤¨",
  "top;": "âŠ¤",
  "topbot;": "âŒ¶",
  "topcir;": "â«±",
  "Topf;": "ð•‹",
  "topf;": "ð•¥",
  "topfork;": "â«š",
  "tosa;": "â¤©",
  "tprime;": "â€´",
  "TRADE;": "â„¢",
  "trade;": "â„¢",
  "triangle;": "â–µ",
  "triangledown;": "â–¿",
  "triangleleft;": "â—ƒ",
  "trianglelefteq;": "âŠ´",
  "triangleq;": "â‰œ",
  "triangleright;": "â–¹",
  "trianglerighteq;": "âŠµ",
  "tridot;": "â—¬",
  "trie;": "â‰œ",
  "triminus;": "â¨º",
  "TripleDot;": "âƒ›",
  "triplus;": "â¨¹",
  "trisb;": "â§",
  "tritime;": "â¨»",
  "trpezium;": "â¢",
  "Tscr;": "ð’¯",
  "tscr;": "ð“‰",
  "TScy;": "Ð¦",
  "tscy;": "Ñ†",
  "TSHcy;": "Ð‹",
  "tshcy;": "Ñ›",
  "Tstrok;": "Å¦",
  "tstrok;": "Å§",
  "twixt;": "â‰¬",
  "twoheadleftarrow;": "â†ž",
  "twoheadrightarrow;": "â† ",
  "Uacute;": "Ãš",
  Uacute: Uacute$4,
  "uacute;": "Ãº",
  uacute: uacute$4,
  "Uarr;": "â†Ÿ",
  "uArr;": "â‡‘",
  "uarr;": "â†‘",
  "Uarrocir;": "â¥‰",
  "Ubrcy;": "ÐŽ",
  "ubrcy;": "Ñž",
  "Ubreve;": "Å¬",
  "ubreve;": "Å­",
  "Ucirc;": "Ã›",
  Ucirc: Ucirc$4,
  "ucirc;": "Ã»",
  ucirc: ucirc$4,
  "Ucy;": "Ð£",
  "ucy;": "Ñƒ",
  "udarr;": "â‡…",
  "Udblac;": "Å°",
  "udblac;": "Å±",
  "udhar;": "â¥®",
  "ufisht;": "â¥¾",
  "Ufr;": "ð”˜",
  "ufr;": "ð”²",
  "Ugrave;": "Ã™",
  Ugrave: Ugrave$4,
  "ugrave;": "Ã¹",
  ugrave: ugrave$4,
  "uHar;": "â¥£",
  "uharl;": "â†¿",
  "uharr;": "â†¾",
  "uhblk;": "â–€",
  "ulcorn;": "âŒœ",
  "ulcorner;": "âŒœ",
  "ulcrop;": "âŒ",
  "ultri;": "â—¸",
  "Umacr;": "Åª",
  "umacr;": "Å«",
  "uml;": "Â¨",
  uml: uml$4,
  "UnderBar;": "_",
  "UnderBrace;": "âŸ",
  "UnderBracket;": "âŽµ",
  "UnderParenthesis;": "â",
  "Union;": "â‹ƒ",
  "UnionPlus;": "âŠŽ",
  "Uogon;": "Å²",
  "uogon;": "Å³",
  "Uopf;": "ð•Œ",
  "uopf;": "ð•¦",
  "UpArrow;": "â†‘",
  "Uparrow;": "â‡‘",
  "uparrow;": "â†‘",
  "UpArrowBar;": "â¤’",
  "UpArrowDownArrow;": "â‡…",
  "UpDownArrow;": "â†•",
  "Updownarrow;": "â‡•",
  "updownarrow;": "â†•",
  "UpEquilibrium;": "â¥®",
  "upharpoonleft;": "â†¿",
  "upharpoonright;": "â†¾",
  "uplus;": "âŠŽ",
  "UpperLeftArrow;": "â†–",
  "UpperRightArrow;": "â†—",
  "Upsi;": "Ï’",
  "upsi;": "Ï…",
  "upsih;": "Ï’",
  "Upsilon;": "Î¥",
  "upsilon;": "Ï…",
  "UpTee;": "âŠ¥",
  "UpTeeArrow;": "â†¥",
  "upuparrows;": "â‡ˆ",
  "urcorn;": "âŒ",
  "urcorner;": "âŒ",
  "urcrop;": "âŒŽ",
  "Uring;": "Å®",
  "uring;": "Å¯",
  "urtri;": "â—¹",
  "Uscr;": "ð’°",
  "uscr;": "ð“Š",
  "utdot;": "â‹°",
  "Utilde;": "Å¨",
  "utilde;": "Å©",
  "utri;": "â–µ",
  "utrif;": "â–´",
  "uuarr;": "â‡ˆ",
  "Uuml;": "Ãœ",
  Uuml: Uuml$4,
  "uuml;": "Ã¼",
  uuml: uuml$4,
  "uwangle;": "â¦§",
  "vangrt;": "â¦œ",
  "varepsilon;": "Ïµ",
  "varkappa;": "Ï°",
  "varnothing;": "âˆ…",
  "varphi;": "Ï•",
  "varpi;": "Ï–",
  "varpropto;": "âˆ",
  "vArr;": "â‡•",
  "varr;": "â†•",
  "varrho;": "Ï±",
  "varsigma;": "Ï‚",
  "varsubsetneq;": "âŠŠï¸€",
  "varsubsetneqq;": "â«‹ï¸€",
  "varsupsetneq;": "âŠ‹ï¸€",
  "varsupsetneqq;": "â«Œï¸€",
  "vartheta;": "Ï‘",
  "vartriangleleft;": "âŠ²",
  "vartriangleright;": "âŠ³",
  "Vbar;": "â««",
  "vBar;": "â«¨",
  "vBarv;": "â«©",
  "Vcy;": "Ð’",
  "vcy;": "Ð²",
  "VDash;": "âŠ«",
  "Vdash;": "âŠ©",
  "vDash;": "âŠ¨",
  "vdash;": "âŠ¢",
  "Vdashl;": "â«¦",
  "Vee;": "â‹",
  "vee;": "âˆ¨",
  "veebar;": "âŠ»",
  "veeeq;": "â‰š",
  "vellip;": "â‹®",
  "Verbar;": "â€–",
  "verbar;": "|",
  "Vert;": "â€–",
  "vert;": "|",
  "VerticalBar;": "âˆ£",
  "VerticalLine;": "|",
  "VerticalSeparator;": "â˜",
  "VerticalTilde;": "â‰€",
  "VeryThinSpace;": "â€Š",
  "Vfr;": "ð”™",
  "vfr;": "ð”³",
  "vltri;": "âŠ²",
  "vnsub;": "âŠ‚âƒ’",
  "vnsup;": "âŠƒâƒ’",
  "Vopf;": "ð•",
  "vopf;": "ð•§",
  "vprop;": "âˆ",
  "vrtri;": "âŠ³",
  "Vscr;": "ð’±",
  "vscr;": "ð“‹",
  "vsubnE;": "â«‹ï¸€",
  "vsubne;": "âŠŠï¸€",
  "vsupnE;": "â«Œï¸€",
  "vsupne;": "âŠ‹ï¸€",
  "Vvdash;": "âŠª",
  "vzigzag;": "â¦š",
  "Wcirc;": "Å´",
  "wcirc;": "Åµ",
  "wedbar;": "â©Ÿ",
  "Wedge;": "â‹€",
  "wedge;": "âˆ§",
  "wedgeq;": "â‰™",
  "weierp;": "â„˜",
  "Wfr;": "ð”š",
  "wfr;": "ð”´",
  "Wopf;": "ð•Ž",
  "wopf;": "ð•¨",
  "wp;": "â„˜",
  "wr;": "â‰€",
  "wreath;": "â‰€",
  "Wscr;": "ð’²",
  "wscr;": "ð“Œ",
  "xcap;": "â‹‚",
  "xcirc;": "â—¯",
  "xcup;": "â‹ƒ",
  "xdtri;": "â–½",
  "Xfr;": "ð”›",
  "xfr;": "ð”µ",
  "xhArr;": "âŸº",
  "xharr;": "âŸ·",
  "Xi;": "Îž",
  "xi;": "Î¾",
  "xlArr;": "âŸ¸",
  "xlarr;": "âŸµ",
  "xmap;": "âŸ¼",
  "xnis;": "â‹»",
  "xodot;": "â¨€",
  "Xopf;": "ð•",
  "xopf;": "ð•©",
  "xoplus;": "â¨",
  "xotime;": "â¨‚",
  "xrArr;": "âŸ¹",
  "xrarr;": "âŸ¶",
  "Xscr;": "ð’³",
  "xscr;": "ð“",
  "xsqcup;": "â¨†",
  "xuplus;": "â¨„",
  "xutri;": "â–³",
  "xvee;": "â‹",
  "xwedge;": "â‹€",
  "Yacute;": "Ã",
  Yacute: Yacute$4,
  "yacute;": "Ã½",
  yacute: yacute$4,
  "YAcy;": "Ð¯",
  "yacy;": "Ñ",
  "Ycirc;": "Å¶",
  "ycirc;": "Å·",
  "Ycy;": "Ð«",
  "ycy;": "Ñ‹",
  "yen;": "Â¥",
  yen: yen$4,
  "Yfr;": "ð”œ",
  "yfr;": "ð”¶",
  "YIcy;": "Ð‡",
  "yicy;": "Ñ—",
  "Yopf;": "ð•",
  "yopf;": "ð•ª",
  "Yscr;": "ð’´",
  "yscr;": "ð“Ž",
  "YUcy;": "Ð®",
  "yucy;": "ÑŽ",
  "Yuml;": "Å¸",
  "yuml;": "Ã¿",
  yuml: yuml$4,
  "Zacute;": "Å¹",
  "zacute;": "Åº",
  "Zcaron;": "Å½",
  "zcaron;": "Å¾",
  "Zcy;": "Ð—",
  "zcy;": "Ð·",
  "Zdot;": "Å»",
  "zdot;": "Å¼",
  "zeetrf;": "â„¨",
  "ZeroWidthSpace;": "â€‹",
  "Zeta;": "Î–",
  "zeta;": "Î¶",
  "Zfr;": "â„¨",
  "zfr;": "ð”·",
  "ZHcy;": "Ð–",
  "zhcy;": "Ð¶",
  "zigrarr;": "â‡",
  "Zopf;": "â„¤",
  "zopf;": "ð•«",
  "Zscr;": "ð’µ",
  "zscr;": "ð“",
  "zwj;": "â€",
  "zwnj;": "â€Œ"
};
var decode$2;
var hasRequiredDecode$1;
function requireDecode$1() {
  if (hasRequiredDecode$1) return decode$2;
  hasRequiredDecode$1 = 1;
  var punycode2 = requirePunycode();
  var $encode = punycode2.ucs2.encode;
  var regexTest = /* @__PURE__ */ requireSafeRegexTest();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var $TypeError = /* @__PURE__ */ requireType();
  var entities2 = require$$4;
  var endsInSemicolon = regexTest(/;$/);
  var $replace = callBound2("String.prototype.replace");
  var $exec = callBound2("RegExp.prototype.exec");
  var $parseInt = parseInt;
  decode$2 = function decode2(str) {
    if (typeof str !== "string") {
      throw new $TypeError("Expected a String");
    }
    return $replace(str, /&(#?[^;\W]+;?)/g, function(_, match) {
      var m = $exec(/^#(\d+);?$/, match);
      if (m) {
        return $encode([$parseInt(m[1], 10)]);
      }
      var m2 = $exec(/^#[Xx]([A-Fa-f0-9]+);?/, match);
      if (m2) {
        return $encode([$parseInt(m2[1], 16)]);
      }
      var hasSemi = endsInSemicolon(match);
      var withoutSemi = hasSemi ? $replace(match, /;$/, "") : match;
      var target2 = entities2[withoutSemi] || hasSemi && entities2[match];
      if (typeof target2 === "number") {
        return $encode([target2]);
      } else if (typeof target2 === "string") {
        return target2;
      }
      return "&" + match;
    });
  };
  return decode$2;
}
var hasRequiredEnt;
function requireEnt() {
  if (hasRequiredEnt) return ent;
  hasRequiredEnt = 1;
  ent.encode = /* @__PURE__ */ requireEncode$1();
  ent.decode = /* @__PURE__ */ requireDecode$1();
  return ent;
}
var convertTagAttributes_1;
var hasRequiredConvertTagAttributes;
function requireConvertTagAttributes() {
  if (hasRequiredConvertTagAttributes) return convertTagAttributes_1;
  hasRequiredConvertTagAttributes = 1;
  var decode2 = requireEnt().decode;
  var MUST_USE_ATTRIBUTE = 1;
  var MUST_USE_PROPERTY = 2;
  var HAS_BOOLEAN_VALUE = 8;
  var HAS_NUMERIC_VALUE = 16;
  var HAS_POSITIVE_NUMERIC_VALUE = 32 | 16;
  var HAS_OVERLOADED_BOOLEAN_VALUE = 64;
  function checkMask(value, bitmask) {
    return (value & bitmask) === bitmask;
  }
  var isCustomAttribute = RegExp.prototype.test.bind(
    /^(data|aria)-[a-z_][a-z\d_.\-]*$/
  );
  var HTMLDOMPropertyConfig = {
    Properties: {
      /**
       * Standard Properties
       */
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoFocus: HAS_BOOLEAN_VALUE,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      challenge: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      // To set className on SVG elements, it's necessary to use .setAttribute;
      // this works on HTML elements too in all browsers except IE8.
      className: MUST_USE_ATTRIBUTE,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      // For `<object />` acts as `src`.
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      headers: null,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      high: null,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      is: MUST_USE_ATTRIBUTE,
      keyParams: MUST_USE_ATTRIBUTE,
      keyType: MUST_USE_ATTRIBUTE,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      low: null,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      minLength: MUST_USE_ATTRIBUTE,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      /**
       * Non-standard Properties
       */
      // autoCapitalize and autoCorrect are supported in Mobile Safari for
      // keyboard hints.
      autoCapitalize: null,
      autoCorrect: null,
      // itemProp, itemScope, itemType are for
      // Microdata support. See http://schema.org/docs/gs.html
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      // itemID and itemRef are for Microdata support as well but
      // only specified in the the WHATWG spec document. See
      // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
      itemID: MUST_USE_ATTRIBUTE,
      itemRef: MUST_USE_ATTRIBUTE,
      // property is supported for OpenGraph in meta tags.
      property: null,
      // IE-only attribute that controls focus behavior
      unselectable: MUST_USE_ATTRIBUTE
    }
  };
  var parseStyles = function(input) {
    var attributes = input.split(";");
    var styles = attributes.reduce(function(object2, attribute2) {
      var entry = attribute2.split(/:(.+)/);
      if (entry[0] && entry[1]) {
        object2[entry[0].trim()] = entry[1].trim();
      }
      return object2;
    }, {});
    return styles;
  };
  var propertyToAttributeMapping = {
    "className": "class",
    "htmlFor": "for",
    "httpEquiv": "http-equiv",
    "acceptCharset": "accept-charset"
  };
  var propertyValueConversions = {
    "style": parseStyles,
    "placeholder": decode2,
    "title": decode2,
    "alt": decode2
  };
  var getPropertyInfo = (function() {
    var propInfoByAttributeName = {};
    Object.keys(HTMLDOMPropertyConfig.Properties).forEach(function(propName) {
      var propConfig = HTMLDOMPropertyConfig.Properties[propName];
      var attributeName = propertyToAttributeMapping[propName] || propName.toLowerCase();
      var propertyInfo = {
        attributeName,
        propertyName: propName,
        mustUseAttribute: checkMask(propConfig, MUST_USE_ATTRIBUTE),
        mustUseProperty: checkMask(propConfig, MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      propInfoByAttributeName[attributeName] = propertyInfo;
    });
    return function(attributeName) {
      return propInfoByAttributeName[attributeName];
    };
  })();
  var convertTagAttributes = function(tag) {
    var attributes = tag.attribs;
    var vdomProperties = {
      attributes: {}
    };
    Object.keys(attributes).forEach(function(attributeName) {
      var lowerCased = attributeName.toLowerCase();
      var propInfo = getPropertyInfo(lowerCased);
      var value = attributes[attributeName];
      if (isCustomAttribute(attributeName) || !propInfo) {
        vdomProperties.attributes[attributeName] = value;
        return;
      }
      var valueConverter = propertyValueConversions[propInfo.propertyName];
      if (valueConverter) {
        value = valueConverter(value);
      }
      if (propInfo.mustUseAttribute) {
        if (propInfo.hasBooleanValue) {
          vdomProperties.attributes[propInfo.attributeName] = "";
        } else {
          vdomProperties.attributes[propInfo.attributeName] = value;
        }
      } else {
        var isTrue;
        if (propInfo.hasBooleanValue) {
          isTrue = value === "" || value.toLowerCase() === propInfo.attributeName;
          vdomProperties[propInfo.propertyName] = isTrue ? true : false;
        } else if (propInfo.hasOverloadedBooleanValue) {
          isTrue = value === "";
          vdomProperties[propInfo.propertyName] = isTrue ? true : value;
        } else if (propInfo.hasNumericValue || propInfo.hasPositiveNumericValue) {
          vdomProperties[propInfo.propertyName] = Number(value);
        } else {
          vdomProperties[propInfo.propertyName] = value;
        }
      }
    });
    return vdomProperties;
  };
  convertTagAttributes_1 = convertTagAttributes;
  return convertTagAttributes_1;
}
var htmlparserToVdom;
var hasRequiredHtmlparserToVdom;
function requireHtmlparserToVdom() {
  if (hasRequiredHtmlparserToVdom) return htmlparserToVdom;
  hasRequiredHtmlparserToVdom = 1;
  var decode2 = requireEnt().decode;
  var convertTagAttributes = requireConvertTagAttributes();
  htmlparserToVdom = function createConverter(VNode, VText) {
    var converter = {
      convert: function(node2, getVNodeKey) {
        if (node2.type === "tag" || node2.type === "script" || node2.type === "style") {
          return converter.convertTag(node2, getVNodeKey);
        } else if (node2.type === "text") {
          return new VText(decode2(node2.data));
        } else {
          return new VText("");
        }
      },
      convertTag: function(tag, getVNodeKey) {
        var attributes = convertTagAttributes(tag);
        var key;
        if (getVNodeKey) {
          key = getVNodeKey(attributes);
        }
        var children = Array.prototype.map.call(tag.children || [], function(node2) {
          return converter.convert(node2, getVNodeKey);
        });
        return new VNode(tag.name, attributes, children, key);
      }
    };
    return converter;
  };
  return htmlparserToVdom;
}
var lib$3 = { exports: {} };
const require$$0$2 = {
  "0": 65533,
  "128": 8364,
  "130": 8218,
  "131": 402,
  "132": 8222,
  "133": 8230,
  "134": 8224,
  "135": 8225,
  "136": 710,
  "137": 8240,
  "138": 352,
  "139": 8249,
  "140": 338,
  "142": 381,
  "145": 8216,
  "146": 8217,
  "147": 8220,
  "148": 8221,
  "149": 8226,
  "150": 8211,
  "151": 8212,
  "152": 732,
  "153": 8482,
  "154": 353,
  "155": 8250,
  "156": 339,
  "158": 382,
  "159": 376
};
var decode_codepoint$1;
var hasRequiredDecode_codepoint$1;
function requireDecode_codepoint$1() {
  if (hasRequiredDecode_codepoint$1) return decode_codepoint$1;
  hasRequiredDecode_codepoint$1 = 1;
  var decodeMap = require$$0$2;
  decode_codepoint$1 = decodeCodePoint;
  function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "ï¿½";
    }
    if (codePoint in decodeMap) {
      codePoint = decodeMap[codePoint];
    }
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
  return decode_codepoint$1;
}
const Aacute$3 = "Ã";
const aacute$3 = "Ã¡";
const Abreve$1 = "Ä‚";
const abreve$1 = "Äƒ";
const ac$1 = "âˆ¾";
const acd$1 = "âˆ¿";
const acE$1 = "âˆ¾Ì³";
const Acirc$3 = "Ã‚";
const acirc$3 = "Ã¢";
const acute$3 = "Â´";
const Acy$1 = "Ð";
const acy$1 = "Ð°";
const AElig$3 = "Ã†";
const aelig$3 = "Ã¦";
const af$1 = "â¡";
const Afr$1 = "ð”„";
const afr$1 = "ð”ž";
const Agrave$3 = "Ã€";
const agrave$3 = "Ã ";
const alefsym$1 = "â„µ";
const aleph$1 = "â„µ";
const Alpha$1 = "Î‘";
const alpha$1 = "Î±";
const Amacr$1 = "Ä€";
const amacr$1 = "Ä";
const amalg$1 = "â¨¿";
const amp$5 = "&";
const AMP$3 = "&";
const andand$1 = "â©•";
const And$1 = "â©“";
const and$1 = "âˆ§";
const andd$1 = "â©œ";
const andslope$1 = "â©˜";
const andv$1 = "â©š";
const ang$1 = "âˆ ";
const ange$1 = "â¦¤";
const angle$1 = "âˆ ";
const angmsdaa$1 = "â¦¨";
const angmsdab$1 = "â¦©";
const angmsdac$1 = "â¦ª";
const angmsdad$1 = "â¦«";
const angmsdae$1 = "â¦¬";
const angmsdaf$1 = "â¦­";
const angmsdag$1 = "â¦®";
const angmsdah$1 = "â¦¯";
const angmsd$1 = "âˆ¡";
const angrt$1 = "âˆŸ";
const angrtvb$1 = "âŠ¾";
const angrtvbd$1 = "â¦";
const angsph$1 = "âˆ¢";
const angst$1 = "Ã…";
const angzarr$1 = "â¼";
const Aogon$1 = "Ä„";
const aogon$1 = "Ä…";
const Aopf$1 = "ð”¸";
const aopf$1 = "ð•’";
const apacir$1 = "â©¯";
const ap$1 = "â‰ˆ";
const apE$1 = "â©°";
const ape$1 = "â‰Š";
const apid$1 = "â‰‹";
const apos$3 = "'";
const ApplyFunction$1 = "â¡";
const approx$1 = "â‰ˆ";
const approxeq$1 = "â‰Š";
const Aring$3 = "Ã…";
const aring$3 = "Ã¥";
const Ascr$1 = "ð’œ";
const ascr$1 = "ð’¶";
const Assign$1 = "â‰”";
const ast$1 = "*";
const asymp$1 = "â‰ˆ";
const asympeq$1 = "â‰";
const Atilde$3 = "Ãƒ";
const atilde$3 = "Ã£";
const Auml$3 = "Ã„";
const auml$3 = "Ã¤";
const awconint$1 = "âˆ³";
const awint$1 = "â¨‘";
const backcong$1 = "â‰Œ";
const backepsilon$1 = "Ï¶";
const backprime$1 = "â€µ";
const backsim$1 = "âˆ½";
const backsimeq$1 = "â‹";
const Backslash$1 = "âˆ–";
const Barv$1 = "â«§";
const barvee$1 = "âŠ½";
const barwed$1 = "âŒ…";
const Barwed$1 = "âŒ†";
const barwedge$1 = "âŒ…";
const bbrk$1 = "âŽµ";
const bbrktbrk$1 = "âŽ¶";
const bcong$1 = "â‰Œ";
const Bcy$1 = "Ð‘";
const bcy$1 = "Ð±";
const bdquo$1 = "â€ž";
const becaus$1 = "âˆµ";
const because$1 = "âˆµ";
const Because$1 = "âˆµ";
const bemptyv$1 = "â¦°";
const bepsi$1 = "Ï¶";
const bernou$1 = "â„¬";
const Bernoullis$1 = "â„¬";
const Beta$1 = "Î’";
const beta$1 = "Î²";
const beth$1 = "â„¶";
const between$1 = "â‰¬";
const Bfr$1 = "ð”…";
const bfr$1 = "ð”Ÿ";
const bigcap$1 = "â‹‚";
const bigcirc$1 = "â—¯";
const bigcup$1 = "â‹ƒ";
const bigodot$1 = "â¨€";
const bigoplus$1 = "â¨";
const bigotimes$1 = "â¨‚";
const bigsqcup$1 = "â¨†";
const bigstar$1 = "â˜…";
const bigtriangledown$1 = "â–½";
const bigtriangleup$1 = "â–³";
const biguplus$1 = "â¨„";
const bigvee$1 = "â‹";
const bigwedge$1 = "â‹€";
const bkarow$1 = "â¤";
const blacklozenge$1 = "â§«";
const blacksquare$1 = "â–ª";
const blacktriangle$1 = "â–´";
const blacktriangledown$1 = "â–¾";
const blacktriangleleft$1 = "â—‚";
const blacktriangleright$1 = "â–¸";
const blank$1 = "â£";
const blk12$1 = "â–’";
const blk14$1 = "â–‘";
const blk34$1 = "â–“";
const block$1 = "â–ˆ";
const bne$1 = "=âƒ¥";
const bnequiv$1 = "â‰¡âƒ¥";
const bNot$1 = "â«­";
const bnot$1 = "âŒ";
const Bopf$1 = "ð”¹";
const bopf$1 = "ð•“";
const bot$1 = "âŠ¥";
const bottom$1 = "âŠ¥";
const bowtie$1 = "â‹ˆ";
const boxbox$1 = "â§‰";
const boxdl$1 = "â”";
const boxdL$1 = "â••";
const boxDl$1 = "â•–";
const boxDL$1 = "â•—";
const boxdr$1 = "â”Œ";
const boxdR$1 = "â•’";
const boxDr$1 = "â•“";
const boxDR$1 = "â•”";
const boxh$1 = "â”€";
const boxH$1 = "â•";
const boxhd$1 = "â”¬";
const boxHd$1 = "â•¤";
const boxhD$1 = "â•¥";
const boxHD$1 = "â•¦";
const boxhu$1 = "â”´";
const boxHu$1 = "â•§";
const boxhU$1 = "â•¨";
const boxHU$1 = "â•©";
const boxminus$1 = "âŠŸ";
const boxplus$1 = "âŠž";
const boxtimes$1 = "âŠ ";
const boxul$1 = "â”˜";
const boxuL$1 = "â•›";
const boxUl$1 = "â•œ";
const boxUL$1 = "â•";
const boxur$1 = "â””";
const boxuR$1 = "â•˜";
const boxUr$1 = "â•™";
const boxUR$1 = "â•š";
const boxv$1 = "â”‚";
const boxV$1 = "â•‘";
const boxvh$1 = "â”¼";
const boxvH$1 = "â•ª";
const boxVh$1 = "â•«";
const boxVH$1 = "â•¬";
const boxvl$1 = "â”¤";
const boxvL$1 = "â•¡";
const boxVl$1 = "â•¢";
const boxVL$1 = "â•£";
const boxvr$1 = "â”œ";
const boxvR$1 = "â•ž";
const boxVr$1 = "â•Ÿ";
const boxVR$1 = "â• ";
const bprime$1 = "â€µ";
const breve$1 = "Ë˜";
const Breve$1 = "Ë˜";
const brvbar$3 = "Â¦";
const bscr$1 = "ð’·";
const Bscr$1 = "â„¬";
const bsemi$1 = "â";
const bsim$1 = "âˆ½";
const bsime$1 = "â‹";
const bsolb$1 = "â§…";
const bsol$1 = "\\";
const bsolhsub$1 = "âŸˆ";
const bull$1 = "â€¢";
const bullet$1 = "â€¢";
const bump$1 = "â‰Ž";
const bumpE$1 = "âª®";
const bumpe$1 = "â‰";
const Bumpeq$1 = "â‰Ž";
const bumpeq$1 = "â‰";
const Cacute$1 = "Ä†";
const cacute$1 = "Ä‡";
const capand$1 = "â©„";
const capbrcup$1 = "â©‰";
const capcap$1 = "â©‹";
const cap$1 = "âˆ©";
const Cap$1 = "â‹’";
const capcup$1 = "â©‡";
const capdot$1 = "â©€";
const CapitalDifferentialD$1 = "â……";
const caps$1 = "âˆ©ï¸€";
const caret$1 = "â";
const caron$1 = "Ë‡";
const Cayleys$1 = "â„­";
const ccaps$1 = "â©";
const Ccaron$1 = "ÄŒ";
const ccaron$1 = "Ä";
const Ccedil$3 = "Ã‡";
const ccedil$3 = "Ã§";
const Ccirc$1 = "Äˆ";
const ccirc$1 = "Ä‰";
const Cconint$1 = "âˆ°";
const ccups$1 = "â©Œ";
const ccupssm$1 = "â©";
const Cdot$1 = "ÄŠ";
const cdot$1 = "Ä‹";
const cedil$3 = "Â¸";
const Cedilla$1 = "Â¸";
const cemptyv$1 = "â¦²";
const cent$3 = "Â¢";
const centerdot$1 = "Â·";
const CenterDot$1 = "Â·";
const cfr$1 = "ð” ";
const Cfr$1 = "â„­";
const CHcy$1 = "Ð§";
const chcy$1 = "Ñ‡";
const check$1 = "âœ“";
const checkmark$1 = "âœ“";
const Chi$1 = "Î§";
const chi$1 = "Ï‡";
const circ$1 = "Ë†";
const circeq$1 = "â‰—";
const circlearrowleft$1 = "â†º";
const circlearrowright$1 = "â†»";
const circledast$1 = "âŠ›";
const circledcirc$1 = "âŠš";
const circleddash$1 = "âŠ";
const CircleDot$1 = "âŠ™";
const circledR$1 = "Â®";
const circledS$1 = "â“ˆ";
const CircleMinus$1 = "âŠ–";
const CirclePlus$1 = "âŠ•";
const CircleTimes$1 = "âŠ—";
const cir$1 = "â—‹";
const cirE$1 = "â§ƒ";
const cire$1 = "â‰—";
const cirfnint$1 = "â¨";
const cirmid$1 = "â«¯";
const cirscir$1 = "â§‚";
const ClockwiseContourIntegral$1 = "âˆ²";
const CloseCurlyDoubleQuote$1 = "â€";
const CloseCurlyQuote$1 = "â€™";
const clubs$1 = "â™£";
const clubsuit$1 = "â™£";
const colon$1 = ":";
const Colon$1 = "âˆ·";
const Colone$1 = "â©´";
const colone$1 = "â‰”";
const coloneq$1 = "â‰”";
const comma$1 = ",";
const commat$1 = "@";
const comp$1 = "âˆ";
const compfn$1 = "âˆ˜";
const complement$1 = "âˆ";
const complexes$1 = "â„‚";
const cong$1 = "â‰…";
const congdot$1 = "â©­";
const Congruent$1 = "â‰¡";
const conint$1 = "âˆ®";
const Conint$1 = "âˆ¯";
const ContourIntegral$1 = "âˆ®";
const copf$1 = "ð•”";
const Copf$1 = "â„‚";
const coprod$1 = "âˆ";
const Coproduct$1 = "âˆ";
const copy$3 = "Â©";
const COPY$3 = "Â©";
const copysr$1 = "â„—";
const CounterClockwiseContourIntegral$1 = "âˆ³";
const crarr$1 = "â†µ";
const cross$1 = "âœ—";
const Cross$1 = "â¨¯";
const Cscr$1 = "ð’ž";
const cscr$1 = "ð’¸";
const csub$1 = "â«";
const csube$1 = "â«‘";
const csup$1 = "â«";
const csupe$1 = "â«’";
const ctdot$1 = "â‹¯";
const cudarrl$1 = "â¤¸";
const cudarrr$1 = "â¤µ";
const cuepr$1 = "â‹ž";
const cuesc$1 = "â‹Ÿ";
const cularr$1 = "â†¶";
const cularrp$1 = "â¤½";
const cupbrcap$1 = "â©ˆ";
const cupcap$1 = "â©†";
const CupCap$1 = "â‰";
const cup$1 = "âˆª";
const Cup$1 = "â‹“";
const cupcup$1 = "â©Š";
const cupdot$1 = "âŠ";
const cupor$1 = "â©…";
const cups$1 = "âˆªï¸€";
const curarr$1 = "â†·";
const curarrm$1 = "â¤¼";
const curlyeqprec$1 = "â‹ž";
const curlyeqsucc$1 = "â‹Ÿ";
const curlyvee$1 = "â‹Ž";
const curlywedge$1 = "â‹";
const curren$3 = "Â¤";
const curvearrowleft$1 = "â†¶";
const curvearrowright$1 = "â†·";
const cuvee$1 = "â‹Ž";
const cuwed$1 = "â‹";
const cwconint$1 = "âˆ²";
const cwint$1 = "âˆ±";
const cylcty$1 = "âŒ­";
const dagger$1 = "â€ ";
const Dagger$1 = "â€¡";
const daleth$1 = "â„¸";
const darr$1 = "â†“";
const Darr$1 = "â†¡";
const dArr$1 = "â‡“";
const dash$1 = "â€";
const Dashv$1 = "â«¤";
const dashv$1 = "âŠ£";
const dbkarow$1 = "â¤";
const dblac$1 = "Ë";
const Dcaron$1 = "ÄŽ";
const dcaron$1 = "Ä";
const Dcy$1 = "Ð”";
const dcy$1 = "Ð´";
const ddagger$1 = "â€¡";
const ddarr$1 = "â‡Š";
const DD$1 = "â……";
const dd$1 = "â…†";
const DDotrahd$1 = "â¤‘";
const ddotseq$1 = "â©·";
const deg$3 = "Â°";
const Del$1 = "âˆ‡";
const Delta$1 = "Î”";
const delta$1 = "Î´";
const demptyv$1 = "â¦±";
const dfisht$1 = "â¥¿";
const Dfr$1 = "ð”‡";
const dfr$1 = "ð”¡";
const dHar$1 = "â¥¥";
const dharl$1 = "â‡ƒ";
const dharr$1 = "â‡‚";
const DiacriticalAcute$1 = "Â´";
const DiacriticalDot$1 = "Ë™";
const DiacriticalDoubleAcute$1 = "Ë";
const DiacriticalGrave$1 = "`";
const DiacriticalTilde$1 = "Ëœ";
const diam$1 = "â‹„";
const diamond$1 = "â‹„";
const Diamond$1 = "â‹„";
const diamondsuit$1 = "â™¦";
const diams$1 = "â™¦";
const die$1 = "Â¨";
const DifferentialD$1 = "â…†";
const digamma$1 = "Ï";
const disin$1 = "â‹²";
const div$1 = "Ã·";
const divide$3 = "Ã·";
const divideontimes$1 = "â‹‡";
const divonx$1 = "â‹‡";
const DJcy$1 = "Ð‚";
const djcy$1 = "Ñ’";
const dlcorn$1 = "âŒž";
const dlcrop$1 = "âŒ";
const dollar$1 = "$";
const Dopf$1 = "ð”»";
const dopf$1 = "ð••";
const Dot$1 = "Â¨";
const dot$1 = "Ë™";
const DotDot$1 = "âƒœ";
const doteq$1 = "â‰";
const doteqdot$1 = "â‰‘";
const DotEqual$1 = "â‰";
const dotminus$1 = "âˆ¸";
const dotplus$1 = "âˆ”";
const dotsquare$1 = "âŠ¡";
const doublebarwedge$1 = "âŒ†";
const DoubleContourIntegral$1 = "âˆ¯";
const DoubleDot$1 = "Â¨";
const DoubleDownArrow$1 = "â‡“";
const DoubleLeftArrow$1 = "â‡";
const DoubleLeftRightArrow$1 = "â‡”";
const DoubleLeftTee$1 = "â«¤";
const DoubleLongLeftArrow$1 = "âŸ¸";
const DoubleLongLeftRightArrow$1 = "âŸº";
const DoubleLongRightArrow$1 = "âŸ¹";
const DoubleRightArrow$1 = "â‡’";
const DoubleRightTee$1 = "âŠ¨";
const DoubleUpArrow$1 = "â‡‘";
const DoubleUpDownArrow$1 = "â‡•";
const DoubleVerticalBar$1 = "âˆ¥";
const DownArrowBar$1 = "â¤“";
const downarrow$1 = "â†“";
const DownArrow$1 = "â†“";
const Downarrow$1 = "â‡“";
const DownArrowUpArrow$1 = "â‡µ";
const DownBreve$1 = "Ì‘";
const downdownarrows$1 = "â‡Š";
const downharpoonleft$1 = "â‡ƒ";
const downharpoonright$1 = "â‡‚";
const DownLeftRightVector$1 = "â¥";
const DownLeftTeeVector$1 = "â¥ž";
const DownLeftVectorBar$1 = "â¥–";
const DownLeftVector$1 = "â†½";
const DownRightTeeVector$1 = "â¥Ÿ";
const DownRightVectorBar$1 = "â¥—";
const DownRightVector$1 = "â‡";
const DownTeeArrow$1 = "â†§";
const DownTee$1 = "âŠ¤";
const drbkarow$1 = "â¤";
const drcorn$1 = "âŒŸ";
const drcrop$1 = "âŒŒ";
const Dscr$1 = "ð’Ÿ";
const dscr$1 = "ð’¹";
const DScy$1 = "Ð…";
const dscy$1 = "Ñ•";
const dsol$1 = "â§¶";
const Dstrok$1 = "Ä";
const dstrok$1 = "Ä‘";
const dtdot$1 = "â‹±";
const dtri$1 = "â–¿";
const dtrif$1 = "â–¾";
const duarr$1 = "â‡µ";
const duhar$1 = "â¥¯";
const dwangle$1 = "â¦¦";
const DZcy$1 = "Ð";
const dzcy$1 = "ÑŸ";
const dzigrarr$1 = "âŸ¿";
const Eacute$3 = "Ã‰";
const eacute$3 = "Ã©";
const easter$1 = "â©®";
const Ecaron$1 = "Äš";
const ecaron$1 = "Ä›";
const Ecirc$3 = "ÃŠ";
const ecirc$3 = "Ãª";
const ecir$1 = "â‰–";
const ecolon$1 = "â‰•";
const Ecy$1 = "Ð­";
const ecy$1 = "Ñ";
const eDDot$1 = "â©·";
const Edot$1 = "Ä–";
const edot$1 = "Ä—";
const eDot$1 = "â‰‘";
const ee$1 = "â…‡";
const efDot$1 = "â‰’";
const Efr$1 = "ð”ˆ";
const efr$1 = "ð”¢";
const eg$1 = "âªš";
const Egrave$3 = "Ãˆ";
const egrave$3 = "Ã¨";
const egs$1 = "âª–";
const egsdot$1 = "âª˜";
const el$1 = "âª™";
const Element$1 = "âˆˆ";
const elinters$1 = "â§";
const ell$1 = "â„“";
const els$1 = "âª•";
const elsdot$1 = "âª—";
const Emacr$1 = "Ä’";
const emacr$1 = "Ä“";
const empty$1 = "âˆ…";
const emptyset$1 = "âˆ…";
const EmptySmallSquare$1 = "â—»";
const emptyv$1 = "âˆ…";
const EmptyVerySmallSquare$1 = "â–«";
const emsp13$1 = "â€„";
const emsp14$1 = "â€…";
const emsp$1 = "â€ƒ";
const ENG$1 = "ÅŠ";
const eng$1 = "Å‹";
const ensp$1 = "â€‚";
const Eogon$1 = "Ä˜";
const eogon$1 = "Ä™";
const Eopf$1 = "ð”¼";
const eopf$1 = "ð•–";
const epar$1 = "â‹•";
const eparsl$1 = "â§£";
const eplus$1 = "â©±";
const epsi$1 = "Îµ";
const Epsilon$1 = "Î•";
const epsilon$1 = "Îµ";
const epsiv$1 = "Ïµ";
const eqcirc$1 = "â‰–";
const eqcolon$1 = "â‰•";
const eqsim$1 = "â‰‚";
const eqslantgtr$1 = "âª–";
const eqslantless$1 = "âª•";
const Equal$1 = "â©µ";
const equals$1 = "=";
const EqualTilde$1 = "â‰‚";
const equest$1 = "â‰Ÿ";
const Equilibrium$1 = "â‡Œ";
const equiv$1 = "â‰¡";
const equivDD$1 = "â©¸";
const eqvparsl$1 = "â§¥";
const erarr$1 = "â¥±";
const erDot$1 = "â‰“";
const escr$1 = "â„¯";
const Escr$1 = "â„°";
const esdot$1 = "â‰";
const Esim$1 = "â©³";
const esim$1 = "â‰‚";
const Eta$1 = "Î—";
const eta$1 = "Î·";
const ETH$3 = "Ã";
const eth$3 = "Ã°";
const Euml$3 = "Ã‹";
const euml$3 = "Ã«";
const euro$1 = "â‚¬";
const excl$1 = "!";
const exist$1 = "âˆƒ";
const Exists$1 = "âˆƒ";
const expectation$1 = "â„°";
const exponentiale$1 = "â…‡";
const ExponentialE$1 = "â…‡";
const fallingdotseq$1 = "â‰’";
const Fcy$1 = "Ð¤";
const fcy$1 = "Ñ„";
const female$1 = "â™€";
const ffilig$1 = "ï¬ƒ";
const fflig$1 = "ï¬€";
const ffllig$1 = "ï¬„";
const Ffr$1 = "ð”‰";
const ffr$1 = "ð”£";
const filig$1 = "ï¬";
const FilledSmallSquare$1 = "â—¼";
const FilledVerySmallSquare$1 = "â–ª";
const fjlig$1 = "fj";
const flat$1 = "â™­";
const fllig$1 = "ï¬‚";
const fltns$1 = "â–±";
const fnof$1 = "Æ’";
const Fopf$1 = "ð”½";
const fopf$1 = "ð•—";
const forall$1 = "âˆ€";
const ForAll$1 = "âˆ€";
const fork$1 = "â‹”";
const forkv$1 = "â«™";
const Fouriertrf$1 = "â„±";
const fpartint$1 = "â¨";
const frac12$3 = "Â½";
const frac13$1 = "â…“";
const frac14$3 = "Â¼";
const frac15$1 = "â…•";
const frac16$1 = "â…™";
const frac18$1 = "â…›";
const frac23$1 = "â…”";
const frac25$1 = "â…–";
const frac34$3 = "Â¾";
const frac35$1 = "â…—";
const frac38$1 = "â…œ";
const frac45$1 = "â…˜";
const frac56$1 = "â…š";
const frac58$1 = "â…";
const frac78$1 = "â…ž";
const frasl$1 = "â„";
const frown$1 = "âŒ¢";
const fscr$1 = "ð’»";
const Fscr$1 = "â„±";
const gacute$1 = "Çµ";
const Gamma$1 = "Î“";
const gamma$1 = "Î³";
const Gammad$1 = "Ïœ";
const gammad$1 = "Ï";
const gap$1 = "âª†";
const Gbreve$1 = "Äž";
const gbreve$1 = "ÄŸ";
const Gcedil$1 = "Ä¢";
const Gcirc$1 = "Äœ";
const gcirc$1 = "Ä";
const Gcy$1 = "Ð“";
const gcy$1 = "Ð³";
const Gdot$1 = "Ä ";
const gdot$1 = "Ä¡";
const ge$1 = "â‰¥";
const gE$1 = "â‰§";
const gEl$1 = "âªŒ";
const gel$1 = "â‹›";
const geq$1 = "â‰¥";
const geqq$1 = "â‰§";
const geqslant$1 = "â©¾";
const gescc$1 = "âª©";
const ges$1 = "â©¾";
const gesdot$1 = "âª€";
const gesdoto$1 = "âª‚";
const gesdotol$1 = "âª„";
const gesl$1 = "â‹›ï¸€";
const gesles$1 = "âª”";
const Gfr$1 = "ð”Š";
const gfr$1 = "ð”¤";
const gg$1 = "â‰«";
const Gg$1 = "â‹™";
const ggg$1 = "â‹™";
const gimel$1 = "â„·";
const GJcy$1 = "Ðƒ";
const gjcy$1 = "Ñ“";
const gla$1 = "âª¥";
const gl$1 = "â‰·";
const glE$1 = "âª’";
const glj$1 = "âª¤";
const gnap$1 = "âªŠ";
const gnapprox$1 = "âªŠ";
const gne$1 = "âªˆ";
const gnE$1 = "â‰©";
const gneq$1 = "âªˆ";
const gneqq$1 = "â‰©";
const gnsim$1 = "â‹§";
const Gopf$1 = "ð”¾";
const gopf$1 = "ð•˜";
const grave$1 = "`";
const GreaterEqual$1 = "â‰¥";
const GreaterEqualLess$1 = "â‹›";
const GreaterFullEqual$1 = "â‰§";
const GreaterGreater$1 = "âª¢";
const GreaterLess$1 = "â‰·";
const GreaterSlantEqual$1 = "â©¾";
const GreaterTilde$1 = "â‰³";
const Gscr$1 = "ð’¢";
const gscr$1 = "â„Š";
const gsim$1 = "â‰³";
const gsime$1 = "âªŽ";
const gsiml$1 = "âª";
const gtcc$1 = "âª§";
const gtcir$1 = "â©º";
const gt$5 = ">";
const GT$3 = ">";
const Gt$1 = "â‰«";
const gtdot$1 = "â‹—";
const gtlPar$1 = "â¦•";
const gtquest$1 = "â©¼";
const gtrapprox$1 = "âª†";
const gtrarr$1 = "â¥¸";
const gtrdot$1 = "â‹—";
const gtreqless$1 = "â‹›";
const gtreqqless$1 = "âªŒ";
const gtrless$1 = "â‰·";
const gtrsim$1 = "â‰³";
const gvertneqq$1 = "â‰©ï¸€";
const gvnE$1 = "â‰©ï¸€";
const Hacek$1 = "Ë‡";
const hairsp$1 = "â€Š";
const half$1 = "Â½";
const hamilt$1 = "â„‹";
const HARDcy$1 = "Ðª";
const hardcy$1 = "ÑŠ";
const harrcir$1 = "â¥ˆ";
const harr$1 = "â†”";
const hArr$1 = "â‡”";
const harrw$1 = "â†­";
const Hat$1 = "^";
const hbar$1 = "â„";
const Hcirc$1 = "Ä¤";
const hcirc$1 = "Ä¥";
const hearts$1 = "â™¥";
const heartsuit$1 = "â™¥";
const hellip$1 = "â€¦";
const hercon$1 = "âŠ¹";
const hfr$1 = "ð”¥";
const Hfr$1 = "â„Œ";
const HilbertSpace$1 = "â„‹";
const hksearow$1 = "â¤¥";
const hkswarow$1 = "â¤¦";
const hoarr$1 = "â‡¿";
const homtht$1 = "âˆ»";
const hookleftarrow$1 = "â†©";
const hookrightarrow$1 = "â†ª";
const hopf$1 = "ð•™";
const Hopf$1 = "â„";
const horbar$1 = "â€•";
const HorizontalLine$1 = "â”€";
const hscr$1 = "ð’½";
const Hscr$1 = "â„‹";
const hslash$1 = "â„";
const Hstrok$1 = "Ä¦";
const hstrok$1 = "Ä§";
const HumpDownHump$1 = "â‰Ž";
const HumpEqual$1 = "â‰";
const hybull$1 = "âƒ";
const hyphen$1 = "â€";
const Iacute$3 = "Ã";
const iacute$3 = "Ã­";
const ic$1 = "â£";
const Icirc$3 = "ÃŽ";
const icirc$3 = "Ã®";
const Icy$1 = "Ð˜";
const icy$1 = "Ð¸";
const Idot$1 = "Ä°";
const IEcy$1 = "Ð•";
const iecy$1 = "Ðµ";
const iexcl$3 = "Â¡";
const iff$1 = "â‡”";
const ifr$1 = "ð”¦";
const Ifr$1 = "â„‘";
const Igrave$3 = "ÃŒ";
const igrave$3 = "Ã¬";
const ii$1 = "â…ˆ";
const iiiint$1 = "â¨Œ";
const iiint$1 = "âˆ­";
const iinfin$1 = "â§œ";
const iiota$1 = "â„©";
const IJlig$1 = "Ä²";
const ijlig$1 = "Ä³";
const Imacr$1 = "Äª";
const imacr$1 = "Ä«";
const image$1 = "â„‘";
const ImaginaryI$1 = "â…ˆ";
const imagline$1 = "â„";
const imagpart$1 = "â„‘";
const imath$1 = "Ä±";
const Im$1 = "â„‘";
const imof$1 = "âŠ·";
const imped$1 = "Æµ";
const Implies$1 = "â‡’";
const incare$1 = "â„…";
const infin$1 = "âˆž";
const infintie$1 = "â§";
const inodot$1 = "Ä±";
const intcal$1 = "âŠº";
const int$1 = "âˆ«";
const Int$1 = "âˆ¬";
const integers$1 = "â„¤";
const Integral$1 = "âˆ«";
const intercal$1 = "âŠº";
const Intersection$1 = "â‹‚";
const intlarhk$1 = "â¨—";
const intprod$1 = "â¨¼";
const InvisibleComma$1 = "â£";
const InvisibleTimes$1 = "â¢";
const IOcy$1 = "Ð";
const iocy$1 = "Ñ‘";
const Iogon$1 = "Ä®";
const iogon$1 = "Ä¯";
const Iopf$1 = "ð•€";
const iopf$1 = "ð•š";
const Iota$1 = "Î™";
const iota$1 = "Î¹";
const iprod$1 = "â¨¼";
const iquest$3 = "Â¿";
const iscr$1 = "ð’¾";
const Iscr$1 = "â„";
const isin$1 = "âˆˆ";
const isindot$1 = "â‹µ";
const isinE$1 = "â‹¹";
const isins$1 = "â‹´";
const isinsv$1 = "â‹³";
const isinv$1 = "âˆˆ";
const it$1 = "â¢";
const Itilde$1 = "Ä¨";
const itilde$1 = "Ä©";
const Iukcy$1 = "Ð†";
const iukcy$1 = "Ñ–";
const Iuml$3 = "Ã";
const iuml$3 = "Ã¯";
const Jcirc$1 = "Ä´";
const jcirc$1 = "Äµ";
const Jcy$1 = "Ð™";
const jcy$1 = "Ð¹";
const Jfr$1 = "ð”";
const jfr$1 = "ð”§";
const jmath$1 = "È·";
const Jopf$1 = "ð•";
const jopf$1 = "ð•›";
const Jscr$1 = "ð’¥";
const jscr$1 = "ð’¿";
const Jsercy$1 = "Ðˆ";
const jsercy$1 = "Ñ˜";
const Jukcy$1 = "Ð„";
const jukcy$1 = "Ñ”";
const Kappa$1 = "Îš";
const kappa$1 = "Îº";
const kappav$1 = "Ï°";
const Kcedil$1 = "Ä¶";
const kcedil$1 = "Ä·";
const Kcy$1 = "Ðš";
const kcy$1 = "Ðº";
const Kfr$1 = "ð”Ž";
const kfr$1 = "ð”¨";
const kgreen$1 = "Ä¸";
const KHcy$1 = "Ð¥";
const khcy$1 = "Ñ…";
const KJcy$1 = "ÐŒ";
const kjcy$1 = "Ñœ";
const Kopf$1 = "ð•‚";
const kopf$1 = "ð•œ";
const Kscr$1 = "ð’¦";
const kscr$1 = "ð“€";
const lAarr$1 = "â‡š";
const Lacute$1 = "Ä¹";
const lacute$1 = "Äº";
const laemptyv$1 = "â¦´";
const lagran$1 = "â„’";
const Lambda$1 = "Î›";
const lambda$1 = "Î»";
const lang$1 = "âŸ¨";
const Lang$1 = "âŸª";
const langd$1 = "â¦‘";
const langle$1 = "âŸ¨";
const lap$1 = "âª…";
const Laplacetrf$1 = "â„’";
const laquo$3 = "Â«";
const larrb$1 = "â‡¤";
const larrbfs$1 = "â¤Ÿ";
const larr$1 = "â†";
const Larr$1 = "â†ž";
const lArr$1 = "â‡";
const larrfs$1 = "â¤";
const larrhk$1 = "â†©";
const larrlp$1 = "â†«";
const larrpl$1 = "â¤¹";
const larrsim$1 = "â¥³";
const larrtl$1 = "â†¢";
const latail$1 = "â¤™";
const lAtail$1 = "â¤›";
const lat$1 = "âª«";
const late$1 = "âª­";
const lates$1 = "âª­ï¸€";
const lbarr$1 = "â¤Œ";
const lBarr$1 = "â¤Ž";
const lbbrk$1 = "â²";
const lbrace$1 = "{";
const lbrack$1 = "[";
const lbrke$1 = "â¦‹";
const lbrksld$1 = "â¦";
const lbrkslu$1 = "â¦";
const Lcaron$1 = "Ä½";
const lcaron$1 = "Ä¾";
const Lcedil$1 = "Ä»";
const lcedil$1 = "Ä¼";
const lceil$1 = "âŒˆ";
const lcub$1 = "{";
const Lcy$1 = "Ð›";
const lcy$1 = "Ð»";
const ldca$1 = "â¤¶";
const ldquo$1 = "â€œ";
const ldquor$1 = "â€ž";
const ldrdhar$1 = "â¥§";
const ldrushar$1 = "â¥‹";
const ldsh$1 = "â†²";
const le$1 = "â‰¤";
const lE$1 = "â‰¦";
const LeftAngleBracket$1 = "âŸ¨";
const LeftArrowBar$1 = "â‡¤";
const leftarrow$1 = "â†";
const LeftArrow$1 = "â†";
const Leftarrow$1 = "â‡";
const LeftArrowRightArrow$1 = "â‡†";
const leftarrowtail$1 = "â†¢";
const LeftCeiling$1 = "âŒˆ";
const LeftDoubleBracket$1 = "âŸ¦";
const LeftDownTeeVector$1 = "â¥¡";
const LeftDownVectorBar$1 = "â¥™";
const LeftDownVector$1 = "â‡ƒ";
const LeftFloor$1 = "âŒŠ";
const leftharpoondown$1 = "â†½";
const leftharpoonup$1 = "â†¼";
const leftleftarrows$1 = "â‡‡";
const leftrightarrow$1 = "â†”";
const LeftRightArrow$1 = "â†”";
const Leftrightarrow$1 = "â‡”";
const leftrightarrows$1 = "â‡†";
const leftrightharpoons$1 = "â‡‹";
const leftrightsquigarrow$1 = "â†­";
const LeftRightVector$1 = "â¥Ž";
const LeftTeeArrow$1 = "â†¤";
const LeftTee$1 = "âŠ£";
const LeftTeeVector$1 = "â¥š";
const leftthreetimes$1 = "â‹‹";
const LeftTriangleBar$1 = "â§";
const LeftTriangle$1 = "âŠ²";
const LeftTriangleEqual$1 = "âŠ´";
const LeftUpDownVector$1 = "â¥‘";
const LeftUpTeeVector$1 = "â¥ ";
const LeftUpVectorBar$1 = "â¥˜";
const LeftUpVector$1 = "â†¿";
const LeftVectorBar$1 = "â¥’";
const LeftVector$1 = "â†¼";
const lEg$1 = "âª‹";
const leg$1 = "â‹š";
const leq$1 = "â‰¤";
const leqq$1 = "â‰¦";
const leqslant$1 = "â©½";
const lescc$1 = "âª¨";
const les$1 = "â©½";
const lesdot$1 = "â©¿";
const lesdoto$1 = "âª";
const lesdotor$1 = "âªƒ";
const lesg$1 = "â‹šï¸€";
const lesges$1 = "âª“";
const lessapprox$1 = "âª…";
const lessdot$1 = "â‹–";
const lesseqgtr$1 = "â‹š";
const lesseqqgtr$1 = "âª‹";
const LessEqualGreater$1 = "â‹š";
const LessFullEqual$1 = "â‰¦";
const LessGreater$1 = "â‰¶";
const lessgtr$1 = "â‰¶";
const LessLess$1 = "âª¡";
const lesssim$1 = "â‰²";
const LessSlantEqual$1 = "â©½";
const LessTilde$1 = "â‰²";
const lfisht$1 = "â¥¼";
const lfloor$1 = "âŒŠ";
const Lfr$1 = "ð”";
const lfr$1 = "ð”©";
const lg$1 = "â‰¶";
const lgE$1 = "âª‘";
const lHar$1 = "â¥¢";
const lhard$1 = "â†½";
const lharu$1 = "â†¼";
const lharul$1 = "â¥ª";
const lhblk$1 = "â–„";
const LJcy$1 = "Ð‰";
const ljcy$1 = "Ñ™";
const llarr$1 = "â‡‡";
const ll$1 = "â‰ª";
const Ll$1 = "â‹˜";
const llcorner$1 = "âŒž";
const Lleftarrow$1 = "â‡š";
const llhard$1 = "â¥«";
const lltri$1 = "â—º";
const Lmidot$1 = "Ä¿";
const lmidot$1 = "Å€";
const lmoustache$1 = "âŽ°";
const lmoust$1 = "âŽ°";
const lnap$1 = "âª‰";
const lnapprox$1 = "âª‰";
const lne$1 = "âª‡";
const lnE$1 = "â‰¨";
const lneq$1 = "âª‡";
const lneqq$1 = "â‰¨";
const lnsim$1 = "â‹¦";
const loang$1 = "âŸ¬";
const loarr$1 = "â‡½";
const lobrk$1 = "âŸ¦";
const longleftarrow$1 = "âŸµ";
const LongLeftArrow$1 = "âŸµ";
const Longleftarrow$1 = "âŸ¸";
const longleftrightarrow$1 = "âŸ·";
const LongLeftRightArrow$1 = "âŸ·";
const Longleftrightarrow$1 = "âŸº";
const longmapsto$1 = "âŸ¼";
const longrightarrow$1 = "âŸ¶";
const LongRightArrow$1 = "âŸ¶";
const Longrightarrow$1 = "âŸ¹";
const looparrowleft$1 = "â†«";
const looparrowright$1 = "â†¬";
const lopar$1 = "â¦…";
const Lopf$1 = "ð•ƒ";
const lopf$1 = "ð•";
const loplus$1 = "â¨­";
const lotimes$1 = "â¨´";
const lowast$1 = "âˆ—";
const lowbar$1 = "_";
const LowerLeftArrow$1 = "â†™";
const LowerRightArrow$1 = "â†˜";
const loz$1 = "â—Š";
const lozenge$1 = "â—Š";
const lozf$1 = "â§«";
const lpar$1 = "(";
const lparlt$1 = "â¦“";
const lrarr$1 = "â‡†";
const lrcorner$1 = "âŒŸ";
const lrhar$1 = "â‡‹";
const lrhard$1 = "â¥­";
const lrm$1 = "â€Ž";
const lrtri$1 = "âŠ¿";
const lsaquo$1 = "â€¹";
const lscr$1 = "ð“";
const Lscr$1 = "â„’";
const lsh$1 = "â†°";
const Lsh$1 = "â†°";
const lsim$1 = "â‰²";
const lsime$1 = "âª";
const lsimg$1 = "âª";
const lsqb$1 = "[";
const lsquo$1 = "â€˜";
const lsquor$1 = "â€š";
const Lstrok$1 = "Å";
const lstrok$1 = "Å‚";
const ltcc$1 = "âª¦";
const ltcir$1 = "â©¹";
const lt$5 = "<";
const LT$3 = "<";
const Lt$1 = "â‰ª";
const ltdot$1 = "â‹–";
const lthree$1 = "â‹‹";
const ltimes$1 = "â‹‰";
const ltlarr$1 = "â¥¶";
const ltquest$1 = "â©»";
const ltri$1 = "â—ƒ";
const ltrie$1 = "âŠ´";
const ltrif$1 = "â—‚";
const ltrPar$1 = "â¦–";
const lurdshar$1 = "â¥Š";
const luruhar$1 = "â¥¦";
const lvertneqq$1 = "â‰¨ï¸€";
const lvnE$1 = "â‰¨ï¸€";
const macr$3 = "Â¯";
const male$1 = "â™‚";
const malt$1 = "âœ ";
const maltese$1 = "âœ ";
const map$1 = "â†¦";
const mapsto$1 = "â†¦";
const mapstodown$1 = "â†§";
const mapstoleft$1 = "â†¤";
const mapstoup$1 = "â†¥";
const marker$1 = "â–®";
const mcomma$1 = "â¨©";
const Mcy$1 = "Ðœ";
const mcy$1 = "Ð¼";
const mdash$1 = "â€”";
const mDDot$1 = "âˆº";
const measuredangle$1 = "âˆ¡";
const MediumSpace$1 = "âŸ";
const Mellintrf$1 = "â„³";
const Mfr$1 = "ð”";
const mfr$1 = "ð”ª";
const mho$1 = "â„§";
const micro$3 = "Âµ";
const midast$1 = "*";
const midcir$1 = "â«°";
const mid$1 = "âˆ£";
const middot$3 = "Â·";
const minusb$1 = "âŠŸ";
const minus$1 = "âˆ’";
const minusd$1 = "âˆ¸";
const minusdu$1 = "â¨ª";
const MinusPlus$1 = "âˆ“";
const mlcp$1 = "â«›";
const mldr$1 = "â€¦";
const mnplus$1 = "âˆ“";
const models$1 = "âŠ§";
const Mopf$1 = "ð•„";
const mopf$1 = "ð•ž";
const mp$1 = "âˆ“";
const mscr$1 = "ð“‚";
const Mscr$1 = "â„³";
const mstpos$1 = "âˆ¾";
const Mu$1 = "Îœ";
const mu$1 = "Î¼";
const multimap$1 = "âŠ¸";
const mumap$1 = "âŠ¸";
const nabla$1 = "âˆ‡";
const Nacute$1 = "Åƒ";
const nacute$1 = "Å„";
const nang$1 = "âˆ âƒ’";
const nap$1 = "â‰‰";
const napE$1 = "â©°Ì¸";
const napid$1 = "â‰‹Ì¸";
const napos$1 = "Å‰";
const napprox$1 = "â‰‰";
const natural$1 = "â™®";
const naturals$1 = "â„•";
const natur$1 = "â™®";
const nbsp$3 = "Â ";
const nbump$1 = "â‰ŽÌ¸";
const nbumpe$1 = "â‰Ì¸";
const ncap$1 = "â©ƒ";
const Ncaron$1 = "Å‡";
const ncaron$1 = "Åˆ";
const Ncedil$1 = "Å…";
const ncedil$1 = "Å†";
const ncong$1 = "â‰‡";
const ncongdot$1 = "â©­Ì¸";
const ncup$1 = "â©‚";
const Ncy$1 = "Ð";
const ncy$1 = "Ð½";
const ndash$1 = "â€“";
const nearhk$1 = "â¤¤";
const nearr$1 = "â†—";
const neArr$1 = "â‡—";
const nearrow$1 = "â†—";
const ne$1 = "â‰ ";
const nedot$1 = "â‰Ì¸";
const NegativeMediumSpace$1 = "â€‹";
const NegativeThickSpace$1 = "â€‹";
const NegativeThinSpace$1 = "â€‹";
const NegativeVeryThinSpace$1 = "â€‹";
const nequiv$1 = "â‰¢";
const nesear$1 = "â¤¨";
const nesim$1 = "â‰‚Ì¸";
const NestedGreaterGreater$1 = "â‰«";
const NestedLessLess$1 = "â‰ª";
const NewLine$1 = "\n";
const nexist$1 = "âˆ„";
const nexists$1 = "âˆ„";
const Nfr$1 = "ð”‘";
const nfr$1 = "ð”«";
const ngE$1 = "â‰§Ì¸";
const nge$1 = "â‰±";
const ngeq$1 = "â‰±";
const ngeqq$1 = "â‰§Ì¸";
const ngeqslant$1 = "â©¾Ì¸";
const nges$1 = "â©¾Ì¸";
const nGg$1 = "â‹™Ì¸";
const ngsim$1 = "â‰µ";
const nGt$1 = "â‰«âƒ’";
const ngt$1 = "â‰¯";
const ngtr$1 = "â‰¯";
const nGtv$1 = "â‰«Ì¸";
const nharr$1 = "â†®";
const nhArr$1 = "â‡Ž";
const nhpar$1 = "â«²";
const ni$1 = "âˆ‹";
const nis$1 = "â‹¼";
const nisd$1 = "â‹º";
const niv$1 = "âˆ‹";
const NJcy$1 = "ÐŠ";
const njcy$1 = "Ñš";
const nlarr$1 = "â†š";
const nlArr$1 = "â‡";
const nldr$1 = "â€¥";
const nlE$1 = "â‰¦Ì¸";
const nle$1 = "â‰°";
const nleftarrow$1 = "â†š";
const nLeftarrow$1 = "â‡";
const nleftrightarrow$1 = "â†®";
const nLeftrightarrow$1 = "â‡Ž";
const nleq$1 = "â‰°";
const nleqq$1 = "â‰¦Ì¸";
const nleqslant$1 = "â©½Ì¸";
const nles$1 = "â©½Ì¸";
const nless$1 = "â‰®";
const nLl$1 = "â‹˜Ì¸";
const nlsim$1 = "â‰´";
const nLt$1 = "â‰ªâƒ’";
const nlt$1 = "â‰®";
const nltri$1 = "â‹ª";
const nltrie$1 = "â‹¬";
const nLtv$1 = "â‰ªÌ¸";
const nmid$1 = "âˆ¤";
const NoBreak$1 = "â ";
const NonBreakingSpace$1 = "Â ";
const nopf$1 = "ð•Ÿ";
const Nopf$1 = "â„•";
const Not$1 = "â«¬";
const not$3 = "Â¬";
const NotCongruent$1 = "â‰¢";
const NotCupCap$1 = "â‰­";
const NotDoubleVerticalBar$1 = "âˆ¦";
const NotElement$1 = "âˆ‰";
const NotEqual$1 = "â‰ ";
const NotEqualTilde$1 = "â‰‚Ì¸";
const NotExists$1 = "âˆ„";
const NotGreater$1 = "â‰¯";
const NotGreaterEqual$1 = "â‰±";
const NotGreaterFullEqual$1 = "â‰§Ì¸";
const NotGreaterGreater$1 = "â‰«Ì¸";
const NotGreaterLess$1 = "â‰¹";
const NotGreaterSlantEqual$1 = "â©¾Ì¸";
const NotGreaterTilde$1 = "â‰µ";
const NotHumpDownHump$1 = "â‰ŽÌ¸";
const NotHumpEqual$1 = "â‰Ì¸";
const notin$1 = "âˆ‰";
const notindot$1 = "â‹µÌ¸";
const notinE$1 = "â‹¹Ì¸";
const notinva$1 = "âˆ‰";
const notinvb$1 = "â‹·";
const notinvc$1 = "â‹¶";
const NotLeftTriangleBar$1 = "â§Ì¸";
const NotLeftTriangle$1 = "â‹ª";
const NotLeftTriangleEqual$1 = "â‹¬";
const NotLess$1 = "â‰®";
const NotLessEqual$1 = "â‰°";
const NotLessGreater$1 = "â‰¸";
const NotLessLess$1 = "â‰ªÌ¸";
const NotLessSlantEqual$1 = "â©½Ì¸";
const NotLessTilde$1 = "â‰´";
const NotNestedGreaterGreater$1 = "âª¢Ì¸";
const NotNestedLessLess$1 = "âª¡Ì¸";
const notni$1 = "âˆŒ";
const notniva$1 = "âˆŒ";
const notnivb$1 = "â‹¾";
const notnivc$1 = "â‹½";
const NotPrecedes$1 = "âŠ€";
const NotPrecedesEqual$1 = "âª¯Ì¸";
const NotPrecedesSlantEqual$1 = "â‹ ";
const NotReverseElement$1 = "âˆŒ";
const NotRightTriangleBar$1 = "â§Ì¸";
const NotRightTriangle$1 = "â‹«";
const NotRightTriangleEqual$1 = "â‹­";
const NotSquareSubset$1 = "âŠÌ¸";
const NotSquareSubsetEqual$1 = "â‹¢";
const NotSquareSuperset$1 = "âŠÌ¸";
const NotSquareSupersetEqual$1 = "â‹£";
const NotSubset$1 = "âŠ‚âƒ’";
const NotSubsetEqual$1 = "âŠˆ";
const NotSucceeds$1 = "âŠ";
const NotSucceedsEqual$1 = "âª°Ì¸";
const NotSucceedsSlantEqual$1 = "â‹¡";
const NotSucceedsTilde$1 = "â‰¿Ì¸";
const NotSuperset$1 = "âŠƒâƒ’";
const NotSupersetEqual$1 = "âŠ‰";
const NotTilde$1 = "â‰";
const NotTildeEqual$1 = "â‰„";
const NotTildeFullEqual$1 = "â‰‡";
const NotTildeTilde$1 = "â‰‰";
const NotVerticalBar$1 = "âˆ¤";
const nparallel$1 = "âˆ¦";
const npar$1 = "âˆ¦";
const nparsl$1 = "â«½âƒ¥";
const npart$1 = "âˆ‚Ì¸";
const npolint$1 = "â¨”";
const npr$1 = "âŠ€";
const nprcue$1 = "â‹ ";
const nprec$1 = "âŠ€";
const npreceq$1 = "âª¯Ì¸";
const npre$1 = "âª¯Ì¸";
const nrarrc$1 = "â¤³Ì¸";
const nrarr$1 = "â†›";
const nrArr$1 = "â‡";
const nrarrw$1 = "â†Ì¸";
const nrightarrow$1 = "â†›";
const nRightarrow$1 = "â‡";
const nrtri$1 = "â‹«";
const nrtrie$1 = "â‹­";
const nsc$1 = "âŠ";
const nsccue$1 = "â‹¡";
const nsce$1 = "âª°Ì¸";
const Nscr$1 = "ð’©";
const nscr$1 = "ð“ƒ";
const nshortmid$1 = "âˆ¤";
const nshortparallel$1 = "âˆ¦";
const nsim$1 = "â‰";
const nsime$1 = "â‰„";
const nsimeq$1 = "â‰„";
const nsmid$1 = "âˆ¤";
const nspar$1 = "âˆ¦";
const nsqsube$1 = "â‹¢";
const nsqsupe$1 = "â‹£";
const nsub$1 = "âŠ„";
const nsubE$1 = "â«…Ì¸";
const nsube$1 = "âŠˆ";
const nsubset$1 = "âŠ‚âƒ’";
const nsubseteq$1 = "âŠˆ";
const nsubseteqq$1 = "â«…Ì¸";
const nsucc$1 = "âŠ";
const nsucceq$1 = "âª°Ì¸";
const nsup$1 = "âŠ…";
const nsupE$1 = "â«†Ì¸";
const nsupe$1 = "âŠ‰";
const nsupset$1 = "âŠƒâƒ’";
const nsupseteq$1 = "âŠ‰";
const nsupseteqq$1 = "â«†Ì¸";
const ntgl$1 = "â‰¹";
const Ntilde$3 = "Ã‘";
const ntilde$3 = "Ã±";
const ntlg$1 = "â‰¸";
const ntriangleleft$1 = "â‹ª";
const ntrianglelefteq$1 = "â‹¬";
const ntriangleright$1 = "â‹«";
const ntrianglerighteq$1 = "â‹­";
const Nu$1 = "Î";
const nu$1 = "Î½";
const num$1 = "#";
const numero$1 = "â„–";
const numsp$1 = "â€‡";
const nvap$1 = "â‰âƒ’";
const nvdash$1 = "âŠ¬";
const nvDash$1 = "âŠ­";
const nVdash$1 = "âŠ®";
const nVDash$1 = "âŠ¯";
const nvge$1 = "â‰¥âƒ’";
const nvgt$1 = ">âƒ’";
const nvHarr$1 = "â¤„";
const nvinfin$1 = "â§ž";
const nvlArr$1 = "â¤‚";
const nvle$1 = "â‰¤âƒ’";
const nvlt$1 = "<âƒ’";
const nvltrie$1 = "âŠ´âƒ’";
const nvrArr$1 = "â¤ƒ";
const nvrtrie$1 = "âŠµâƒ’";
const nvsim$1 = "âˆ¼âƒ’";
const nwarhk$1 = "â¤£";
const nwarr$1 = "â†–";
const nwArr$1 = "â‡–";
const nwarrow$1 = "â†–";
const nwnear$1 = "â¤§";
const Oacute$3 = "Ã“";
const oacute$3 = "Ã³";
const oast$1 = "âŠ›";
const Ocirc$3 = "Ã”";
const ocirc$3 = "Ã´";
const ocir$1 = "âŠš";
const Ocy$1 = "Ðž";
const ocy$1 = "Ð¾";
const odash$1 = "âŠ";
const Odblac$1 = "Å";
const odblac$1 = "Å‘";
const odiv$1 = "â¨¸";
const odot$1 = "âŠ™";
const odsold$1 = "â¦¼";
const OElig$1 = "Å’";
const oelig$1 = "Å“";
const ofcir$1 = "â¦¿";
const Ofr$1 = "ð”’";
const ofr$1 = "ð”¬";
const ogon$1 = "Ë›";
const Ograve$3 = "Ã’";
const ograve$3 = "Ã²";
const ogt$1 = "â§";
const ohbar$1 = "â¦µ";
const ohm$1 = "Î©";
const oint$1 = "âˆ®";
const olarr$1 = "â†º";
const olcir$1 = "â¦¾";
const olcross$1 = "â¦»";
const oline$1 = "â€¾";
const olt$1 = "â§€";
const Omacr$1 = "ÅŒ";
const omacr$1 = "Å";
const Omega$1 = "Î©";
const omega$1 = "Ï‰";
const Omicron$1 = "ÎŸ";
const omicron$1 = "Î¿";
const omid$1 = "â¦¶";
const ominus$1 = "âŠ–";
const Oopf$1 = "ð•†";
const oopf$1 = "ð• ";
const opar$1 = "â¦·";
const OpenCurlyDoubleQuote$1 = "â€œ";
const OpenCurlyQuote$1 = "â€˜";
const operp$1 = "â¦¹";
const oplus$1 = "âŠ•";
const orarr$1 = "â†»";
const Or$1 = "â©”";
const or$1 = "âˆ¨";
const ord$1 = "â©";
const order$1 = "â„´";
const orderof$1 = "â„´";
const ordf$3 = "Âª";
const ordm$3 = "Âº";
const origof$1 = "âŠ¶";
const oror$1 = "â©–";
const orslope$1 = "â©—";
const orv$1 = "â©›";
const oS$1 = "â“ˆ";
const Oscr$1 = "ð’ª";
const oscr$1 = "â„´";
const Oslash$3 = "Ã˜";
const oslash$3 = "Ã¸";
const osol$1 = "âŠ˜";
const Otilde$3 = "Ã•";
const otilde$3 = "Ãµ";
const otimesas$1 = "â¨¶";
const Otimes$1 = "â¨·";
const otimes$1 = "âŠ—";
const Ouml$3 = "Ã–";
const ouml$3 = "Ã¶";
const ovbar$1 = "âŒ½";
const OverBar$1 = "â€¾";
const OverBrace$1 = "âž";
const OverBracket$1 = "âŽ´";
const OverParenthesis$1 = "âœ";
const para$3 = "Â¶";
const parallel$1 = "âˆ¥";
const par$1 = "âˆ¥";
const parsim$1 = "â«³";
const parsl$1 = "â«½";
const part$1 = "âˆ‚";
const PartialD$1 = "âˆ‚";
const Pcy$1 = "ÐŸ";
const pcy$1 = "Ð¿";
const percnt$1 = "%";
const period$1 = ".";
const permil$1 = "â€°";
const perp$1 = "âŠ¥";
const pertenk$1 = "â€±";
const Pfr$1 = "ð”“";
const pfr$1 = "ð”­";
const Phi$1 = "Î¦";
const phi$1 = "Ï†";
const phiv$1 = "Ï•";
const phmmat$1 = "â„³";
const phone$1 = "â˜Ž";
const Pi$1 = "Î ";
const pi$1 = "Ï€";
const pitchfork$1 = "â‹”";
const piv$1 = "Ï–";
const planck$1 = "â„";
const planckh$1 = "â„Ž";
const plankv$1 = "â„";
const plusacir$1 = "â¨£";
const plusb$1 = "âŠž";
const pluscir$1 = "â¨¢";
const plus$1 = "+";
const plusdo$1 = "âˆ”";
const plusdu$1 = "â¨¥";
const pluse$1 = "â©²";
const PlusMinus$1 = "Â±";
const plusmn$3 = "Â±";
const plussim$1 = "â¨¦";
const plustwo$1 = "â¨§";
const pm$1 = "Â±";
const Poincareplane$1 = "â„Œ";
const pointint$1 = "â¨•";
const popf$1 = "ð•¡";
const Popf$1 = "â„™";
const pound$3 = "Â£";
const prap$1 = "âª·";
const Pr$1 = "âª»";
const pr$1 = "â‰º";
const prcue$1 = "â‰¼";
const precapprox$1 = "âª·";
const prec$1 = "â‰º";
const preccurlyeq$1 = "â‰¼";
const Precedes$1 = "â‰º";
const PrecedesEqual$1 = "âª¯";
const PrecedesSlantEqual$1 = "â‰¼";
const PrecedesTilde$1 = "â‰¾";
const preceq$1 = "âª¯";
const precnapprox$1 = "âª¹";
const precneqq$1 = "âªµ";
const precnsim$1 = "â‹¨";
const pre$1 = "âª¯";
const prE$1 = "âª³";
const precsim$1 = "â‰¾";
const prime$1 = "â€²";
const Prime$1 = "â€³";
const primes$1 = "â„™";
const prnap$1 = "âª¹";
const prnE$1 = "âªµ";
const prnsim$1 = "â‹¨";
const prod$1 = "âˆ";
const Product$1 = "âˆ";
const profalar$1 = "âŒ®";
const profline$1 = "âŒ’";
const profsurf$1 = "âŒ“";
const prop$1 = "âˆ";
const Proportional$1 = "âˆ";
const Proportion$1 = "âˆ·";
const propto$1 = "âˆ";
const prsim$1 = "â‰¾";
const prurel$1 = "âŠ°";
const Pscr$1 = "ð’«";
const pscr$1 = "ð“…";
const Psi$1 = "Î¨";
const psi$1 = "Ïˆ";
const puncsp$1 = "â€ˆ";
const Qfr$1 = "ð””";
const qfr$1 = "ð”®";
const qint$1 = "â¨Œ";
const qopf$1 = "ð•¢";
const Qopf$1 = "â„š";
const qprime$1 = "â—";
const Qscr$1 = "ð’¬";
const qscr$1 = "ð“†";
const quaternions$1 = "â„";
const quatint$1 = "â¨–";
const quest$1 = "?";
const questeq$1 = "â‰Ÿ";
const quot$5 = '"';
const QUOT$3 = '"';
const rAarr$1 = "â‡›";
const race$1 = "âˆ½Ì±";
const Racute$1 = "Å”";
const racute$1 = "Å•";
const radic$1 = "âˆš";
const raemptyv$1 = "â¦³";
const rang$1 = "âŸ©";
const Rang$1 = "âŸ«";
const rangd$1 = "â¦’";
const range$1 = "â¦¥";
const rangle$1 = "âŸ©";
const raquo$3 = "Â»";
const rarrap$1 = "â¥µ";
const rarrb$1 = "â‡¥";
const rarrbfs$1 = "â¤ ";
const rarrc$1 = "â¤³";
const rarr$1 = "â†’";
const Rarr$1 = "â† ";
const rArr$1 = "â‡’";
const rarrfs$1 = "â¤ž";
const rarrhk$1 = "â†ª";
const rarrlp$1 = "â†¬";
const rarrpl$1 = "â¥…";
const rarrsim$1 = "â¥´";
const Rarrtl$1 = "â¤–";
const rarrtl$1 = "â†£";
const rarrw$1 = "â†";
const ratail$1 = "â¤š";
const rAtail$1 = "â¤œ";
const ratio$1 = "âˆ¶";
const rationals$1 = "â„š";
const rbarr$1 = "â¤";
const rBarr$1 = "â¤";
const RBarr$1 = "â¤";
const rbbrk$1 = "â³";
const rbrace$1 = "}";
const rbrack$1 = "]";
const rbrke$1 = "â¦Œ";
const rbrksld$1 = "â¦Ž";
const rbrkslu$1 = "â¦";
const Rcaron$1 = "Å˜";
const rcaron$1 = "Å™";
const Rcedil$1 = "Å–";
const rcedil$1 = "Å—";
const rceil$1 = "âŒ‰";
const rcub$1 = "}";
const Rcy$1 = "Ð ";
const rcy$1 = "Ñ€";
const rdca$1 = "â¤·";
const rdldhar$1 = "â¥©";
const rdquo$1 = "â€";
const rdquor$1 = "â€";
const rdsh$1 = "â†³";
const real$1 = "â„œ";
const realine$1 = "â„›";
const realpart$1 = "â„œ";
const reals$1 = "â„";
const Re$1 = "â„œ";
const rect$1 = "â–­";
const reg$3 = "Â®";
const REG$3 = "Â®";
const ReverseElement$1 = "âˆ‹";
const ReverseEquilibrium$1 = "â‡‹";
const ReverseUpEquilibrium$1 = "â¥¯";
const rfisht$1 = "â¥½";
const rfloor$1 = "âŒ‹";
const rfr$1 = "ð”¯";
const Rfr$1 = "â„œ";
const rHar$1 = "â¥¤";
const rhard$1 = "â‡";
const rharu$1 = "â‡€";
const rharul$1 = "â¥¬";
const Rho$1 = "Î¡";
const rho$1 = "Ï";
const rhov$1 = "Ï±";
const RightAngleBracket$1 = "âŸ©";
const RightArrowBar$1 = "â‡¥";
const rightarrow$1 = "â†’";
const RightArrow$1 = "â†’";
const Rightarrow$1 = "â‡’";
const RightArrowLeftArrow$1 = "â‡„";
const rightarrowtail$1 = "â†£";
const RightCeiling$1 = "âŒ‰";
const RightDoubleBracket$1 = "âŸ§";
const RightDownTeeVector$1 = "â¥";
const RightDownVectorBar$1 = "â¥•";
const RightDownVector$1 = "â‡‚";
const RightFloor$1 = "âŒ‹";
const rightharpoondown$1 = "â‡";
const rightharpoonup$1 = "â‡€";
const rightleftarrows$1 = "â‡„";
const rightleftharpoons$1 = "â‡Œ";
const rightrightarrows$1 = "â‡‰";
const rightsquigarrow$1 = "â†";
const RightTeeArrow$1 = "â†¦";
const RightTee$1 = "âŠ¢";
const RightTeeVector$1 = "â¥›";
const rightthreetimes$1 = "â‹Œ";
const RightTriangleBar$1 = "â§";
const RightTriangle$1 = "âŠ³";
const RightTriangleEqual$1 = "âŠµ";
const RightUpDownVector$1 = "â¥";
const RightUpTeeVector$1 = "â¥œ";
const RightUpVectorBar$1 = "â¥”";
const RightUpVector$1 = "â†¾";
const RightVectorBar$1 = "â¥“";
const RightVector$1 = "â‡€";
const ring$1 = "Ëš";
const risingdotseq$1 = "â‰“";
const rlarr$1 = "â‡„";
const rlhar$1 = "â‡Œ";
const rlm$1 = "â€";
const rmoustache$1 = "âŽ±";
const rmoust$1 = "âŽ±";
const rnmid$1 = "â«®";
const roang$1 = "âŸ­";
const roarr$1 = "â‡¾";
const robrk$1 = "âŸ§";
const ropar$1 = "â¦†";
const ropf$1 = "ð•£";
const Ropf$1 = "â„";
const roplus$1 = "â¨®";
const rotimes$1 = "â¨µ";
const RoundImplies$1 = "â¥°";
const rpar$1 = ")";
const rpargt$1 = "â¦”";
const rppolint$1 = "â¨’";
const rrarr$1 = "â‡‰";
const Rrightarrow$1 = "â‡›";
const rsaquo$1 = "â€º";
const rscr$1 = "ð“‡";
const Rscr$1 = "â„›";
const rsh$1 = "â†±";
const Rsh$1 = "â†±";
const rsqb$1 = "]";
const rsquo$1 = "â€™";
const rsquor$1 = "â€™";
const rthree$1 = "â‹Œ";
const rtimes$1 = "â‹Š";
const rtri$1 = "â–¹";
const rtrie$1 = "âŠµ";
const rtrif$1 = "â–¸";
const rtriltri$1 = "â§Ž";
const RuleDelayed$1 = "â§´";
const ruluhar$1 = "â¥¨";
const rx$1 = "â„ž";
const Sacute$1 = "Åš";
const sacute$1 = "Å›";
const sbquo$1 = "â€š";
const scap$1 = "âª¸";
const Scaron$1 = "Å ";
const scaron$1 = "Å¡";
const Sc$1 = "âª¼";
const sc$1 = "â‰»";
const sccue$1 = "â‰½";
const sce$1 = "âª°";
const scE$1 = "âª´";
const Scedil$1 = "Åž";
const scedil$1 = "ÅŸ";
const Scirc$1 = "Åœ";
const scirc$1 = "Å";
const scnap$1 = "âªº";
const scnE$1 = "âª¶";
const scnsim$1 = "â‹©";
const scpolint$1 = "â¨“";
const scsim$1 = "â‰¿";
const Scy$1 = "Ð¡";
const scy$1 = "Ñ";
const sdotb$1 = "âŠ¡";
const sdot$1 = "â‹…";
const sdote$1 = "â©¦";
const searhk$1 = "â¤¥";
const searr$1 = "â†˜";
const seArr$1 = "â‡˜";
const searrow$1 = "â†˜";
const sect$3 = "Â§";
const semi$1 = ";";
const seswar$1 = "â¤©";
const setminus$1 = "âˆ–";
const setmn$1 = "âˆ–";
const sext$1 = "âœ¶";
const Sfr$1 = "ð”–";
const sfr$1 = "ð”°";
const sfrown$1 = "âŒ¢";
const sharp$1 = "â™¯";
const SHCHcy$1 = "Ð©";
const shchcy$1 = "Ñ‰";
const SHcy$1 = "Ð¨";
const shcy$1 = "Ñˆ";
const ShortDownArrow$1 = "â†“";
const ShortLeftArrow$1 = "â†";
const shortmid$1 = "âˆ£";
const shortparallel$1 = "âˆ¥";
const ShortRightArrow$1 = "â†’";
const ShortUpArrow$1 = "â†‘";
const shy$3 = "Â­";
const Sigma$1 = "Î£";
const sigma$1 = "Ïƒ";
const sigmaf$1 = "Ï‚";
const sigmav$1 = "Ï‚";
const sim$1 = "âˆ¼";
const simdot$1 = "â©ª";
const sime$1 = "â‰ƒ";
const simeq$1 = "â‰ƒ";
const simg$1 = "âªž";
const simgE$1 = "âª ";
const siml$1 = "âª";
const simlE$1 = "âªŸ";
const simne$1 = "â‰†";
const simplus$1 = "â¨¤";
const simrarr$1 = "â¥²";
const slarr$1 = "â†";
const SmallCircle$1 = "âˆ˜";
const smallsetminus$1 = "âˆ–";
const smashp$1 = "â¨³";
const smeparsl$1 = "â§¤";
const smid$1 = "âˆ£";
const smile$1 = "âŒ£";
const smt$1 = "âªª";
const smte$1 = "âª¬";
const smtes$1 = "âª¬ï¸€";
const SOFTcy$1 = "Ð¬";
const softcy$1 = "ÑŒ";
const solbar$1 = "âŒ¿";
const solb$1 = "â§„";
const sol$1 = "/";
const Sopf$1 = "ð•Š";
const sopf$1 = "ð•¤";
const spades$1 = "â™ ";
const spadesuit$1 = "â™ ";
const spar$1 = "âˆ¥";
const sqcap$1 = "âŠ“";
const sqcaps$1 = "âŠ“ï¸€";
const sqcup$1 = "âŠ”";
const sqcups$1 = "âŠ”ï¸€";
const Sqrt$1 = "âˆš";
const sqsub$1 = "âŠ";
const sqsube$1 = "âŠ‘";
const sqsubset$1 = "âŠ";
const sqsubseteq$1 = "âŠ‘";
const sqsup$1 = "âŠ";
const sqsupe$1 = "âŠ’";
const sqsupset$1 = "âŠ";
const sqsupseteq$1 = "âŠ’";
const square$1 = "â–¡";
const Square$1 = "â–¡";
const SquareIntersection$1 = "âŠ“";
const SquareSubset$1 = "âŠ";
const SquareSubsetEqual$1 = "âŠ‘";
const SquareSuperset$1 = "âŠ";
const SquareSupersetEqual$1 = "âŠ’";
const SquareUnion$1 = "âŠ”";
const squarf$1 = "â–ª";
const squ$1 = "â–¡";
const squf$1 = "â–ª";
const srarr$1 = "â†’";
const Sscr$1 = "ð’®";
const sscr$1 = "ð“ˆ";
const ssetmn$1 = "âˆ–";
const ssmile$1 = "âŒ£";
const sstarf$1 = "â‹†";
const Star$1 = "â‹†";
const star$1 = "â˜†";
const starf$1 = "â˜…";
const straightepsilon$1 = "Ïµ";
const straightphi$1 = "Ï•";
const strns$1 = "Â¯";
const sub$1 = "âŠ‚";
const Sub$1 = "â‹";
const subdot$1 = "âª½";
const subE$1 = "â«…";
const sube$1 = "âŠ†";
const subedot$1 = "â«ƒ";
const submult$1 = "â«";
const subnE$1 = "â«‹";
const subne$1 = "âŠŠ";
const subplus$1 = "âª¿";
const subrarr$1 = "â¥¹";
const subset$1 = "âŠ‚";
const Subset$1 = "â‹";
const subseteq$1 = "âŠ†";
const subseteqq$1 = "â«…";
const SubsetEqual$1 = "âŠ†";
const subsetneq$1 = "âŠŠ";
const subsetneqq$1 = "â«‹";
const subsim$1 = "â«‡";
const subsub$1 = "â«•";
const subsup$1 = "â«“";
const succapprox$1 = "âª¸";
const succ$1 = "â‰»";
const succcurlyeq$1 = "â‰½";
const Succeeds$1 = "â‰»";
const SucceedsEqual$1 = "âª°";
const SucceedsSlantEqual$1 = "â‰½";
const SucceedsTilde$1 = "â‰¿";
const succeq$1 = "âª°";
const succnapprox$1 = "âªº";
const succneqq$1 = "âª¶";
const succnsim$1 = "â‹©";
const succsim$1 = "â‰¿";
const SuchThat$1 = "âˆ‹";
const sum$1 = "âˆ‘";
const Sum$1 = "âˆ‘";
const sung$1 = "â™ª";
const sup1$3 = "Â¹";
const sup2$3 = "Â²";
const sup3$3 = "Â³";
const sup$1 = "âŠƒ";
const Sup$1 = "â‹‘";
const supdot$1 = "âª¾";
const supdsub$1 = "â«˜";
const supE$1 = "â«†";
const supe$1 = "âŠ‡";
const supedot$1 = "â«„";
const Superset$1 = "âŠƒ";
const SupersetEqual$1 = "âŠ‡";
const suphsol$1 = "âŸ‰";
const suphsub$1 = "â«—";
const suplarr$1 = "â¥»";
const supmult$1 = "â«‚";
const supnE$1 = "â«Œ";
const supne$1 = "âŠ‹";
const supplus$1 = "â«€";
const supset$1 = "âŠƒ";
const Supset$1 = "â‹‘";
const supseteq$1 = "âŠ‡";
const supseteqq$1 = "â«†";
const supsetneq$1 = "âŠ‹";
const supsetneqq$1 = "â«Œ";
const supsim$1 = "â«ˆ";
const supsub$1 = "â«”";
const supsup$1 = "â«–";
const swarhk$1 = "â¤¦";
const swarr$1 = "â†™";
const swArr$1 = "â‡™";
const swarrow$1 = "â†™";
const swnwar$1 = "â¤ª";
const szlig$3 = "ÃŸ";
const Tab$1 = "	";
const target$1 = "âŒ–";
const Tau$1 = "Î¤";
const tau$1 = "Ï„";
const tbrk$1 = "âŽ´";
const Tcaron$1 = "Å¤";
const tcaron$1 = "Å¥";
const Tcedil$1 = "Å¢";
const tcedil$1 = "Å£";
const Tcy$1 = "Ð¢";
const tcy$1 = "Ñ‚";
const tdot$1 = "âƒ›";
const telrec$1 = "âŒ•";
const Tfr$1 = "ð”—";
const tfr$1 = "ð”±";
const there4$1 = "âˆ´";
const therefore$1 = "âˆ´";
const Therefore$1 = "âˆ´";
const Theta$1 = "Î˜";
const theta$1 = "Î¸";
const thetasym$1 = "Ï‘";
const thetav$1 = "Ï‘";
const thickapprox$1 = "â‰ˆ";
const thicksim$1 = "âˆ¼";
const ThickSpace$1 = "âŸâ€Š";
const ThinSpace$1 = "â€‰";
const thinsp$1 = "â€‰";
const thkap$1 = "â‰ˆ";
const thksim$1 = "âˆ¼";
const THORN$3 = "Ãž";
const thorn$3 = "Ã¾";
const tilde$1 = "Ëœ";
const Tilde$1 = "âˆ¼";
const TildeEqual$1 = "â‰ƒ";
const TildeFullEqual$1 = "â‰…";
const TildeTilde$1 = "â‰ˆ";
const timesbar$1 = "â¨±";
const timesb$1 = "âŠ ";
const times$3 = "Ã—";
const timesd$1 = "â¨°";
const tint$1 = "âˆ­";
const toea$1 = "â¤¨";
const topbot$1 = "âŒ¶";
const topcir$1 = "â«±";
const top$1 = "âŠ¤";
const Topf$1 = "ð•‹";
const topf$1 = "ð•¥";
const topfork$1 = "â«š";
const tosa$1 = "â¤©";
const tprime$1 = "â€´";
const trade$1 = "â„¢";
const TRADE$1 = "â„¢";
const triangle$1 = "â–µ";
const triangledown$1 = "â–¿";
const triangleleft$1 = "â—ƒ";
const trianglelefteq$1 = "âŠ´";
const triangleq$1 = "â‰œ";
const triangleright$1 = "â–¹";
const trianglerighteq$1 = "âŠµ";
const tridot$1 = "â—¬";
const trie$1 = "â‰œ";
const triminus$1 = "â¨º";
const TripleDot$1 = "âƒ›";
const triplus$1 = "â¨¹";
const trisb$1 = "â§";
const tritime$1 = "â¨»";
const trpezium$1 = "â¢";
const Tscr$1 = "ð’¯";
const tscr$1 = "ð“‰";
const TScy$1 = "Ð¦";
const tscy$1 = "Ñ†";
const TSHcy$1 = "Ð‹";
const tshcy$1 = "Ñ›";
const Tstrok$1 = "Å¦";
const tstrok$1 = "Å§";
const twixt$1 = "â‰¬";
const twoheadleftarrow$1 = "â†ž";
const twoheadrightarrow$1 = "â† ";
const Uacute$3 = "Ãš";
const uacute$3 = "Ãº";
const uarr$1 = "â†‘";
const Uarr$1 = "â†Ÿ";
const uArr$1 = "â‡‘";
const Uarrocir$1 = "â¥‰";
const Ubrcy$1 = "ÐŽ";
const ubrcy$1 = "Ñž";
const Ubreve$1 = "Å¬";
const ubreve$1 = "Å­";
const Ucirc$3 = "Ã›";
const ucirc$3 = "Ã»";
const Ucy$1 = "Ð£";
const ucy$1 = "Ñƒ";
const udarr$1 = "â‡…";
const Udblac$1 = "Å°";
const udblac$1 = "Å±";
const udhar$1 = "â¥®";
const ufisht$1 = "â¥¾";
const Ufr$1 = "ð”˜";
const ufr$1 = "ð”²";
const Ugrave$3 = "Ã™";
const ugrave$3 = "Ã¹";
const uHar$1 = "â¥£";
const uharl$1 = "â†¿";
const uharr$1 = "â†¾";
const uhblk$1 = "â–€";
const ulcorn$1 = "âŒœ";
const ulcorner$1 = "âŒœ";
const ulcrop$1 = "âŒ";
const ultri$1 = "â—¸";
const Umacr$1 = "Åª";
const umacr$1 = "Å«";
const uml$3 = "Â¨";
const UnderBar$1 = "_";
const UnderBrace$1 = "âŸ";
const UnderBracket$1 = "âŽµ";
const UnderParenthesis$1 = "â";
const Union$1 = "â‹ƒ";
const UnionPlus$1 = "âŠŽ";
const Uogon$1 = "Å²";
const uogon$1 = "Å³";
const Uopf$1 = "ð•Œ";
const uopf$1 = "ð•¦";
const UpArrowBar$1 = "â¤’";
const uparrow$1 = "â†‘";
const UpArrow$1 = "â†‘";
const Uparrow$1 = "â‡‘";
const UpArrowDownArrow$1 = "â‡…";
const updownarrow$1 = "â†•";
const UpDownArrow$1 = "â†•";
const Updownarrow$1 = "â‡•";
const UpEquilibrium$1 = "â¥®";
const upharpoonleft$1 = "â†¿";
const upharpoonright$1 = "â†¾";
const uplus$1 = "âŠŽ";
const UpperLeftArrow$1 = "â†–";
const UpperRightArrow$1 = "â†—";
const upsi$1 = "Ï…";
const Upsi$1 = "Ï’";
const upsih$1 = "Ï’";
const Upsilon$1 = "Î¥";
const upsilon$1 = "Ï…";
const UpTeeArrow$1 = "â†¥";
const UpTee$1 = "âŠ¥";
const upuparrows$1 = "â‡ˆ";
const urcorn$1 = "âŒ";
const urcorner$1 = "âŒ";
const urcrop$1 = "âŒŽ";
const Uring$1 = "Å®";
const uring$1 = "Å¯";
const urtri$1 = "â—¹";
const Uscr$1 = "ð’°";
const uscr$1 = "ð“Š";
const utdot$1 = "â‹°";
const Utilde$1 = "Å¨";
const utilde$1 = "Å©";
const utri$1 = "â–µ";
const utrif$1 = "â–´";
const uuarr$1 = "â‡ˆ";
const Uuml$3 = "Ãœ";
const uuml$3 = "Ã¼";
const uwangle$1 = "â¦§";
const vangrt$1 = "â¦œ";
const varepsilon$1 = "Ïµ";
const varkappa$1 = "Ï°";
const varnothing$1 = "âˆ…";
const varphi$1 = "Ï•";
const varpi$1 = "Ï–";
const varpropto$1 = "âˆ";
const varr$1 = "â†•";
const vArr$1 = "â‡•";
const varrho$1 = "Ï±";
const varsigma$1 = "Ï‚";
const varsubsetneq$1 = "âŠŠï¸€";
const varsubsetneqq$1 = "â«‹ï¸€";
const varsupsetneq$1 = "âŠ‹ï¸€";
const varsupsetneqq$1 = "â«Œï¸€";
const vartheta$1 = "Ï‘";
const vartriangleleft$1 = "âŠ²";
const vartriangleright$1 = "âŠ³";
const vBar$1 = "â«¨";
const Vbar$1 = "â««";
const vBarv$1 = "â«©";
const Vcy$1 = "Ð’";
const vcy$1 = "Ð²";
const vdash$1 = "âŠ¢";
const vDash$1 = "âŠ¨";
const Vdash$1 = "âŠ©";
const VDash$1 = "âŠ«";
const Vdashl$1 = "â«¦";
const veebar$1 = "âŠ»";
const vee$1 = "âˆ¨";
const Vee$1 = "â‹";
const veeeq$1 = "â‰š";
const vellip$1 = "â‹®";
const verbar$1 = "|";
const Verbar$1 = "â€–";
const vert$1 = "|";
const Vert$1 = "â€–";
const VerticalBar$1 = "âˆ£";
const VerticalLine$1 = "|";
const VerticalSeparator$1 = "â˜";
const VerticalTilde$1 = "â‰€";
const VeryThinSpace$1 = "â€Š";
const Vfr$1 = "ð”™";
const vfr$1 = "ð”³";
const vltri$1 = "âŠ²";
const vnsub$1 = "âŠ‚âƒ’";
const vnsup$1 = "âŠƒâƒ’";
const Vopf$1 = "ð•";
const vopf$1 = "ð•§";
const vprop$1 = "âˆ";
const vrtri$1 = "âŠ³";
const Vscr$1 = "ð’±";
const vscr$1 = "ð“‹";
const vsubnE$1 = "â«‹ï¸€";
const vsubne$1 = "âŠŠï¸€";
const vsupnE$1 = "â«Œï¸€";
const vsupne$1 = "âŠ‹ï¸€";
const Vvdash$1 = "âŠª";
const vzigzag$1 = "â¦š";
const Wcirc$1 = "Å´";
const wcirc$1 = "Åµ";
const wedbar$1 = "â©Ÿ";
const wedge$1 = "âˆ§";
const Wedge$1 = "â‹€";
const wedgeq$1 = "â‰™";
const weierp$1 = "â„˜";
const Wfr$1 = "ð”š";
const wfr$1 = "ð”´";
const Wopf$1 = "ð•Ž";
const wopf$1 = "ð•¨";
const wp$1 = "â„˜";
const wr$1 = "â‰€";
const wreath$1 = "â‰€";
const Wscr$1 = "ð’²";
const wscr$1 = "ð“Œ";
const xcap$1 = "â‹‚";
const xcirc$1 = "â—¯";
const xcup$1 = "â‹ƒ";
const xdtri$1 = "â–½";
const Xfr$1 = "ð”›";
const xfr$1 = "ð”µ";
const xharr$1 = "âŸ·";
const xhArr$1 = "âŸº";
const Xi$1 = "Îž";
const xi$1 = "Î¾";
const xlarr$1 = "âŸµ";
const xlArr$1 = "âŸ¸";
const xmap$1 = "âŸ¼";
const xnis$1 = "â‹»";
const xodot$1 = "â¨€";
const Xopf$1 = "ð•";
const xopf$1 = "ð•©";
const xoplus$1 = "â¨";
const xotime$1 = "â¨‚";
const xrarr$1 = "âŸ¶";
const xrArr$1 = "âŸ¹";
const Xscr$1 = "ð’³";
const xscr$1 = "ð“";
const xsqcup$1 = "â¨†";
const xuplus$1 = "â¨„";
const xutri$1 = "â–³";
const xvee$1 = "â‹";
const xwedge$1 = "â‹€";
const Yacute$3 = "Ã";
const yacute$3 = "Ã½";
const YAcy$1 = "Ð¯";
const yacy$1 = "Ñ";
const Ycirc$1 = "Å¶";
const ycirc$1 = "Å·";
const Ycy$1 = "Ð«";
const ycy$1 = "Ñ‹";
const yen$3 = "Â¥";
const Yfr$1 = "ð”œ";
const yfr$1 = "ð”¶";
const YIcy$1 = "Ð‡";
const yicy$1 = "Ñ—";
const Yopf$1 = "ð•";
const yopf$1 = "ð•ª";
const Yscr$1 = "ð’´";
const yscr$1 = "ð“Ž";
const YUcy$1 = "Ð®";
const yucy$1 = "ÑŽ";
const yuml$3 = "Ã¿";
const Yuml$1 = "Å¸";
const Zacute$1 = "Å¹";
const zacute$1 = "Åº";
const Zcaron$1 = "Å½";
const zcaron$1 = "Å¾";
const Zcy$1 = "Ð—";
const zcy$1 = "Ð·";
const Zdot$1 = "Å»";
const zdot$1 = "Å¼";
const zeetrf$1 = "â„¨";
const ZeroWidthSpace$1 = "â€‹";
const Zeta$1 = "Î–";
const zeta$1 = "Î¶";
const zfr$1 = "ð”·";
const Zfr$1 = "â„¨";
const ZHcy$1 = "Ð–";
const zhcy$1 = "Ð¶";
const zigrarr$1 = "â‡";
const zopf$1 = "ð•«";
const Zopf$1 = "â„¤";
const Zscr$1 = "ð’µ";
const zscr$1 = "ð“";
const zwj$1 = "â€";
const zwnj$1 = "â€Œ";
const require$$1$2 = {
  Aacute: Aacute$3,
  aacute: aacute$3,
  Abreve: Abreve$1,
  abreve: abreve$1,
  ac: ac$1,
  acd: acd$1,
  acE: acE$1,
  Acirc: Acirc$3,
  acirc: acirc$3,
  acute: acute$3,
  Acy: Acy$1,
  acy: acy$1,
  AElig: AElig$3,
  aelig: aelig$3,
  af: af$1,
  Afr: Afr$1,
  afr: afr$1,
  Agrave: Agrave$3,
  agrave: agrave$3,
  alefsym: alefsym$1,
  aleph: aleph$1,
  Alpha: Alpha$1,
  alpha: alpha$1,
  Amacr: Amacr$1,
  amacr: amacr$1,
  amalg: amalg$1,
  amp: amp$5,
  AMP: AMP$3,
  andand: andand$1,
  And: And$1,
  and: and$1,
  andd: andd$1,
  andslope: andslope$1,
  andv: andv$1,
  ang: ang$1,
  ange: ange$1,
  angle: angle$1,
  angmsdaa: angmsdaa$1,
  angmsdab: angmsdab$1,
  angmsdac: angmsdac$1,
  angmsdad: angmsdad$1,
  angmsdae: angmsdae$1,
  angmsdaf: angmsdaf$1,
  angmsdag: angmsdag$1,
  angmsdah: angmsdah$1,
  angmsd: angmsd$1,
  angrt: angrt$1,
  angrtvb: angrtvb$1,
  angrtvbd: angrtvbd$1,
  angsph: angsph$1,
  angst: angst$1,
  angzarr: angzarr$1,
  Aogon: Aogon$1,
  aogon: aogon$1,
  Aopf: Aopf$1,
  aopf: aopf$1,
  apacir: apacir$1,
  ap: ap$1,
  apE: apE$1,
  ape: ape$1,
  apid: apid$1,
  apos: apos$3,
  ApplyFunction: ApplyFunction$1,
  approx: approx$1,
  approxeq: approxeq$1,
  Aring: Aring$3,
  aring: aring$3,
  Ascr: Ascr$1,
  ascr: ascr$1,
  Assign: Assign$1,
  ast: ast$1,
  asymp: asymp$1,
  asympeq: asympeq$1,
  Atilde: Atilde$3,
  atilde: atilde$3,
  Auml: Auml$3,
  auml: auml$3,
  awconint: awconint$1,
  awint: awint$1,
  backcong: backcong$1,
  backepsilon: backepsilon$1,
  backprime: backprime$1,
  backsim: backsim$1,
  backsimeq: backsimeq$1,
  Backslash: Backslash$1,
  Barv: Barv$1,
  barvee: barvee$1,
  barwed: barwed$1,
  Barwed: Barwed$1,
  barwedge: barwedge$1,
  bbrk: bbrk$1,
  bbrktbrk: bbrktbrk$1,
  bcong: bcong$1,
  Bcy: Bcy$1,
  bcy: bcy$1,
  bdquo: bdquo$1,
  becaus: becaus$1,
  because: because$1,
  Because: Because$1,
  bemptyv: bemptyv$1,
  bepsi: bepsi$1,
  bernou: bernou$1,
  Bernoullis: Bernoullis$1,
  Beta: Beta$1,
  beta: beta$1,
  beth: beth$1,
  between: between$1,
  Bfr: Bfr$1,
  bfr: bfr$1,
  bigcap: bigcap$1,
  bigcirc: bigcirc$1,
  bigcup: bigcup$1,
  bigodot: bigodot$1,
  bigoplus: bigoplus$1,
  bigotimes: bigotimes$1,
  bigsqcup: bigsqcup$1,
  bigstar: bigstar$1,
  bigtriangledown: bigtriangledown$1,
  bigtriangleup: bigtriangleup$1,
  biguplus: biguplus$1,
  bigvee: bigvee$1,
  bigwedge: bigwedge$1,
  bkarow: bkarow$1,
  blacklozenge: blacklozenge$1,
  blacksquare: blacksquare$1,
  blacktriangle: blacktriangle$1,
  blacktriangledown: blacktriangledown$1,
  blacktriangleleft: blacktriangleleft$1,
  blacktriangleright: blacktriangleright$1,
  blank: blank$1,
  blk12: blk12$1,
  blk14: blk14$1,
  blk34: blk34$1,
  block: block$1,
  bne: bne$1,
  bnequiv: bnequiv$1,
  bNot: bNot$1,
  bnot: bnot$1,
  Bopf: Bopf$1,
  bopf: bopf$1,
  bot: bot$1,
  bottom: bottom$1,
  bowtie: bowtie$1,
  boxbox: boxbox$1,
  boxdl: boxdl$1,
  boxdL: boxdL$1,
  boxDl: boxDl$1,
  boxDL: boxDL$1,
  boxdr: boxdr$1,
  boxdR: boxdR$1,
  boxDr: boxDr$1,
  boxDR: boxDR$1,
  boxh: boxh$1,
  boxH: boxH$1,
  boxhd: boxhd$1,
  boxHd: boxHd$1,
  boxhD: boxhD$1,
  boxHD: boxHD$1,
  boxhu: boxhu$1,
  boxHu: boxHu$1,
  boxhU: boxhU$1,
  boxHU: boxHU$1,
  boxminus: boxminus$1,
  boxplus: boxplus$1,
  boxtimes: boxtimes$1,
  boxul: boxul$1,
  boxuL: boxuL$1,
  boxUl: boxUl$1,
  boxUL: boxUL$1,
  boxur: boxur$1,
  boxuR: boxuR$1,
  boxUr: boxUr$1,
  boxUR: boxUR$1,
  boxv: boxv$1,
  boxV: boxV$1,
  boxvh: boxvh$1,
  boxvH: boxvH$1,
  boxVh: boxVh$1,
  boxVH: boxVH$1,
  boxvl: boxvl$1,
  boxvL: boxvL$1,
  boxVl: boxVl$1,
  boxVL: boxVL$1,
  boxvr: boxvr$1,
  boxvR: boxvR$1,
  boxVr: boxVr$1,
  boxVR: boxVR$1,
  bprime: bprime$1,
  breve: breve$1,
  Breve: Breve$1,
  brvbar: brvbar$3,
  bscr: bscr$1,
  Bscr: Bscr$1,
  bsemi: bsemi$1,
  bsim: bsim$1,
  bsime: bsime$1,
  bsolb: bsolb$1,
  bsol: bsol$1,
  bsolhsub: bsolhsub$1,
  bull: bull$1,
  bullet: bullet$1,
  bump: bump$1,
  bumpE: bumpE$1,
  bumpe: bumpe$1,
  Bumpeq: Bumpeq$1,
  bumpeq: bumpeq$1,
  Cacute: Cacute$1,
  cacute: cacute$1,
  capand: capand$1,
  capbrcup: capbrcup$1,
  capcap: capcap$1,
  cap: cap$1,
  Cap: Cap$1,
  capcup: capcup$1,
  capdot: capdot$1,
  CapitalDifferentialD: CapitalDifferentialD$1,
  caps: caps$1,
  caret: caret$1,
  caron: caron$1,
  Cayleys: Cayleys$1,
  ccaps: ccaps$1,
  Ccaron: Ccaron$1,
  ccaron: ccaron$1,
  Ccedil: Ccedil$3,
  ccedil: ccedil$3,
  Ccirc: Ccirc$1,
  ccirc: ccirc$1,
  Cconint: Cconint$1,
  ccups: ccups$1,
  ccupssm: ccupssm$1,
  Cdot: Cdot$1,
  cdot: cdot$1,
  cedil: cedil$3,
  Cedilla: Cedilla$1,
  cemptyv: cemptyv$1,
  cent: cent$3,
  centerdot: centerdot$1,
  CenterDot: CenterDot$1,
  cfr: cfr$1,
  Cfr: Cfr$1,
  CHcy: CHcy$1,
  chcy: chcy$1,
  check: check$1,
  checkmark: checkmark$1,
  Chi: Chi$1,
  chi: chi$1,
  circ: circ$1,
  circeq: circeq$1,
  circlearrowleft: circlearrowleft$1,
  circlearrowright: circlearrowright$1,
  circledast: circledast$1,
  circledcirc: circledcirc$1,
  circleddash: circleddash$1,
  CircleDot: CircleDot$1,
  circledR: circledR$1,
  circledS: circledS$1,
  CircleMinus: CircleMinus$1,
  CirclePlus: CirclePlus$1,
  CircleTimes: CircleTimes$1,
  cir: cir$1,
  cirE: cirE$1,
  cire: cire$1,
  cirfnint: cirfnint$1,
  cirmid: cirmid$1,
  cirscir: cirscir$1,
  ClockwiseContourIntegral: ClockwiseContourIntegral$1,
  CloseCurlyDoubleQuote: CloseCurlyDoubleQuote$1,
  CloseCurlyQuote: CloseCurlyQuote$1,
  clubs: clubs$1,
  clubsuit: clubsuit$1,
  colon: colon$1,
  Colon: Colon$1,
  Colone: Colone$1,
  colone: colone$1,
  coloneq: coloneq$1,
  comma: comma$1,
  commat: commat$1,
  comp: comp$1,
  compfn: compfn$1,
  complement: complement$1,
  complexes: complexes$1,
  cong: cong$1,
  congdot: congdot$1,
  Congruent: Congruent$1,
  conint: conint$1,
  Conint: Conint$1,
  ContourIntegral: ContourIntegral$1,
  copf: copf$1,
  Copf: Copf$1,
  coprod: coprod$1,
  Coproduct: Coproduct$1,
  copy: copy$3,
  COPY: COPY$3,
  copysr: copysr$1,
  CounterClockwiseContourIntegral: CounterClockwiseContourIntegral$1,
  crarr: crarr$1,
  cross: cross$1,
  Cross: Cross$1,
  Cscr: Cscr$1,
  cscr: cscr$1,
  csub: csub$1,
  csube: csube$1,
  csup: csup$1,
  csupe: csupe$1,
  ctdot: ctdot$1,
  cudarrl: cudarrl$1,
  cudarrr: cudarrr$1,
  cuepr: cuepr$1,
  cuesc: cuesc$1,
  cularr: cularr$1,
  cularrp: cularrp$1,
  cupbrcap: cupbrcap$1,
  cupcap: cupcap$1,
  CupCap: CupCap$1,
  cup: cup$1,
  Cup: Cup$1,
  cupcup: cupcup$1,
  cupdot: cupdot$1,
  cupor: cupor$1,
  cups: cups$1,
  curarr: curarr$1,
  curarrm: curarrm$1,
  curlyeqprec: curlyeqprec$1,
  curlyeqsucc: curlyeqsucc$1,
  curlyvee: curlyvee$1,
  curlywedge: curlywedge$1,
  curren: curren$3,
  curvearrowleft: curvearrowleft$1,
  curvearrowright: curvearrowright$1,
  cuvee: cuvee$1,
  cuwed: cuwed$1,
  cwconint: cwconint$1,
  cwint: cwint$1,
  cylcty: cylcty$1,
  dagger: dagger$1,
  Dagger: Dagger$1,
  daleth: daleth$1,
  darr: darr$1,
  Darr: Darr$1,
  dArr: dArr$1,
  dash: dash$1,
  Dashv: Dashv$1,
  dashv: dashv$1,
  dbkarow: dbkarow$1,
  dblac: dblac$1,
  Dcaron: Dcaron$1,
  dcaron: dcaron$1,
  Dcy: Dcy$1,
  dcy: dcy$1,
  ddagger: ddagger$1,
  ddarr: ddarr$1,
  DD: DD$1,
  dd: dd$1,
  DDotrahd: DDotrahd$1,
  ddotseq: ddotseq$1,
  deg: deg$3,
  Del: Del$1,
  Delta: Delta$1,
  delta: delta$1,
  demptyv: demptyv$1,
  dfisht: dfisht$1,
  Dfr: Dfr$1,
  dfr: dfr$1,
  dHar: dHar$1,
  dharl: dharl$1,
  dharr: dharr$1,
  DiacriticalAcute: DiacriticalAcute$1,
  DiacriticalDot: DiacriticalDot$1,
  DiacriticalDoubleAcute: DiacriticalDoubleAcute$1,
  DiacriticalGrave: DiacriticalGrave$1,
  DiacriticalTilde: DiacriticalTilde$1,
  diam: diam$1,
  diamond: diamond$1,
  Diamond: Diamond$1,
  diamondsuit: diamondsuit$1,
  diams: diams$1,
  die: die$1,
  DifferentialD: DifferentialD$1,
  digamma: digamma$1,
  disin: disin$1,
  div: div$1,
  divide: divide$3,
  divideontimes: divideontimes$1,
  divonx: divonx$1,
  DJcy: DJcy$1,
  djcy: djcy$1,
  dlcorn: dlcorn$1,
  dlcrop: dlcrop$1,
  dollar: dollar$1,
  Dopf: Dopf$1,
  dopf: dopf$1,
  Dot: Dot$1,
  dot: dot$1,
  DotDot: DotDot$1,
  doteq: doteq$1,
  doteqdot: doteqdot$1,
  DotEqual: DotEqual$1,
  dotminus: dotminus$1,
  dotplus: dotplus$1,
  dotsquare: dotsquare$1,
  doublebarwedge: doublebarwedge$1,
  DoubleContourIntegral: DoubleContourIntegral$1,
  DoubleDot: DoubleDot$1,
  DoubleDownArrow: DoubleDownArrow$1,
  DoubleLeftArrow: DoubleLeftArrow$1,
  DoubleLeftRightArrow: DoubleLeftRightArrow$1,
  DoubleLeftTee: DoubleLeftTee$1,
  DoubleLongLeftArrow: DoubleLongLeftArrow$1,
  DoubleLongLeftRightArrow: DoubleLongLeftRightArrow$1,
  DoubleLongRightArrow: DoubleLongRightArrow$1,
  DoubleRightArrow: DoubleRightArrow$1,
  DoubleRightTee: DoubleRightTee$1,
  DoubleUpArrow: DoubleUpArrow$1,
  DoubleUpDownArrow: DoubleUpDownArrow$1,
  DoubleVerticalBar: DoubleVerticalBar$1,
  DownArrowBar: DownArrowBar$1,
  downarrow: downarrow$1,
  DownArrow: DownArrow$1,
  Downarrow: Downarrow$1,
  DownArrowUpArrow: DownArrowUpArrow$1,
  DownBreve: DownBreve$1,
  downdownarrows: downdownarrows$1,
  downharpoonleft: downharpoonleft$1,
  downharpoonright: downharpoonright$1,
  DownLeftRightVector: DownLeftRightVector$1,
  DownLeftTeeVector: DownLeftTeeVector$1,
  DownLeftVectorBar: DownLeftVectorBar$1,
  DownLeftVector: DownLeftVector$1,
  DownRightTeeVector: DownRightTeeVector$1,
  DownRightVectorBar: DownRightVectorBar$1,
  DownRightVector: DownRightVector$1,
  DownTeeArrow: DownTeeArrow$1,
  DownTee: DownTee$1,
  drbkarow: drbkarow$1,
  drcorn: drcorn$1,
  drcrop: drcrop$1,
  Dscr: Dscr$1,
  dscr: dscr$1,
  DScy: DScy$1,
  dscy: dscy$1,
  dsol: dsol$1,
  Dstrok: Dstrok$1,
  dstrok: dstrok$1,
  dtdot: dtdot$1,
  dtri: dtri$1,
  dtrif: dtrif$1,
  duarr: duarr$1,
  duhar: duhar$1,
  dwangle: dwangle$1,
  DZcy: DZcy$1,
  dzcy: dzcy$1,
  dzigrarr: dzigrarr$1,
  Eacute: Eacute$3,
  eacute: eacute$3,
  easter: easter$1,
  Ecaron: Ecaron$1,
  ecaron: ecaron$1,
  Ecirc: Ecirc$3,
  ecirc: ecirc$3,
  ecir: ecir$1,
  ecolon: ecolon$1,
  Ecy: Ecy$1,
  ecy: ecy$1,
  eDDot: eDDot$1,
  Edot: Edot$1,
  edot: edot$1,
  eDot: eDot$1,
  ee: ee$1,
  efDot: efDot$1,
  Efr: Efr$1,
  efr: efr$1,
  eg: eg$1,
  Egrave: Egrave$3,
  egrave: egrave$3,
  egs: egs$1,
  egsdot: egsdot$1,
  el: el$1,
  Element: Element$1,
  elinters: elinters$1,
  ell: ell$1,
  els: els$1,
  elsdot: elsdot$1,
  Emacr: Emacr$1,
  emacr: emacr$1,
  empty: empty$1,
  emptyset: emptyset$1,
  EmptySmallSquare: EmptySmallSquare$1,
  emptyv: emptyv$1,
  EmptyVerySmallSquare: EmptyVerySmallSquare$1,
  emsp13: emsp13$1,
  emsp14: emsp14$1,
  emsp: emsp$1,
  ENG: ENG$1,
  eng: eng$1,
  ensp: ensp$1,
  Eogon: Eogon$1,
  eogon: eogon$1,
  Eopf: Eopf$1,
  eopf: eopf$1,
  epar: epar$1,
  eparsl: eparsl$1,
  eplus: eplus$1,
  epsi: epsi$1,
  Epsilon: Epsilon$1,
  epsilon: epsilon$1,
  epsiv: epsiv$1,
  eqcirc: eqcirc$1,
  eqcolon: eqcolon$1,
  eqsim: eqsim$1,
  eqslantgtr: eqslantgtr$1,
  eqslantless: eqslantless$1,
  Equal: Equal$1,
  equals: equals$1,
  EqualTilde: EqualTilde$1,
  equest: equest$1,
  Equilibrium: Equilibrium$1,
  equiv: equiv$1,
  equivDD: equivDD$1,
  eqvparsl: eqvparsl$1,
  erarr: erarr$1,
  erDot: erDot$1,
  escr: escr$1,
  Escr: Escr$1,
  esdot: esdot$1,
  Esim: Esim$1,
  esim: esim$1,
  Eta: Eta$1,
  eta: eta$1,
  ETH: ETH$3,
  eth: eth$3,
  Euml: Euml$3,
  euml: euml$3,
  euro: euro$1,
  excl: excl$1,
  exist: exist$1,
  Exists: Exists$1,
  expectation: expectation$1,
  exponentiale: exponentiale$1,
  ExponentialE: ExponentialE$1,
  fallingdotseq: fallingdotseq$1,
  Fcy: Fcy$1,
  fcy: fcy$1,
  female: female$1,
  ffilig: ffilig$1,
  fflig: fflig$1,
  ffllig: ffllig$1,
  Ffr: Ffr$1,
  ffr: ffr$1,
  filig: filig$1,
  FilledSmallSquare: FilledSmallSquare$1,
  FilledVerySmallSquare: FilledVerySmallSquare$1,
  fjlig: fjlig$1,
  flat: flat$1,
  fllig: fllig$1,
  fltns: fltns$1,
  fnof: fnof$1,
  Fopf: Fopf$1,
  fopf: fopf$1,
  forall: forall$1,
  ForAll: ForAll$1,
  fork: fork$1,
  forkv: forkv$1,
  Fouriertrf: Fouriertrf$1,
  fpartint: fpartint$1,
  frac12: frac12$3,
  frac13: frac13$1,
  frac14: frac14$3,
  frac15: frac15$1,
  frac16: frac16$1,
  frac18: frac18$1,
  frac23: frac23$1,
  frac25: frac25$1,
  frac34: frac34$3,
  frac35: frac35$1,
  frac38: frac38$1,
  frac45: frac45$1,
  frac56: frac56$1,
  frac58: frac58$1,
  frac78: frac78$1,
  frasl: frasl$1,
  frown: frown$1,
  fscr: fscr$1,
  Fscr: Fscr$1,
  gacute: gacute$1,
  Gamma: Gamma$1,
  gamma: gamma$1,
  Gammad: Gammad$1,
  gammad: gammad$1,
  gap: gap$1,
  Gbreve: Gbreve$1,
  gbreve: gbreve$1,
  Gcedil: Gcedil$1,
  Gcirc: Gcirc$1,
  gcirc: gcirc$1,
  Gcy: Gcy$1,
  gcy: gcy$1,
  Gdot: Gdot$1,
  gdot: gdot$1,
  ge: ge$1,
  gE: gE$1,
  gEl: gEl$1,
  gel: gel$1,
  geq: geq$1,
  geqq: geqq$1,
  geqslant: geqslant$1,
  gescc: gescc$1,
  ges: ges$1,
  gesdot: gesdot$1,
  gesdoto: gesdoto$1,
  gesdotol: gesdotol$1,
  gesl: gesl$1,
  gesles: gesles$1,
  Gfr: Gfr$1,
  gfr: gfr$1,
  gg: gg$1,
  Gg: Gg$1,
  ggg: ggg$1,
  gimel: gimel$1,
  GJcy: GJcy$1,
  gjcy: gjcy$1,
  gla: gla$1,
  gl: gl$1,
  glE: glE$1,
  glj: glj$1,
  gnap: gnap$1,
  gnapprox: gnapprox$1,
  gne: gne$1,
  gnE: gnE$1,
  gneq: gneq$1,
  gneqq: gneqq$1,
  gnsim: gnsim$1,
  Gopf: Gopf$1,
  gopf: gopf$1,
  grave: grave$1,
  GreaterEqual: GreaterEqual$1,
  GreaterEqualLess: GreaterEqualLess$1,
  GreaterFullEqual: GreaterFullEqual$1,
  GreaterGreater: GreaterGreater$1,
  GreaterLess: GreaterLess$1,
  GreaterSlantEqual: GreaterSlantEqual$1,
  GreaterTilde: GreaterTilde$1,
  Gscr: Gscr$1,
  gscr: gscr$1,
  gsim: gsim$1,
  gsime: gsime$1,
  gsiml: gsiml$1,
  gtcc: gtcc$1,
  gtcir: gtcir$1,
  gt: gt$5,
  GT: GT$3,
  Gt: Gt$1,
  gtdot: gtdot$1,
  gtlPar: gtlPar$1,
  gtquest: gtquest$1,
  gtrapprox: gtrapprox$1,
  gtrarr: gtrarr$1,
  gtrdot: gtrdot$1,
  gtreqless: gtreqless$1,
  gtreqqless: gtreqqless$1,
  gtrless: gtrless$1,
  gtrsim: gtrsim$1,
  gvertneqq: gvertneqq$1,
  gvnE: gvnE$1,
  Hacek: Hacek$1,
  hairsp: hairsp$1,
  half: half$1,
  hamilt: hamilt$1,
  HARDcy: HARDcy$1,
  hardcy: hardcy$1,
  harrcir: harrcir$1,
  harr: harr$1,
  hArr: hArr$1,
  harrw: harrw$1,
  Hat: Hat$1,
  hbar: hbar$1,
  Hcirc: Hcirc$1,
  hcirc: hcirc$1,
  hearts: hearts$1,
  heartsuit: heartsuit$1,
  hellip: hellip$1,
  hercon: hercon$1,
  hfr: hfr$1,
  Hfr: Hfr$1,
  HilbertSpace: HilbertSpace$1,
  hksearow: hksearow$1,
  hkswarow: hkswarow$1,
  hoarr: hoarr$1,
  homtht: homtht$1,
  hookleftarrow: hookleftarrow$1,
  hookrightarrow: hookrightarrow$1,
  hopf: hopf$1,
  Hopf: Hopf$1,
  horbar: horbar$1,
  HorizontalLine: HorizontalLine$1,
  hscr: hscr$1,
  Hscr: Hscr$1,
  hslash: hslash$1,
  Hstrok: Hstrok$1,
  hstrok: hstrok$1,
  HumpDownHump: HumpDownHump$1,
  HumpEqual: HumpEqual$1,
  hybull: hybull$1,
  hyphen: hyphen$1,
  Iacute: Iacute$3,
  iacute: iacute$3,
  ic: ic$1,
  Icirc: Icirc$3,
  icirc: icirc$3,
  Icy: Icy$1,
  icy: icy$1,
  Idot: Idot$1,
  IEcy: IEcy$1,
  iecy: iecy$1,
  iexcl: iexcl$3,
  iff: iff$1,
  ifr: ifr$1,
  Ifr: Ifr$1,
  Igrave: Igrave$3,
  igrave: igrave$3,
  ii: ii$1,
  iiiint: iiiint$1,
  iiint: iiint$1,
  iinfin: iinfin$1,
  iiota: iiota$1,
  IJlig: IJlig$1,
  ijlig: ijlig$1,
  Imacr: Imacr$1,
  imacr: imacr$1,
  image: image$1,
  ImaginaryI: ImaginaryI$1,
  imagline: imagline$1,
  imagpart: imagpart$1,
  imath: imath$1,
  Im: Im$1,
  imof: imof$1,
  imped: imped$1,
  Implies: Implies$1,
  incare: incare$1,
  "in": "âˆˆ",
  infin: infin$1,
  infintie: infintie$1,
  inodot: inodot$1,
  intcal: intcal$1,
  int: int$1,
  Int: Int$1,
  integers: integers$1,
  Integral: Integral$1,
  intercal: intercal$1,
  Intersection: Intersection$1,
  intlarhk: intlarhk$1,
  intprod: intprod$1,
  InvisibleComma: InvisibleComma$1,
  InvisibleTimes: InvisibleTimes$1,
  IOcy: IOcy$1,
  iocy: iocy$1,
  Iogon: Iogon$1,
  iogon: iogon$1,
  Iopf: Iopf$1,
  iopf: iopf$1,
  Iota: Iota$1,
  iota: iota$1,
  iprod: iprod$1,
  iquest: iquest$3,
  iscr: iscr$1,
  Iscr: Iscr$1,
  isin: isin$1,
  isindot: isindot$1,
  isinE: isinE$1,
  isins: isins$1,
  isinsv: isinsv$1,
  isinv: isinv$1,
  it: it$1,
  Itilde: Itilde$1,
  itilde: itilde$1,
  Iukcy: Iukcy$1,
  iukcy: iukcy$1,
  Iuml: Iuml$3,
  iuml: iuml$3,
  Jcirc: Jcirc$1,
  jcirc: jcirc$1,
  Jcy: Jcy$1,
  jcy: jcy$1,
  Jfr: Jfr$1,
  jfr: jfr$1,
  jmath: jmath$1,
  Jopf: Jopf$1,
  jopf: jopf$1,
  Jscr: Jscr$1,
  jscr: jscr$1,
  Jsercy: Jsercy$1,
  jsercy: jsercy$1,
  Jukcy: Jukcy$1,
  jukcy: jukcy$1,
  Kappa: Kappa$1,
  kappa: kappa$1,
  kappav: kappav$1,
  Kcedil: Kcedil$1,
  kcedil: kcedil$1,
  Kcy: Kcy$1,
  kcy: kcy$1,
  Kfr: Kfr$1,
  kfr: kfr$1,
  kgreen: kgreen$1,
  KHcy: KHcy$1,
  khcy: khcy$1,
  KJcy: KJcy$1,
  kjcy: kjcy$1,
  Kopf: Kopf$1,
  kopf: kopf$1,
  Kscr: Kscr$1,
  kscr: kscr$1,
  lAarr: lAarr$1,
  Lacute: Lacute$1,
  lacute: lacute$1,
  laemptyv: laemptyv$1,
  lagran: lagran$1,
  Lambda: Lambda$1,
  lambda: lambda$1,
  lang: lang$1,
  Lang: Lang$1,
  langd: langd$1,
  langle: langle$1,
  lap: lap$1,
  Laplacetrf: Laplacetrf$1,
  laquo: laquo$3,
  larrb: larrb$1,
  larrbfs: larrbfs$1,
  larr: larr$1,
  Larr: Larr$1,
  lArr: lArr$1,
  larrfs: larrfs$1,
  larrhk: larrhk$1,
  larrlp: larrlp$1,
  larrpl: larrpl$1,
  larrsim: larrsim$1,
  larrtl: larrtl$1,
  latail: latail$1,
  lAtail: lAtail$1,
  lat: lat$1,
  late: late$1,
  lates: lates$1,
  lbarr: lbarr$1,
  lBarr: lBarr$1,
  lbbrk: lbbrk$1,
  lbrace: lbrace$1,
  lbrack: lbrack$1,
  lbrke: lbrke$1,
  lbrksld: lbrksld$1,
  lbrkslu: lbrkslu$1,
  Lcaron: Lcaron$1,
  lcaron: lcaron$1,
  Lcedil: Lcedil$1,
  lcedil: lcedil$1,
  lceil: lceil$1,
  lcub: lcub$1,
  Lcy: Lcy$1,
  lcy: lcy$1,
  ldca: ldca$1,
  ldquo: ldquo$1,
  ldquor: ldquor$1,
  ldrdhar: ldrdhar$1,
  ldrushar: ldrushar$1,
  ldsh: ldsh$1,
  le: le$1,
  lE: lE$1,
  LeftAngleBracket: LeftAngleBracket$1,
  LeftArrowBar: LeftArrowBar$1,
  leftarrow: leftarrow$1,
  LeftArrow: LeftArrow$1,
  Leftarrow: Leftarrow$1,
  LeftArrowRightArrow: LeftArrowRightArrow$1,
  leftarrowtail: leftarrowtail$1,
  LeftCeiling: LeftCeiling$1,
  LeftDoubleBracket: LeftDoubleBracket$1,
  LeftDownTeeVector: LeftDownTeeVector$1,
  LeftDownVectorBar: LeftDownVectorBar$1,
  LeftDownVector: LeftDownVector$1,
  LeftFloor: LeftFloor$1,
  leftharpoondown: leftharpoondown$1,
  leftharpoonup: leftharpoonup$1,
  leftleftarrows: leftleftarrows$1,
  leftrightarrow: leftrightarrow$1,
  LeftRightArrow: LeftRightArrow$1,
  Leftrightarrow: Leftrightarrow$1,
  leftrightarrows: leftrightarrows$1,
  leftrightharpoons: leftrightharpoons$1,
  leftrightsquigarrow: leftrightsquigarrow$1,
  LeftRightVector: LeftRightVector$1,
  LeftTeeArrow: LeftTeeArrow$1,
  LeftTee: LeftTee$1,
  LeftTeeVector: LeftTeeVector$1,
  leftthreetimes: leftthreetimes$1,
  LeftTriangleBar: LeftTriangleBar$1,
  LeftTriangle: LeftTriangle$1,
  LeftTriangleEqual: LeftTriangleEqual$1,
  LeftUpDownVector: LeftUpDownVector$1,
  LeftUpTeeVector: LeftUpTeeVector$1,
  LeftUpVectorBar: LeftUpVectorBar$1,
  LeftUpVector: LeftUpVector$1,
  LeftVectorBar: LeftVectorBar$1,
  LeftVector: LeftVector$1,
  lEg: lEg$1,
  leg: leg$1,
  leq: leq$1,
  leqq: leqq$1,
  leqslant: leqslant$1,
  lescc: lescc$1,
  les: les$1,
  lesdot: lesdot$1,
  lesdoto: lesdoto$1,
  lesdotor: lesdotor$1,
  lesg: lesg$1,
  lesges: lesges$1,
  lessapprox: lessapprox$1,
  lessdot: lessdot$1,
  lesseqgtr: lesseqgtr$1,
  lesseqqgtr: lesseqqgtr$1,
  LessEqualGreater: LessEqualGreater$1,
  LessFullEqual: LessFullEqual$1,
  LessGreater: LessGreater$1,
  lessgtr: lessgtr$1,
  LessLess: LessLess$1,
  lesssim: lesssim$1,
  LessSlantEqual: LessSlantEqual$1,
  LessTilde: LessTilde$1,
  lfisht: lfisht$1,
  lfloor: lfloor$1,
  Lfr: Lfr$1,
  lfr: lfr$1,
  lg: lg$1,
  lgE: lgE$1,
  lHar: lHar$1,
  lhard: lhard$1,
  lharu: lharu$1,
  lharul: lharul$1,
  lhblk: lhblk$1,
  LJcy: LJcy$1,
  ljcy: ljcy$1,
  llarr: llarr$1,
  ll: ll$1,
  Ll: Ll$1,
  llcorner: llcorner$1,
  Lleftarrow: Lleftarrow$1,
  llhard: llhard$1,
  lltri: lltri$1,
  Lmidot: Lmidot$1,
  lmidot: lmidot$1,
  lmoustache: lmoustache$1,
  lmoust: lmoust$1,
  lnap: lnap$1,
  lnapprox: lnapprox$1,
  lne: lne$1,
  lnE: lnE$1,
  lneq: lneq$1,
  lneqq: lneqq$1,
  lnsim: lnsim$1,
  loang: loang$1,
  loarr: loarr$1,
  lobrk: lobrk$1,
  longleftarrow: longleftarrow$1,
  LongLeftArrow: LongLeftArrow$1,
  Longleftarrow: Longleftarrow$1,
  longleftrightarrow: longleftrightarrow$1,
  LongLeftRightArrow: LongLeftRightArrow$1,
  Longleftrightarrow: Longleftrightarrow$1,
  longmapsto: longmapsto$1,
  longrightarrow: longrightarrow$1,
  LongRightArrow: LongRightArrow$1,
  Longrightarrow: Longrightarrow$1,
  looparrowleft: looparrowleft$1,
  looparrowright: looparrowright$1,
  lopar: lopar$1,
  Lopf: Lopf$1,
  lopf: lopf$1,
  loplus: loplus$1,
  lotimes: lotimes$1,
  lowast: lowast$1,
  lowbar: lowbar$1,
  LowerLeftArrow: LowerLeftArrow$1,
  LowerRightArrow: LowerRightArrow$1,
  loz: loz$1,
  lozenge: lozenge$1,
  lozf: lozf$1,
  lpar: lpar$1,
  lparlt: lparlt$1,
  lrarr: lrarr$1,
  lrcorner: lrcorner$1,
  lrhar: lrhar$1,
  lrhard: lrhard$1,
  lrm: lrm$1,
  lrtri: lrtri$1,
  lsaquo: lsaquo$1,
  lscr: lscr$1,
  Lscr: Lscr$1,
  lsh: lsh$1,
  Lsh: Lsh$1,
  lsim: lsim$1,
  lsime: lsime$1,
  lsimg: lsimg$1,
  lsqb: lsqb$1,
  lsquo: lsquo$1,
  lsquor: lsquor$1,
  Lstrok: Lstrok$1,
  lstrok: lstrok$1,
  ltcc: ltcc$1,
  ltcir: ltcir$1,
  lt: lt$5,
  LT: LT$3,
  Lt: Lt$1,
  ltdot: ltdot$1,
  lthree: lthree$1,
  ltimes: ltimes$1,
  ltlarr: ltlarr$1,
  ltquest: ltquest$1,
  ltri: ltri$1,
  ltrie: ltrie$1,
  ltrif: ltrif$1,
  ltrPar: ltrPar$1,
  lurdshar: lurdshar$1,
  luruhar: luruhar$1,
  lvertneqq: lvertneqq$1,
  lvnE: lvnE$1,
  macr: macr$3,
  male: male$1,
  malt: malt$1,
  maltese: maltese$1,
  "Map": "â¤…",
  map: map$1,
  mapsto: mapsto$1,
  mapstodown: mapstodown$1,
  mapstoleft: mapstoleft$1,
  mapstoup: mapstoup$1,
  marker: marker$1,
  mcomma: mcomma$1,
  Mcy: Mcy$1,
  mcy: mcy$1,
  mdash: mdash$1,
  mDDot: mDDot$1,
  measuredangle: measuredangle$1,
  MediumSpace: MediumSpace$1,
  Mellintrf: Mellintrf$1,
  Mfr: Mfr$1,
  mfr: mfr$1,
  mho: mho$1,
  micro: micro$3,
  midast: midast$1,
  midcir: midcir$1,
  mid: mid$1,
  middot: middot$3,
  minusb: minusb$1,
  minus: minus$1,
  minusd: minusd$1,
  minusdu: minusdu$1,
  MinusPlus: MinusPlus$1,
  mlcp: mlcp$1,
  mldr: mldr$1,
  mnplus: mnplus$1,
  models: models$1,
  Mopf: Mopf$1,
  mopf: mopf$1,
  mp: mp$1,
  mscr: mscr$1,
  Mscr: Mscr$1,
  mstpos: mstpos$1,
  Mu: Mu$1,
  mu: mu$1,
  multimap: multimap$1,
  mumap: mumap$1,
  nabla: nabla$1,
  Nacute: Nacute$1,
  nacute: nacute$1,
  nang: nang$1,
  nap: nap$1,
  napE: napE$1,
  napid: napid$1,
  napos: napos$1,
  napprox: napprox$1,
  natural: natural$1,
  naturals: naturals$1,
  natur: natur$1,
  nbsp: nbsp$3,
  nbump: nbump$1,
  nbumpe: nbumpe$1,
  ncap: ncap$1,
  Ncaron: Ncaron$1,
  ncaron: ncaron$1,
  Ncedil: Ncedil$1,
  ncedil: ncedil$1,
  ncong: ncong$1,
  ncongdot: ncongdot$1,
  ncup: ncup$1,
  Ncy: Ncy$1,
  ncy: ncy$1,
  ndash: ndash$1,
  nearhk: nearhk$1,
  nearr: nearr$1,
  neArr: neArr$1,
  nearrow: nearrow$1,
  ne: ne$1,
  nedot: nedot$1,
  NegativeMediumSpace: NegativeMediumSpace$1,
  NegativeThickSpace: NegativeThickSpace$1,
  NegativeThinSpace: NegativeThinSpace$1,
  NegativeVeryThinSpace: NegativeVeryThinSpace$1,
  nequiv: nequiv$1,
  nesear: nesear$1,
  nesim: nesim$1,
  NestedGreaterGreater: NestedGreaterGreater$1,
  NestedLessLess: NestedLessLess$1,
  NewLine: NewLine$1,
  nexist: nexist$1,
  nexists: nexists$1,
  Nfr: Nfr$1,
  nfr: nfr$1,
  ngE: ngE$1,
  nge: nge$1,
  ngeq: ngeq$1,
  ngeqq: ngeqq$1,
  ngeqslant: ngeqslant$1,
  nges: nges$1,
  nGg: nGg$1,
  ngsim: ngsim$1,
  nGt: nGt$1,
  ngt: ngt$1,
  ngtr: ngtr$1,
  nGtv: nGtv$1,
  nharr: nharr$1,
  nhArr: nhArr$1,
  nhpar: nhpar$1,
  ni: ni$1,
  nis: nis$1,
  nisd: nisd$1,
  niv: niv$1,
  NJcy: NJcy$1,
  njcy: njcy$1,
  nlarr: nlarr$1,
  nlArr: nlArr$1,
  nldr: nldr$1,
  nlE: nlE$1,
  nle: nle$1,
  nleftarrow: nleftarrow$1,
  nLeftarrow: nLeftarrow$1,
  nleftrightarrow: nleftrightarrow$1,
  nLeftrightarrow: nLeftrightarrow$1,
  nleq: nleq$1,
  nleqq: nleqq$1,
  nleqslant: nleqslant$1,
  nles: nles$1,
  nless: nless$1,
  nLl: nLl$1,
  nlsim: nlsim$1,
  nLt: nLt$1,
  nlt: nlt$1,
  nltri: nltri$1,
  nltrie: nltrie$1,
  nLtv: nLtv$1,
  nmid: nmid$1,
  NoBreak: NoBreak$1,
  NonBreakingSpace: NonBreakingSpace$1,
  nopf: nopf$1,
  Nopf: Nopf$1,
  Not: Not$1,
  not: not$3,
  NotCongruent: NotCongruent$1,
  NotCupCap: NotCupCap$1,
  NotDoubleVerticalBar: NotDoubleVerticalBar$1,
  NotElement: NotElement$1,
  NotEqual: NotEqual$1,
  NotEqualTilde: NotEqualTilde$1,
  NotExists: NotExists$1,
  NotGreater: NotGreater$1,
  NotGreaterEqual: NotGreaterEqual$1,
  NotGreaterFullEqual: NotGreaterFullEqual$1,
  NotGreaterGreater: NotGreaterGreater$1,
  NotGreaterLess: NotGreaterLess$1,
  NotGreaterSlantEqual: NotGreaterSlantEqual$1,
  NotGreaterTilde: NotGreaterTilde$1,
  NotHumpDownHump: NotHumpDownHump$1,
  NotHumpEqual: NotHumpEqual$1,
  notin: notin$1,
  notindot: notindot$1,
  notinE: notinE$1,
  notinva: notinva$1,
  notinvb: notinvb$1,
  notinvc: notinvc$1,
  NotLeftTriangleBar: NotLeftTriangleBar$1,
  NotLeftTriangle: NotLeftTriangle$1,
  NotLeftTriangleEqual: NotLeftTriangleEqual$1,
  NotLess: NotLess$1,
  NotLessEqual: NotLessEqual$1,
  NotLessGreater: NotLessGreater$1,
  NotLessLess: NotLessLess$1,
  NotLessSlantEqual: NotLessSlantEqual$1,
  NotLessTilde: NotLessTilde$1,
  NotNestedGreaterGreater: NotNestedGreaterGreater$1,
  NotNestedLessLess: NotNestedLessLess$1,
  notni: notni$1,
  notniva: notniva$1,
  notnivb: notnivb$1,
  notnivc: notnivc$1,
  NotPrecedes: NotPrecedes$1,
  NotPrecedesEqual: NotPrecedesEqual$1,
  NotPrecedesSlantEqual: NotPrecedesSlantEqual$1,
  NotReverseElement: NotReverseElement$1,
  NotRightTriangleBar: NotRightTriangleBar$1,
  NotRightTriangle: NotRightTriangle$1,
  NotRightTriangleEqual: NotRightTriangleEqual$1,
  NotSquareSubset: NotSquareSubset$1,
  NotSquareSubsetEqual: NotSquareSubsetEqual$1,
  NotSquareSuperset: NotSquareSuperset$1,
  NotSquareSupersetEqual: NotSquareSupersetEqual$1,
  NotSubset: NotSubset$1,
  NotSubsetEqual: NotSubsetEqual$1,
  NotSucceeds: NotSucceeds$1,
  NotSucceedsEqual: NotSucceedsEqual$1,
  NotSucceedsSlantEqual: NotSucceedsSlantEqual$1,
  NotSucceedsTilde: NotSucceedsTilde$1,
  NotSuperset: NotSuperset$1,
  NotSupersetEqual: NotSupersetEqual$1,
  NotTilde: NotTilde$1,
  NotTildeEqual: NotTildeEqual$1,
  NotTildeFullEqual: NotTildeFullEqual$1,
  NotTildeTilde: NotTildeTilde$1,
  NotVerticalBar: NotVerticalBar$1,
  nparallel: nparallel$1,
  npar: npar$1,
  nparsl: nparsl$1,
  npart: npart$1,
  npolint: npolint$1,
  npr: npr$1,
  nprcue: nprcue$1,
  nprec: nprec$1,
  npreceq: npreceq$1,
  npre: npre$1,
  nrarrc: nrarrc$1,
  nrarr: nrarr$1,
  nrArr: nrArr$1,
  nrarrw: nrarrw$1,
  nrightarrow: nrightarrow$1,
  nRightarrow: nRightarrow$1,
  nrtri: nrtri$1,
  nrtrie: nrtrie$1,
  nsc: nsc$1,
  nsccue: nsccue$1,
  nsce: nsce$1,
  Nscr: Nscr$1,
  nscr: nscr$1,
  nshortmid: nshortmid$1,
  nshortparallel: nshortparallel$1,
  nsim: nsim$1,
  nsime: nsime$1,
  nsimeq: nsimeq$1,
  nsmid: nsmid$1,
  nspar: nspar$1,
  nsqsube: nsqsube$1,
  nsqsupe: nsqsupe$1,
  nsub: nsub$1,
  nsubE: nsubE$1,
  nsube: nsube$1,
  nsubset: nsubset$1,
  nsubseteq: nsubseteq$1,
  nsubseteqq: nsubseteqq$1,
  nsucc: nsucc$1,
  nsucceq: nsucceq$1,
  nsup: nsup$1,
  nsupE: nsupE$1,
  nsupe: nsupe$1,
  nsupset: nsupset$1,
  nsupseteq: nsupseteq$1,
  nsupseteqq: nsupseteqq$1,
  ntgl: ntgl$1,
  Ntilde: Ntilde$3,
  ntilde: ntilde$3,
  ntlg: ntlg$1,
  ntriangleleft: ntriangleleft$1,
  ntrianglelefteq: ntrianglelefteq$1,
  ntriangleright: ntriangleright$1,
  ntrianglerighteq: ntrianglerighteq$1,
  Nu: Nu$1,
  nu: nu$1,
  num: num$1,
  numero: numero$1,
  numsp: numsp$1,
  nvap: nvap$1,
  nvdash: nvdash$1,
  nvDash: nvDash$1,
  nVdash: nVdash$1,
  nVDash: nVDash$1,
  nvge: nvge$1,
  nvgt: nvgt$1,
  nvHarr: nvHarr$1,
  nvinfin: nvinfin$1,
  nvlArr: nvlArr$1,
  nvle: nvle$1,
  nvlt: nvlt$1,
  nvltrie: nvltrie$1,
  nvrArr: nvrArr$1,
  nvrtrie: nvrtrie$1,
  nvsim: nvsim$1,
  nwarhk: nwarhk$1,
  nwarr: nwarr$1,
  nwArr: nwArr$1,
  nwarrow: nwarrow$1,
  nwnear: nwnear$1,
  Oacute: Oacute$3,
  oacute: oacute$3,
  oast: oast$1,
  Ocirc: Ocirc$3,
  ocirc: ocirc$3,
  ocir: ocir$1,
  Ocy: Ocy$1,
  ocy: ocy$1,
  odash: odash$1,
  Odblac: Odblac$1,
  odblac: odblac$1,
  odiv: odiv$1,
  odot: odot$1,
  odsold: odsold$1,
  OElig: OElig$1,
  oelig: oelig$1,
  ofcir: ofcir$1,
  Ofr: Ofr$1,
  ofr: ofr$1,
  ogon: ogon$1,
  Ograve: Ograve$3,
  ograve: ograve$3,
  ogt: ogt$1,
  ohbar: ohbar$1,
  ohm: ohm$1,
  oint: oint$1,
  olarr: olarr$1,
  olcir: olcir$1,
  olcross: olcross$1,
  oline: oline$1,
  olt: olt$1,
  Omacr: Omacr$1,
  omacr: omacr$1,
  Omega: Omega$1,
  omega: omega$1,
  Omicron: Omicron$1,
  omicron: omicron$1,
  omid: omid$1,
  ominus: ominus$1,
  Oopf: Oopf$1,
  oopf: oopf$1,
  opar: opar$1,
  OpenCurlyDoubleQuote: OpenCurlyDoubleQuote$1,
  OpenCurlyQuote: OpenCurlyQuote$1,
  operp: operp$1,
  oplus: oplus$1,
  orarr: orarr$1,
  Or: Or$1,
  or: or$1,
  ord: ord$1,
  order: order$1,
  orderof: orderof$1,
  ordf: ordf$3,
  ordm: ordm$3,
  origof: origof$1,
  oror: oror$1,
  orslope: orslope$1,
  orv: orv$1,
  oS: oS$1,
  Oscr: Oscr$1,
  oscr: oscr$1,
  Oslash: Oslash$3,
  oslash: oslash$3,
  osol: osol$1,
  Otilde: Otilde$3,
  otilde: otilde$3,
  otimesas: otimesas$1,
  Otimes: Otimes$1,
  otimes: otimes$1,
  Ouml: Ouml$3,
  ouml: ouml$3,
  ovbar: ovbar$1,
  OverBar: OverBar$1,
  OverBrace: OverBrace$1,
  OverBracket: OverBracket$1,
  OverParenthesis: OverParenthesis$1,
  para: para$3,
  parallel: parallel$1,
  par: par$1,
  parsim: parsim$1,
  parsl: parsl$1,
  part: part$1,
  PartialD: PartialD$1,
  Pcy: Pcy$1,
  pcy: pcy$1,
  percnt: percnt$1,
  period: period$1,
  permil: permil$1,
  perp: perp$1,
  pertenk: pertenk$1,
  Pfr: Pfr$1,
  pfr: pfr$1,
  Phi: Phi$1,
  phi: phi$1,
  phiv: phiv$1,
  phmmat: phmmat$1,
  phone: phone$1,
  Pi: Pi$1,
  pi: pi$1,
  pitchfork: pitchfork$1,
  piv: piv$1,
  planck: planck$1,
  planckh: planckh$1,
  plankv: plankv$1,
  plusacir: plusacir$1,
  plusb: plusb$1,
  pluscir: pluscir$1,
  plus: plus$1,
  plusdo: plusdo$1,
  plusdu: plusdu$1,
  pluse: pluse$1,
  PlusMinus: PlusMinus$1,
  plusmn: plusmn$3,
  plussim: plussim$1,
  plustwo: plustwo$1,
  pm: pm$1,
  Poincareplane: Poincareplane$1,
  pointint: pointint$1,
  popf: popf$1,
  Popf: Popf$1,
  pound: pound$3,
  prap: prap$1,
  Pr: Pr$1,
  pr: pr$1,
  prcue: prcue$1,
  precapprox: precapprox$1,
  prec: prec$1,
  preccurlyeq: preccurlyeq$1,
  Precedes: Precedes$1,
  PrecedesEqual: PrecedesEqual$1,
  PrecedesSlantEqual: PrecedesSlantEqual$1,
  PrecedesTilde: PrecedesTilde$1,
  preceq: preceq$1,
  precnapprox: precnapprox$1,
  precneqq: precneqq$1,
  precnsim: precnsim$1,
  pre: pre$1,
  prE: prE$1,
  precsim: precsim$1,
  prime: prime$1,
  Prime: Prime$1,
  primes: primes$1,
  prnap: prnap$1,
  prnE: prnE$1,
  prnsim: prnsim$1,
  prod: prod$1,
  Product: Product$1,
  profalar: profalar$1,
  profline: profline$1,
  profsurf: profsurf$1,
  prop: prop$1,
  Proportional: Proportional$1,
  Proportion: Proportion$1,
  propto: propto$1,
  prsim: prsim$1,
  prurel: prurel$1,
  Pscr: Pscr$1,
  pscr: pscr$1,
  Psi: Psi$1,
  psi: psi$1,
  puncsp: puncsp$1,
  Qfr: Qfr$1,
  qfr: qfr$1,
  qint: qint$1,
  qopf: qopf$1,
  Qopf: Qopf$1,
  qprime: qprime$1,
  Qscr: Qscr$1,
  qscr: qscr$1,
  quaternions: quaternions$1,
  quatint: quatint$1,
  quest: quest$1,
  questeq: questeq$1,
  quot: quot$5,
  QUOT: QUOT$3,
  rAarr: rAarr$1,
  race: race$1,
  Racute: Racute$1,
  racute: racute$1,
  radic: radic$1,
  raemptyv: raemptyv$1,
  rang: rang$1,
  Rang: Rang$1,
  rangd: rangd$1,
  range: range$1,
  rangle: rangle$1,
  raquo: raquo$3,
  rarrap: rarrap$1,
  rarrb: rarrb$1,
  rarrbfs: rarrbfs$1,
  rarrc: rarrc$1,
  rarr: rarr$1,
  Rarr: Rarr$1,
  rArr: rArr$1,
  rarrfs: rarrfs$1,
  rarrhk: rarrhk$1,
  rarrlp: rarrlp$1,
  rarrpl: rarrpl$1,
  rarrsim: rarrsim$1,
  Rarrtl: Rarrtl$1,
  rarrtl: rarrtl$1,
  rarrw: rarrw$1,
  ratail: ratail$1,
  rAtail: rAtail$1,
  ratio: ratio$1,
  rationals: rationals$1,
  rbarr: rbarr$1,
  rBarr: rBarr$1,
  RBarr: RBarr$1,
  rbbrk: rbbrk$1,
  rbrace: rbrace$1,
  rbrack: rbrack$1,
  rbrke: rbrke$1,
  rbrksld: rbrksld$1,
  rbrkslu: rbrkslu$1,
  Rcaron: Rcaron$1,
  rcaron: rcaron$1,
  Rcedil: Rcedil$1,
  rcedil: rcedil$1,
  rceil: rceil$1,
  rcub: rcub$1,
  Rcy: Rcy$1,
  rcy: rcy$1,
  rdca: rdca$1,
  rdldhar: rdldhar$1,
  rdquo: rdquo$1,
  rdquor: rdquor$1,
  rdsh: rdsh$1,
  real: real$1,
  realine: realine$1,
  realpart: realpart$1,
  reals: reals$1,
  Re: Re$1,
  rect: rect$1,
  reg: reg$3,
  REG: REG$3,
  ReverseElement: ReverseElement$1,
  ReverseEquilibrium: ReverseEquilibrium$1,
  ReverseUpEquilibrium: ReverseUpEquilibrium$1,
  rfisht: rfisht$1,
  rfloor: rfloor$1,
  rfr: rfr$1,
  Rfr: Rfr$1,
  rHar: rHar$1,
  rhard: rhard$1,
  rharu: rharu$1,
  rharul: rharul$1,
  Rho: Rho$1,
  rho: rho$1,
  rhov: rhov$1,
  RightAngleBracket: RightAngleBracket$1,
  RightArrowBar: RightArrowBar$1,
  rightarrow: rightarrow$1,
  RightArrow: RightArrow$1,
  Rightarrow: Rightarrow$1,
  RightArrowLeftArrow: RightArrowLeftArrow$1,
  rightarrowtail: rightarrowtail$1,
  RightCeiling: RightCeiling$1,
  RightDoubleBracket: RightDoubleBracket$1,
  RightDownTeeVector: RightDownTeeVector$1,
  RightDownVectorBar: RightDownVectorBar$1,
  RightDownVector: RightDownVector$1,
  RightFloor: RightFloor$1,
  rightharpoondown: rightharpoondown$1,
  rightharpoonup: rightharpoonup$1,
  rightleftarrows: rightleftarrows$1,
  rightleftharpoons: rightleftharpoons$1,
  rightrightarrows: rightrightarrows$1,
  rightsquigarrow: rightsquigarrow$1,
  RightTeeArrow: RightTeeArrow$1,
  RightTee: RightTee$1,
  RightTeeVector: RightTeeVector$1,
  rightthreetimes: rightthreetimes$1,
  RightTriangleBar: RightTriangleBar$1,
  RightTriangle: RightTriangle$1,
  RightTriangleEqual: RightTriangleEqual$1,
  RightUpDownVector: RightUpDownVector$1,
  RightUpTeeVector: RightUpTeeVector$1,
  RightUpVectorBar: RightUpVectorBar$1,
  RightUpVector: RightUpVector$1,
  RightVectorBar: RightVectorBar$1,
  RightVector: RightVector$1,
  ring: ring$1,
  risingdotseq: risingdotseq$1,
  rlarr: rlarr$1,
  rlhar: rlhar$1,
  rlm: rlm$1,
  rmoustache: rmoustache$1,
  rmoust: rmoust$1,
  rnmid: rnmid$1,
  roang: roang$1,
  roarr: roarr$1,
  robrk: robrk$1,
  ropar: ropar$1,
  ropf: ropf$1,
  Ropf: Ropf$1,
  roplus: roplus$1,
  rotimes: rotimes$1,
  RoundImplies: RoundImplies$1,
  rpar: rpar$1,
  rpargt: rpargt$1,
  rppolint: rppolint$1,
  rrarr: rrarr$1,
  Rrightarrow: Rrightarrow$1,
  rsaquo: rsaquo$1,
  rscr: rscr$1,
  Rscr: Rscr$1,
  rsh: rsh$1,
  Rsh: Rsh$1,
  rsqb: rsqb$1,
  rsquo: rsquo$1,
  rsquor: rsquor$1,
  rthree: rthree$1,
  rtimes: rtimes$1,
  rtri: rtri$1,
  rtrie: rtrie$1,
  rtrif: rtrif$1,
  rtriltri: rtriltri$1,
  RuleDelayed: RuleDelayed$1,
  ruluhar: ruluhar$1,
  rx: rx$1,
  Sacute: Sacute$1,
  sacute: sacute$1,
  sbquo: sbquo$1,
  scap: scap$1,
  Scaron: Scaron$1,
  scaron: scaron$1,
  Sc: Sc$1,
  sc: sc$1,
  sccue: sccue$1,
  sce: sce$1,
  scE: scE$1,
  Scedil: Scedil$1,
  scedil: scedil$1,
  Scirc: Scirc$1,
  scirc: scirc$1,
  scnap: scnap$1,
  scnE: scnE$1,
  scnsim: scnsim$1,
  scpolint: scpolint$1,
  scsim: scsim$1,
  Scy: Scy$1,
  scy: scy$1,
  sdotb: sdotb$1,
  sdot: sdot$1,
  sdote: sdote$1,
  searhk: searhk$1,
  searr: searr$1,
  seArr: seArr$1,
  searrow: searrow$1,
  sect: sect$3,
  semi: semi$1,
  seswar: seswar$1,
  setminus: setminus$1,
  setmn: setmn$1,
  sext: sext$1,
  Sfr: Sfr$1,
  sfr: sfr$1,
  sfrown: sfrown$1,
  sharp: sharp$1,
  SHCHcy: SHCHcy$1,
  shchcy: shchcy$1,
  SHcy: SHcy$1,
  shcy: shcy$1,
  ShortDownArrow: ShortDownArrow$1,
  ShortLeftArrow: ShortLeftArrow$1,
  shortmid: shortmid$1,
  shortparallel: shortparallel$1,
  ShortRightArrow: ShortRightArrow$1,
  ShortUpArrow: ShortUpArrow$1,
  shy: shy$3,
  Sigma: Sigma$1,
  sigma: sigma$1,
  sigmaf: sigmaf$1,
  sigmav: sigmav$1,
  sim: sim$1,
  simdot: simdot$1,
  sime: sime$1,
  simeq: simeq$1,
  simg: simg$1,
  simgE: simgE$1,
  siml: siml$1,
  simlE: simlE$1,
  simne: simne$1,
  simplus: simplus$1,
  simrarr: simrarr$1,
  slarr: slarr$1,
  SmallCircle: SmallCircle$1,
  smallsetminus: smallsetminus$1,
  smashp: smashp$1,
  smeparsl: smeparsl$1,
  smid: smid$1,
  smile: smile$1,
  smt: smt$1,
  smte: smte$1,
  smtes: smtes$1,
  SOFTcy: SOFTcy$1,
  softcy: softcy$1,
  solbar: solbar$1,
  solb: solb$1,
  sol: sol$1,
  Sopf: Sopf$1,
  sopf: sopf$1,
  spades: spades$1,
  spadesuit: spadesuit$1,
  spar: spar$1,
  sqcap: sqcap$1,
  sqcaps: sqcaps$1,
  sqcup: sqcup$1,
  sqcups: sqcups$1,
  Sqrt: Sqrt$1,
  sqsub: sqsub$1,
  sqsube: sqsube$1,
  sqsubset: sqsubset$1,
  sqsubseteq: sqsubseteq$1,
  sqsup: sqsup$1,
  sqsupe: sqsupe$1,
  sqsupset: sqsupset$1,
  sqsupseteq: sqsupseteq$1,
  square: square$1,
  Square: Square$1,
  SquareIntersection: SquareIntersection$1,
  SquareSubset: SquareSubset$1,
  SquareSubsetEqual: SquareSubsetEqual$1,
  SquareSuperset: SquareSuperset$1,
  SquareSupersetEqual: SquareSupersetEqual$1,
  SquareUnion: SquareUnion$1,
  squarf: squarf$1,
  squ: squ$1,
  squf: squf$1,
  srarr: srarr$1,
  Sscr: Sscr$1,
  sscr: sscr$1,
  ssetmn: ssetmn$1,
  ssmile: ssmile$1,
  sstarf: sstarf$1,
  Star: Star$1,
  star: star$1,
  starf: starf$1,
  straightepsilon: straightepsilon$1,
  straightphi: straightphi$1,
  strns: strns$1,
  sub: sub$1,
  Sub: Sub$1,
  subdot: subdot$1,
  subE: subE$1,
  sube: sube$1,
  subedot: subedot$1,
  submult: submult$1,
  subnE: subnE$1,
  subne: subne$1,
  subplus: subplus$1,
  subrarr: subrarr$1,
  subset: subset$1,
  Subset: Subset$1,
  subseteq: subseteq$1,
  subseteqq: subseteqq$1,
  SubsetEqual: SubsetEqual$1,
  subsetneq: subsetneq$1,
  subsetneqq: subsetneqq$1,
  subsim: subsim$1,
  subsub: subsub$1,
  subsup: subsup$1,
  succapprox: succapprox$1,
  succ: succ$1,
  succcurlyeq: succcurlyeq$1,
  Succeeds: Succeeds$1,
  SucceedsEqual: SucceedsEqual$1,
  SucceedsSlantEqual: SucceedsSlantEqual$1,
  SucceedsTilde: SucceedsTilde$1,
  succeq: succeq$1,
  succnapprox: succnapprox$1,
  succneqq: succneqq$1,
  succnsim: succnsim$1,
  succsim: succsim$1,
  SuchThat: SuchThat$1,
  sum: sum$1,
  Sum: Sum$1,
  sung: sung$1,
  sup1: sup1$3,
  sup2: sup2$3,
  sup3: sup3$3,
  sup: sup$1,
  Sup: Sup$1,
  supdot: supdot$1,
  supdsub: supdsub$1,
  supE: supE$1,
  supe: supe$1,
  supedot: supedot$1,
  Superset: Superset$1,
  SupersetEqual: SupersetEqual$1,
  suphsol: suphsol$1,
  suphsub: suphsub$1,
  suplarr: suplarr$1,
  supmult: supmult$1,
  supnE: supnE$1,
  supne: supne$1,
  supplus: supplus$1,
  supset: supset$1,
  Supset: Supset$1,
  supseteq: supseteq$1,
  supseteqq: supseteqq$1,
  supsetneq: supsetneq$1,
  supsetneqq: supsetneqq$1,
  supsim: supsim$1,
  supsub: supsub$1,
  supsup: supsup$1,
  swarhk: swarhk$1,
  swarr: swarr$1,
  swArr: swArr$1,
  swarrow: swarrow$1,
  swnwar: swnwar$1,
  szlig: szlig$3,
  Tab: Tab$1,
  target: target$1,
  Tau: Tau$1,
  tau: tau$1,
  tbrk: tbrk$1,
  Tcaron: Tcaron$1,
  tcaron: tcaron$1,
  Tcedil: Tcedil$1,
  tcedil: tcedil$1,
  Tcy: Tcy$1,
  tcy: tcy$1,
  tdot: tdot$1,
  telrec: telrec$1,
  Tfr: Tfr$1,
  tfr: tfr$1,
  there4: there4$1,
  therefore: therefore$1,
  Therefore: Therefore$1,
  Theta: Theta$1,
  theta: theta$1,
  thetasym: thetasym$1,
  thetav: thetav$1,
  thickapprox: thickapprox$1,
  thicksim: thicksim$1,
  ThickSpace: ThickSpace$1,
  ThinSpace: ThinSpace$1,
  thinsp: thinsp$1,
  thkap: thkap$1,
  thksim: thksim$1,
  THORN: THORN$3,
  thorn: thorn$3,
  tilde: tilde$1,
  Tilde: Tilde$1,
  TildeEqual: TildeEqual$1,
  TildeFullEqual: TildeFullEqual$1,
  TildeTilde: TildeTilde$1,
  timesbar: timesbar$1,
  timesb: timesb$1,
  times: times$3,
  timesd: timesd$1,
  tint: tint$1,
  toea: toea$1,
  topbot: topbot$1,
  topcir: topcir$1,
  top: top$1,
  Topf: Topf$1,
  topf: topf$1,
  topfork: topfork$1,
  tosa: tosa$1,
  tprime: tprime$1,
  trade: trade$1,
  TRADE: TRADE$1,
  triangle: triangle$1,
  triangledown: triangledown$1,
  triangleleft: triangleleft$1,
  trianglelefteq: trianglelefteq$1,
  triangleq: triangleq$1,
  triangleright: triangleright$1,
  trianglerighteq: trianglerighteq$1,
  tridot: tridot$1,
  trie: trie$1,
  triminus: triminus$1,
  TripleDot: TripleDot$1,
  triplus: triplus$1,
  trisb: trisb$1,
  tritime: tritime$1,
  trpezium: trpezium$1,
  Tscr: Tscr$1,
  tscr: tscr$1,
  TScy: TScy$1,
  tscy: tscy$1,
  TSHcy: TSHcy$1,
  tshcy: tshcy$1,
  Tstrok: Tstrok$1,
  tstrok: tstrok$1,
  twixt: twixt$1,
  twoheadleftarrow: twoheadleftarrow$1,
  twoheadrightarrow: twoheadrightarrow$1,
  Uacute: Uacute$3,
  uacute: uacute$3,
  uarr: uarr$1,
  Uarr: Uarr$1,
  uArr: uArr$1,
  Uarrocir: Uarrocir$1,
  Ubrcy: Ubrcy$1,
  ubrcy: ubrcy$1,
  Ubreve: Ubreve$1,
  ubreve: ubreve$1,
  Ucirc: Ucirc$3,
  ucirc: ucirc$3,
  Ucy: Ucy$1,
  ucy: ucy$1,
  udarr: udarr$1,
  Udblac: Udblac$1,
  udblac: udblac$1,
  udhar: udhar$1,
  ufisht: ufisht$1,
  Ufr: Ufr$1,
  ufr: ufr$1,
  Ugrave: Ugrave$3,
  ugrave: ugrave$3,
  uHar: uHar$1,
  uharl: uharl$1,
  uharr: uharr$1,
  uhblk: uhblk$1,
  ulcorn: ulcorn$1,
  ulcorner: ulcorner$1,
  ulcrop: ulcrop$1,
  ultri: ultri$1,
  Umacr: Umacr$1,
  umacr: umacr$1,
  uml: uml$3,
  UnderBar: UnderBar$1,
  UnderBrace: UnderBrace$1,
  UnderBracket: UnderBracket$1,
  UnderParenthesis: UnderParenthesis$1,
  Union: Union$1,
  UnionPlus: UnionPlus$1,
  Uogon: Uogon$1,
  uogon: uogon$1,
  Uopf: Uopf$1,
  uopf: uopf$1,
  UpArrowBar: UpArrowBar$1,
  uparrow: uparrow$1,
  UpArrow: UpArrow$1,
  Uparrow: Uparrow$1,
  UpArrowDownArrow: UpArrowDownArrow$1,
  updownarrow: updownarrow$1,
  UpDownArrow: UpDownArrow$1,
  Updownarrow: Updownarrow$1,
  UpEquilibrium: UpEquilibrium$1,
  upharpoonleft: upharpoonleft$1,
  upharpoonright: upharpoonright$1,
  uplus: uplus$1,
  UpperLeftArrow: UpperLeftArrow$1,
  UpperRightArrow: UpperRightArrow$1,
  upsi: upsi$1,
  Upsi: Upsi$1,
  upsih: upsih$1,
  Upsilon: Upsilon$1,
  upsilon: upsilon$1,
  UpTeeArrow: UpTeeArrow$1,
  UpTee: UpTee$1,
  upuparrows: upuparrows$1,
  urcorn: urcorn$1,
  urcorner: urcorner$1,
  urcrop: urcrop$1,
  Uring: Uring$1,
  uring: uring$1,
  urtri: urtri$1,
  Uscr: Uscr$1,
  uscr: uscr$1,
  utdot: utdot$1,
  Utilde: Utilde$1,
  utilde: utilde$1,
  utri: utri$1,
  utrif: utrif$1,
  uuarr: uuarr$1,
  Uuml: Uuml$3,
  uuml: uuml$3,
  uwangle: uwangle$1,
  vangrt: vangrt$1,
  varepsilon: varepsilon$1,
  varkappa: varkappa$1,
  varnothing: varnothing$1,
  varphi: varphi$1,
  varpi: varpi$1,
  varpropto: varpropto$1,
  varr: varr$1,
  vArr: vArr$1,
  varrho: varrho$1,
  varsigma: varsigma$1,
  varsubsetneq: varsubsetneq$1,
  varsubsetneqq: varsubsetneqq$1,
  varsupsetneq: varsupsetneq$1,
  varsupsetneqq: varsupsetneqq$1,
  vartheta: vartheta$1,
  vartriangleleft: vartriangleleft$1,
  vartriangleright: vartriangleright$1,
  vBar: vBar$1,
  Vbar: Vbar$1,
  vBarv: vBarv$1,
  Vcy: Vcy$1,
  vcy: vcy$1,
  vdash: vdash$1,
  vDash: vDash$1,
  Vdash: Vdash$1,
  VDash: VDash$1,
  Vdashl: Vdashl$1,
  veebar: veebar$1,
  vee: vee$1,
  Vee: Vee$1,
  veeeq: veeeq$1,
  vellip: vellip$1,
  verbar: verbar$1,
  Verbar: Verbar$1,
  vert: vert$1,
  Vert: Vert$1,
  VerticalBar: VerticalBar$1,
  VerticalLine: VerticalLine$1,
  VerticalSeparator: VerticalSeparator$1,
  VerticalTilde: VerticalTilde$1,
  VeryThinSpace: VeryThinSpace$1,
  Vfr: Vfr$1,
  vfr: vfr$1,
  vltri: vltri$1,
  vnsub: vnsub$1,
  vnsup: vnsup$1,
  Vopf: Vopf$1,
  vopf: vopf$1,
  vprop: vprop$1,
  vrtri: vrtri$1,
  Vscr: Vscr$1,
  vscr: vscr$1,
  vsubnE: vsubnE$1,
  vsubne: vsubne$1,
  vsupnE: vsupnE$1,
  vsupne: vsupne$1,
  Vvdash: Vvdash$1,
  vzigzag: vzigzag$1,
  Wcirc: Wcirc$1,
  wcirc: wcirc$1,
  wedbar: wedbar$1,
  wedge: wedge$1,
  Wedge: Wedge$1,
  wedgeq: wedgeq$1,
  weierp: weierp$1,
  Wfr: Wfr$1,
  wfr: wfr$1,
  Wopf: Wopf$1,
  wopf: wopf$1,
  wp: wp$1,
  wr: wr$1,
  wreath: wreath$1,
  Wscr: Wscr$1,
  wscr: wscr$1,
  xcap: xcap$1,
  xcirc: xcirc$1,
  xcup: xcup$1,
  xdtri: xdtri$1,
  Xfr: Xfr$1,
  xfr: xfr$1,
  xharr: xharr$1,
  xhArr: xhArr$1,
  Xi: Xi$1,
  xi: xi$1,
  xlarr: xlarr$1,
  xlArr: xlArr$1,
  xmap: xmap$1,
  xnis: xnis$1,
  xodot: xodot$1,
  Xopf: Xopf$1,
  xopf: xopf$1,
  xoplus: xoplus$1,
  xotime: xotime$1,
  xrarr: xrarr$1,
  xrArr: xrArr$1,
  Xscr: Xscr$1,
  xscr: xscr$1,
  xsqcup: xsqcup$1,
  xuplus: xuplus$1,
  xutri: xutri$1,
  xvee: xvee$1,
  xwedge: xwedge$1,
  Yacute: Yacute$3,
  yacute: yacute$3,
  YAcy: YAcy$1,
  yacy: yacy$1,
  Ycirc: Ycirc$1,
  ycirc: ycirc$1,
  Ycy: Ycy$1,
  ycy: ycy$1,
  yen: yen$3,
  Yfr: Yfr$1,
  yfr: yfr$1,
  YIcy: YIcy$1,
  yicy: yicy$1,
  Yopf: Yopf$1,
  yopf: yopf$1,
  Yscr: Yscr$1,
  yscr: yscr$1,
  YUcy: YUcy$1,
  yucy: yucy$1,
  yuml: yuml$3,
  Yuml: Yuml$1,
  Zacute: Zacute$1,
  zacute: zacute$1,
  Zcaron: Zcaron$1,
  zcaron: zcaron$1,
  Zcy: Zcy$1,
  zcy: zcy$1,
  Zdot: Zdot$1,
  zdot: zdot$1,
  zeetrf: zeetrf$1,
  ZeroWidthSpace: ZeroWidthSpace$1,
  Zeta: Zeta$1,
  zeta: zeta$1,
  zfr: zfr$1,
  Zfr: Zfr$1,
  ZHcy: ZHcy$1,
  zhcy: zhcy$1,
  zigrarr: zigrarr$1,
  zopf: zopf$1,
  Zopf: Zopf$1,
  Zscr: Zscr$1,
  zscr: zscr$1,
  zwj: zwj$1,
  zwnj: zwnj$1
};
const Aacute$2 = "Ã";
const aacute$2 = "Ã¡";
const Acirc$2 = "Ã‚";
const acirc$2 = "Ã¢";
const acute$2 = "Â´";
const AElig$2 = "Ã†";
const aelig$2 = "Ã¦";
const Agrave$2 = "Ã€";
const agrave$2 = "Ã ";
const amp$4 = "&";
const AMP$2 = "&";
const Aring$2 = "Ã…";
const aring$2 = "Ã¥";
const Atilde$2 = "Ãƒ";
const atilde$2 = "Ã£";
const Auml$2 = "Ã„";
const auml$2 = "Ã¤";
const brvbar$2 = "Â¦";
const Ccedil$2 = "Ã‡";
const ccedil$2 = "Ã§";
const cedil$2 = "Â¸";
const cent$2 = "Â¢";
const copy$2 = "Â©";
const COPY$2 = "Â©";
const curren$2 = "Â¤";
const deg$2 = "Â°";
const divide$2 = "Ã·";
const Eacute$2 = "Ã‰";
const eacute$2 = "Ã©";
const Ecirc$2 = "ÃŠ";
const ecirc$2 = "Ãª";
const Egrave$2 = "Ãˆ";
const egrave$2 = "Ã¨";
const ETH$2 = "Ã";
const eth$2 = "Ã°";
const Euml$2 = "Ã‹";
const euml$2 = "Ã«";
const frac12$2 = "Â½";
const frac14$2 = "Â¼";
const frac34$2 = "Â¾";
const gt$4 = ">";
const GT$2 = ">";
const Iacute$2 = "Ã";
const iacute$2 = "Ã­";
const Icirc$2 = "ÃŽ";
const icirc$2 = "Ã®";
const iexcl$2 = "Â¡";
const Igrave$2 = "ÃŒ";
const igrave$2 = "Ã¬";
const iquest$2 = "Â¿";
const Iuml$2 = "Ã";
const iuml$2 = "Ã¯";
const laquo$2 = "Â«";
const lt$4 = "<";
const LT$2 = "<";
const macr$2 = "Â¯";
const micro$2 = "Âµ";
const middot$2 = "Â·";
const nbsp$2 = "Â ";
const not$2 = "Â¬";
const Ntilde$2 = "Ã‘";
const ntilde$2 = "Ã±";
const Oacute$2 = "Ã“";
const oacute$2 = "Ã³";
const Ocirc$2 = "Ã”";
const ocirc$2 = "Ã´";
const Ograve$2 = "Ã’";
const ograve$2 = "Ã²";
const ordf$2 = "Âª";
const ordm$2 = "Âº";
const Oslash$2 = "Ã˜";
const oslash$2 = "Ã¸";
const Otilde$2 = "Ã•";
const otilde$2 = "Ãµ";
const Ouml$2 = "Ã–";
const ouml$2 = "Ã¶";
const para$2 = "Â¶";
const plusmn$2 = "Â±";
const pound$2 = "Â£";
const quot$4 = '"';
const QUOT$2 = '"';
const raquo$2 = "Â»";
const reg$2 = "Â®";
const REG$2 = "Â®";
const sect$2 = "Â§";
const shy$2 = "Â­";
const sup1$2 = "Â¹";
const sup2$2 = "Â²";
const sup3$2 = "Â³";
const szlig$2 = "ÃŸ";
const THORN$2 = "Ãž";
const thorn$2 = "Ã¾";
const times$2 = "Ã—";
const Uacute$2 = "Ãš";
const uacute$2 = "Ãº";
const Ucirc$2 = "Ã›";
const ucirc$2 = "Ã»";
const Ugrave$2 = "Ã™";
const ugrave$2 = "Ã¹";
const uml$2 = "Â¨";
const Uuml$2 = "Ãœ";
const uuml$2 = "Ã¼";
const Yacute$2 = "Ã";
const yacute$2 = "Ã½";
const yen$2 = "Â¥";
const yuml$2 = "Ã¿";
const require$$2$2 = {
  Aacute: Aacute$2,
  aacute: aacute$2,
  Acirc: Acirc$2,
  acirc: acirc$2,
  acute: acute$2,
  AElig: AElig$2,
  aelig: aelig$2,
  Agrave: Agrave$2,
  agrave: agrave$2,
  amp: amp$4,
  AMP: AMP$2,
  Aring: Aring$2,
  aring: aring$2,
  Atilde: Atilde$2,
  atilde: atilde$2,
  Auml: Auml$2,
  auml: auml$2,
  brvbar: brvbar$2,
  Ccedil: Ccedil$2,
  ccedil: ccedil$2,
  cedil: cedil$2,
  cent: cent$2,
  copy: copy$2,
  COPY: COPY$2,
  curren: curren$2,
  deg: deg$2,
  divide: divide$2,
  Eacute: Eacute$2,
  eacute: eacute$2,
  Ecirc: Ecirc$2,
  ecirc: ecirc$2,
  Egrave: Egrave$2,
  egrave: egrave$2,
  ETH: ETH$2,
  eth: eth$2,
  Euml: Euml$2,
  euml: euml$2,
  frac12: frac12$2,
  frac14: frac14$2,
  frac34: frac34$2,
  gt: gt$4,
  GT: GT$2,
  Iacute: Iacute$2,
  iacute: iacute$2,
  Icirc: Icirc$2,
  icirc: icirc$2,
  iexcl: iexcl$2,
  Igrave: Igrave$2,
  igrave: igrave$2,
  iquest: iquest$2,
  Iuml: Iuml$2,
  iuml: iuml$2,
  laquo: laquo$2,
  lt: lt$4,
  LT: LT$2,
  macr: macr$2,
  micro: micro$2,
  middot: middot$2,
  nbsp: nbsp$2,
  not: not$2,
  Ntilde: Ntilde$2,
  ntilde: ntilde$2,
  Oacute: Oacute$2,
  oacute: oacute$2,
  Ocirc: Ocirc$2,
  ocirc: ocirc$2,
  Ograve: Ograve$2,
  ograve: ograve$2,
  ordf: ordf$2,
  ordm: ordm$2,
  Oslash: Oslash$2,
  oslash: oslash$2,
  Otilde: Otilde$2,
  otilde: otilde$2,
  Ouml: Ouml$2,
  ouml: ouml$2,
  para: para$2,
  plusmn: plusmn$2,
  pound: pound$2,
  quot: quot$4,
  QUOT: QUOT$2,
  raquo: raquo$2,
  reg: reg$2,
  REG: REG$2,
  sect: sect$2,
  shy: shy$2,
  sup1: sup1$2,
  sup2: sup2$2,
  sup3: sup3$2,
  szlig: szlig$2,
  THORN: THORN$2,
  thorn: thorn$2,
  times: times$2,
  Uacute: Uacute$2,
  uacute: uacute$2,
  Ucirc: Ucirc$2,
  ucirc: ucirc$2,
  Ugrave: Ugrave$2,
  ugrave: ugrave$2,
  uml: uml$2,
  Uuml: Uuml$2,
  uuml: uuml$2,
  Yacute: Yacute$2,
  yacute: yacute$2,
  yen: yen$2,
  yuml: yuml$2
};
const amp$3 = "&";
const apos$2 = "'";
const gt$3 = ">";
const lt$3 = "<";
const quot$3 = '"';
const require$$3 = {
  amp: amp$3,
  apos: apos$2,
  gt: gt$3,
  lt: lt$3,
  quot: quot$3
};
var Tokenizer_1;
var hasRequiredTokenizer;
function requireTokenizer() {
  if (hasRequiredTokenizer) return Tokenizer_1;
  hasRequiredTokenizer = 1;
  Tokenizer_1 = Tokenizer;
  var decodeCodePoint = requireDecode_codepoint$1();
  var entityMap = require$$1$2;
  var legacyMap = require$$2$2;
  var xmlMap = require$$3;
  var i = 0;
  var TEXT = i++;
  var BEFORE_TAG_NAME = i++;
  var IN_TAG_NAME = i++;
  var IN_SELF_CLOSING_TAG = i++;
  var BEFORE_CLOSING_TAG_NAME = i++;
  var IN_CLOSING_TAG_NAME = i++;
  var AFTER_CLOSING_TAG_NAME = i++;
  var BEFORE_ATTRIBUTE_NAME = i++;
  var IN_ATTRIBUTE_NAME = i++;
  var AFTER_ATTRIBUTE_NAME = i++;
  var BEFORE_ATTRIBUTE_VALUE = i++;
  var IN_ATTRIBUTE_VALUE_DQ = i++;
  var IN_ATTRIBUTE_VALUE_SQ = i++;
  var IN_ATTRIBUTE_VALUE_NQ = i++;
  var BEFORE_DECLARATION = i++;
  var IN_DECLARATION = i++;
  var IN_PROCESSING_INSTRUCTION = i++;
  var BEFORE_COMMENT = i++;
  var IN_COMMENT = i++;
  var AFTER_COMMENT_1 = i++;
  var AFTER_COMMENT_2 = i++;
  var BEFORE_CDATA_1 = i++;
  var BEFORE_CDATA_2 = i++;
  var BEFORE_CDATA_3 = i++;
  var BEFORE_CDATA_4 = i++;
  var BEFORE_CDATA_5 = i++;
  var BEFORE_CDATA_6 = i++;
  var IN_CDATA = i++;
  var AFTER_CDATA_1 = i++;
  var AFTER_CDATA_2 = i++;
  var BEFORE_SPECIAL = i++;
  var BEFORE_SPECIAL_END = i++;
  var BEFORE_SCRIPT_1 = i++;
  var BEFORE_SCRIPT_2 = i++;
  var BEFORE_SCRIPT_3 = i++;
  var BEFORE_SCRIPT_4 = i++;
  var BEFORE_SCRIPT_5 = i++;
  var AFTER_SCRIPT_1 = i++;
  var AFTER_SCRIPT_2 = i++;
  var AFTER_SCRIPT_3 = i++;
  var AFTER_SCRIPT_4 = i++;
  var AFTER_SCRIPT_5 = i++;
  var BEFORE_STYLE_1 = i++;
  var BEFORE_STYLE_2 = i++;
  var BEFORE_STYLE_3 = i++;
  var BEFORE_STYLE_4 = i++;
  var AFTER_STYLE_1 = i++;
  var AFTER_STYLE_2 = i++;
  var AFTER_STYLE_3 = i++;
  var AFTER_STYLE_4 = i++;
  var BEFORE_ENTITY = i++;
  var BEFORE_NUMERIC_ENTITY = i++;
  var IN_NAMED_ENTITY = i++;
  var IN_NUMERIC_ENTITY = i++;
  var IN_HEX_ENTITY = i++;
  var j = 0;
  var SPECIAL_NONE = j++;
  var SPECIAL_SCRIPT = j++;
  var SPECIAL_STYLE = j++;
  function whitespace(c) {
    return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
  }
  function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
      return function(c) {
        if (c === lower) {
          this._state = SUCCESS;
        } else {
          this._state = FAILURE;
          this._index--;
        }
      };
    } else {
      return function(c) {
        if (c === lower || c === upper) {
          this._state = SUCCESS;
        } else {
          this._state = FAILURE;
          this._index--;
        }
      };
    }
  }
  function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function(c) {
      if (c === lower || c === upper) {
        this._state = NEXT_STATE;
      } else {
        this._state = IN_TAG_NAME;
        this._index--;
      }
    };
  }
  function Tokenizer(options, cbs) {
    this._state = TEXT;
    this._buffer = "";
    this._sectionStart = 0;
    this._index = 0;
    this._bufferOffset = 0;
    this._baseState = TEXT;
    this._special = SPECIAL_NONE;
    this._cbs = cbs;
    this._running = true;
    this._ended = false;
    this._xmlMode = !!(options && options.xmlMode);
    this._decodeEntities = !!(options && options.decodeEntities);
  }
  Tokenizer.prototype._stateText = function(c) {
    if (c === "<") {
      if (this._index > this._sectionStart) {
        this._cbs.ontext(this._getSection());
      }
      this._state = BEFORE_TAG_NAME;
      this._sectionStart = this._index;
    } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
      if (this._index > this._sectionStart) {
        this._cbs.ontext(this._getSection());
      }
      this._baseState = TEXT;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeTagName = function(c) {
    if (c === "/") {
      this._state = BEFORE_CLOSING_TAG_NAME;
    } else if (c === "<") {
      this._cbs.ontext(this._getSection());
      this._sectionStart = this._index;
    } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
      this._state = TEXT;
    } else if (c === "!") {
      this._state = BEFORE_DECLARATION;
      this._sectionStart = this._index + 1;
    } else if (c === "?") {
      this._state = IN_PROCESSING_INSTRUCTION;
      this._sectionStart = this._index + 1;
    } else {
      this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInTagName = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._emitToken("onopentagname");
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateBeforeCloseingTagName = function(c) {
    if (whitespace(c)) ;
    else if (c === ">") {
      this._state = TEXT;
    } else if (this._special !== SPECIAL_NONE) {
      if (c === "s" || c === "S") {
        this._state = BEFORE_SPECIAL_END;
      } else {
        this._state = TEXT;
        this._index--;
      }
    } else {
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInCloseingTagName = function(c) {
    if (c === ">" || whitespace(c)) {
      this._emitToken("onclosetag");
      this._state = AFTER_CLOSING_TAG_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateAfterCloseingTagName = function(c) {
    if (c === ">") {
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateBeforeAttributeName = function(c) {
    if (c === ">") {
      this._cbs.onopentagend();
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c === "/") {
      this._state = IN_SELF_CLOSING_TAG;
    } else if (!whitespace(c)) {
      this._state = IN_ATTRIBUTE_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInSelfClosingTag = function(c) {
    if (c === ">") {
      this._cbs.onselfclosingtag();
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInAttributeName = function(c) {
    if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
      this._cbs.onattribname(this._getSection());
      this._sectionStart = -1;
      this._state = AFTER_ATTRIBUTE_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateAfterAttributeName = function(c) {
    if (c === "=") {
      this._state = BEFORE_ATTRIBUTE_VALUE;
    } else if (c === "/" || c === ">") {
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    } else if (!whitespace(c)) {
      this._cbs.onattribend();
      this._state = IN_ATTRIBUTE_NAME;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeAttributeValue = function(c) {
    if (c === '"') {
      this._state = IN_ATTRIBUTE_VALUE_DQ;
      this._sectionStart = this._index + 1;
    } else if (c === "'") {
      this._state = IN_ATTRIBUTE_VALUE_SQ;
      this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
      this._state = IN_ATTRIBUTE_VALUE_NQ;
      this._sectionStart = this._index;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c) {
    if (c === '"') {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c) {
    if (c === "'") {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c) {
    if (whitespace(c) || c === ">") {
      this._emitToken("onattribdata");
      this._cbs.onattribend();
      this._state = BEFORE_ATTRIBUTE_NAME;
      this._index--;
    } else if (this._decodeEntities && c === "&") {
      this._emitToken("onattribdata");
      this._baseState = this._state;
      this._state = BEFORE_ENTITY;
      this._sectionStart = this._index;
    }
  };
  Tokenizer.prototype._stateBeforeDeclaration = function(c) {
    this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
  };
  Tokenizer.prototype._stateInDeclaration = function(c) {
    if (c === ">") {
      this._cbs.ondeclaration(this._getSection());
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateInProcessingInstruction = function(c) {
    if (c === ">") {
      this._cbs.onprocessinginstruction(this._getSection());
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    }
  };
  Tokenizer.prototype._stateBeforeComment = function(c) {
    if (c === "-") {
      this._state = IN_COMMENT;
      this._sectionStart = this._index + 1;
    } else {
      this._state = IN_DECLARATION;
    }
  };
  Tokenizer.prototype._stateInComment = function(c) {
    if (c === "-") this._state = AFTER_COMMENT_1;
  };
  Tokenizer.prototype._stateAfterComment1 = function(c) {
    if (c === "-") {
      this._state = AFTER_COMMENT_2;
    } else {
      this._state = IN_COMMENT;
    }
  };
  Tokenizer.prototype._stateAfterComment2 = function(c) {
    if (c === ">") {
      this._cbs.oncomment(
        this._buffer.substring(this._sectionStart, this._index - 2)
      );
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c !== "-") {
      this._state = IN_COMMENT;
    }
  };
  Tokenizer.prototype._stateBeforeCdata1 = ifElseState(
    "C",
    BEFORE_CDATA_2,
    IN_DECLARATION
  );
  Tokenizer.prototype._stateBeforeCdata2 = ifElseState(
    "D",
    BEFORE_CDATA_3,
    IN_DECLARATION
  );
  Tokenizer.prototype._stateBeforeCdata3 = ifElseState(
    "A",
    BEFORE_CDATA_4,
    IN_DECLARATION
  );
  Tokenizer.prototype._stateBeforeCdata4 = ifElseState(
    "T",
    BEFORE_CDATA_5,
    IN_DECLARATION
  );
  Tokenizer.prototype._stateBeforeCdata5 = ifElseState(
    "A",
    BEFORE_CDATA_6,
    IN_DECLARATION
  );
  Tokenizer.prototype._stateBeforeCdata6 = function(c) {
    if (c === "[") {
      this._state = IN_CDATA;
      this._sectionStart = this._index + 1;
    } else {
      this._state = IN_DECLARATION;
      this._index--;
    }
  };
  Tokenizer.prototype._stateInCdata = function(c) {
    if (c === "]") this._state = AFTER_CDATA_1;
  };
  Tokenizer.prototype._stateAfterCdata1 = function(c) {
    if (c === "]") this._state = AFTER_CDATA_2;
    else this._state = IN_CDATA;
  };
  Tokenizer.prototype._stateAfterCdata2 = function(c) {
    if (c === ">") {
      this._cbs.oncdata(
        this._buffer.substring(this._sectionStart, this._index - 2)
      );
      this._state = TEXT;
      this._sectionStart = this._index + 1;
    } else if (c !== "]") {
      this._state = IN_CDATA;
    }
  };
  Tokenizer.prototype._stateBeforeSpecial = function(c) {
    if (c === "c" || c === "C") {
      this._state = BEFORE_SCRIPT_1;
    } else if (c === "t" || c === "T") {
      this._state = BEFORE_STYLE_1;
    } else {
      this._state = IN_TAG_NAME;
      this._index--;
    }
  };
  Tokenizer.prototype._stateBeforeSpecialEnd = function(c) {
    if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
      this._state = AFTER_SCRIPT_1;
    } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
      this._state = AFTER_STYLE_1;
    } else this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar(
    "R",
    BEFORE_SCRIPT_2
  );
  Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar(
    "I",
    BEFORE_SCRIPT_3
  );
  Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar(
    "P",
    BEFORE_SCRIPT_4
  );
  Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar(
    "T",
    BEFORE_SCRIPT_5
  );
  Tokenizer.prototype._stateBeforeScript5 = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._special = SPECIAL_SCRIPT;
    }
    this._state = IN_TAG_NAME;
    this._index--;
  };
  Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
  Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
  Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
  Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
  Tokenizer.prototype._stateAfterScript5 = function(c) {
    if (c === ">" || whitespace(c)) {
      this._special = SPECIAL_NONE;
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index - 6;
      this._index--;
    } else this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar(
    "Y",
    BEFORE_STYLE_2
  );
  Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar(
    "L",
    BEFORE_STYLE_3
  );
  Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar(
    "E",
    BEFORE_STYLE_4
  );
  Tokenizer.prototype._stateBeforeStyle4 = function(c) {
    if (c === "/" || c === ">" || whitespace(c)) {
      this._special = SPECIAL_STYLE;
    }
    this._state = IN_TAG_NAME;
    this._index--;
  };
  Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
  Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
  Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
  Tokenizer.prototype._stateAfterStyle4 = function(c) {
    if (c === ">" || whitespace(c)) {
      this._special = SPECIAL_NONE;
      this._state = IN_CLOSING_TAG_NAME;
      this._sectionStart = this._index - 5;
      this._index--;
    } else this._state = TEXT;
  };
  Tokenizer.prototype._stateBeforeEntity = ifElseState(
    "#",
    BEFORE_NUMERIC_ENTITY,
    IN_NAMED_ENTITY
  );
  Tokenizer.prototype._stateBeforeNumericEntity = ifElseState(
    "X",
    IN_HEX_ENTITY,
    IN_NUMERIC_ENTITY
  );
  Tokenizer.prototype._parseNamedEntityStrict = function() {
    if (this._sectionStart + 1 < this._index) {
      var entity = this._buffer.substring(
        this._sectionStart + 1,
        this._index
      ), map2 = this._xmlMode ? xmlMap : entityMap;
      if (map2.hasOwnProperty(entity)) {
        this._emitPartial(map2[entity]);
        this._sectionStart = this._index + 1;
      }
    }
  };
  Tokenizer.prototype._parseLegacyEntity = function() {
    var start = this._sectionStart + 1, limit = this._index - start;
    if (limit > 6) limit = 6;
    while (limit >= 2) {
      var entity = this._buffer.substr(start, limit);
      if (legacyMap.hasOwnProperty(entity)) {
        this._emitPartial(legacyMap[entity]);
        this._sectionStart += limit + 1;
        return;
      } else {
        limit--;
      }
    }
  };
  Tokenizer.prototype._stateInNamedEntity = function(c) {
    if (c === ";") {
      this._parseNamedEntityStrict();
      if (this._sectionStart + 1 < this._index && !this._xmlMode) {
        this._parseLegacyEntity();
      }
      this._state = this._baseState;
    } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
      if (this._xmlMode) ;
      else if (this._sectionStart + 1 === this._index) ;
      else if (this._baseState !== TEXT) {
        if (c !== "=") {
          this._parseNamedEntityStrict();
        }
      } else {
        this._parseLegacyEntity();
      }
      this._state = this._baseState;
      this._index--;
    }
  };
  Tokenizer.prototype._decodeNumericEntity = function(offset, base) {
    var sectionStart = this._sectionStart + offset;
    if (sectionStart !== this._index) {
      var entity = this._buffer.substring(sectionStart, this._index);
      var parsed = parseInt(entity, base);
      this._emitPartial(decodeCodePoint(parsed));
      this._sectionStart = this._index;
    } else {
      this._sectionStart--;
    }
    this._state = this._baseState;
  };
  Tokenizer.prototype._stateInNumericEntity = function(c) {
    if (c === ";") {
      this._decodeNumericEntity(2, 10);
      this._sectionStart++;
    } else if (c < "0" || c > "9") {
      if (!this._xmlMode) {
        this._decodeNumericEntity(2, 10);
      } else {
        this._state = this._baseState;
      }
      this._index--;
    }
  };
  Tokenizer.prototype._stateInHexEntity = function(c) {
    if (c === ";") {
      this._decodeNumericEntity(3, 16);
      this._sectionStart++;
    } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
      if (!this._xmlMode) {
        this._decodeNumericEntity(3, 16);
      } else {
        this._state = this._baseState;
      }
      this._index--;
    }
  };
  Tokenizer.prototype._cleanup = function() {
    if (this._sectionStart < 0) {
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else if (this._running) {
      if (this._state === TEXT) {
        if (this._sectionStart !== this._index) {
          this._cbs.ontext(this._buffer.substr(this._sectionStart));
        }
        this._buffer = "";
        this._bufferOffset += this._index;
        this._index = 0;
      } else if (this._sectionStart === this._index) {
        this._buffer = "";
        this._bufferOffset += this._index;
        this._index = 0;
      } else {
        this._buffer = this._buffer.substr(this._sectionStart);
        this._index -= this._sectionStart;
        this._bufferOffset += this._sectionStart;
      }
      this._sectionStart = 0;
    }
  };
  Tokenizer.prototype.write = function(chunk) {
    if (this._ended) this._cbs.onerror(Error(".write() after done!"));
    this._buffer += chunk;
    this._parse();
  };
  Tokenizer.prototype._parse = function() {
    while (this._index < this._buffer.length && this._running) {
      var c = this._buffer.charAt(this._index);
      if (this._state === TEXT) {
        this._stateText(c);
      } else if (this._state === BEFORE_TAG_NAME) {
        this._stateBeforeTagName(c);
      } else if (this._state === IN_TAG_NAME) {
        this._stateInTagName(c);
      } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
        this._stateBeforeCloseingTagName(c);
      } else if (this._state === IN_CLOSING_TAG_NAME) {
        this._stateInCloseingTagName(c);
      } else if (this._state === AFTER_CLOSING_TAG_NAME) {
        this._stateAfterCloseingTagName(c);
      } else if (this._state === IN_SELF_CLOSING_TAG) {
        this._stateInSelfClosingTag(c);
      } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
        this._stateBeforeAttributeName(c);
      } else if (this._state === IN_ATTRIBUTE_NAME) {
        this._stateInAttributeName(c);
      } else if (this._state === AFTER_ATTRIBUTE_NAME) {
        this._stateAfterAttributeName(c);
      } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
        this._stateBeforeAttributeValue(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
        this._stateInAttributeValueDoubleQuotes(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
        this._stateInAttributeValueSingleQuotes(c);
      } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
        this._stateInAttributeValueNoQuotes(c);
      } else if (this._state === BEFORE_DECLARATION) {
        this._stateBeforeDeclaration(c);
      } else if (this._state === IN_DECLARATION) {
        this._stateInDeclaration(c);
      } else if (this._state === IN_PROCESSING_INSTRUCTION) {
        this._stateInProcessingInstruction(c);
      } else if (this._state === BEFORE_COMMENT) {
        this._stateBeforeComment(c);
      } else if (this._state === IN_COMMENT) {
        this._stateInComment(c);
      } else if (this._state === AFTER_COMMENT_1) {
        this._stateAfterComment1(c);
      } else if (this._state === AFTER_COMMENT_2) {
        this._stateAfterComment2(c);
      } else if (this._state === BEFORE_CDATA_1) {
        this._stateBeforeCdata1(c);
      } else if (this._state === BEFORE_CDATA_2) {
        this._stateBeforeCdata2(c);
      } else if (this._state === BEFORE_CDATA_3) {
        this._stateBeforeCdata3(c);
      } else if (this._state === BEFORE_CDATA_4) {
        this._stateBeforeCdata4(c);
      } else if (this._state === BEFORE_CDATA_5) {
        this._stateBeforeCdata5(c);
      } else if (this._state === BEFORE_CDATA_6) {
        this._stateBeforeCdata6(c);
      } else if (this._state === IN_CDATA) {
        this._stateInCdata(c);
      } else if (this._state === AFTER_CDATA_1) {
        this._stateAfterCdata1(c);
      } else if (this._state === AFTER_CDATA_2) {
        this._stateAfterCdata2(c);
      } else if (this._state === BEFORE_SPECIAL) {
        this._stateBeforeSpecial(c);
      } else if (this._state === BEFORE_SPECIAL_END) {
        this._stateBeforeSpecialEnd(c);
      } else if (this._state === BEFORE_SCRIPT_1) {
        this._stateBeforeScript1(c);
      } else if (this._state === BEFORE_SCRIPT_2) {
        this._stateBeforeScript2(c);
      } else if (this._state === BEFORE_SCRIPT_3) {
        this._stateBeforeScript3(c);
      } else if (this._state === BEFORE_SCRIPT_4) {
        this._stateBeforeScript4(c);
      } else if (this._state === BEFORE_SCRIPT_5) {
        this._stateBeforeScript5(c);
      } else if (this._state === AFTER_SCRIPT_1) {
        this._stateAfterScript1(c);
      } else if (this._state === AFTER_SCRIPT_2) {
        this._stateAfterScript2(c);
      } else if (this._state === AFTER_SCRIPT_3) {
        this._stateAfterScript3(c);
      } else if (this._state === AFTER_SCRIPT_4) {
        this._stateAfterScript4(c);
      } else if (this._state === AFTER_SCRIPT_5) {
        this._stateAfterScript5(c);
      } else if (this._state === BEFORE_STYLE_1) {
        this._stateBeforeStyle1(c);
      } else if (this._state === BEFORE_STYLE_2) {
        this._stateBeforeStyle2(c);
      } else if (this._state === BEFORE_STYLE_3) {
        this._stateBeforeStyle3(c);
      } else if (this._state === BEFORE_STYLE_4) {
        this._stateBeforeStyle4(c);
      } else if (this._state === AFTER_STYLE_1) {
        this._stateAfterStyle1(c);
      } else if (this._state === AFTER_STYLE_2) {
        this._stateAfterStyle2(c);
      } else if (this._state === AFTER_STYLE_3) {
        this._stateAfterStyle3(c);
      } else if (this._state === AFTER_STYLE_4) {
        this._stateAfterStyle4(c);
      } else if (this._state === BEFORE_ENTITY) {
        this._stateBeforeEntity(c);
      } else if (this._state === BEFORE_NUMERIC_ENTITY) {
        this._stateBeforeNumericEntity(c);
      } else if (this._state === IN_NAMED_ENTITY) {
        this._stateInNamedEntity(c);
      } else if (this._state === IN_NUMERIC_ENTITY) {
        this._stateInNumericEntity(c);
      } else if (this._state === IN_HEX_ENTITY) {
        this._stateInHexEntity(c);
      } else {
        this._cbs.onerror(Error("unknown _state"), this._state);
      }
      this._index++;
    }
    this._cleanup();
  };
  Tokenizer.prototype.pause = function() {
    this._running = false;
  };
  Tokenizer.prototype.resume = function() {
    this._running = true;
    if (this._index < this._buffer.length) {
      this._parse();
    }
    if (this._ended) {
      this._finish();
    }
  };
  Tokenizer.prototype.end = function(chunk) {
    if (this._ended) this._cbs.onerror(Error(".end() after done!"));
    if (chunk) this.write(chunk);
    this._ended = true;
    if (this._running) this._finish();
  };
  Tokenizer.prototype._finish = function() {
    if (this._sectionStart < this._index) {
      this._handleTrailingData();
    }
    this._cbs.onend();
  };
  Tokenizer.prototype._handleTrailingData = function() {
    var data = this._buffer.substr(this._sectionStart);
    if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
      this._cbs.oncdata(data);
    } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
      this._cbs.oncomment(data);
    } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
      this._parseLegacyEntity();
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
      this._decodeNumericEntity(2, 10);
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
      this._decodeNumericEntity(3, 16);
      if (this._sectionStart < this._index) {
        this._state = this._baseState;
        this._handleTrailingData();
      }
    } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
      this._cbs.ontext(data);
    }
  };
  Tokenizer.prototype.reset = function() {
    Tokenizer.call(
      this,
      { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities },
      this._cbs
    );
  };
  Tokenizer.prototype.getAbsoluteIndex = function() {
    return this._bufferOffset + this._index;
  };
  Tokenizer.prototype._getSection = function() {
    return this._buffer.substring(this._sectionStart, this._index);
  };
  Tokenizer.prototype._emitToken = function(name) {
    this._cbs[name](this._getSection());
    this._sectionStart = -1;
  };
  Tokenizer.prototype._emitPartial = function(value) {
    if (this._baseState !== TEXT) {
      this._cbs.onattribdata(value);
    } else {
      this._cbs.ontext(value);
    }
  };
  return Tokenizer_1;
}
var Parser_1;
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return Parser_1;
  hasRequiredParser = 1;
  var Tokenizer = requireTokenizer();
  var formTags = {
    input: true,
    option: true,
    optgroup: true,
    select: true,
    button: true,
    datalist: true,
    textarea: true
  };
  var openImpliesClose = {
    tr: { tr: true, th: true, td: true },
    th: { th: true },
    td: { thead: true, th: true, td: true },
    body: { head: true, link: true, script: true },
    li: { li: true },
    p: { p: true },
    h1: { p: true },
    h2: { p: true },
    h3: { p: true },
    h4: { p: true },
    h5: { p: true },
    h6: { p: true },
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: { option: true },
    optgroup: { optgroup: true }
  };
  var voidElements = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var foreignContextElements = {
    __proto__: null,
    math: true,
    svg: true
  };
  var htmlIntegrationElements = {
    __proto__: null,
    mi: true,
    mo: true,
    mn: true,
    ms: true,
    mtext: true,
    "annotation-xml": true,
    foreignObject: true,
    desc: true,
    title: true
  };
  var re_nameEnd = /\s|\//;
  function Parser(cbs, options) {
    this._options = options || {};
    this._cbs = cbs || {};
    this._tagname = "";
    this._attribname = "";
    this._attribvalue = "";
    this._attribs = null;
    this._stack = [];
    this._foreignContext = [];
    this.startIndex = 0;
    this.endIndex = null;
    this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
    this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
    if (this._options.Tokenizer) {
      Tokenizer = this._options.Tokenizer;
    }
    this._tokenizer = new Tokenizer(this._options, this);
    if (this._cbs.onparserinit) this._cbs.onparserinit(this);
  }
  requireInherits()(Parser, require$$2$3.EventEmitter);
  Parser.prototype._updatePosition = function(initialOffset) {
    if (this.endIndex === null) {
      if (this._tokenizer._sectionStart <= initialOffset) {
        this.startIndex = 0;
      } else {
        this.startIndex = this._tokenizer._sectionStart - initialOffset;
      }
    } else this.startIndex = this.endIndex + 1;
    this.endIndex = this._tokenizer.getAbsoluteIndex();
  };
  Parser.prototype.ontext = function(data) {
    this._updatePosition(1);
    this.endIndex--;
    if (this._cbs.ontext) this._cbs.ontext(data);
  };
  Parser.prototype.onopentagname = function(name) {
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    this._tagname = name;
    if (!this._options.xmlMode && name in openImpliesClose) {
      for (var el2; (el2 = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el2)) ;
    }
    if (this._options.xmlMode || !(name in voidElements)) {
      this._stack.push(name);
      if (name in foreignContextElements) this._foreignContext.push(true);
      else if (name in htmlIntegrationElements)
        this._foreignContext.push(false);
    }
    if (this._cbs.onopentagname) this._cbs.onopentagname(name);
    if (this._cbs.onopentag) this._attribs = {};
  };
  Parser.prototype.onopentagend = function() {
    this._updatePosition(1);
    if (this._attribs) {
      if (this._cbs.onopentag)
        this._cbs.onopentag(this._tagname, this._attribs);
      this._attribs = null;
    }
    if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
      this._cbs.onclosetag(this._tagname);
    }
    this._tagname = "";
  };
  Parser.prototype.onclosetag = function(name) {
    this._updatePosition(1);
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    if (name in foreignContextElements || name in htmlIntegrationElements) {
      this._foreignContext.pop();
    }
    if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
      var pos = this._stack.lastIndexOf(name);
      if (pos !== -1) {
        if (this._cbs.onclosetag) {
          pos = this._stack.length - pos;
          while (pos--) this._cbs.onclosetag(this._stack.pop());
        } else this._stack.length = pos;
      } else if (name === "p" && !this._options.xmlMode) {
        this.onopentagname(name);
        this._closeCurrentTag();
      }
    } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
      this.onopentagname(name);
      this._closeCurrentTag();
    }
  };
  Parser.prototype.onselfclosingtag = function() {
    if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
      this._closeCurrentTag();
    } else {
      this.onopentagend();
    }
  };
  Parser.prototype._closeCurrentTag = function() {
    var name = this._tagname;
    this.onopentagend();
    if (this._stack[this._stack.length - 1] === name) {
      if (this._cbs.onclosetag) {
        this._cbs.onclosetag(name);
      }
      this._stack.pop();
    }
  };
  Parser.prototype.onattribname = function(name) {
    if (this._lowerCaseAttributeNames) {
      name = name.toLowerCase();
    }
    this._attribname = name;
  };
  Parser.prototype.onattribdata = function(value) {
    this._attribvalue += value;
  };
  Parser.prototype.onattribend = function() {
    if (this._cbs.onattribute)
      this._cbs.onattribute(this._attribname, this._attribvalue);
    if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
      this._attribs[this._attribname] = this._attribvalue;
    }
    this._attribname = "";
    this._attribvalue = "";
  };
  Parser.prototype._getInstructionName = function(value) {
    var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx);
    if (this._lowerCaseTagNames) {
      name = name.toLowerCase();
    }
    return name;
  };
  Parser.prototype.ondeclaration = function(value) {
    if (this._cbs.onprocessinginstruction) {
      var name = this._getInstructionName(value);
      this._cbs.onprocessinginstruction("!" + name, "!" + value);
    }
  };
  Parser.prototype.onprocessinginstruction = function(value) {
    if (this._cbs.onprocessinginstruction) {
      var name = this._getInstructionName(value);
      this._cbs.onprocessinginstruction("?" + name, "?" + value);
    }
  };
  Parser.prototype.oncomment = function(value) {
    this._updatePosition(4);
    if (this._cbs.oncomment) this._cbs.oncomment(value);
    if (this._cbs.oncommentend) this._cbs.oncommentend();
  };
  Parser.prototype.oncdata = function(value) {
    this._updatePosition(1);
    if (this._options.xmlMode || this._options.recognizeCDATA) {
      if (this._cbs.oncdatastart) this._cbs.oncdatastart();
      if (this._cbs.ontext) this._cbs.ontext(value);
      if (this._cbs.oncdataend) this._cbs.oncdataend();
    } else {
      this.oncomment("[CDATA[" + value + "]]");
    }
  };
  Parser.prototype.onerror = function(err) {
    if (this._cbs.onerror) this._cbs.onerror(err);
  };
  Parser.prototype.onend = function() {
    if (this._cbs.onclosetag) {
      for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i])) ;
    }
    if (this._cbs.onend) this._cbs.onend();
  };
  Parser.prototype.reset = function() {
    if (this._cbs.onreset) this._cbs.onreset();
    this._tokenizer.reset();
    this._tagname = "";
    this._attribname = "";
    this._attribs = null;
    this._stack = [];
    if (this._cbs.onparserinit) this._cbs.onparserinit(this);
  };
  Parser.prototype.parseComplete = function(data) {
    this.reset();
    this.end(data);
  };
  Parser.prototype.write = function(chunk) {
    this._tokenizer.write(chunk);
  };
  Parser.prototype.end = function(chunk) {
    this._tokenizer.end(chunk);
  };
  Parser.prototype.pause = function() {
    this._tokenizer.pause();
  };
  Parser.prototype.resume = function() {
    this._tokenizer.resume();
  };
  Parser.prototype.parseChunk = Parser.prototype.write;
  Parser.prototype.done = Parser.prototype.end;
  Parser_1 = Parser;
  return Parser_1;
}
var domelementtype;
var hasRequiredDomelementtype;
function requireDomelementtype() {
  if (hasRequiredDomelementtype) return domelementtype;
  hasRequiredDomelementtype = 1;
  domelementtype = {
    Text: "text",
    //Text
    Directive: "directive",
    //<? ... ?>
    Comment: "comment",
    //<!-- ... -->
    Script: "script",
    //<script> tags
    Style: "style",
    //<style> tags
    Tag: "tag",
    //Any tag
    CDATA: "cdata",
    //<![CDATA[ ... ]]>
    Doctype: "doctype",
    isTag: function(elem) {
      return elem.type === "tag" || elem.type === "script" || elem.type === "style";
    }
  };
  return domelementtype;
}
var node = { exports: {} };
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  var NodePrototype = node.exports = {
    get firstChild() {
      var children = this.children;
      return children && children[0] || null;
    },
    get lastChild() {
      var children = this.children;
      return children && children[children.length - 1] || null;
    },
    get nodeType() {
      return nodeTypes[this.type] || nodeTypes.element;
    }
  };
  var domLvl1 = {
    tagName: "name",
    childNodes: "children",
    parentNode: "parent",
    previousSibling: "prev",
    nextSibling: "next",
    nodeValue: "data"
  };
  var nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
  };
  Object.keys(domLvl1).forEach(function(key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(NodePrototype, key, {
      get: function() {
        return this[shorthand] || null;
      },
      set: function(val) {
        this[shorthand] = val;
        return val;
      }
    });
  });
  return node.exports;
}
var element = { exports: {} };
var hasRequiredElement;
function requireElement() {
  if (hasRequiredElement) return element.exports;
  hasRequiredElement = 1;
  var NodePrototype = requireNode();
  var ElementPrototype = element.exports = Object.create(NodePrototype);
  var domLvl1 = {
    tagName: "name"
  };
  Object.keys(domLvl1).forEach(function(key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(ElementPrototype, key, {
      get: function() {
        return this[shorthand] || null;
      },
      set: function(val) {
        this[shorthand] = val;
        return val;
      }
    });
  });
  return element.exports;
}
var domhandler;
var hasRequiredDomhandler;
function requireDomhandler() {
  if (hasRequiredDomhandler) return domhandler;
  hasRequiredDomhandler = 1;
  var ElementType = requireDomelementtype();
  var re_whitespace = /\s+/g;
  var NodePrototype = requireNode();
  var ElementPrototype = requireElement();
  function DomHandler(callback, options, elementCB) {
    if (typeof callback === "object") {
      elementCB = options;
      options = callback;
      callback = null;
    } else if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    this._callback = callback;
    this._options = options || defaultOpts;
    this._elementCB = elementCB;
    this.dom = [];
    this._done = false;
    this._tagStack = [];
    this._parser = this._parser || null;
  }
  var defaultOpts = {
    normalizeWhitespace: false,
    //Replace all whitespace with single spaces
    withStartIndices: false,
    //Add startIndex properties to nodes
    withEndIndices: false
    //Add endIndex properties to nodes
  };
  DomHandler.prototype.onparserinit = function(parser2) {
    this._parser = parser2;
  };
  DomHandler.prototype.onreset = function() {
    DomHandler.call(this, this._callback, this._options, this._elementCB);
  };
  DomHandler.prototype.onend = function() {
    if (this._done) return;
    this._done = true;
    this._parser = null;
    this._handleCallback(null);
  };
  DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function(error) {
    if (typeof this._callback === "function") {
      this._callback(error, this.dom);
    } else {
      if (error) throw error;
    }
  };
  DomHandler.prototype.onclosetag = function() {
    var elem = this._tagStack.pop();
    if (this._options.withEndIndices && elem) {
      elem.endIndex = this._parser.endIndex;
    }
    if (this._elementCB) this._elementCB(elem);
  };
  DomHandler.prototype._createDomElement = function(properties) {
    if (!this._options.withDomLvl1) return properties;
    var element2;
    if (properties.type === "tag") {
      element2 = Object.create(ElementPrototype);
    } else {
      element2 = Object.create(NodePrototype);
    }
    for (var key in properties) {
      if (properties.hasOwnProperty(key)) {
        element2[key] = properties[key];
      }
    }
    return element2;
  };
  DomHandler.prototype._addDomElement = function(element2) {
    var parent = this._tagStack[this._tagStack.length - 1];
    var siblings = parent ? parent.children : this.dom;
    var previousSibling = siblings[siblings.length - 1];
    element2.next = null;
    if (this._options.withStartIndices) {
      element2.startIndex = this._parser.startIndex;
    }
    if (this._options.withEndIndices) {
      element2.endIndex = this._parser.endIndex;
    }
    if (previousSibling) {
      element2.prev = previousSibling;
      previousSibling.next = element2;
    } else {
      element2.prev = null;
    }
    siblings.push(element2);
    element2.parent = parent || null;
  };
  DomHandler.prototype.onopentag = function(name, attribs) {
    var properties = {
      type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
      name,
      attribs,
      children: []
    };
    var element2 = this._createDomElement(properties);
    this._addDomElement(element2);
    this._tagStack.push(element2);
  };
  DomHandler.prototype.ontext = function(data) {
    var normalize2 = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
    var lastTag;
    if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
      if (normalize2) {
        lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
      } else {
        lastTag.data += data;
      }
    } else {
      if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
        if (normalize2) {
          lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
        } else {
          lastTag.data += data;
        }
      } else {
        if (normalize2) {
          data = data.replace(re_whitespace, " ");
        }
        var element2 = this._createDomElement({
          data,
          type: ElementType.Text
        });
        this._addDomElement(element2);
      }
    }
  };
  DomHandler.prototype.oncomment = function(data) {
    var lastTag = this._tagStack[this._tagStack.length - 1];
    if (lastTag && lastTag.type === ElementType.Comment) {
      lastTag.data += data;
      return;
    }
    var properties = {
      data,
      type: ElementType.Comment
    };
    var element2 = this._createDomElement(properties);
    this._addDomElement(element2);
    this._tagStack.push(element2);
  };
  DomHandler.prototype.oncdatastart = function() {
    var properties = {
      children: [{
        data: "",
        type: ElementType.Text
      }],
      type: ElementType.CDATA
    };
    var element2 = this._createDomElement(properties);
    this._addDomElement(element2);
    this._tagStack.push(element2);
  };
  DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function() {
    this._tagStack.pop();
  };
  DomHandler.prototype.onprocessinginstruction = function(name, data) {
    var element2 = this._createDomElement({
      name,
      data,
      type: ElementType.Directive
    });
    this._addDomElement(element2);
  };
  domhandler = DomHandler;
  return domhandler;
}
var domutils = { exports: {} };
var domSerializer = { exports: {} };
var lib$2 = {};
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Doctype = exports$1.CDATA = exports$1.Tag = exports$1.Style = exports$1.Script = exports$1.Comment = exports$1.Directive = exports$1.Text = exports$1.Root = exports$1.isTag = exports$1.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports$1.ElementType || (exports$1.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports$1.isTag = isTag;
    exports$1.Root = ElementType.Root;
    exports$1.Text = ElementType.Text;
    exports$1.Directive = ElementType.Directive;
    exports$1.Comment = ElementType.Comment;
    exports$1.Script = ElementType.Script;
    exports$1.Style = ElementType.Style;
    exports$1.Tag = ElementType.Tag;
    exports$1.CDATA = ElementType.CDATA;
    exports$1.Doctype = ElementType.Doctype;
  })(lib$2);
  return lib$2;
}
var lib = {};
var decode$1 = {};
const Aacute$1 = "Ã";
const aacute$1 = "Ã¡";
const Abreve = "Ä‚";
const abreve = "Äƒ";
const ac = "âˆ¾";
const acd = "âˆ¿";
const acE = "âˆ¾Ì³";
const Acirc$1 = "Ã‚";
const acirc$1 = "Ã¢";
const acute$1 = "Â´";
const Acy = "Ð";
const acy = "Ð°";
const AElig$1 = "Ã†";
const aelig$1 = "Ã¦";
const af = "â¡";
const Afr = "ð”„";
const afr = "ð”ž";
const Agrave$1 = "Ã€";
const agrave$1 = "Ã ";
const alefsym = "â„µ";
const aleph = "â„µ";
const Alpha = "Î‘";
const alpha = "Î±";
const Amacr = "Ä€";
const amacr = "Ä";
const amalg = "â¨¿";
const amp$2 = "&";
const AMP$1 = "&";
const andand = "â©•";
const And = "â©“";
const and = "âˆ§";
const andd = "â©œ";
const andslope = "â©˜";
const andv = "â©š";
const ang = "âˆ ";
const ange = "â¦¤";
const angle = "âˆ ";
const angmsdaa = "â¦¨";
const angmsdab = "â¦©";
const angmsdac = "â¦ª";
const angmsdad = "â¦«";
const angmsdae = "â¦¬";
const angmsdaf = "â¦­";
const angmsdag = "â¦®";
const angmsdah = "â¦¯";
const angmsd = "âˆ¡";
const angrt = "âˆŸ";
const angrtvb = "âŠ¾";
const angrtvbd = "â¦";
const angsph = "âˆ¢";
const angst = "Ã…";
const angzarr = "â¼";
const Aogon = "Ä„";
const aogon = "Ä…";
const Aopf = "ð”¸";
const aopf = "ð•’";
const apacir = "â©¯";
const ap = "â‰ˆ";
const apE = "â©°";
const ape = "â‰Š";
const apid = "â‰‹";
const apos$1 = "'";
const ApplyFunction = "â¡";
const approx = "â‰ˆ";
const approxeq = "â‰Š";
const Aring$1 = "Ã…";
const aring$1 = "Ã¥";
const Ascr = "ð’œ";
const ascr = "ð’¶";
const Assign = "â‰”";
const ast = "*";
const asymp = "â‰ˆ";
const asympeq = "â‰";
const Atilde$1 = "Ãƒ";
const atilde$1 = "Ã£";
const Auml$1 = "Ã„";
const auml$1 = "Ã¤";
const awconint = "âˆ³";
const awint = "â¨‘";
const backcong = "â‰Œ";
const backepsilon = "Ï¶";
const backprime = "â€µ";
const backsim = "âˆ½";
const backsimeq = "â‹";
const Backslash = "âˆ–";
const Barv = "â«§";
const barvee = "âŠ½";
const barwed = "âŒ…";
const Barwed = "âŒ†";
const barwedge = "âŒ…";
const bbrk = "âŽµ";
const bbrktbrk = "âŽ¶";
const bcong = "â‰Œ";
const Bcy = "Ð‘";
const bcy = "Ð±";
const bdquo = "â€ž";
const becaus = "âˆµ";
const because = "âˆµ";
const Because = "âˆµ";
const bemptyv = "â¦°";
const bepsi = "Ï¶";
const bernou = "â„¬";
const Bernoullis = "â„¬";
const Beta = "Î’";
const beta = "Î²";
const beth = "â„¶";
const between = "â‰¬";
const Bfr = "ð”…";
const bfr = "ð”Ÿ";
const bigcap = "â‹‚";
const bigcirc = "â—¯";
const bigcup = "â‹ƒ";
const bigodot = "â¨€";
const bigoplus = "â¨";
const bigotimes = "â¨‚";
const bigsqcup = "â¨†";
const bigstar = "â˜…";
const bigtriangledown = "â–½";
const bigtriangleup = "â–³";
const biguplus = "â¨„";
const bigvee = "â‹";
const bigwedge = "â‹€";
const bkarow = "â¤";
const blacklozenge = "â§«";
const blacksquare = "â–ª";
const blacktriangle = "â–´";
const blacktriangledown = "â–¾";
const blacktriangleleft = "â—‚";
const blacktriangleright = "â–¸";
const blank = "â£";
const blk12 = "â–’";
const blk14 = "â–‘";
const blk34 = "â–“";
const block = "â–ˆ";
const bne = "=âƒ¥";
const bnequiv = "â‰¡âƒ¥";
const bNot = "â«­";
const bnot = "âŒ";
const Bopf = "ð”¹";
const bopf = "ð•“";
const bot = "âŠ¥";
const bottom = "âŠ¥";
const bowtie = "â‹ˆ";
const boxbox = "â§‰";
const boxdl = "â”";
const boxdL = "â••";
const boxDl = "â•–";
const boxDL = "â•—";
const boxdr = "â”Œ";
const boxdR = "â•’";
const boxDr = "â•“";
const boxDR = "â•”";
const boxh = "â”€";
const boxH = "â•";
const boxhd = "â”¬";
const boxHd = "â•¤";
const boxhD = "â•¥";
const boxHD = "â•¦";
const boxhu = "â”´";
const boxHu = "â•§";
const boxhU = "â•¨";
const boxHU = "â•©";
const boxminus = "âŠŸ";
const boxplus = "âŠž";
const boxtimes = "âŠ ";
const boxul = "â”˜";
const boxuL = "â•›";
const boxUl = "â•œ";
const boxUL = "â•";
const boxur = "â””";
const boxuR = "â•˜";
const boxUr = "â•™";
const boxUR = "â•š";
const boxv = "â”‚";
const boxV = "â•‘";
const boxvh = "â”¼";
const boxvH = "â•ª";
const boxVh = "â•«";
const boxVH = "â•¬";
const boxvl = "â”¤";
const boxvL = "â•¡";
const boxVl = "â•¢";
const boxVL = "â•£";
const boxvr = "â”œ";
const boxvR = "â•ž";
const boxVr = "â•Ÿ";
const boxVR = "â• ";
const bprime = "â€µ";
const breve = "Ë˜";
const Breve = "Ë˜";
const brvbar$1 = "Â¦";
const bscr = "ð’·";
const Bscr = "â„¬";
const bsemi = "â";
const bsim = "âˆ½";
const bsime = "â‹";
const bsolb = "â§…";
const bsol = "\\";
const bsolhsub = "âŸˆ";
const bull = "â€¢";
const bullet = "â€¢";
const bump = "â‰Ž";
const bumpE = "âª®";
const bumpe = "â‰";
const Bumpeq = "â‰Ž";
const bumpeq = "â‰";
const Cacute = "Ä†";
const cacute = "Ä‡";
const capand = "â©„";
const capbrcup = "â©‰";
const capcap = "â©‹";
const cap = "âˆ©";
const Cap = "â‹’";
const capcup = "â©‡";
const capdot = "â©€";
const CapitalDifferentialD = "â……";
const caps = "âˆ©ï¸€";
const caret = "â";
const caron = "Ë‡";
const Cayleys = "â„­";
const ccaps = "â©";
const Ccaron = "ÄŒ";
const ccaron = "Ä";
const Ccedil$1 = "Ã‡";
const ccedil$1 = "Ã§";
const Ccirc = "Äˆ";
const ccirc = "Ä‰";
const Cconint = "âˆ°";
const ccups = "â©Œ";
const ccupssm = "â©";
const Cdot = "ÄŠ";
const cdot = "Ä‹";
const cedil$1 = "Â¸";
const Cedilla = "Â¸";
const cemptyv = "â¦²";
const cent$1 = "Â¢";
const centerdot = "Â·";
const CenterDot = "Â·";
const cfr = "ð” ";
const Cfr = "â„­";
const CHcy = "Ð§";
const chcy = "Ñ‡";
const check = "âœ“";
const checkmark = "âœ“";
const Chi = "Î§";
const chi = "Ï‡";
const circ = "Ë†";
const circeq = "â‰—";
const circlearrowleft = "â†º";
const circlearrowright = "â†»";
const circledast = "âŠ›";
const circledcirc = "âŠš";
const circleddash = "âŠ";
const CircleDot = "âŠ™";
const circledR = "Â®";
const circledS = "â“ˆ";
const CircleMinus = "âŠ–";
const CirclePlus = "âŠ•";
const CircleTimes = "âŠ—";
const cir = "â—‹";
const cirE = "â§ƒ";
const cire = "â‰—";
const cirfnint = "â¨";
const cirmid = "â«¯";
const cirscir = "â§‚";
const ClockwiseContourIntegral = "âˆ²";
const CloseCurlyDoubleQuote = "â€";
const CloseCurlyQuote = "â€™";
const clubs = "â™£";
const clubsuit = "â™£";
const colon = ":";
const Colon = "âˆ·";
const Colone = "â©´";
const colone = "â‰”";
const coloneq = "â‰”";
const comma = ",";
const commat = "@";
const comp = "âˆ";
const compfn = "âˆ˜";
const complement = "âˆ";
const complexes = "â„‚";
const cong = "â‰…";
const congdot = "â©­";
const Congruent = "â‰¡";
const conint = "âˆ®";
const Conint = "âˆ¯";
const ContourIntegral = "âˆ®";
const copf = "ð•”";
const Copf = "â„‚";
const coprod = "âˆ";
const Coproduct = "âˆ";
const copy$1 = "Â©";
const COPY$1 = "Â©";
const copysr = "â„—";
const CounterClockwiseContourIntegral = "âˆ³";
const crarr = "â†µ";
const cross = "âœ—";
const Cross = "â¨¯";
const Cscr = "ð’ž";
const cscr = "ð’¸";
const csub = "â«";
const csube = "â«‘";
const csup = "â«";
const csupe = "â«’";
const ctdot = "â‹¯";
const cudarrl = "â¤¸";
const cudarrr = "â¤µ";
const cuepr = "â‹ž";
const cuesc = "â‹Ÿ";
const cularr = "â†¶";
const cularrp = "â¤½";
const cupbrcap = "â©ˆ";
const cupcap = "â©†";
const CupCap = "â‰";
const cup = "âˆª";
const Cup = "â‹“";
const cupcup = "â©Š";
const cupdot = "âŠ";
const cupor = "â©…";
const cups = "âˆªï¸€";
const curarr = "â†·";
const curarrm = "â¤¼";
const curlyeqprec = "â‹ž";
const curlyeqsucc = "â‹Ÿ";
const curlyvee = "â‹Ž";
const curlywedge = "â‹";
const curren$1 = "Â¤";
const curvearrowleft = "â†¶";
const curvearrowright = "â†·";
const cuvee = "â‹Ž";
const cuwed = "â‹";
const cwconint = "âˆ²";
const cwint = "âˆ±";
const cylcty = "âŒ­";
const dagger = "â€ ";
const Dagger = "â€¡";
const daleth = "â„¸";
const darr = "â†“";
const Darr = "â†¡";
const dArr = "â‡“";
const dash = "â€";
const Dashv = "â«¤";
const dashv = "âŠ£";
const dbkarow = "â¤";
const dblac = "Ë";
const Dcaron = "ÄŽ";
const dcaron = "Ä";
const Dcy = "Ð”";
const dcy = "Ð´";
const ddagger = "â€¡";
const ddarr = "â‡Š";
const DD = "â……";
const dd = "â…†";
const DDotrahd = "â¤‘";
const ddotseq = "â©·";
const deg$1 = "Â°";
const Del = "âˆ‡";
const Delta = "Î”";
const delta = "Î´";
const demptyv = "â¦±";
const dfisht = "â¥¿";
const Dfr = "ð”‡";
const dfr = "ð”¡";
const dHar = "â¥¥";
const dharl = "â‡ƒ";
const dharr = "â‡‚";
const DiacriticalAcute = "Â´";
const DiacriticalDot = "Ë™";
const DiacriticalDoubleAcute = "Ë";
const DiacriticalGrave = "`";
const DiacriticalTilde = "Ëœ";
const diam = "â‹„";
const diamond = "â‹„";
const Diamond = "â‹„";
const diamondsuit = "â™¦";
const diams = "â™¦";
const die = "Â¨";
const DifferentialD = "â…†";
const digamma = "Ï";
const disin = "â‹²";
const div = "Ã·";
const divide$1 = "Ã·";
const divideontimes = "â‹‡";
const divonx = "â‹‡";
const DJcy = "Ð‚";
const djcy = "Ñ’";
const dlcorn = "âŒž";
const dlcrop = "âŒ";
const dollar = "$";
const Dopf = "ð”»";
const dopf = "ð••";
const Dot = "Â¨";
const dot = "Ë™";
const DotDot = "âƒœ";
const doteq = "â‰";
const doteqdot = "â‰‘";
const DotEqual = "â‰";
const dotminus = "âˆ¸";
const dotplus = "âˆ”";
const dotsquare = "âŠ¡";
const doublebarwedge = "âŒ†";
const DoubleContourIntegral = "âˆ¯";
const DoubleDot = "Â¨";
const DoubleDownArrow = "â‡“";
const DoubleLeftArrow = "â‡";
const DoubleLeftRightArrow = "â‡”";
const DoubleLeftTee = "â«¤";
const DoubleLongLeftArrow = "âŸ¸";
const DoubleLongLeftRightArrow = "âŸº";
const DoubleLongRightArrow = "âŸ¹";
const DoubleRightArrow = "â‡’";
const DoubleRightTee = "âŠ¨";
const DoubleUpArrow = "â‡‘";
const DoubleUpDownArrow = "â‡•";
const DoubleVerticalBar = "âˆ¥";
const DownArrowBar = "â¤“";
const downarrow = "â†“";
const DownArrow = "â†“";
const Downarrow = "â‡“";
const DownArrowUpArrow = "â‡µ";
const DownBreve = "Ì‘";
const downdownarrows = "â‡Š";
const downharpoonleft = "â‡ƒ";
const downharpoonright = "â‡‚";
const DownLeftRightVector = "â¥";
const DownLeftTeeVector = "â¥ž";
const DownLeftVectorBar = "â¥–";
const DownLeftVector = "â†½";
const DownRightTeeVector = "â¥Ÿ";
const DownRightVectorBar = "â¥—";
const DownRightVector = "â‡";
const DownTeeArrow = "â†§";
const DownTee = "âŠ¤";
const drbkarow = "â¤";
const drcorn = "âŒŸ";
const drcrop = "âŒŒ";
const Dscr = "ð’Ÿ";
const dscr = "ð’¹";
const DScy = "Ð…";
const dscy = "Ñ•";
const dsol = "â§¶";
const Dstrok = "Ä";
const dstrok = "Ä‘";
const dtdot = "â‹±";
const dtri = "â–¿";
const dtrif = "â–¾";
const duarr = "â‡µ";
const duhar = "â¥¯";
const dwangle = "â¦¦";
const DZcy = "Ð";
const dzcy = "ÑŸ";
const dzigrarr = "âŸ¿";
const Eacute$1 = "Ã‰";
const eacute$1 = "Ã©";
const easter = "â©®";
const Ecaron = "Äš";
const ecaron = "Ä›";
const Ecirc$1 = "ÃŠ";
const ecirc$1 = "Ãª";
const ecir = "â‰–";
const ecolon = "â‰•";
const Ecy = "Ð­";
const ecy = "Ñ";
const eDDot = "â©·";
const Edot = "Ä–";
const edot = "Ä—";
const eDot = "â‰‘";
const ee = "â…‡";
const efDot = "â‰’";
const Efr = "ð”ˆ";
const efr = "ð”¢";
const eg = "âªš";
const Egrave$1 = "Ãˆ";
const egrave$1 = "Ã¨";
const egs = "âª–";
const egsdot = "âª˜";
const el = "âª™";
const Element = "âˆˆ";
const elinters = "â§";
const ell = "â„“";
const els = "âª•";
const elsdot = "âª—";
const Emacr = "Ä’";
const emacr = "Ä“";
const empty = "âˆ…";
const emptyset = "âˆ…";
const EmptySmallSquare = "â—»";
const emptyv = "âˆ…";
const EmptyVerySmallSquare = "â–«";
const emsp13 = "â€„";
const emsp14 = "â€…";
const emsp = "â€ƒ";
const ENG = "ÅŠ";
const eng = "Å‹";
const ensp = "â€‚";
const Eogon = "Ä˜";
const eogon = "Ä™";
const Eopf = "ð”¼";
const eopf = "ð•–";
const epar = "â‹•";
const eparsl = "â§£";
const eplus = "â©±";
const epsi = "Îµ";
const Epsilon = "Î•";
const epsilon = "Îµ";
const epsiv = "Ïµ";
const eqcirc = "â‰–";
const eqcolon = "â‰•";
const eqsim = "â‰‚";
const eqslantgtr = "âª–";
const eqslantless = "âª•";
const Equal = "â©µ";
const equals = "=";
const EqualTilde = "â‰‚";
const equest = "â‰Ÿ";
const Equilibrium = "â‡Œ";
const equiv = "â‰¡";
const equivDD = "â©¸";
const eqvparsl = "â§¥";
const erarr = "â¥±";
const erDot = "â‰“";
const escr = "â„¯";
const Escr = "â„°";
const esdot = "â‰";
const Esim = "â©³";
const esim = "â‰‚";
const Eta = "Î—";
const eta = "Î·";
const ETH$1 = "Ã";
const eth$1 = "Ã°";
const Euml$1 = "Ã‹";
const euml$1 = "Ã«";
const euro = "â‚¬";
const excl = "!";
const exist = "âˆƒ";
const Exists = "âˆƒ";
const expectation = "â„°";
const exponentiale = "â…‡";
const ExponentialE = "â…‡";
const fallingdotseq = "â‰’";
const Fcy = "Ð¤";
const fcy = "Ñ„";
const female = "â™€";
const ffilig = "ï¬ƒ";
const fflig = "ï¬€";
const ffllig = "ï¬„";
const Ffr = "ð”‰";
const ffr = "ð”£";
const filig = "ï¬";
const FilledSmallSquare = "â—¼";
const FilledVerySmallSquare = "â–ª";
const fjlig = "fj";
const flat = "â™­";
const fllig = "ï¬‚";
const fltns = "â–±";
const fnof = "Æ’";
const Fopf = "ð”½";
const fopf = "ð•—";
const forall = "âˆ€";
const ForAll = "âˆ€";
const fork = "â‹”";
const forkv = "â«™";
const Fouriertrf = "â„±";
const fpartint = "â¨";
const frac12$1 = "Â½";
const frac13 = "â…“";
const frac14$1 = "Â¼";
const frac15 = "â…•";
const frac16 = "â…™";
const frac18 = "â…›";
const frac23 = "â…”";
const frac25 = "â…–";
const frac34$1 = "Â¾";
const frac35 = "â…—";
const frac38 = "â…œ";
const frac45 = "â…˜";
const frac56 = "â…š";
const frac58 = "â…";
const frac78 = "â…ž";
const frasl = "â„";
const frown = "âŒ¢";
const fscr = "ð’»";
const Fscr = "â„±";
const gacute = "Çµ";
const Gamma = "Î“";
const gamma = "Î³";
const Gammad = "Ïœ";
const gammad = "Ï";
const gap = "âª†";
const Gbreve = "Äž";
const gbreve = "ÄŸ";
const Gcedil = "Ä¢";
const Gcirc = "Äœ";
const gcirc = "Ä";
const Gcy = "Ð“";
const gcy = "Ð³";
const Gdot = "Ä ";
const gdot = "Ä¡";
const ge = "â‰¥";
const gE = "â‰§";
const gEl = "âªŒ";
const gel = "â‹›";
const geq = "â‰¥";
const geqq = "â‰§";
const geqslant = "â©¾";
const gescc = "âª©";
const ges = "â©¾";
const gesdot = "âª€";
const gesdoto = "âª‚";
const gesdotol = "âª„";
const gesl = "â‹›ï¸€";
const gesles = "âª”";
const Gfr = "ð”Š";
const gfr = "ð”¤";
const gg = "â‰«";
const Gg = "â‹™";
const ggg = "â‹™";
const gimel = "â„·";
const GJcy = "Ðƒ";
const gjcy = "Ñ“";
const gla = "âª¥";
const gl = "â‰·";
const glE = "âª’";
const glj = "âª¤";
const gnap = "âªŠ";
const gnapprox = "âªŠ";
const gne = "âªˆ";
const gnE = "â‰©";
const gneq = "âªˆ";
const gneqq = "â‰©";
const gnsim = "â‹§";
const Gopf = "ð”¾";
const gopf = "ð•˜";
const grave = "`";
const GreaterEqual = "â‰¥";
const GreaterEqualLess = "â‹›";
const GreaterFullEqual = "â‰§";
const GreaterGreater = "âª¢";
const GreaterLess = "â‰·";
const GreaterSlantEqual = "â©¾";
const GreaterTilde = "â‰³";
const Gscr = "ð’¢";
const gscr = "â„Š";
const gsim = "â‰³";
const gsime = "âªŽ";
const gsiml = "âª";
const gtcc = "âª§";
const gtcir = "â©º";
const gt$2 = ">";
const GT$1 = ">";
const Gt = "â‰«";
const gtdot = "â‹—";
const gtlPar = "â¦•";
const gtquest = "â©¼";
const gtrapprox = "âª†";
const gtrarr = "â¥¸";
const gtrdot = "â‹—";
const gtreqless = "â‹›";
const gtreqqless = "âªŒ";
const gtrless = "â‰·";
const gtrsim = "â‰³";
const gvertneqq = "â‰©ï¸€";
const gvnE = "â‰©ï¸€";
const Hacek = "Ë‡";
const hairsp = "â€Š";
const half = "Â½";
const hamilt = "â„‹";
const HARDcy = "Ðª";
const hardcy = "ÑŠ";
const harrcir = "â¥ˆ";
const harr = "â†”";
const hArr = "â‡”";
const harrw = "â†­";
const Hat = "^";
const hbar = "â„";
const Hcirc = "Ä¤";
const hcirc = "Ä¥";
const hearts = "â™¥";
const heartsuit = "â™¥";
const hellip = "â€¦";
const hercon = "âŠ¹";
const hfr = "ð”¥";
const Hfr = "â„Œ";
const HilbertSpace = "â„‹";
const hksearow = "â¤¥";
const hkswarow = "â¤¦";
const hoarr = "â‡¿";
const homtht = "âˆ»";
const hookleftarrow = "â†©";
const hookrightarrow = "â†ª";
const hopf = "ð•™";
const Hopf = "â„";
const horbar = "â€•";
const HorizontalLine = "â”€";
const hscr = "ð’½";
const Hscr = "â„‹";
const hslash = "â„";
const Hstrok = "Ä¦";
const hstrok = "Ä§";
const HumpDownHump = "â‰Ž";
const HumpEqual = "â‰";
const hybull = "âƒ";
const hyphen = "â€";
const Iacute$1 = "Ã";
const iacute$1 = "Ã­";
const ic = "â£";
const Icirc$1 = "ÃŽ";
const icirc$1 = "Ã®";
const Icy = "Ð˜";
const icy = "Ð¸";
const Idot = "Ä°";
const IEcy = "Ð•";
const iecy = "Ðµ";
const iexcl$1 = "Â¡";
const iff = "â‡”";
const ifr = "ð”¦";
const Ifr = "â„‘";
const Igrave$1 = "ÃŒ";
const igrave$1 = "Ã¬";
const ii = "â…ˆ";
const iiiint = "â¨Œ";
const iiint = "âˆ­";
const iinfin = "â§œ";
const iiota = "â„©";
const IJlig = "Ä²";
const ijlig = "Ä³";
const Imacr = "Äª";
const imacr = "Ä«";
const image = "â„‘";
const ImaginaryI = "â…ˆ";
const imagline = "â„";
const imagpart = "â„‘";
const imath = "Ä±";
const Im = "â„‘";
const imof = "âŠ·";
const imped = "Æµ";
const Implies = "â‡’";
const incare = "â„…";
const infin = "âˆž";
const infintie = "â§";
const inodot = "Ä±";
const intcal = "âŠº";
const int = "âˆ«";
const Int = "âˆ¬";
const integers = "â„¤";
const Integral = "âˆ«";
const intercal = "âŠº";
const Intersection = "â‹‚";
const intlarhk = "â¨—";
const intprod = "â¨¼";
const InvisibleComma = "â£";
const InvisibleTimes = "â¢";
const IOcy = "Ð";
const iocy = "Ñ‘";
const Iogon = "Ä®";
const iogon = "Ä¯";
const Iopf = "ð•€";
const iopf = "ð•š";
const Iota = "Î™";
const iota = "Î¹";
const iprod = "â¨¼";
const iquest$1 = "Â¿";
const iscr = "ð’¾";
const Iscr = "â„";
const isin = "âˆˆ";
const isindot = "â‹µ";
const isinE = "â‹¹";
const isins = "â‹´";
const isinsv = "â‹³";
const isinv = "âˆˆ";
const it = "â¢";
const Itilde = "Ä¨";
const itilde = "Ä©";
const Iukcy = "Ð†";
const iukcy = "Ñ–";
const Iuml$1 = "Ã";
const iuml$1 = "Ã¯";
const Jcirc = "Ä´";
const jcirc = "Äµ";
const Jcy = "Ð™";
const jcy = "Ð¹";
const Jfr = "ð”";
const jfr = "ð”§";
const jmath = "È·";
const Jopf = "ð•";
const jopf = "ð•›";
const Jscr = "ð’¥";
const jscr = "ð’¿";
const Jsercy = "Ðˆ";
const jsercy = "Ñ˜";
const Jukcy = "Ð„";
const jukcy = "Ñ”";
const Kappa = "Îš";
const kappa = "Îº";
const kappav = "Ï°";
const Kcedil = "Ä¶";
const kcedil = "Ä·";
const Kcy = "Ðš";
const kcy = "Ðº";
const Kfr = "ð”Ž";
const kfr = "ð”¨";
const kgreen = "Ä¸";
const KHcy = "Ð¥";
const khcy = "Ñ…";
const KJcy = "ÐŒ";
const kjcy = "Ñœ";
const Kopf = "ð•‚";
const kopf = "ð•œ";
const Kscr = "ð’¦";
const kscr = "ð“€";
const lAarr = "â‡š";
const Lacute = "Ä¹";
const lacute = "Äº";
const laemptyv = "â¦´";
const lagran = "â„’";
const Lambda = "Î›";
const lambda = "Î»";
const lang = "âŸ¨";
const Lang = "âŸª";
const langd = "â¦‘";
const langle = "âŸ¨";
const lap = "âª…";
const Laplacetrf = "â„’";
const laquo$1 = "Â«";
const larrb = "â‡¤";
const larrbfs = "â¤Ÿ";
const larr = "â†";
const Larr = "â†ž";
const lArr = "â‡";
const larrfs = "â¤";
const larrhk = "â†©";
const larrlp = "â†«";
const larrpl = "â¤¹";
const larrsim = "â¥³";
const larrtl = "â†¢";
const latail = "â¤™";
const lAtail = "â¤›";
const lat = "âª«";
const late = "âª­";
const lates = "âª­ï¸€";
const lbarr = "â¤Œ";
const lBarr = "â¤Ž";
const lbbrk = "â²";
const lbrace = "{";
const lbrack = "[";
const lbrke = "â¦‹";
const lbrksld = "â¦";
const lbrkslu = "â¦";
const Lcaron = "Ä½";
const lcaron = "Ä¾";
const Lcedil = "Ä»";
const lcedil = "Ä¼";
const lceil = "âŒˆ";
const lcub = "{";
const Lcy = "Ð›";
const lcy = "Ð»";
const ldca = "â¤¶";
const ldquo = "â€œ";
const ldquor = "â€ž";
const ldrdhar = "â¥§";
const ldrushar = "â¥‹";
const ldsh = "â†²";
const le = "â‰¤";
const lE = "â‰¦";
const LeftAngleBracket = "âŸ¨";
const LeftArrowBar = "â‡¤";
const leftarrow = "â†";
const LeftArrow = "â†";
const Leftarrow = "â‡";
const LeftArrowRightArrow = "â‡†";
const leftarrowtail = "â†¢";
const LeftCeiling = "âŒˆ";
const LeftDoubleBracket = "âŸ¦";
const LeftDownTeeVector = "â¥¡";
const LeftDownVectorBar = "â¥™";
const LeftDownVector = "â‡ƒ";
const LeftFloor = "âŒŠ";
const leftharpoondown = "â†½";
const leftharpoonup = "â†¼";
const leftleftarrows = "â‡‡";
const leftrightarrow = "â†”";
const LeftRightArrow = "â†”";
const Leftrightarrow = "â‡”";
const leftrightarrows = "â‡†";
const leftrightharpoons = "â‡‹";
const leftrightsquigarrow = "â†­";
const LeftRightVector = "â¥Ž";
const LeftTeeArrow = "â†¤";
const LeftTee = "âŠ£";
const LeftTeeVector = "â¥š";
const leftthreetimes = "â‹‹";
const LeftTriangleBar = "â§";
const LeftTriangle = "âŠ²";
const LeftTriangleEqual = "âŠ´";
const LeftUpDownVector = "â¥‘";
const LeftUpTeeVector = "â¥ ";
const LeftUpVectorBar = "â¥˜";
const LeftUpVector = "â†¿";
const LeftVectorBar = "â¥’";
const LeftVector = "â†¼";
const lEg = "âª‹";
const leg = "â‹š";
const leq = "â‰¤";
const leqq = "â‰¦";
const leqslant = "â©½";
const lescc = "âª¨";
const les = "â©½";
const lesdot = "â©¿";
const lesdoto = "âª";
const lesdotor = "âªƒ";
const lesg = "â‹šï¸€";
const lesges = "âª“";
const lessapprox = "âª…";
const lessdot = "â‹–";
const lesseqgtr = "â‹š";
const lesseqqgtr = "âª‹";
const LessEqualGreater = "â‹š";
const LessFullEqual = "â‰¦";
const LessGreater = "â‰¶";
const lessgtr = "â‰¶";
const LessLess = "âª¡";
const lesssim = "â‰²";
const LessSlantEqual = "â©½";
const LessTilde = "â‰²";
const lfisht = "â¥¼";
const lfloor = "âŒŠ";
const Lfr = "ð”";
const lfr = "ð”©";
const lg = "â‰¶";
const lgE = "âª‘";
const lHar = "â¥¢";
const lhard = "â†½";
const lharu = "â†¼";
const lharul = "â¥ª";
const lhblk = "â–„";
const LJcy = "Ð‰";
const ljcy = "Ñ™";
const llarr = "â‡‡";
const ll = "â‰ª";
const Ll = "â‹˜";
const llcorner = "âŒž";
const Lleftarrow = "â‡š";
const llhard = "â¥«";
const lltri = "â—º";
const Lmidot = "Ä¿";
const lmidot = "Å€";
const lmoustache = "âŽ°";
const lmoust = "âŽ°";
const lnap = "âª‰";
const lnapprox = "âª‰";
const lne = "âª‡";
const lnE = "â‰¨";
const lneq = "âª‡";
const lneqq = "â‰¨";
const lnsim = "â‹¦";
const loang = "âŸ¬";
const loarr = "â‡½";
const lobrk = "âŸ¦";
const longleftarrow = "âŸµ";
const LongLeftArrow = "âŸµ";
const Longleftarrow = "âŸ¸";
const longleftrightarrow = "âŸ·";
const LongLeftRightArrow = "âŸ·";
const Longleftrightarrow = "âŸº";
const longmapsto = "âŸ¼";
const longrightarrow = "âŸ¶";
const LongRightArrow = "âŸ¶";
const Longrightarrow = "âŸ¹";
const looparrowleft = "â†«";
const looparrowright = "â†¬";
const lopar = "â¦…";
const Lopf = "ð•ƒ";
const lopf = "ð•";
const loplus = "â¨­";
const lotimes = "â¨´";
const lowast = "âˆ—";
const lowbar = "_";
const LowerLeftArrow = "â†™";
const LowerRightArrow = "â†˜";
const loz = "â—Š";
const lozenge = "â—Š";
const lozf = "â§«";
const lpar = "(";
const lparlt = "â¦“";
const lrarr = "â‡†";
const lrcorner = "âŒŸ";
const lrhar = "â‡‹";
const lrhard = "â¥­";
const lrm = "â€Ž";
const lrtri = "âŠ¿";
const lsaquo = "â€¹";
const lscr = "ð“";
const Lscr = "â„’";
const lsh = "â†°";
const Lsh = "â†°";
const lsim = "â‰²";
const lsime = "âª";
const lsimg = "âª";
const lsqb = "[";
const lsquo = "â€˜";
const lsquor = "â€š";
const Lstrok = "Å";
const lstrok = "Å‚";
const ltcc = "âª¦";
const ltcir = "â©¹";
const lt$2 = "<";
const LT$1 = "<";
const Lt = "â‰ª";
const ltdot = "â‹–";
const lthree = "â‹‹";
const ltimes = "â‹‰";
const ltlarr = "â¥¶";
const ltquest = "â©»";
const ltri = "â—ƒ";
const ltrie = "âŠ´";
const ltrif = "â—‚";
const ltrPar = "â¦–";
const lurdshar = "â¥Š";
const luruhar = "â¥¦";
const lvertneqq = "â‰¨ï¸€";
const lvnE = "â‰¨ï¸€";
const macr$1 = "Â¯";
const male = "â™‚";
const malt = "âœ ";
const maltese = "âœ ";
const map = "â†¦";
const mapsto = "â†¦";
const mapstodown = "â†§";
const mapstoleft = "â†¤";
const mapstoup = "â†¥";
const marker = "â–®";
const mcomma = "â¨©";
const Mcy = "Ðœ";
const mcy = "Ð¼";
const mdash = "â€”";
const mDDot = "âˆº";
const measuredangle = "âˆ¡";
const MediumSpace = "âŸ";
const Mellintrf = "â„³";
const Mfr = "ð”";
const mfr = "ð”ª";
const mho = "â„§";
const micro$1 = "Âµ";
const midast = "*";
const midcir = "â«°";
const mid = "âˆ£";
const middot$1 = "Â·";
const minusb = "âŠŸ";
const minus = "âˆ’";
const minusd = "âˆ¸";
const minusdu = "â¨ª";
const MinusPlus = "âˆ“";
const mlcp = "â«›";
const mldr = "â€¦";
const mnplus = "âˆ“";
const models = "âŠ§";
const Mopf = "ð•„";
const mopf = "ð•ž";
const mp = "âˆ“";
const mscr = "ð“‚";
const Mscr = "â„³";
const mstpos = "âˆ¾";
const Mu = "Îœ";
const mu = "Î¼";
const multimap = "âŠ¸";
const mumap = "âŠ¸";
const nabla = "âˆ‡";
const Nacute = "Åƒ";
const nacute = "Å„";
const nang = "âˆ âƒ’";
const nap = "â‰‰";
const napE = "â©°Ì¸";
const napid = "â‰‹Ì¸";
const napos = "Å‰";
const napprox = "â‰‰";
const natural = "â™®";
const naturals = "â„•";
const natur = "â™®";
const nbsp$1 = "Â ";
const nbump = "â‰ŽÌ¸";
const nbumpe = "â‰Ì¸";
const ncap = "â©ƒ";
const Ncaron = "Å‡";
const ncaron = "Åˆ";
const Ncedil = "Å…";
const ncedil = "Å†";
const ncong = "â‰‡";
const ncongdot = "â©­Ì¸";
const ncup = "â©‚";
const Ncy = "Ð";
const ncy = "Ð½";
const ndash = "â€“";
const nearhk = "â¤¤";
const nearr = "â†—";
const neArr = "â‡—";
const nearrow = "â†—";
const ne = "â‰ ";
const nedot = "â‰Ì¸";
const NegativeMediumSpace = "â€‹";
const NegativeThickSpace = "â€‹";
const NegativeThinSpace = "â€‹";
const NegativeVeryThinSpace = "â€‹";
const nequiv = "â‰¢";
const nesear = "â¤¨";
const nesim = "â‰‚Ì¸";
const NestedGreaterGreater = "â‰«";
const NestedLessLess = "â‰ª";
const NewLine = "\n";
const nexist = "âˆ„";
const nexists = "âˆ„";
const Nfr = "ð”‘";
const nfr = "ð”«";
const ngE = "â‰§Ì¸";
const nge = "â‰±";
const ngeq = "â‰±";
const ngeqq = "â‰§Ì¸";
const ngeqslant = "â©¾Ì¸";
const nges = "â©¾Ì¸";
const nGg = "â‹™Ì¸";
const ngsim = "â‰µ";
const nGt = "â‰«âƒ’";
const ngt = "â‰¯";
const ngtr = "â‰¯";
const nGtv = "â‰«Ì¸";
const nharr = "â†®";
const nhArr = "â‡Ž";
const nhpar = "â«²";
const ni = "âˆ‹";
const nis = "â‹¼";
const nisd = "â‹º";
const niv = "âˆ‹";
const NJcy = "ÐŠ";
const njcy = "Ñš";
const nlarr = "â†š";
const nlArr = "â‡";
const nldr = "â€¥";
const nlE = "â‰¦Ì¸";
const nle = "â‰°";
const nleftarrow = "â†š";
const nLeftarrow = "â‡";
const nleftrightarrow = "â†®";
const nLeftrightarrow = "â‡Ž";
const nleq = "â‰°";
const nleqq = "â‰¦Ì¸";
const nleqslant = "â©½Ì¸";
const nles = "â©½Ì¸";
const nless = "â‰®";
const nLl = "â‹˜Ì¸";
const nlsim = "â‰´";
const nLt = "â‰ªâƒ’";
const nlt = "â‰®";
const nltri = "â‹ª";
const nltrie = "â‹¬";
const nLtv = "â‰ªÌ¸";
const nmid = "âˆ¤";
const NoBreak = "â ";
const NonBreakingSpace = "Â ";
const nopf = "ð•Ÿ";
const Nopf = "â„•";
const Not = "â«¬";
const not$1 = "Â¬";
const NotCongruent = "â‰¢";
const NotCupCap = "â‰­";
const NotDoubleVerticalBar = "âˆ¦";
const NotElement = "âˆ‰";
const NotEqual = "â‰ ";
const NotEqualTilde = "â‰‚Ì¸";
const NotExists = "âˆ„";
const NotGreater = "â‰¯";
const NotGreaterEqual = "â‰±";
const NotGreaterFullEqual = "â‰§Ì¸";
const NotGreaterGreater = "â‰«Ì¸";
const NotGreaterLess = "â‰¹";
const NotGreaterSlantEqual = "â©¾Ì¸";
const NotGreaterTilde = "â‰µ";
const NotHumpDownHump = "â‰ŽÌ¸";
const NotHumpEqual = "â‰Ì¸";
const notin = "âˆ‰";
const notindot = "â‹µÌ¸";
const notinE = "â‹¹Ì¸";
const notinva = "âˆ‰";
const notinvb = "â‹·";
const notinvc = "â‹¶";
const NotLeftTriangleBar = "â§Ì¸";
const NotLeftTriangle = "â‹ª";
const NotLeftTriangleEqual = "â‹¬";
const NotLess = "â‰®";
const NotLessEqual = "â‰°";
const NotLessGreater = "â‰¸";
const NotLessLess = "â‰ªÌ¸";
const NotLessSlantEqual = "â©½Ì¸";
const NotLessTilde = "â‰´";
const NotNestedGreaterGreater = "âª¢Ì¸";
const NotNestedLessLess = "âª¡Ì¸";
const notni = "âˆŒ";
const notniva = "âˆŒ";
const notnivb = "â‹¾";
const notnivc = "â‹½";
const NotPrecedes = "âŠ€";
const NotPrecedesEqual = "âª¯Ì¸";
const NotPrecedesSlantEqual = "â‹ ";
const NotReverseElement = "âˆŒ";
const NotRightTriangleBar = "â§Ì¸";
const NotRightTriangle = "â‹«";
const NotRightTriangleEqual = "â‹­";
const NotSquareSubset = "âŠÌ¸";
const NotSquareSubsetEqual = "â‹¢";
const NotSquareSuperset = "âŠÌ¸";
const NotSquareSupersetEqual = "â‹£";
const NotSubset = "âŠ‚âƒ’";
const NotSubsetEqual = "âŠˆ";
const NotSucceeds = "âŠ";
const NotSucceedsEqual = "âª°Ì¸";
const NotSucceedsSlantEqual = "â‹¡";
const NotSucceedsTilde = "â‰¿Ì¸";
const NotSuperset = "âŠƒâƒ’";
const NotSupersetEqual = "âŠ‰";
const NotTilde = "â‰";
const NotTildeEqual = "â‰„";
const NotTildeFullEqual = "â‰‡";
const NotTildeTilde = "â‰‰";
const NotVerticalBar = "âˆ¤";
const nparallel = "âˆ¦";
const npar = "âˆ¦";
const nparsl = "â«½âƒ¥";
const npart = "âˆ‚Ì¸";
const npolint = "â¨”";
const npr = "âŠ€";
const nprcue = "â‹ ";
const nprec = "âŠ€";
const npreceq = "âª¯Ì¸";
const npre = "âª¯Ì¸";
const nrarrc = "â¤³Ì¸";
const nrarr = "â†›";
const nrArr = "â‡";
const nrarrw = "â†Ì¸";
const nrightarrow = "â†›";
const nRightarrow = "â‡";
const nrtri = "â‹«";
const nrtrie = "â‹­";
const nsc = "âŠ";
const nsccue = "â‹¡";
const nsce = "âª°Ì¸";
const Nscr = "ð’©";
const nscr = "ð“ƒ";
const nshortmid = "âˆ¤";
const nshortparallel = "âˆ¦";
const nsim = "â‰";
const nsime = "â‰„";
const nsimeq = "â‰„";
const nsmid = "âˆ¤";
const nspar = "âˆ¦";
const nsqsube = "â‹¢";
const nsqsupe = "â‹£";
const nsub = "âŠ„";
const nsubE = "â«…Ì¸";
const nsube = "âŠˆ";
const nsubset = "âŠ‚âƒ’";
const nsubseteq = "âŠˆ";
const nsubseteqq = "â«…Ì¸";
const nsucc = "âŠ";
const nsucceq = "âª°Ì¸";
const nsup = "âŠ…";
const nsupE = "â«†Ì¸";
const nsupe = "âŠ‰";
const nsupset = "âŠƒâƒ’";
const nsupseteq = "âŠ‰";
const nsupseteqq = "â«†Ì¸";
const ntgl = "â‰¹";
const Ntilde$1 = "Ã‘";
const ntilde$1 = "Ã±";
const ntlg = "â‰¸";
const ntriangleleft = "â‹ª";
const ntrianglelefteq = "â‹¬";
const ntriangleright = "â‹«";
const ntrianglerighteq = "â‹­";
const Nu = "Î";
const nu = "Î½";
const num = "#";
const numero = "â„–";
const numsp = "â€‡";
const nvap = "â‰âƒ’";
const nvdash = "âŠ¬";
const nvDash = "âŠ­";
const nVdash = "âŠ®";
const nVDash = "âŠ¯";
const nvge = "â‰¥âƒ’";
const nvgt = ">âƒ’";
const nvHarr = "â¤„";
const nvinfin = "â§ž";
const nvlArr = "â¤‚";
const nvle = "â‰¤âƒ’";
const nvlt = "<âƒ’";
const nvltrie = "âŠ´âƒ’";
const nvrArr = "â¤ƒ";
const nvrtrie = "âŠµâƒ’";
const nvsim = "âˆ¼âƒ’";
const nwarhk = "â¤£";
const nwarr = "â†–";
const nwArr = "â‡–";
const nwarrow = "â†–";
const nwnear = "â¤§";
const Oacute$1 = "Ã“";
const oacute$1 = "Ã³";
const oast = "âŠ›";
const Ocirc$1 = "Ã”";
const ocirc$1 = "Ã´";
const ocir = "âŠš";
const Ocy = "Ðž";
const ocy = "Ð¾";
const odash = "âŠ";
const Odblac = "Å";
const odblac = "Å‘";
const odiv = "â¨¸";
const odot = "âŠ™";
const odsold = "â¦¼";
const OElig = "Å’";
const oelig = "Å“";
const ofcir = "â¦¿";
const Ofr = "ð”’";
const ofr = "ð”¬";
const ogon = "Ë›";
const Ograve$1 = "Ã’";
const ograve$1 = "Ã²";
const ogt = "â§";
const ohbar = "â¦µ";
const ohm = "Î©";
const oint = "âˆ®";
const olarr = "â†º";
const olcir = "â¦¾";
const olcross = "â¦»";
const oline = "â€¾";
const olt = "â§€";
const Omacr = "ÅŒ";
const omacr = "Å";
const Omega = "Î©";
const omega = "Ï‰";
const Omicron = "ÎŸ";
const omicron = "Î¿";
const omid = "â¦¶";
const ominus = "âŠ–";
const Oopf = "ð•†";
const oopf = "ð• ";
const opar = "â¦·";
const OpenCurlyDoubleQuote = "â€œ";
const OpenCurlyQuote = "â€˜";
const operp = "â¦¹";
const oplus = "âŠ•";
const orarr = "â†»";
const Or = "â©”";
const or = "âˆ¨";
const ord = "â©";
const order = "â„´";
const orderof = "â„´";
const ordf$1 = "Âª";
const ordm$1 = "Âº";
const origof = "âŠ¶";
const oror = "â©–";
const orslope = "â©—";
const orv = "â©›";
const oS = "â“ˆ";
const Oscr = "ð’ª";
const oscr = "â„´";
const Oslash$1 = "Ã˜";
const oslash$1 = "Ã¸";
const osol = "âŠ˜";
const Otilde$1 = "Ã•";
const otilde$1 = "Ãµ";
const otimesas = "â¨¶";
const Otimes = "â¨·";
const otimes = "âŠ—";
const Ouml$1 = "Ã–";
const ouml$1 = "Ã¶";
const ovbar = "âŒ½";
const OverBar = "â€¾";
const OverBrace = "âž";
const OverBracket = "âŽ´";
const OverParenthesis = "âœ";
const para$1 = "Â¶";
const parallel = "âˆ¥";
const par = "âˆ¥";
const parsim = "â«³";
const parsl = "â«½";
const part = "âˆ‚";
const PartialD = "âˆ‚";
const Pcy = "ÐŸ";
const pcy = "Ð¿";
const percnt = "%";
const period = ".";
const permil = "â€°";
const perp = "âŠ¥";
const pertenk = "â€±";
const Pfr = "ð”“";
const pfr = "ð”­";
const Phi = "Î¦";
const phi = "Ï†";
const phiv = "Ï•";
const phmmat = "â„³";
const phone = "â˜Ž";
const Pi = "Î ";
const pi = "Ï€";
const pitchfork = "â‹”";
const piv = "Ï–";
const planck = "â„";
const planckh = "â„Ž";
const plankv = "â„";
const plusacir = "â¨£";
const plusb = "âŠž";
const pluscir = "â¨¢";
const plus = "+";
const plusdo = "âˆ”";
const plusdu = "â¨¥";
const pluse = "â©²";
const PlusMinus = "Â±";
const plusmn$1 = "Â±";
const plussim = "â¨¦";
const plustwo = "â¨§";
const pm = "Â±";
const Poincareplane = "â„Œ";
const pointint = "â¨•";
const popf = "ð•¡";
const Popf = "â„™";
const pound$1 = "Â£";
const prap = "âª·";
const Pr = "âª»";
const pr = "â‰º";
const prcue = "â‰¼";
const precapprox = "âª·";
const prec = "â‰º";
const preccurlyeq = "â‰¼";
const Precedes = "â‰º";
const PrecedesEqual = "âª¯";
const PrecedesSlantEqual = "â‰¼";
const PrecedesTilde = "â‰¾";
const preceq = "âª¯";
const precnapprox = "âª¹";
const precneqq = "âªµ";
const precnsim = "â‹¨";
const pre = "âª¯";
const prE = "âª³";
const precsim = "â‰¾";
const prime = "â€²";
const Prime = "â€³";
const primes = "â„™";
const prnap = "âª¹";
const prnE = "âªµ";
const prnsim = "â‹¨";
const prod = "âˆ";
const Product = "âˆ";
const profalar = "âŒ®";
const profline = "âŒ’";
const profsurf = "âŒ“";
const prop = "âˆ";
const Proportional = "âˆ";
const Proportion = "âˆ·";
const propto = "âˆ";
const prsim = "â‰¾";
const prurel = "âŠ°";
const Pscr = "ð’«";
const pscr = "ð“…";
const Psi = "Î¨";
const psi = "Ïˆ";
const puncsp = "â€ˆ";
const Qfr = "ð””";
const qfr = "ð”®";
const qint = "â¨Œ";
const qopf = "ð•¢";
const Qopf = "â„š";
const qprime = "â—";
const Qscr = "ð’¬";
const qscr = "ð“†";
const quaternions = "â„";
const quatint = "â¨–";
const quest = "?";
const questeq = "â‰Ÿ";
const quot$2 = '"';
const QUOT$1 = '"';
const rAarr = "â‡›";
const race = "âˆ½Ì±";
const Racute = "Å”";
const racute = "Å•";
const radic = "âˆš";
const raemptyv = "â¦³";
const rang = "âŸ©";
const Rang = "âŸ«";
const rangd = "â¦’";
const range = "â¦¥";
const rangle = "âŸ©";
const raquo$1 = "Â»";
const rarrap = "â¥µ";
const rarrb = "â‡¥";
const rarrbfs = "â¤ ";
const rarrc = "â¤³";
const rarr = "â†’";
const Rarr = "â† ";
const rArr = "â‡’";
const rarrfs = "â¤ž";
const rarrhk = "â†ª";
const rarrlp = "â†¬";
const rarrpl = "â¥…";
const rarrsim = "â¥´";
const Rarrtl = "â¤–";
const rarrtl = "â†£";
const rarrw = "â†";
const ratail = "â¤š";
const rAtail = "â¤œ";
const ratio = "âˆ¶";
const rationals = "â„š";
const rbarr = "â¤";
const rBarr = "â¤";
const RBarr = "â¤";
const rbbrk = "â³";
const rbrace = "}";
const rbrack = "]";
const rbrke = "â¦Œ";
const rbrksld = "â¦Ž";
const rbrkslu = "â¦";
const Rcaron = "Å˜";
const rcaron = "Å™";
const Rcedil = "Å–";
const rcedil = "Å—";
const rceil = "âŒ‰";
const rcub = "}";
const Rcy = "Ð ";
const rcy = "Ñ€";
const rdca = "â¤·";
const rdldhar = "â¥©";
const rdquo = "â€";
const rdquor = "â€";
const rdsh = "â†³";
const real = "â„œ";
const realine = "â„›";
const realpart = "â„œ";
const reals = "â„";
const Re = "â„œ";
const rect = "â–­";
const reg$1 = "Â®";
const REG$1 = "Â®";
const ReverseElement = "âˆ‹";
const ReverseEquilibrium = "â‡‹";
const ReverseUpEquilibrium = "â¥¯";
const rfisht = "â¥½";
const rfloor = "âŒ‹";
const rfr = "ð”¯";
const Rfr = "â„œ";
const rHar = "â¥¤";
const rhard = "â‡";
const rharu = "â‡€";
const rharul = "â¥¬";
const Rho = "Î¡";
const rho = "Ï";
const rhov = "Ï±";
const RightAngleBracket = "âŸ©";
const RightArrowBar = "â‡¥";
const rightarrow = "â†’";
const RightArrow = "â†’";
const Rightarrow = "â‡’";
const RightArrowLeftArrow = "â‡„";
const rightarrowtail = "â†£";
const RightCeiling = "âŒ‰";
const RightDoubleBracket = "âŸ§";
const RightDownTeeVector = "â¥";
const RightDownVectorBar = "â¥•";
const RightDownVector = "â‡‚";
const RightFloor = "âŒ‹";
const rightharpoondown = "â‡";
const rightharpoonup = "â‡€";
const rightleftarrows = "â‡„";
const rightleftharpoons = "â‡Œ";
const rightrightarrows = "â‡‰";
const rightsquigarrow = "â†";
const RightTeeArrow = "â†¦";
const RightTee = "âŠ¢";
const RightTeeVector = "â¥›";
const rightthreetimes = "â‹Œ";
const RightTriangleBar = "â§";
const RightTriangle = "âŠ³";
const RightTriangleEqual = "âŠµ";
const RightUpDownVector = "â¥";
const RightUpTeeVector = "â¥œ";
const RightUpVectorBar = "â¥”";
const RightUpVector = "â†¾";
const RightVectorBar = "â¥“";
const RightVector = "â‡€";
const ring = "Ëš";
const risingdotseq = "â‰“";
const rlarr = "â‡„";
const rlhar = "â‡Œ";
const rlm = "â€";
const rmoustache = "âŽ±";
const rmoust = "âŽ±";
const rnmid = "â«®";
const roang = "âŸ­";
const roarr = "â‡¾";
const robrk = "âŸ§";
const ropar = "â¦†";
const ropf = "ð•£";
const Ropf = "â„";
const roplus = "â¨®";
const rotimes = "â¨µ";
const RoundImplies = "â¥°";
const rpar = ")";
const rpargt = "â¦”";
const rppolint = "â¨’";
const rrarr = "â‡‰";
const Rrightarrow = "â‡›";
const rsaquo = "â€º";
const rscr = "ð“‡";
const Rscr = "â„›";
const rsh = "â†±";
const Rsh = "â†±";
const rsqb = "]";
const rsquo = "â€™";
const rsquor = "â€™";
const rthree = "â‹Œ";
const rtimes = "â‹Š";
const rtri = "â–¹";
const rtrie = "âŠµ";
const rtrif = "â–¸";
const rtriltri = "â§Ž";
const RuleDelayed = "â§´";
const ruluhar = "â¥¨";
const rx = "â„ž";
const Sacute = "Åš";
const sacute = "Å›";
const sbquo = "â€š";
const scap = "âª¸";
const Scaron = "Å ";
const scaron = "Å¡";
const Sc = "âª¼";
const sc = "â‰»";
const sccue = "â‰½";
const sce = "âª°";
const scE = "âª´";
const Scedil = "Åž";
const scedil = "ÅŸ";
const Scirc = "Åœ";
const scirc = "Å";
const scnap = "âªº";
const scnE = "âª¶";
const scnsim = "â‹©";
const scpolint = "â¨“";
const scsim = "â‰¿";
const Scy = "Ð¡";
const scy = "Ñ";
const sdotb = "âŠ¡";
const sdot = "â‹…";
const sdote = "â©¦";
const searhk = "â¤¥";
const searr = "â†˜";
const seArr = "â‡˜";
const searrow = "â†˜";
const sect$1 = "Â§";
const semi = ";";
const seswar = "â¤©";
const setminus = "âˆ–";
const setmn = "âˆ–";
const sext = "âœ¶";
const Sfr = "ð”–";
const sfr = "ð”°";
const sfrown = "âŒ¢";
const sharp = "â™¯";
const SHCHcy = "Ð©";
const shchcy = "Ñ‰";
const SHcy = "Ð¨";
const shcy = "Ñˆ";
const ShortDownArrow = "â†“";
const ShortLeftArrow = "â†";
const shortmid = "âˆ£";
const shortparallel = "âˆ¥";
const ShortRightArrow = "â†’";
const ShortUpArrow = "â†‘";
const shy$1 = "Â­";
const Sigma = "Î£";
const sigma = "Ïƒ";
const sigmaf = "Ï‚";
const sigmav = "Ï‚";
const sim = "âˆ¼";
const simdot = "â©ª";
const sime = "â‰ƒ";
const simeq = "â‰ƒ";
const simg = "âªž";
const simgE = "âª ";
const siml = "âª";
const simlE = "âªŸ";
const simne = "â‰†";
const simplus = "â¨¤";
const simrarr = "â¥²";
const slarr = "â†";
const SmallCircle = "âˆ˜";
const smallsetminus = "âˆ–";
const smashp = "â¨³";
const smeparsl = "â§¤";
const smid = "âˆ£";
const smile = "âŒ£";
const smt = "âªª";
const smte = "âª¬";
const smtes = "âª¬ï¸€";
const SOFTcy = "Ð¬";
const softcy = "ÑŒ";
const solbar = "âŒ¿";
const solb = "â§„";
const sol = "/";
const Sopf = "ð•Š";
const sopf = "ð•¤";
const spades = "â™ ";
const spadesuit = "â™ ";
const spar = "âˆ¥";
const sqcap = "âŠ“";
const sqcaps = "âŠ“ï¸€";
const sqcup = "âŠ”";
const sqcups = "âŠ”ï¸€";
const Sqrt = "âˆš";
const sqsub = "âŠ";
const sqsube = "âŠ‘";
const sqsubset = "âŠ";
const sqsubseteq = "âŠ‘";
const sqsup = "âŠ";
const sqsupe = "âŠ’";
const sqsupset = "âŠ";
const sqsupseteq = "âŠ’";
const square = "â–¡";
const Square = "â–¡";
const SquareIntersection = "âŠ“";
const SquareSubset = "âŠ";
const SquareSubsetEqual = "âŠ‘";
const SquareSuperset = "âŠ";
const SquareSupersetEqual = "âŠ’";
const SquareUnion = "âŠ”";
const squarf = "â–ª";
const squ = "â–¡";
const squf = "â–ª";
const srarr = "â†’";
const Sscr = "ð’®";
const sscr = "ð“ˆ";
const ssetmn = "âˆ–";
const ssmile = "âŒ£";
const sstarf = "â‹†";
const Star = "â‹†";
const star = "â˜†";
const starf = "â˜…";
const straightepsilon = "Ïµ";
const straightphi = "Ï•";
const strns = "Â¯";
const sub = "âŠ‚";
const Sub = "â‹";
const subdot = "âª½";
const subE = "â«…";
const sube = "âŠ†";
const subedot = "â«ƒ";
const submult = "â«";
const subnE = "â«‹";
const subne = "âŠŠ";
const subplus = "âª¿";
const subrarr = "â¥¹";
const subset = "âŠ‚";
const Subset = "â‹";
const subseteq = "âŠ†";
const subseteqq = "â«…";
const SubsetEqual = "âŠ†";
const subsetneq = "âŠŠ";
const subsetneqq = "â«‹";
const subsim = "â«‡";
const subsub = "â«•";
const subsup = "â«“";
const succapprox = "âª¸";
const succ = "â‰»";
const succcurlyeq = "â‰½";
const Succeeds = "â‰»";
const SucceedsEqual = "âª°";
const SucceedsSlantEqual = "â‰½";
const SucceedsTilde = "â‰¿";
const succeq = "âª°";
const succnapprox = "âªº";
const succneqq = "âª¶";
const succnsim = "â‹©";
const succsim = "â‰¿";
const SuchThat = "âˆ‹";
const sum = "âˆ‘";
const Sum = "âˆ‘";
const sung = "â™ª";
const sup1$1 = "Â¹";
const sup2$1 = "Â²";
const sup3$1 = "Â³";
const sup = "âŠƒ";
const Sup = "â‹‘";
const supdot = "âª¾";
const supdsub = "â«˜";
const supE = "â«†";
const supe = "âŠ‡";
const supedot = "â«„";
const Superset = "âŠƒ";
const SupersetEqual = "âŠ‡";
const suphsol = "âŸ‰";
const suphsub = "â«—";
const suplarr = "â¥»";
const supmult = "â«‚";
const supnE = "â«Œ";
const supne = "âŠ‹";
const supplus = "â«€";
const supset = "âŠƒ";
const Supset = "â‹‘";
const supseteq = "âŠ‡";
const supseteqq = "â«†";
const supsetneq = "âŠ‹";
const supsetneqq = "â«Œ";
const supsim = "â«ˆ";
const supsub = "â«”";
const supsup = "â«–";
const swarhk = "â¤¦";
const swarr = "â†™";
const swArr = "â‡™";
const swarrow = "â†™";
const swnwar = "â¤ª";
const szlig$1 = "ÃŸ";
const Tab = "	";
const target = "âŒ–";
const Tau = "Î¤";
const tau = "Ï„";
const tbrk = "âŽ´";
const Tcaron = "Å¤";
const tcaron = "Å¥";
const Tcedil = "Å¢";
const tcedil = "Å£";
const Tcy = "Ð¢";
const tcy = "Ñ‚";
const tdot = "âƒ›";
const telrec = "âŒ•";
const Tfr = "ð”—";
const tfr = "ð”±";
const there4 = "âˆ´";
const therefore = "âˆ´";
const Therefore = "âˆ´";
const Theta = "Î˜";
const theta = "Î¸";
const thetasym = "Ï‘";
const thetav = "Ï‘";
const thickapprox = "â‰ˆ";
const thicksim = "âˆ¼";
const ThickSpace = "âŸâ€Š";
const ThinSpace = "â€‰";
const thinsp = "â€‰";
const thkap = "â‰ˆ";
const thksim = "âˆ¼";
const THORN$1 = "Ãž";
const thorn$1 = "Ã¾";
const tilde = "Ëœ";
const Tilde = "âˆ¼";
const TildeEqual = "â‰ƒ";
const TildeFullEqual = "â‰…";
const TildeTilde = "â‰ˆ";
const timesbar = "â¨±";
const timesb = "âŠ ";
const times$1 = "Ã—";
const timesd = "â¨°";
const tint = "âˆ­";
const toea = "â¤¨";
const topbot = "âŒ¶";
const topcir = "â«±";
const top = "âŠ¤";
const Topf = "ð•‹";
const topf = "ð•¥";
const topfork = "â«š";
const tosa = "â¤©";
const tprime = "â€´";
const trade = "â„¢";
const TRADE = "â„¢";
const triangle = "â–µ";
const triangledown = "â–¿";
const triangleleft = "â—ƒ";
const trianglelefteq = "âŠ´";
const triangleq = "â‰œ";
const triangleright = "â–¹";
const trianglerighteq = "âŠµ";
const tridot = "â—¬";
const trie = "â‰œ";
const triminus = "â¨º";
const TripleDot = "âƒ›";
const triplus = "â¨¹";
const trisb = "â§";
const tritime = "â¨»";
const trpezium = "â¢";
const Tscr = "ð’¯";
const tscr = "ð“‰";
const TScy = "Ð¦";
const tscy = "Ñ†";
const TSHcy = "Ð‹";
const tshcy = "Ñ›";
const Tstrok = "Å¦";
const tstrok = "Å§";
const twixt = "â‰¬";
const twoheadleftarrow = "â†ž";
const twoheadrightarrow = "â† ";
const Uacute$1 = "Ãš";
const uacute$1 = "Ãº";
const uarr = "â†‘";
const Uarr = "â†Ÿ";
const uArr = "â‡‘";
const Uarrocir = "â¥‰";
const Ubrcy = "ÐŽ";
const ubrcy = "Ñž";
const Ubreve = "Å¬";
const ubreve = "Å­";
const Ucirc$1 = "Ã›";
const ucirc$1 = "Ã»";
const Ucy = "Ð£";
const ucy = "Ñƒ";
const udarr = "â‡…";
const Udblac = "Å°";
const udblac = "Å±";
const udhar = "â¥®";
const ufisht = "â¥¾";
const Ufr = "ð”˜";
const ufr = "ð”²";
const Ugrave$1 = "Ã™";
const ugrave$1 = "Ã¹";
const uHar = "â¥£";
const uharl = "â†¿";
const uharr = "â†¾";
const uhblk = "â–€";
const ulcorn = "âŒœ";
const ulcorner = "âŒœ";
const ulcrop = "âŒ";
const ultri = "â—¸";
const Umacr = "Åª";
const umacr = "Å«";
const uml$1 = "Â¨";
const UnderBar = "_";
const UnderBrace = "âŸ";
const UnderBracket = "âŽµ";
const UnderParenthesis = "â";
const Union = "â‹ƒ";
const UnionPlus = "âŠŽ";
const Uogon = "Å²";
const uogon = "Å³";
const Uopf = "ð•Œ";
const uopf = "ð•¦";
const UpArrowBar = "â¤’";
const uparrow = "â†‘";
const UpArrow = "â†‘";
const Uparrow = "â‡‘";
const UpArrowDownArrow = "â‡…";
const updownarrow = "â†•";
const UpDownArrow = "â†•";
const Updownarrow = "â‡•";
const UpEquilibrium = "â¥®";
const upharpoonleft = "â†¿";
const upharpoonright = "â†¾";
const uplus = "âŠŽ";
const UpperLeftArrow = "â†–";
const UpperRightArrow = "â†—";
const upsi = "Ï…";
const Upsi = "Ï’";
const upsih = "Ï’";
const Upsilon = "Î¥";
const upsilon = "Ï…";
const UpTeeArrow = "â†¥";
const UpTee = "âŠ¥";
const upuparrows = "â‡ˆ";
const urcorn = "âŒ";
const urcorner = "âŒ";
const urcrop = "âŒŽ";
const Uring = "Å®";
const uring = "Å¯";
const urtri = "â—¹";
const Uscr = "ð’°";
const uscr = "ð“Š";
const utdot = "â‹°";
const Utilde = "Å¨";
const utilde = "Å©";
const utri = "â–µ";
const utrif = "â–´";
const uuarr = "â‡ˆ";
const Uuml$1 = "Ãœ";
const uuml$1 = "Ã¼";
const uwangle = "â¦§";
const vangrt = "â¦œ";
const varepsilon = "Ïµ";
const varkappa = "Ï°";
const varnothing = "âˆ…";
const varphi = "Ï•";
const varpi = "Ï–";
const varpropto = "âˆ";
const varr = "â†•";
const vArr = "â‡•";
const varrho = "Ï±";
const varsigma = "Ï‚";
const varsubsetneq = "âŠŠï¸€";
const varsubsetneqq = "â«‹ï¸€";
const varsupsetneq = "âŠ‹ï¸€";
const varsupsetneqq = "â«Œï¸€";
const vartheta = "Ï‘";
const vartriangleleft = "âŠ²";
const vartriangleright = "âŠ³";
const vBar = "â«¨";
const Vbar = "â««";
const vBarv = "â«©";
const Vcy = "Ð’";
const vcy = "Ð²";
const vdash = "âŠ¢";
const vDash = "âŠ¨";
const Vdash = "âŠ©";
const VDash = "âŠ«";
const Vdashl = "â«¦";
const veebar = "âŠ»";
const vee = "âˆ¨";
const Vee = "â‹";
const veeeq = "â‰š";
const vellip = "â‹®";
const verbar = "|";
const Verbar = "â€–";
const vert = "|";
const Vert = "â€–";
const VerticalBar = "âˆ£";
const VerticalLine = "|";
const VerticalSeparator = "â˜";
const VerticalTilde = "â‰€";
const VeryThinSpace = "â€Š";
const Vfr = "ð”™";
const vfr = "ð”³";
const vltri = "âŠ²";
const vnsub = "âŠ‚âƒ’";
const vnsup = "âŠƒâƒ’";
const Vopf = "ð•";
const vopf = "ð•§";
const vprop = "âˆ";
const vrtri = "âŠ³";
const Vscr = "ð’±";
const vscr = "ð“‹";
const vsubnE = "â«‹ï¸€";
const vsubne = "âŠŠï¸€";
const vsupnE = "â«Œï¸€";
const vsupne = "âŠ‹ï¸€";
const Vvdash = "âŠª";
const vzigzag = "â¦š";
const Wcirc = "Å´";
const wcirc = "Åµ";
const wedbar = "â©Ÿ";
const wedge = "âˆ§";
const Wedge = "â‹€";
const wedgeq = "â‰™";
const weierp = "â„˜";
const Wfr = "ð”š";
const wfr = "ð”´";
const Wopf = "ð•Ž";
const wopf = "ð•¨";
const wp = "â„˜";
const wr = "â‰€";
const wreath = "â‰€";
const Wscr = "ð’²";
const wscr = "ð“Œ";
const xcap = "â‹‚";
const xcirc = "â—¯";
const xcup = "â‹ƒ";
const xdtri = "â–½";
const Xfr = "ð”›";
const xfr = "ð”µ";
const xharr = "âŸ·";
const xhArr = "âŸº";
const Xi = "Îž";
const xi = "Î¾";
const xlarr = "âŸµ";
const xlArr = "âŸ¸";
const xmap = "âŸ¼";
const xnis = "â‹»";
const xodot = "â¨€";
const Xopf = "ð•";
const xopf = "ð•©";
const xoplus = "â¨";
const xotime = "â¨‚";
const xrarr = "âŸ¶";
const xrArr = "âŸ¹";
const Xscr = "ð’³";
const xscr = "ð“";
const xsqcup = "â¨†";
const xuplus = "â¨„";
const xutri = "â–³";
const xvee = "â‹";
const xwedge = "â‹€";
const Yacute$1 = "Ã";
const yacute$1 = "Ã½";
const YAcy = "Ð¯";
const yacy = "Ñ";
const Ycirc = "Å¶";
const ycirc = "Å·";
const Ycy = "Ð«";
const ycy = "Ñ‹";
const yen$1 = "Â¥";
const Yfr = "ð”œ";
const yfr = "ð”¶";
const YIcy = "Ð‡";
const yicy = "Ñ—";
const Yopf = "ð•";
const yopf = "ð•ª";
const Yscr = "ð’´";
const yscr = "ð“Ž";
const YUcy = "Ð®";
const yucy = "ÑŽ";
const yuml$1 = "Ã¿";
const Yuml = "Å¸";
const Zacute = "Å¹";
const zacute = "Åº";
const Zcaron = "Å½";
const zcaron = "Å¾";
const Zcy = "Ð—";
const zcy = "Ð·";
const Zdot = "Å»";
const zdot = "Å¼";
const zeetrf = "â„¨";
const ZeroWidthSpace = "â€‹";
const Zeta = "Î–";
const zeta = "Î¶";
const zfr = "ð”·";
const Zfr = "â„¨";
const ZHcy = "Ð–";
const zhcy = "Ð¶";
const zigrarr = "â‡";
const zopf = "ð•«";
const Zopf = "â„¤";
const Zscr = "ð’µ";
const zscr = "ð“";
const zwj = "â€";
const zwnj = "â€Œ";
const require$$1$1 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$2,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "âˆˆ",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  "Map": "â¤…",
  map,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
const Aacute = "Ã";
const aacute = "Ã¡";
const Acirc = "Ã‚";
const acirc = "Ã¢";
const acute = "Â´";
const AElig = "Ã†";
const aelig = "Ã¦";
const Agrave = "Ã€";
const agrave = "Ã ";
const amp$1 = "&";
const AMP = "&";
const Aring = "Ã…";
const aring = "Ã¥";
const Atilde = "Ãƒ";
const atilde = "Ã£";
const Auml = "Ã„";
const auml = "Ã¤";
const brvbar = "Â¦";
const Ccedil = "Ã‡";
const ccedil = "Ã§";
const cedil = "Â¸";
const cent = "Â¢";
const copy = "Â©";
const COPY = "Â©";
const curren = "Â¤";
const deg = "Â°";
const divide = "Ã·";
const Eacute = "Ã‰";
const eacute = "Ã©";
const Ecirc = "ÃŠ";
const ecirc = "Ãª";
const Egrave = "Ãˆ";
const egrave = "Ã¨";
const ETH = "Ã";
const eth = "Ã°";
const Euml = "Ã‹";
const euml = "Ã«";
const frac12 = "Â½";
const frac14 = "Â¼";
const frac34 = "Â¾";
const gt$1 = ">";
const GT = ">";
const Iacute = "Ã";
const iacute = "Ã­";
const Icirc = "ÃŽ";
const icirc = "Ã®";
const iexcl = "Â¡";
const Igrave = "ÃŒ";
const igrave = "Ã¬";
const iquest = "Â¿";
const Iuml = "Ã";
const iuml = "Ã¯";
const laquo = "Â«";
const lt$1 = "<";
const LT = "<";
const macr = "Â¯";
const micro = "Âµ";
const middot = "Â·";
const nbsp = "Â ";
const not = "Â¬";
const Ntilde = "Ã‘";
const ntilde = "Ã±";
const Oacute = "Ã“";
const oacute = "Ã³";
const Ocirc = "Ã”";
const ocirc = "Ã´";
const Ograve = "Ã’";
const ograve = "Ã²";
const ordf = "Âª";
const ordm = "Âº";
const Oslash = "Ã˜";
const oslash = "Ã¸";
const Otilde = "Ã•";
const otilde = "Ãµ";
const Ouml = "Ã–";
const ouml = "Ã¶";
const para = "Â¶";
const plusmn = "Â±";
const pound = "Â£";
const quot$1 = '"';
const QUOT = '"';
const raquo = "Â»";
const reg = "Â®";
const REG = "Â®";
const sect = "Â§";
const shy = "Â­";
const sup1 = "Â¹";
const sup2 = "Â²";
const sup3 = "Â³";
const szlig = "ÃŸ";
const THORN = "Ãž";
const thorn = "Ã¾";
const times = "Ã—";
const Uacute = "Ãš";
const uacute = "Ãº";
const Ucirc = "Ã›";
const ucirc = "Ã»";
const Ugrave = "Ã™";
const ugrave = "Ã¹";
const uml = "Â¨";
const Uuml = "Ãœ";
const uuml = "Ã¼";
const Yacute = "Ã";
const yacute = "Ã½";
const yen = "Â¥";
const yuml = "Ã¿";
const require$$1 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$1,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml
};
const amp = "&";
const apos = "'";
const gt = ">";
const lt = "<";
const quot = '"';
const require$$0$1 = {
  amp,
  apos,
  gt,
  lt,
  quot
};
var decode_codepoint = {};
const require$$0 = {
  "0": 65533,
  "128": 8364,
  "130": 8218,
  "131": 402,
  "132": 8222,
  "133": 8230,
  "134": 8224,
  "135": 8225,
  "136": 710,
  "137": 8240,
  "138": 352,
  "139": 8249,
  "140": 338,
  "142": 381,
  "145": 8216,
  "146": 8217,
  "147": 8220,
  "148": 8221,
  "149": 8226,
  "150": 8211,
  "151": 8212,
  "152": 732,
  "153": 8482,
  "154": 353,
  "155": 8250,
  "156": 339,
  "158": 382,
  "159": 376
};
var hasRequiredDecode_codepoint;
function requireDecode_codepoint() {
  if (hasRequiredDecode_codepoint) return decode_codepoint;
  hasRequiredDecode_codepoint = 1;
  var __importDefault = decode_codepoint && decode_codepoint.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(decode_codepoint, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require$$0);
  var fromCodePoint2 = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
  );
  function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "ï¿½";
    }
    if (codePoint in decode_json_1.default) {
      codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint2(codePoint);
  }
  decode_codepoint.default = decodeCodePoint;
  return decode_codepoint;
}
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode$1;
  hasRequiredDecode = 1;
  var __importDefault = decode$1 && decode$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(decode$1, "__esModule", { value: true });
  decode$1.decodeHTML = decode$1.decodeHTMLStrict = decode$1.decodeXML = void 0;
  var entities_json_1 = __importDefault(require$$1$1);
  var legacy_json_1 = __importDefault(require$$1);
  var xml_json_1 = __importDefault(require$$0$1);
  var decode_codepoint_1 = __importDefault(/* @__PURE__ */ requireDecode_codepoint());
  var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  decode$1.decodeXML = getStrictDecoder(xml_json_1.default);
  decode$1.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map2) {
    var replace = getReplacer(map2);
    return function(str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function(a, b) {
    return a < b ? 1 : -1;
  };
  decode$1.decodeHTML = (function() {
    var legacy2 = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
      if (legacy2[j] === keys[i]) {
        keys[i] += ";?";
        j++;
      } else {
        keys[i] += ";";
      }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
      if (str.substr(-1) !== ";")
        str += ";";
      return replace(str);
    }
    return function(str) {
      return String(str).replace(re, replacer);
    };
  })();
  function getReplacer(map2) {
    return function replace(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        if (secondChar === "X" || secondChar === "x") {
          return decode_codepoint_1.default(parseInt(str.substr(3), 16));
        }
        return decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      return map2[str.slice(1, -1)] || str;
    };
  }
  return decode$1;
}
var encode = {};
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode;
  hasRequiredEncode = 1;
  var __importDefault = encode && encode.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(encode, "__esModule", { value: true });
  encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
  var xml_json_1 = __importDefault(require$$0$1);
  var inverseXML = getInverseObj(xml_json_1.default);
  var xmlReplacer = getInverseReplacer(inverseXML);
  encode.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require$$1$1);
  var inverseHTML = getInverseObj(entities_json_1.default);
  var htmlReplacer = getInverseReplacer(inverseHTML);
  encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function(inverse, name) {
      inverse[obj[name]] = "&" + name + ";";
      return inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
      var k = _a[_i];
      if (k.length === 1) {
        single.push("\\" + k);
      } else {
        multiple.push(k);
      }
    }
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
      var end = start;
      while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
        end += 1;
      }
      var count = 1 + end - start;
      if (count < 3)
        continue;
      single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
  var getCodePoint = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      function(str) {
        return str.codePointAt(0);
      }
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c) {
        return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
      }
    )
  );
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
    return function(data) {
      return data.replace(re, function(name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  encode.escape = escape;
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  encode.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function(data) {
      return data.replace(reEscapeChars, function(c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
  return encode;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.decodeXMLStrict = exports$1.decodeHTML5Strict = exports$1.decodeHTML4Strict = exports$1.decodeHTML5 = exports$1.decodeHTML4 = exports$1.decodeHTMLStrict = exports$1.decodeHTML = exports$1.decodeXML = exports$1.encodeHTML5 = exports$1.encodeHTML4 = exports$1.escapeUTF8 = exports$1.escape = exports$1.encodeNonAsciiHTML = exports$1.encodeHTML = exports$1.encodeXML = exports$1.encode = exports$1.decodeStrict = exports$1.decode = void 0;
    var decode_1 = /* @__PURE__ */ requireDecode();
    var encode_1 = /* @__PURE__ */ requireEncode();
    function decode2(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports$1.decode = decode2;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports$1.decodeStrict = decodeStrict;
    function encode2(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports$1.encode = encode2;
    var encode_2 = /* @__PURE__ */ requireEncode();
    Object.defineProperty(exports$1, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports$1, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports$1, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports$1, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports$1, "escapeUTF8", { enumerable: true, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports$1, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports$1, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = /* @__PURE__ */ requireDecode();
    Object.defineProperty(exports$1, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports$1, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports$1, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports$1, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports$1, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports$1, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports$1, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports$1, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  })(lib);
  return lib;
}
const elementNames = { "altglyph": "altGlyph", "altglyphdef": "altGlyphDef", "altglyphitem": "altGlyphItem", "animatecolor": "animateColor", "animatemotion": "animateMotion", "animatetransform": "animateTransform", "clippath": "clipPath", "feblend": "feBlend", "fecolormatrix": "feColorMatrix", "fecomponenttransfer": "feComponentTransfer", "fecomposite": "feComposite", "feconvolvematrix": "feConvolveMatrix", "fediffuselighting": "feDiffuseLighting", "fedisplacementmap": "feDisplacementMap", "fedistantlight": "feDistantLight", "fedropshadow": "feDropShadow", "feflood": "feFlood", "fefunca": "feFuncA", "fefuncb": "feFuncB", "fefuncg": "feFuncG", "fefuncr": "feFuncR", "fegaussianblur": "feGaussianBlur", "feimage": "feImage", "femerge": "feMerge", "femergenode": "feMergeNode", "femorphology": "feMorphology", "feoffset": "feOffset", "fepointlight": "fePointLight", "fespecularlighting": "feSpecularLighting", "fespotlight": "feSpotLight", "fetile": "feTile", "feturbulence": "feTurbulence", "foreignobject": "foreignObject", "glyphref": "glyphRef", "lineargradient": "linearGradient", "radialgradient": "radialGradient", "textpath": "textPath" };
const attributeNames = { "definitionurl": "definitionURL", "attributename": "attributeName", "attributetype": "attributeType", "basefrequency": "baseFrequency", "baseprofile": "baseProfile", "calcmode": "calcMode", "clippathunits": "clipPathUnits", "diffuseconstant": "diffuseConstant", "edgemode": "edgeMode", "filterunits": "filterUnits", "glyphref": "glyphRef", "gradienttransform": "gradientTransform", "gradientunits": "gradientUnits", "kernelmatrix": "kernelMatrix", "kernelunitlength": "kernelUnitLength", "keypoints": "keyPoints", "keysplines": "keySplines", "keytimes": "keyTimes", "lengthadjust": "lengthAdjust", "limitingconeangle": "limitingConeAngle", "markerheight": "markerHeight", "markerunits": "markerUnits", "markerwidth": "markerWidth", "maskcontentunits": "maskContentUnits", "maskunits": "maskUnits", "numoctaves": "numOctaves", "pathlength": "pathLength", "patterncontentunits": "patternContentUnits", "patterntransform": "patternTransform", "patternunits": "patternUnits", "pointsatx": "pointsAtX", "pointsaty": "pointsAtY", "pointsatz": "pointsAtZ", "preservealpha": "preserveAlpha", "preserveaspectratio": "preserveAspectRatio", "primitiveunits": "primitiveUnits", "refx": "refX", "refy": "refY", "repeatcount": "repeatCount", "repeatdur": "repeatDur", "requiredextensions": "requiredExtensions", "requiredfeatures": "requiredFeatures", "specularconstant": "specularConstant", "specularexponent": "specularExponent", "spreadmethod": "spreadMethod", "startoffset": "startOffset", "stddeviation": "stdDeviation", "stitchtiles": "stitchTiles", "surfacescale": "surfaceScale", "systemlanguage": "systemLanguage", "tablevalues": "tableValues", "targetx": "targetX", "targety": "targetY", "textlength": "textLength", "viewbox": "viewBox", "viewtarget": "viewTarget", "xchannelselector": "xChannelSelector", "ychannelselector": "yChannelSelector", "zoomandpan": "zoomAndPan" };
const require$$2$1 = {
  elementNames,
  attributeNames
};
var hasRequiredDomSerializer;
function requireDomSerializer() {
  if (hasRequiredDomSerializer) return domSerializer.exports;
  hasRequiredDomSerializer = 1;
  var ElementType = /* @__PURE__ */ requireLib$2();
  var entities2 = /* @__PURE__ */ requireLib$1();
  var foreignNames = require$$2$1;
  foreignNames.elementNames.__proto__ = null;
  foreignNames.attributeNames.__proto__ = null;
  var unencodedElements = {
    __proto__: null,
    style: true,
    script: true,
    xmp: true,
    iframe: true,
    noembed: true,
    noframes: true,
    plaintext: true,
    noscript: true
  };
  function formatAttrs(attributes, opts) {
    if (!attributes) return;
    var output = "";
    var value;
    for (var key in attributes) {
      value = attributes[key];
      if (output) {
        output += " ";
      }
      if (opts.xmlMode === "foreign") {
        key = foreignNames.attributeNames[key] || key;
      }
      output += key;
      if (value !== null && value !== "" || opts.xmlMode) {
        output += '="' + (opts.decodeEntities ? entities2.encodeXML(value) : value.replace(/\"/g, "&quot;")) + '"';
      }
    }
    return output;
  }
  var singleTag = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var render = domSerializer.exports = function(dom2, opts) {
    if (!Array.isArray(dom2) && !dom2.cheerio) dom2 = [dom2];
    opts = opts || {};
    var output = "";
    for (var i = 0; i < dom2.length; i++) {
      var elem = dom2[i];
      if (elem.type === "root") output += render(elem.children, opts);
      else if (ElementType.isTag(elem)) output += renderTag(elem, opts);
      else if (elem.type === ElementType.Directive)
        output += renderDirective(elem);
      else if (elem.type === ElementType.Comment) output += renderComment(elem);
      else if (elem.type === ElementType.CDATA) output += renderCdata(elem);
      else output += renderText(elem, opts);
    }
    return output;
  };
  var foreignModeIntegrationPoints = [
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ];
  function renderTag(elem, opts) {
    if (opts.xmlMode === "foreign") {
      elem.name = foreignNames.elementNames[elem.name] || elem.name;
      if (elem.parent && foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0)
        opts = Object.assign({}, opts, { xmlMode: false });
    }
    if (!opts.xmlMode && ["svg", "math"].indexOf(elem.name) >= 0) {
      opts = Object.assign({}, opts, { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttrs(elem.attribs, opts);
    if (attribs) {
      tag += " " + attribs;
    }
    if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children) {
        tag += render(elem.children, opts);
      }
      if (!singleTag[elem.name] || opts.xmlMode) {
        tag += "</" + elem.name + ">";
      }
    }
    return tag;
  }
  function renderDirective(elem) {
    return "<" + elem.data + ">";
  }
  function renderText(elem, opts) {
    var data = elem.data || "";
    if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
      data = entities2.encodeXML(data);
    }
    return data;
  }
  function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
  }
  function renderComment(elem) {
    return "<!--" + elem.data + "-->";
  }
  return domSerializer.exports;
}
var stringify;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  var ElementType = requireDomelementtype(), getOuterHTML = requireDomSerializer(), isTag = ElementType.isTag;
  stringify = {
    getInnerHTML,
    getOuterHTML,
    getText
  };
  function getInnerHTML(elem, opts) {
    return elem.children ? elem.children.map(function(elem2) {
      return getOuterHTML(elem2, opts);
    }).join("") : "";
  }
  function getText(elem) {
    if (Array.isArray(elem)) return elem.map(getText).join("");
    if (isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
    if (elem.type === ElementType.CDATA) return getText(elem.children);
    if (elem.type === ElementType.Text) return elem.data;
    return "";
  }
  return stringify;
}
var traversal = {};
var hasRequiredTraversal;
function requireTraversal() {
  if (hasRequiredTraversal) return traversal;
  hasRequiredTraversal = 1;
  var getChildren = traversal.getChildren = function(elem) {
    return elem.children;
  };
  var getParent = traversal.getParent = function(elem) {
    return elem.parent;
  };
  traversal.getSiblings = function(elem) {
    var parent = getParent(elem);
    return parent ? getChildren(parent) : [elem];
  };
  traversal.getAttributeValue = function(elem, name) {
    return elem.attribs && elem.attribs[name];
  };
  traversal.hasAttrib = function(elem, name) {
    return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
  };
  traversal.getName = function(elem) {
    return elem.name;
  };
  return traversal;
}
var manipulation = {};
var hasRequiredManipulation;
function requireManipulation() {
  if (hasRequiredManipulation) return manipulation;
  hasRequiredManipulation = 1;
  manipulation.removeElement = function(elem) {
    if (elem.prev) elem.prev.next = elem.next;
    if (elem.next) elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      childs.splice(childs.lastIndexOf(elem), 1);
    }
  };
  manipulation.replaceElement = function(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
    }
  };
  manipulation.appendChild = function(elem, child) {
    child.parent = elem;
    if (elem.children.push(child) !== 1) {
      var sibling = elem.children[elem.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
      child.next = null;
    }
  };
  manipulation.append = function(elem, next) {
    var parent = elem.parent, currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };
  manipulation.prepend = function(elem, prev) {
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };
  return manipulation;
}
var querying;
var hasRequiredQuerying;
function requireQuerying() {
  if (hasRequiredQuerying) return querying;
  hasRequiredQuerying = 1;
  var isTag = requireDomelementtype().isTag;
  querying = {
    filter: filter2,
    find: find2,
    findOneChild,
    findOne,
    existsOne,
    findAll
  };
  function filter2(test, element2, recurse, limit) {
    if (!Array.isArray(element2)) element2 = [element2];
    if (typeof limit !== "number" || !isFinite(limit)) {
      limit = Infinity;
    }
    return find2(test, element2, recurse !== false, limit);
  }
  function find2(test, elems, recurse, limit) {
    var result = [], childs;
    for (var i = 0, j = elems.length; i < j; i++) {
      if (test(elems[i])) {
        result.push(elems[i]);
        if (--limit <= 0) break;
      }
      childs = elems[i].children;
      if (recurse && childs && childs.length > 0) {
        childs = find2(test, childs, recurse, limit);
        result = result.concat(childs);
        limit -= childs.length;
        if (limit <= 0) break;
      }
    }
    return result;
  }
  function findOneChild(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
      if (test(elems[i])) return elems[i];
    }
    return null;
  }
  function findOne(test, elems) {
    var elem = null;
    for (var i = 0, l = elems.length; i < l && !elem; i++) {
      if (!isTag(elems[i])) {
        continue;
      } else if (test(elems[i])) {
        elem = elems[i];
      } else if (elems[i].children.length > 0) {
        elem = findOne(test, elems[i].children);
      }
    }
    return elem;
  }
  function existsOne(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
      if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
        return true;
      }
    }
    return false;
  }
  function findAll(test, rootElems) {
    var result = [];
    var stack = rootElems.slice();
    while (stack.length) {
      var elem = stack.shift();
      if (!isTag(elem)) continue;
      if (elem.children && elem.children.length > 0) {
        stack.unshift.apply(stack, elem.children);
      }
      if (test(elem)) result.push(elem);
    }
    return result;
  }
  return querying;
}
var legacy = {};
var hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var ElementType = requireDomelementtype();
  var isTag = legacy.isTag = ElementType.isTag;
  legacy.testElement = function(options, element2) {
    for (var key in options) {
      if (!options.hasOwnProperty(key)) ;
      else if (key === "tag_name") {
        if (!isTag(element2) || !options.tag_name(element2.name)) {
          return false;
        }
      } else if (key === "tag_type") {
        if (!options.tag_type(element2.type)) return false;
      } else if (key === "tag_contains") {
        if (isTag(element2) || !options.tag_contains(element2.data)) {
          return false;
        }
      } else if (!element2.attribs || !options[key](element2.attribs[key])) {
        return false;
      }
    }
    return true;
  };
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return isTag(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return isTag;
      } else {
        return function(elem) {
          return isTag(elem) && elem.name === name;
        };
      }
    },
    tag_type: function(type2) {
      if (typeof type2 === "function") {
        return function(elem) {
          return type2(elem.type);
        };
      } else {
        return function(elem) {
          return elem.type === type2;
        };
      }
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return !isTag(elem) && data(elem.data);
        };
      } else {
        return function(elem) {
          return !isTag(elem) && elem.data === data;
        };
      }
    }
  };
  function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return elem.attribs && value(elem.attribs[attrib]);
      };
    } else {
      return function(elem) {
        return elem.attribs && elem.attribs[attrib] === value;
      };
    }
  }
  function combineFuncs(a, b) {
    return function(elem) {
      return a(elem) || b(elem);
    };
  }
  legacy.getElements = function(options, element2, recurse, limit) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? [] : this.filter(
      funcs.reduce(combineFuncs),
      element2,
      recurse,
      limit
    );
  };
  legacy.getElementById = function(id, element2, recurse) {
    if (!Array.isArray(element2)) element2 = [element2];
    return this.findOne(getAttribCheck("id", id), element2, recurse !== false);
  };
  legacy.getElementsByTagName = function(name, element2, recurse, limit) {
    return this.filter(Checks.tag_name(name), element2, recurse, limit);
  };
  legacy.getElementsByTagType = function(type2, element2, recurse, limit) {
    return this.filter(Checks.tag_type(type2), element2, recurse, limit);
  };
  return legacy;
}
var helpers = {};
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  helpers.removeSubsets = function(nodes2) {
    var idx = nodes2.length, node2, ancestor, replace;
    while (--idx > -1) {
      node2 = ancestor = nodes2[idx];
      nodes2[idx] = null;
      replace = true;
      while (ancestor) {
        if (nodes2.indexOf(ancestor) > -1) {
          replace = false;
          nodes2.splice(idx, 1);
          break;
        }
        ancestor = ancestor.parent;
      }
      if (replace) {
        nodes2[idx] = node2;
      }
    }
    return nodes2;
  };
  var POSITION = {
    DISCONNECTED: 1,
    PRECEDING: 2,
    FOLLOWING: 4,
    CONTAINS: 8,
    CONTAINED_BY: 16
  };
  var comparePos = helpers.compareDocumentPosition = function(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    var current, sharedParent, siblings, aSibling, bSibling, idx;
    if (nodeA === nodeB) {
      return 0;
    }
    current = nodeA;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = nodeB;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    idx = 0;
    while (aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return POSITION.DISCONNECTED;
    }
    sharedParent = aParents[idx - 1];
    siblings = sharedParent.children;
    aSibling = aParents[idx];
    bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
      }
      return POSITION.FOLLOWING;
    } else {
      if (sharedParent === nodeA) {
        return POSITION.PRECEDING | POSITION.CONTAINS;
      }
      return POSITION.PRECEDING;
    }
  };
  helpers.uniqueSort = function(nodes2) {
    var idx = nodes2.length, node2, position;
    nodes2 = nodes2.slice();
    while (--idx > -1) {
      node2 = nodes2[idx];
      position = nodes2.indexOf(node2);
      if (position > -1 && position < idx) {
        nodes2.splice(idx, 1);
      }
    }
    nodes2.sort(function(a, b) {
      var relative = comparePos(a, b);
      if (relative & POSITION.PRECEDING) {
        return -1;
      } else if (relative & POSITION.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes2;
  };
  return helpers;
}
var hasRequiredDomutils;
function requireDomutils() {
  if (hasRequiredDomutils) return domutils.exports;
  hasRequiredDomutils = 1;
  (function(module) {
    var DomUtils = module.exports;
    [
      requireStringify(),
      requireTraversal(),
      requireManipulation(),
      requireQuerying(),
      requireLegacy(),
      requireHelpers()
    ].forEach(function(ext) {
      Object.keys(ext).forEach(function(key) {
        DomUtils[key] = ext[key].bind(DomUtils);
      });
    });
  })(domutils);
  return domutils.exports;
}
var FeedHandler_1;
var hasRequiredFeedHandler;
function requireFeedHandler() {
  if (hasRequiredFeedHandler) return FeedHandler_1;
  hasRequiredFeedHandler = 1;
  var DomHandler = requireDomhandler();
  var DomUtils = requireDomutils();
  function FeedHandler(callback, options) {
    this.init(callback, options);
  }
  requireInherits()(FeedHandler, DomHandler);
  FeedHandler.prototype.init = DomHandler;
  function getElements(what, where) {
    return DomUtils.getElementsByTagName(what, where, true);
  }
  function getOneElement(what, where) {
    return DomUtils.getElementsByTagName(what, where, true, 1)[0];
  }
  function fetch2(what, where, recurse) {
    return DomUtils.getText(
      DomUtils.getElementsByTagName(what, where, recurse, 1)
    ).trim();
  }
  function addConditionally(obj, prop2, what, where, recurse) {
    var tmp = fetch2(what, where, recurse);
    if (tmp) obj[prop2] = tmp;
  }
  var isValidFeed = function(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  FeedHandler.prototype.onend = function() {
    var feed = {}, feedRoot = getOneElement(isValidFeed, this.dom), tmp, childs;
    if (feedRoot) {
      if (feedRoot.name === "feed") {
        childs = feedRoot.children;
        feed.type = "atom";
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href))
          feed.link = tmp;
        addConditionally(feed, "description", "subtitle", childs);
        if (tmp = fetch2("updated", childs)) feed.updated = new Date(tmp);
        addConditionally(feed, "author", "email", childs, true);
        feed.items = getElements("entry", childs).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally(entry, "id", "id", item);
          addConditionally(entry, "title", "title", item);
          if ((tmp2 = getOneElement("link", item)) && (tmp2 = tmp2.attribs) && (tmp2 = tmp2.href))
            entry.link = tmp2;
          if (tmp2 = fetch2("summary", item) || fetch2("content", item))
            entry.description = tmp2;
          if (tmp2 = fetch2("updated", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      } else {
        childs = getOneElement("channel", feedRoot.children).children;
        feed.type = feedRoot.name.substr(0, 3);
        feed.id = "";
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        if (tmp = fetch2("lastBuildDate", childs))
          feed.updated = new Date(tmp);
        addConditionally(feed, "author", "managingEditor", childs, true);
        feed.items = getElements("item", feedRoot.children).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally(entry, "id", "guid", item);
          addConditionally(entry, "title", "title", item);
          addConditionally(entry, "link", "link", item);
          addConditionally(entry, "description", "description", item);
          if (tmp2 = fetch2("pubDate", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      }
    }
    this.dom = feed;
    DomHandler.prototype._handleCallback.call(
      this,
      feedRoot ? null : Error("couldn't find root of feed")
    );
  };
  FeedHandler_1 = FeedHandler;
  return FeedHandler_1;
}
var readable = { exports: {} };
var stream;
var hasRequiredStream$1;
function requireStream$1() {
  if (hasRequiredStream$1) return stream;
  hasRequiredStream$1 = 1;
  stream = Stream;
  return stream;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target2, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target2;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target2, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target2, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = require$$0$3, Buffer2 = _require.Buffer;
  var _require2 = require$$1$3, inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target2, offset) {
    Buffer2.prototype.copy.call(src, target2, offset);
  }
  buffer_list = /* @__PURE__ */ (function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList2, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  })();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream2, err) {
    var rState = stream2._readableState;
    var wState = stream2._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err);
    else stream2.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errors.codes = codes;
  return errors;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireNode$1()
  };
  var Stream2 = requireStream$1();
  var Buffer2 = require$$0$3.Buffer;
  var OurUint8Array = (typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits()(Writable, Stream2);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream2, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream2, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync) {
        process.nextTick(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream2, err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) process.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) keys2.push(key);
    return keys2;
  };
  _stream_duplex = Duplex;
  var Readable2 = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits()(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function eos(stream2, opts, callback) {
    if (typeof opts === "function") return eos(stream2, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable2 = opts.readable || opts.readable !== false && stream2.readable;
    var writable = opts.writable || opts.writable !== false && stream2.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream2.writable) onfinish();
    };
    var writableEnded = stream2._writableState && stream2._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable2) callback.call(stream2);
    };
    var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
    var onend = function onend2() {
      readable2 = false;
      readableEnded = true;
      if (!writable) callback.call(stream2);
    };
    var onerror = function onerror2(err) {
      callback.call(stream2, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable2 && !readableEnded) {
        if (!stream2._readableState || !stream2._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
      if (writable && !writableEnded) {
        if (!stream2._writableState || !stream2._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
    };
    var onrequest = function onrequest2() {
      stream2.req.on("finish", onfinish);
    };
    if (isRequest2(stream2)) {
      stream2.on("complete", onfinish);
      stream2.on("abort", onclose);
      if (stream2.req) onrequest();
      else stream2.on("request", onrequest);
    } else if (writable && !stream2._writableState) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (opts.error !== false) stream2.on("error", onerror);
    stream2.on("close", onclose);
    return function() {
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req) stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done2) {
    return {
      value,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var from_1;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from_1;
  hasRequiredFrom = 1;
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target2, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target2;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable2, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable2 = new Readable2(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable2._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done2 = _yield$iterator$next.done;
          if (done2) {
            readable2.push(null);
          } else if (readable2.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable2.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable2;
  }
  from_1 = from;
  return from_1;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable2;
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$3.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream2 = requireStream$1();
  var Buffer2 = require$$0$3.Buffer;
  var OurUint8Array = (typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$1$3;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits()(Readable2, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable2)) return new Readable2(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream2, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream2, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) ;
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ (function methodWrap(method2) {
          return function methodWrapReturnFunction() {
            return stream2[method2].apply(stream2, arguments);
          };
        })(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state2.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFrom();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrors().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done2(_this, er, data);
      });
    } else {
      done2(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done2(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream2.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough2;
  var Transform = require_stream_transform();
  requireInherits()(PassThrough2, Transform);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrors().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err) throw err;
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function destroyer(stream2, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream2.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream2, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest2(stream2)) return stream2.abort();
      if (typeof stream2.destroy === "function") return stream2.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream2, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream2, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable.exports;
  hasRequiredReadable = 1;
  (function(module, exports$1) {
    var Stream$1 = Stream;
    if (process.env.READABLE_STREAM === "disable" && Stream$1) {
      module.exports = Stream$1.Readable;
      Object.assign(module.exports, Stream$1);
      module.exports.Stream = Stream$1;
    } else {
      exports$1 = module.exports = require_stream_readable();
      exports$1.Stream = Stream$1 || exports$1;
      exports$1.Readable = exports$1;
      exports$1.Writable = require_stream_writable();
      exports$1.Duplex = require_stream_duplex();
      exports$1.Transform = require_stream_transform();
      exports$1.PassThrough = require_stream_passthrough();
      exports$1.finished = requireEndOfStream();
      exports$1.pipeline = requirePipeline();
    }
  })(readable, readable.exports);
  return readable.exports;
}
var WritableStream_1;
var hasRequiredWritableStream;
function requireWritableStream() {
  if (hasRequiredWritableStream) return WritableStream_1;
  hasRequiredWritableStream = 1;
  WritableStream_1 = Stream2;
  var Parser = requireParser();
  var WritableStream = requireReadable().Writable;
  var StringDecoder = require$$2$5.StringDecoder;
  var Buffer2 = require$$0$3.Buffer;
  function Stream2(cbs, options) {
    var parser2 = this._parser = new Parser(cbs, options);
    var decoder = this._decoder = new StringDecoder();
    WritableStream.call(this, { decodeStrings: false });
    this.once("finish", function() {
      parser2.end(decoder.end());
    });
  }
  requireInherits()(Stream2, WritableStream);
  Stream2.prototype._write = function(chunk, encoding, cb) {
    if (chunk instanceof Buffer2) chunk = this._decoder.write(chunk);
    this._parser.write(chunk);
    cb();
  };
  return WritableStream_1;
}
var Stream_1;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return Stream_1;
  hasRequiredStream = 1;
  Stream_1 = Stream2;
  var Parser = requireWritableStream();
  function Stream2(options) {
    Parser.call(this, new Cbs(this), options);
  }
  requireInherits()(Stream2, Parser);
  Stream2.prototype.readable = true;
  function Cbs(scope) {
    this.scope = scope;
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      Cbs.prototype["on" + name] = function() {
        this.scope.emit(name);
      };
    } else if (EVENTS[name] === 1) {
      Cbs.prototype["on" + name] = function(a) {
        this.scope.emit(name, a);
      };
    } else if (EVENTS[name] === 2) {
      Cbs.prototype["on" + name] = function(a, b) {
        this.scope.emit(name, a, b);
      };
    } else {
      throw Error("wrong number of arguments!");
    }
  });
  return Stream_1;
}
var ProxyHandler_1;
var hasRequiredProxyHandler;
function requireProxyHandler() {
  if (hasRequiredProxyHandler) return ProxyHandler_1;
  hasRequiredProxyHandler = 1;
  ProxyHandler_1 = ProxyHandler;
  function ProxyHandler(cbs) {
    this._cbs = cbs || {};
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function() {
        if (this._cbs[name]) this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function(a) {
        if (this._cbs[name]) this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function(a, b) {
        if (this._cbs[name]) this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  return ProxyHandler_1;
}
var CollectingHandler_1;
var hasRequiredCollectingHandler;
function requireCollectingHandler() {
  if (hasRequiredCollectingHandler) return CollectingHandler_1;
  hasRequiredCollectingHandler = 1;
  CollectingHandler_1 = CollectingHandler;
  function CollectingHandler(cbs) {
    this._cbs = cbs || {};
    this.events = [];
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function(name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function() {
        this.events.push([name]);
        if (this._cbs[name]) this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function(a) {
        this.events.push([name, a]);
        if (this._cbs[name]) this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function(a, b) {
        this.events.push([name, a, b]);
        if (this._cbs[name]) this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  CollectingHandler.prototype.onreset = function() {
    this.events = [];
    if (this._cbs.onreset) this._cbs.onreset();
  };
  CollectingHandler.prototype.restart = function() {
    if (this._cbs.onreset) this._cbs.onreset();
    for (var i = 0, len = this.events.length; i < len; i++) {
      if (this._cbs[this.events[i][0]]) {
        var num2 = this.events[i].length;
        if (num2 === 1) {
          this._cbs[this.events[i][0]]();
        } else if (num2 === 2) {
          this._cbs[this.events[i][0]](this.events[i][1]);
        } else {
          this._cbs[this.events[i][0]](
            this.events[i][1],
            this.events[i][2]
          );
        }
      }
    }
  };
  return CollectingHandler_1;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$3.exports;
  hasRequiredLib = 1;
  (function(module) {
    var Parser = requireParser();
    var DomHandler = requireDomhandler();
    function defineProp(name, value) {
      delete module.exports[name];
      module.exports[name] = value;
      return value;
    }
    module.exports = {
      Parser,
      Tokenizer: requireTokenizer(),
      ElementType: requireDomelementtype(),
      DomHandler,
      get FeedHandler() {
        return defineProp("FeedHandler", requireFeedHandler());
      },
      get Stream() {
        return defineProp("Stream", requireStream());
      },
      get WritableStream() {
        return defineProp("WritableStream", requireWritableStream());
      },
      get ProxyHandler() {
        return defineProp("ProxyHandler", requireProxyHandler());
      },
      get DomUtils() {
        return defineProp("DomUtils", requireDomutils());
      },
      get CollectingHandler() {
        return defineProp(
          "CollectingHandler",
          requireCollectingHandler()
        );
      },
      // For legacy support
      DefaultHandler: DomHandler,
      get RssHandler() {
        return defineProp("RssHandler", this.FeedHandler);
      },
      //helper methods
      parseDOM: function(data, options) {
        var handler = new DomHandler(options);
        new Parser(handler, options).end(data);
        return handler.dom;
      },
      parseFeed: function(feed, options) {
        var handler = new module.exports.FeedHandler(options);
        new Parser(handler, options).end(feed);
        return handler.dom;
      },
      createDomStream: function(cb, options, elementCb) {
        var handler = new DomHandler(cb, options, elementCb);
        return new Parser(handler, options);
      },
      // List of all events that the parser emits
      EVENTS: {
        /* Format: eventname: number of arguments */
        attribute: 2,
        cdatastart: 0,
        cdataend: 0,
        text: 1,
        processinginstruction: 2,
        comment: 1,
        commentend: 0,
        closetag: 1,
        opentag: 2,
        opentagname: 1,
        error: 1,
        end: 0
      }
    };
  })(lib$3);
  return lib$3.exports;
}
var parseHtml;
var hasRequiredParseHtml;
function requireParseHtml() {
  if (hasRequiredParseHtml) return parseHtml;
  hasRequiredParseHtml = 1;
  var htmlparser = requireLib();
  var parseHTML = function parseHTML2(html2) {
    var handler = new htmlparser.DomHandler();
    var parser2 = new htmlparser.Parser(handler, {
      lowerCaseAttributeNames: false
    });
    parser2.parseComplete(html2);
    return handler.dom;
  };
  parseHtml = parseHTML;
  return parseHtml;
}
var htmlToVdom$1;
var hasRequiredHtmlToVdom$1;
function requireHtmlToVdom$1() {
  if (hasRequiredHtmlToVdom$1) return htmlToVdom$1;
  hasRequiredHtmlToVdom$1 = 1;
  var createConverter = requireHtmlparserToVdom();
  var parseHTML = requireParseHtml();
  htmlToVdom$1 = function initializeHtmlToVdom(VTree, VText) {
    var htmlparserToVdom2 = createConverter(VTree, VText);
    return function convertHTML2(options, html2) {
      var noOptions = typeof html2 === "undefined" && typeof options === "string";
      var hasOptions = !noOptions;
      var htmlToConvert = noOptions ? options : html2;
      var getVNodeKey = hasOptions ? options.getVNodeKey : void 0;
      var tags = parseHTML(htmlToConvert);
      var convertedHTML;
      if (tags.length > 1) {
        convertedHTML = tags.map(function(tag) {
          return htmlparserToVdom2.convert(tag, getVNodeKey);
        });
      } else {
        convertedHTML = htmlparserToVdom2.convert(tags[0], getVNodeKey);
      }
      return convertedHTML;
    };
  };
  return htmlToVdom$1;
}
var htmlToVdom;
var hasRequiredHtmlToVdom;
function requireHtmlToVdom() {
  if (hasRequiredHtmlToVdom) return htmlToVdom;
  hasRequiredHtmlToVdom = 1;
  var convertHTML2 = requireHtmlToVdom$1();
  htmlToVdom = function initializeConverter(dependencies) {
    if (!dependencies.VNode || !dependencies.VText) {
      throw new Error("html-to-vdom needs to be initialized with VNode and VText");
    }
    return convertHTML2(dependencies.VNode, dependencies.VText);
  };
  return htmlToVdom;
}
var htmlToVdomExports = requireHtmlToVdom();
const HTMLToVDOM = /* @__PURE__ */ getDefaultExportFromCjs(htmlToVdomExports);
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var pairDivider = "~";
var blockDivider = "~~";
function generateNamedReferences(input, prev) {
  var entities2 = {};
  var characters = {};
  var blocks = input.split(blockDivider);
  var isOptionalBlock = false;
  for (var i = 0; blocks.length > i; i++) {
    var entries = blocks[i].split(pairDivider);
    for (var j = 0; j < entries.length; j += 2) {
      var entity = entries[j];
      var character = entries[j + 1];
      var fullEntity = "&" + entity + ";";
      entities2[fullEntity] = character;
      if (isOptionalBlock) {
        entities2["&" + entity] = character;
      }
      characters[character] = fullEntity;
    }
    isOptionalBlock = true;
  }
  return prev ? { entities: __assign$1(__assign$1({}, entities2), prev.entities), characters: __assign$1(__assign$1({}, characters), prev.characters) } : { entities: entities2, characters };
}
var bodyRegExps = {
  xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
var namedReferences = {};
namedReferences["xml"] = generateNamedReferences(`lt~<~gt~>~quot~"~apos~'~amp~&`);
namedReferences["html4"] = generateNamedReferences(`apos~'~OElig~Å’~oelig~Å“~Scaron~Å ~scaron~Å¡~Yuml~Å¸~circ~Ë†~tilde~Ëœ~ensp~â€‚~emsp~â€ƒ~thinsp~â€‰~zwnj~â€Œ~zwj~â€~lrm~â€Ž~rlm~â€~ndash~â€“~mdash~â€”~lsquo~â€˜~rsquo~â€™~sbquo~â€š~ldquo~â€œ~rdquo~â€~bdquo~â€ž~dagger~â€ ~Dagger~â€¡~permil~â€°~lsaquo~â€¹~rsaquo~â€º~euro~â‚¬~fnof~Æ’~Alpha~Î‘~Beta~Î’~Gamma~Î“~Delta~Î”~Epsilon~Î•~Zeta~Î–~Eta~Î—~Theta~Î˜~Iota~Î™~Kappa~Îš~Lambda~Î›~Mu~Îœ~Nu~Î~Xi~Îž~Omicron~ÎŸ~Pi~Î ~Rho~Î¡~Sigma~Î£~Tau~Î¤~Upsilon~Î¥~Phi~Î¦~Chi~Î§~Psi~Î¨~Omega~Î©~alpha~Î±~beta~Î²~gamma~Î³~delta~Î´~epsilon~Îµ~zeta~Î¶~eta~Î·~theta~Î¸~iota~Î¹~kappa~Îº~lambda~Î»~mu~Î¼~nu~Î½~xi~Î¾~omicron~Î¿~pi~Ï€~rho~Ï~sigmaf~Ï‚~sigma~Ïƒ~tau~Ï„~upsilon~Ï…~phi~Ï†~chi~Ï‡~psi~Ïˆ~omega~Ï‰~thetasym~Ï‘~upsih~Ï’~piv~Ï–~bull~â€¢~hellip~â€¦~prime~â€²~Prime~â€³~oline~â€¾~frasl~â„~weierp~â„˜~image~â„‘~real~â„œ~trade~â„¢~alefsym~â„µ~larr~â†~uarr~â†‘~rarr~â†’~darr~â†“~harr~â†”~crarr~â†µ~lArr~â‡~uArr~â‡‘~rArr~â‡’~dArr~â‡“~hArr~â‡”~forall~âˆ€~part~âˆ‚~exist~âˆƒ~empty~âˆ…~nabla~âˆ‡~isin~âˆˆ~notin~âˆ‰~ni~âˆ‹~prod~âˆ~sum~âˆ‘~minus~âˆ’~lowast~âˆ—~radic~âˆš~prop~âˆ~infin~âˆž~ang~âˆ ~and~âˆ§~or~âˆ¨~cap~âˆ©~cup~âˆª~int~âˆ«~there4~âˆ´~sim~âˆ¼~cong~â‰…~asymp~â‰ˆ~ne~â‰ ~equiv~â‰¡~le~â‰¤~ge~â‰¥~sub~âŠ‚~sup~âŠƒ~nsub~âŠ„~sube~âŠ†~supe~âŠ‡~oplus~âŠ•~otimes~âŠ—~perp~âŠ¥~sdot~â‹…~lceil~âŒˆ~rceil~âŒ‰~lfloor~âŒŠ~rfloor~âŒ‹~lang~âŒ©~rang~âŒª~loz~â—Š~spades~â™ ~clubs~â™£~hearts~â™¥~diams~â™¦~~nbsp~Â ~iexcl~Â¡~cent~Â¢~pound~Â£~curren~Â¤~yen~Â¥~brvbar~Â¦~sect~Â§~uml~Â¨~copy~Â©~ordf~Âª~laquo~Â«~not~Â¬~shy~Â­~reg~Â®~macr~Â¯~deg~Â°~plusmn~Â±~sup2~Â²~sup3~Â³~acute~Â´~micro~Âµ~para~Â¶~middot~Â·~cedil~Â¸~sup1~Â¹~ordm~Âº~raquo~Â»~frac14~Â¼~frac12~Â½~frac34~Â¾~iquest~Â¿~Agrave~Ã€~Aacute~Ã~Acirc~Ã‚~Atilde~Ãƒ~Auml~Ã„~Aring~Ã…~AElig~Ã†~Ccedil~Ã‡~Egrave~Ãˆ~Eacute~Ã‰~Ecirc~ÃŠ~Euml~Ã‹~Igrave~ÃŒ~Iacute~Ã~Icirc~ÃŽ~Iuml~Ã~ETH~Ã~Ntilde~Ã‘~Ograve~Ã’~Oacute~Ã“~Ocirc~Ã”~Otilde~Ã•~Ouml~Ã–~times~Ã—~Oslash~Ã˜~Ugrave~Ã™~Uacute~Ãš~Ucirc~Ã›~Uuml~Ãœ~Yacute~Ã~THORN~Ãž~szlig~ÃŸ~agrave~Ã ~aacute~Ã¡~acirc~Ã¢~atilde~Ã£~auml~Ã¤~aring~Ã¥~aelig~Ã¦~ccedil~Ã§~egrave~Ã¨~eacute~Ã©~ecirc~Ãª~euml~Ã«~igrave~Ã¬~iacute~Ã­~icirc~Ã®~iuml~Ã¯~eth~Ã°~ntilde~Ã±~ograve~Ã²~oacute~Ã³~ocirc~Ã´~otilde~Ãµ~ouml~Ã¶~divide~Ã·~oslash~Ã¸~ugrave~Ã¹~uacute~Ãº~ucirc~Ã»~uuml~Ã¼~yacute~Ã½~thorn~Ã¾~yuml~Ã¿~quot~"~amp~&~lt~<~gt~>`);
namedReferences["html5"] = generateNamedReferences('Abreve~Ä‚~Acy~Ð~Afr~ð”„~Amacr~Ä€~And~â©“~Aogon~Ä„~Aopf~ð”¸~ApplyFunction~â¡~Ascr~ð’œ~Assign~â‰”~Backslash~âˆ–~Barv~â«§~Barwed~âŒ†~Bcy~Ð‘~Because~âˆµ~Bernoullis~â„¬~Bfr~ð”…~Bopf~ð”¹~Breve~Ë˜~Bscr~â„¬~Bumpeq~â‰Ž~CHcy~Ð§~Cacute~Ä†~Cap~â‹’~CapitalDifferentialD~â……~Cayleys~â„­~Ccaron~ÄŒ~Ccirc~Äˆ~Cconint~âˆ°~Cdot~ÄŠ~Cedilla~Â¸~CenterDot~Â·~Cfr~â„­~CircleDot~âŠ™~CircleMinus~âŠ–~CirclePlus~âŠ•~CircleTimes~âŠ—~ClockwiseContourIntegral~âˆ²~CloseCurlyDoubleQuote~â€~CloseCurlyQuote~â€™~Colon~âˆ·~Colone~â©´~Congruent~â‰¡~Conint~âˆ¯~ContourIntegral~âˆ®~Copf~â„‚~Coproduct~âˆ~CounterClockwiseContourIntegral~âˆ³~Cross~â¨¯~Cscr~ð’ž~Cup~â‹“~CupCap~â‰~DD~â……~DDotrahd~â¤‘~DJcy~Ð‚~DScy~Ð…~DZcy~Ð~Darr~â†¡~Dashv~â«¤~Dcaron~ÄŽ~Dcy~Ð”~Del~âˆ‡~Dfr~ð”‡~DiacriticalAcute~Â´~DiacriticalDot~Ë™~DiacriticalDoubleAcute~Ë~DiacriticalGrave~`~DiacriticalTilde~Ëœ~Diamond~â‹„~DifferentialD~â…†~Dopf~ð”»~Dot~Â¨~DotDot~âƒœ~DotEqual~â‰~DoubleContourIntegral~âˆ¯~DoubleDot~Â¨~DoubleDownArrow~â‡“~DoubleLeftArrow~â‡~DoubleLeftRightArrow~â‡”~DoubleLeftTee~â«¤~DoubleLongLeftArrow~âŸ¸~DoubleLongLeftRightArrow~âŸº~DoubleLongRightArrow~âŸ¹~DoubleRightArrow~â‡’~DoubleRightTee~âŠ¨~DoubleUpArrow~â‡‘~DoubleUpDownArrow~â‡•~DoubleVerticalBar~âˆ¥~DownArrow~â†“~DownArrowBar~â¤“~DownArrowUpArrow~â‡µ~DownBreve~Ì‘~DownLeftRightVector~â¥~DownLeftTeeVector~â¥ž~DownLeftVector~â†½~DownLeftVectorBar~â¥–~DownRightTeeVector~â¥Ÿ~DownRightVector~â‡~DownRightVectorBar~â¥—~DownTee~âŠ¤~DownTeeArrow~â†§~Downarrow~â‡“~Dscr~ð’Ÿ~Dstrok~Ä~ENG~ÅŠ~Ecaron~Äš~Ecy~Ð­~Edot~Ä–~Efr~ð”ˆ~Element~âˆˆ~Emacr~Ä’~EmptySmallSquare~â—»~EmptyVerySmallSquare~â–«~Eogon~Ä˜~Eopf~ð”¼~Equal~â©µ~EqualTilde~â‰‚~Equilibrium~â‡Œ~Escr~â„°~Esim~â©³~Exists~âˆƒ~ExponentialE~â…‡~Fcy~Ð¤~Ffr~ð”‰~FilledSmallSquare~â—¼~FilledVerySmallSquare~â–ª~Fopf~ð”½~ForAll~âˆ€~Fouriertrf~â„±~Fscr~â„±~GJcy~Ðƒ~Gammad~Ïœ~Gbreve~Äž~Gcedil~Ä¢~Gcirc~Äœ~Gcy~Ð“~Gdot~Ä ~Gfr~ð”Š~Gg~â‹™~Gopf~ð”¾~GreaterEqual~â‰¥~GreaterEqualLess~â‹›~GreaterFullEqual~â‰§~GreaterGreater~âª¢~GreaterLess~â‰·~GreaterSlantEqual~â©¾~GreaterTilde~â‰³~Gscr~ð’¢~Gt~â‰«~HARDcy~Ðª~Hacek~Ë‡~Hat~^~Hcirc~Ä¤~Hfr~â„Œ~HilbertSpace~â„‹~Hopf~â„~HorizontalLine~â”€~Hscr~â„‹~Hstrok~Ä¦~HumpDownHump~â‰Ž~HumpEqual~â‰~IEcy~Ð•~IJlig~Ä²~IOcy~Ð~Icy~Ð˜~Idot~Ä°~Ifr~â„‘~Im~â„‘~Imacr~Äª~ImaginaryI~â…ˆ~Implies~â‡’~Int~âˆ¬~Integral~âˆ«~Intersection~â‹‚~InvisibleComma~â£~InvisibleTimes~â¢~Iogon~Ä®~Iopf~ð•€~Iscr~â„~Itilde~Ä¨~Iukcy~Ð†~Jcirc~Ä´~Jcy~Ð™~Jfr~ð”~Jopf~ð•~Jscr~ð’¥~Jsercy~Ðˆ~Jukcy~Ð„~KHcy~Ð¥~KJcy~ÐŒ~Kcedil~Ä¶~Kcy~Ðš~Kfr~ð”Ž~Kopf~ð•‚~Kscr~ð’¦~LJcy~Ð‰~Lacute~Ä¹~Lang~âŸª~Laplacetrf~â„’~Larr~â†ž~Lcaron~Ä½~Lcedil~Ä»~Lcy~Ð›~LeftAngleBracket~âŸ¨~LeftArrow~â†~LeftArrowBar~â‡¤~LeftArrowRightArrow~â‡†~LeftCeiling~âŒˆ~LeftDoubleBracket~âŸ¦~LeftDownTeeVector~â¥¡~LeftDownVector~â‡ƒ~LeftDownVectorBar~â¥™~LeftFloor~âŒŠ~LeftRightArrow~â†”~LeftRightVector~â¥Ž~LeftTee~âŠ£~LeftTeeArrow~â†¤~LeftTeeVector~â¥š~LeftTriangle~âŠ²~LeftTriangleBar~â§~LeftTriangleEqual~âŠ´~LeftUpDownVector~â¥‘~LeftUpTeeVector~â¥ ~LeftUpVector~â†¿~LeftUpVectorBar~â¥˜~LeftVector~â†¼~LeftVectorBar~â¥’~Leftarrow~â‡~Leftrightarrow~â‡”~LessEqualGreater~â‹š~LessFullEqual~â‰¦~LessGreater~â‰¶~LessLess~âª¡~LessSlantEqual~â©½~LessTilde~â‰²~Lfr~ð”~Ll~â‹˜~Lleftarrow~â‡š~Lmidot~Ä¿~LongLeftArrow~âŸµ~LongLeftRightArrow~âŸ·~LongRightArrow~âŸ¶~Longleftarrow~âŸ¸~Longleftrightarrow~âŸº~Longrightarrow~âŸ¹~Lopf~ð•ƒ~LowerLeftArrow~â†™~LowerRightArrow~â†˜~Lscr~â„’~Lsh~â†°~Lstrok~Å~Lt~â‰ª~Map~â¤…~Mcy~Ðœ~MediumSpace~âŸ~Mellintrf~â„³~Mfr~ð”~MinusPlus~âˆ“~Mopf~ð•„~Mscr~â„³~NJcy~ÐŠ~Nacute~Åƒ~Ncaron~Å‡~Ncedil~Å…~Ncy~Ð~NegativeMediumSpace~â€‹~NegativeThickSpace~â€‹~NegativeThinSpace~â€‹~NegativeVeryThinSpace~â€‹~NestedGreaterGreater~â‰«~NestedLessLess~â‰ª~NewLine~\n~Nfr~ð”‘~NoBreak~â ~NonBreakingSpace~Â ~Nopf~â„•~Not~â«¬~NotCongruent~â‰¢~NotCupCap~â‰­~NotDoubleVerticalBar~âˆ¦~NotElement~âˆ‰~NotEqual~â‰ ~NotEqualTilde~â‰‚Ì¸~NotExists~âˆ„~NotGreater~â‰¯~NotGreaterEqual~â‰±~NotGreaterFullEqual~â‰§Ì¸~NotGreaterGreater~â‰«Ì¸~NotGreaterLess~â‰¹~NotGreaterSlantEqual~â©¾Ì¸~NotGreaterTilde~â‰µ~NotHumpDownHump~â‰ŽÌ¸~NotHumpEqual~â‰Ì¸~NotLeftTriangle~â‹ª~NotLeftTriangleBar~â§Ì¸~NotLeftTriangleEqual~â‹¬~NotLess~â‰®~NotLessEqual~â‰°~NotLessGreater~â‰¸~NotLessLess~â‰ªÌ¸~NotLessSlantEqual~â©½Ì¸~NotLessTilde~â‰´~NotNestedGreaterGreater~âª¢Ì¸~NotNestedLessLess~âª¡Ì¸~NotPrecedes~âŠ€~NotPrecedesEqual~âª¯Ì¸~NotPrecedesSlantEqual~â‹ ~NotReverseElement~âˆŒ~NotRightTriangle~â‹«~NotRightTriangleBar~â§Ì¸~NotRightTriangleEqual~â‹­~NotSquareSubset~âŠÌ¸~NotSquareSubsetEqual~â‹¢~NotSquareSuperset~âŠÌ¸~NotSquareSupersetEqual~â‹£~NotSubset~âŠ‚âƒ’~NotSubsetEqual~âŠˆ~NotSucceeds~âŠ~NotSucceedsEqual~âª°Ì¸~NotSucceedsSlantEqual~â‹¡~NotSucceedsTilde~â‰¿Ì¸~NotSuperset~âŠƒâƒ’~NotSupersetEqual~âŠ‰~NotTilde~â‰~NotTildeEqual~â‰„~NotTildeFullEqual~â‰‡~NotTildeTilde~â‰‰~NotVerticalBar~âˆ¤~Nscr~ð’©~Ocy~Ðž~Odblac~Å~Ofr~ð”’~Omacr~ÅŒ~Oopf~ð•†~OpenCurlyDoubleQuote~â€œ~OpenCurlyQuote~â€˜~Or~â©”~Oscr~ð’ª~Otimes~â¨·~OverBar~â€¾~OverBrace~âž~OverBracket~âŽ´~OverParenthesis~âœ~PartialD~âˆ‚~Pcy~ÐŸ~Pfr~ð”“~PlusMinus~Â±~Poincareplane~â„Œ~Popf~â„™~Pr~âª»~Precedes~â‰º~PrecedesEqual~âª¯~PrecedesSlantEqual~â‰¼~PrecedesTilde~â‰¾~Product~âˆ~Proportion~âˆ·~Proportional~âˆ~Pscr~ð’«~Qfr~ð””~Qopf~â„š~Qscr~ð’¬~RBarr~â¤~Racute~Å”~Rang~âŸ«~Rarr~â† ~Rarrtl~â¤–~Rcaron~Å˜~Rcedil~Å–~Rcy~Ð ~Re~â„œ~ReverseElement~âˆ‹~ReverseEquilibrium~â‡‹~ReverseUpEquilibrium~â¥¯~Rfr~â„œ~RightAngleBracket~âŸ©~RightArrow~â†’~RightArrowBar~â‡¥~RightArrowLeftArrow~â‡„~RightCeiling~âŒ‰~RightDoubleBracket~âŸ§~RightDownTeeVector~â¥~RightDownVector~â‡‚~RightDownVectorBar~â¥•~RightFloor~âŒ‹~RightTee~âŠ¢~RightTeeArrow~â†¦~RightTeeVector~â¥›~RightTriangle~âŠ³~RightTriangleBar~â§~RightTriangleEqual~âŠµ~RightUpDownVector~â¥~RightUpTeeVector~â¥œ~RightUpVector~â†¾~RightUpVectorBar~â¥”~RightVector~â‡€~RightVectorBar~â¥“~Rightarrow~â‡’~Ropf~â„~RoundImplies~â¥°~Rrightarrow~â‡›~Rscr~â„›~Rsh~â†±~RuleDelayed~â§´~SHCHcy~Ð©~SHcy~Ð¨~SOFTcy~Ð¬~Sacute~Åš~Sc~âª¼~Scedil~Åž~Scirc~Åœ~Scy~Ð¡~Sfr~ð”–~ShortDownArrow~â†“~ShortLeftArrow~â†~ShortRightArrow~â†’~ShortUpArrow~â†‘~SmallCircle~âˆ˜~Sopf~ð•Š~Sqrt~âˆš~Square~â–¡~SquareIntersection~âŠ“~SquareSubset~âŠ~SquareSubsetEqual~âŠ‘~SquareSuperset~âŠ~SquareSupersetEqual~âŠ’~SquareUnion~âŠ”~Sscr~ð’®~Star~â‹†~Sub~â‹~Subset~â‹~SubsetEqual~âŠ†~Succeeds~â‰»~SucceedsEqual~âª°~SucceedsSlantEqual~â‰½~SucceedsTilde~â‰¿~SuchThat~âˆ‹~Sum~âˆ‘~Sup~â‹‘~Superset~âŠƒ~SupersetEqual~âŠ‡~Supset~â‹‘~TRADE~â„¢~TSHcy~Ð‹~TScy~Ð¦~Tab~	~Tcaron~Å¤~Tcedil~Å¢~Tcy~Ð¢~Tfr~ð”—~Therefore~âˆ´~ThickSpace~âŸâ€Š~ThinSpace~â€‰~Tilde~âˆ¼~TildeEqual~â‰ƒ~TildeFullEqual~â‰…~TildeTilde~â‰ˆ~Topf~ð•‹~TripleDot~âƒ›~Tscr~ð’¯~Tstrok~Å¦~Uarr~â†Ÿ~Uarrocir~â¥‰~Ubrcy~ÐŽ~Ubreve~Å¬~Ucy~Ð£~Udblac~Å°~Ufr~ð”˜~Umacr~Åª~UnderBar~_~UnderBrace~âŸ~UnderBracket~âŽµ~UnderParenthesis~â~Union~â‹ƒ~UnionPlus~âŠŽ~Uogon~Å²~Uopf~ð•Œ~UpArrow~â†‘~UpArrowBar~â¤’~UpArrowDownArrow~â‡…~UpDownArrow~â†•~UpEquilibrium~â¥®~UpTee~âŠ¥~UpTeeArrow~â†¥~Uparrow~â‡‘~Updownarrow~â‡•~UpperLeftArrow~â†–~UpperRightArrow~â†—~Upsi~Ï’~Uring~Å®~Uscr~ð’°~Utilde~Å¨~VDash~âŠ«~Vbar~â««~Vcy~Ð’~Vdash~âŠ©~Vdashl~â«¦~Vee~â‹~Verbar~â€–~Vert~â€–~VerticalBar~âˆ£~VerticalLine~|~VerticalSeparator~â˜~VerticalTilde~â‰€~VeryThinSpace~â€Š~Vfr~ð”™~Vopf~ð•~Vscr~ð’±~Vvdash~âŠª~Wcirc~Å´~Wedge~â‹€~Wfr~ð”š~Wopf~ð•Ž~Wscr~ð’²~Xfr~ð”›~Xopf~ð•~Xscr~ð’³~YAcy~Ð¯~YIcy~Ð‡~YUcy~Ð®~Ycirc~Å¶~Ycy~Ð«~Yfr~ð”œ~Yopf~ð•~Yscr~ð’´~ZHcy~Ð–~Zacute~Å¹~Zcaron~Å½~Zcy~Ð—~Zdot~Å»~ZeroWidthSpace~â€‹~Zfr~â„¨~Zopf~â„¤~Zscr~ð’µ~abreve~Äƒ~ac~âˆ¾~acE~âˆ¾Ì³~acd~âˆ¿~acy~Ð°~af~â¡~afr~ð”ž~aleph~â„µ~amacr~Ä~amalg~â¨¿~andand~â©•~andd~â©œ~andslope~â©˜~andv~â©š~ange~â¦¤~angle~âˆ ~angmsd~âˆ¡~angmsdaa~â¦¨~angmsdab~â¦©~angmsdac~â¦ª~angmsdad~â¦«~angmsdae~â¦¬~angmsdaf~â¦­~angmsdag~â¦®~angmsdah~â¦¯~angrt~âˆŸ~angrtvb~âŠ¾~angrtvbd~â¦~angsph~âˆ¢~angst~Ã…~angzarr~â¼~aogon~Ä…~aopf~ð•’~ap~â‰ˆ~apE~â©°~apacir~â©¯~ape~â‰Š~apid~â‰‹~approx~â‰ˆ~approxeq~â‰Š~ascr~ð’¶~ast~*~asympeq~â‰~awconint~âˆ³~awint~â¨‘~bNot~â«­~backcong~â‰Œ~backepsilon~Ï¶~backprime~â€µ~backsim~âˆ½~backsimeq~â‹~barvee~âŠ½~barwed~âŒ…~barwedge~âŒ…~bbrk~âŽµ~bbrktbrk~âŽ¶~bcong~â‰Œ~bcy~Ð±~becaus~âˆµ~because~âˆµ~bemptyv~â¦°~bepsi~Ï¶~bernou~â„¬~beth~â„¶~between~â‰¬~bfr~ð”Ÿ~bigcap~â‹‚~bigcirc~â—¯~bigcup~â‹ƒ~bigodot~â¨€~bigoplus~â¨~bigotimes~â¨‚~bigsqcup~â¨†~bigstar~â˜…~bigtriangledown~â–½~bigtriangleup~â–³~biguplus~â¨„~bigvee~â‹~bigwedge~â‹€~bkarow~â¤~blacklozenge~â§«~blacksquare~â–ª~blacktriangle~â–´~blacktriangledown~â–¾~blacktriangleleft~â—‚~blacktriangleright~â–¸~blank~â£~blk12~â–’~blk14~â–‘~blk34~â–“~block~â–ˆ~bne~=âƒ¥~bnequiv~â‰¡âƒ¥~bnot~âŒ~bopf~ð•“~bot~âŠ¥~bottom~âŠ¥~bowtie~â‹ˆ~boxDL~â•—~boxDR~â•”~boxDl~â•–~boxDr~â•“~boxH~â•~boxHD~â•¦~boxHU~â•©~boxHd~â•¤~boxHu~â•§~boxUL~â•~boxUR~â•š~boxUl~â•œ~boxUr~â•™~boxV~â•‘~boxVH~â•¬~boxVL~â•£~boxVR~â• ~boxVh~â•«~boxVl~â•¢~boxVr~â•Ÿ~boxbox~â§‰~boxdL~â••~boxdR~â•’~boxdl~â”~boxdr~â”Œ~boxh~â”€~boxhD~â•¥~boxhU~â•¨~boxhd~â”¬~boxhu~â”´~boxminus~âŠŸ~boxplus~âŠž~boxtimes~âŠ ~boxuL~â•›~boxuR~â•˜~boxul~â”˜~boxur~â””~boxv~â”‚~boxvH~â•ª~boxvL~â•¡~boxvR~â•ž~boxvh~â”¼~boxvl~â”¤~boxvr~â”œ~bprime~â€µ~breve~Ë˜~bscr~ð’·~bsemi~â~bsim~âˆ½~bsime~â‹~bsol~\\~bsolb~â§…~bsolhsub~âŸˆ~bullet~â€¢~bump~â‰Ž~bumpE~âª®~bumpe~â‰~bumpeq~â‰~cacute~Ä‡~capand~â©„~capbrcup~â©‰~capcap~â©‹~capcup~â©‡~capdot~â©€~caps~âˆ©ï¸€~caret~â~caron~Ë‡~ccaps~â©~ccaron~Ä~ccirc~Ä‰~ccups~â©Œ~ccupssm~â©~cdot~Ä‹~cemptyv~â¦²~centerdot~Â·~cfr~ð” ~chcy~Ñ‡~check~âœ“~checkmark~âœ“~cir~â—‹~cirE~â§ƒ~circeq~â‰—~circlearrowleft~â†º~circlearrowright~â†»~circledR~Â®~circledS~â“ˆ~circledast~âŠ›~circledcirc~âŠš~circleddash~âŠ~cire~â‰—~cirfnint~â¨~cirmid~â«¯~cirscir~â§‚~clubsuit~â™£~colon~:~colone~â‰”~coloneq~â‰”~comma~,~commat~@~comp~âˆ~compfn~âˆ˜~complement~âˆ~complexes~â„‚~congdot~â©­~conint~âˆ®~copf~ð•”~coprod~âˆ~copysr~â„—~cross~âœ—~cscr~ð’¸~csub~â«~csube~â«‘~csup~â«~csupe~â«’~ctdot~â‹¯~cudarrl~â¤¸~cudarrr~â¤µ~cuepr~â‹ž~cuesc~â‹Ÿ~cularr~â†¶~cularrp~â¤½~cupbrcap~â©ˆ~cupcap~â©†~cupcup~â©Š~cupdot~âŠ~cupor~â©…~cups~âˆªï¸€~curarr~â†·~curarrm~â¤¼~curlyeqprec~â‹ž~curlyeqsucc~â‹Ÿ~curlyvee~â‹Ž~curlywedge~â‹~curvearrowleft~â†¶~curvearrowright~â†·~cuvee~â‹Ž~cuwed~â‹~cwconint~âˆ²~cwint~âˆ±~cylcty~âŒ­~dHar~â¥¥~daleth~â„¸~dash~â€~dashv~âŠ£~dbkarow~â¤~dblac~Ë~dcaron~Ä~dcy~Ð´~dd~â…†~ddagger~â€¡~ddarr~â‡Š~ddotseq~â©·~demptyv~â¦±~dfisht~â¥¿~dfr~ð”¡~dharl~â‡ƒ~dharr~â‡‚~diam~â‹„~diamond~â‹„~diamondsuit~â™¦~die~Â¨~digamma~Ï~disin~â‹²~div~Ã·~divideontimes~â‹‡~divonx~â‹‡~djcy~Ñ’~dlcorn~âŒž~dlcrop~âŒ~dollar~$~dopf~ð••~dot~Ë™~doteq~â‰~doteqdot~â‰‘~dotminus~âˆ¸~dotplus~âˆ”~dotsquare~âŠ¡~doublebarwedge~âŒ†~downarrow~â†“~downdownarrows~â‡Š~downharpoonleft~â‡ƒ~downharpoonright~â‡‚~drbkarow~â¤~drcorn~âŒŸ~drcrop~âŒŒ~dscr~ð’¹~dscy~Ñ•~dsol~â§¶~dstrok~Ä‘~dtdot~â‹±~dtri~â–¿~dtrif~â–¾~duarr~â‡µ~duhar~â¥¯~dwangle~â¦¦~dzcy~ÑŸ~dzigrarr~âŸ¿~eDDot~â©·~eDot~â‰‘~easter~â©®~ecaron~Ä›~ecir~â‰–~ecolon~â‰•~ecy~Ñ~edot~Ä—~ee~â…‡~efDot~â‰’~efr~ð”¢~eg~âªš~egs~âª–~egsdot~âª˜~el~âª™~elinters~â§~ell~â„“~els~âª•~elsdot~âª—~emacr~Ä“~emptyset~âˆ…~emptyv~âˆ…~emsp13~â€„~emsp14~â€…~eng~Å‹~eogon~Ä™~eopf~ð•–~epar~â‹•~eparsl~â§£~eplus~â©±~epsi~Îµ~epsiv~Ïµ~eqcirc~â‰–~eqcolon~â‰•~eqsim~â‰‚~eqslantgtr~âª–~eqslantless~âª•~equals~=~equest~â‰Ÿ~equivDD~â©¸~eqvparsl~â§¥~erDot~â‰“~erarr~â¥±~escr~â„¯~esdot~â‰~esim~â‰‚~excl~!~expectation~â„°~exponentiale~â…‡~fallingdotseq~â‰’~fcy~Ñ„~female~â™€~ffilig~ï¬ƒ~fflig~ï¬€~ffllig~ï¬„~ffr~ð”£~filig~ï¬~fjlig~fj~flat~â™­~fllig~ï¬‚~fltns~â–±~fopf~ð•—~fork~â‹”~forkv~â«™~fpartint~â¨~frac13~â…“~frac15~â…•~frac16~â…™~frac18~â…›~frac23~â…”~frac25~â…–~frac35~â…—~frac38~â…œ~frac45~â…˜~frac56~â…š~frac58~â…~frac78~â…ž~frown~âŒ¢~fscr~ð’»~gE~â‰§~gEl~âªŒ~gacute~Çµ~gammad~Ï~gap~âª†~gbreve~ÄŸ~gcirc~Ä~gcy~Ð³~gdot~Ä¡~gel~â‹›~geq~â‰¥~geqq~â‰§~geqslant~â©¾~ges~â©¾~gescc~âª©~gesdot~âª€~gesdoto~âª‚~gesdotol~âª„~gesl~â‹›ï¸€~gesles~âª”~gfr~ð”¤~gg~â‰«~ggg~â‹™~gimel~â„·~gjcy~Ñ“~gl~â‰·~glE~âª’~gla~âª¥~glj~âª¤~gnE~â‰©~gnap~âªŠ~gnapprox~âªŠ~gne~âªˆ~gneq~âªˆ~gneqq~â‰©~gnsim~â‹§~gopf~ð•˜~grave~`~gscr~â„Š~gsim~â‰³~gsime~âªŽ~gsiml~âª~gtcc~âª§~gtcir~â©º~gtdot~â‹—~gtlPar~â¦•~gtquest~â©¼~gtrapprox~âª†~gtrarr~â¥¸~gtrdot~â‹—~gtreqless~â‹›~gtreqqless~âªŒ~gtrless~â‰·~gtrsim~â‰³~gvertneqq~â‰©ï¸€~gvnE~â‰©ï¸€~hairsp~â€Š~half~Â½~hamilt~â„‹~hardcy~ÑŠ~harrcir~â¥ˆ~harrw~â†­~hbar~â„~hcirc~Ä¥~heartsuit~â™¥~hercon~âŠ¹~hfr~ð”¥~hksearow~â¤¥~hkswarow~â¤¦~hoarr~â‡¿~homtht~âˆ»~hookleftarrow~â†©~hookrightarrow~â†ª~hopf~ð•™~horbar~â€•~hscr~ð’½~hslash~â„~hstrok~Ä§~hybull~âƒ~hyphen~â€~ic~â£~icy~Ð¸~iecy~Ðµ~iff~â‡”~ifr~ð”¦~ii~â…ˆ~iiiint~â¨Œ~iiint~âˆ­~iinfin~â§œ~iiota~â„©~ijlig~Ä³~imacr~Ä«~imagline~â„~imagpart~â„‘~imath~Ä±~imof~âŠ·~imped~Æµ~in~âˆˆ~incare~â„…~infintie~â§~inodot~Ä±~intcal~âŠº~integers~â„¤~intercal~âŠº~intlarhk~â¨—~intprod~â¨¼~iocy~Ñ‘~iogon~Ä¯~iopf~ð•š~iprod~â¨¼~iscr~ð’¾~isinE~â‹¹~isindot~â‹µ~isins~â‹´~isinsv~â‹³~isinv~âˆˆ~it~â¢~itilde~Ä©~iukcy~Ñ–~jcirc~Äµ~jcy~Ð¹~jfr~ð”§~jmath~È·~jopf~ð•›~jscr~ð’¿~jsercy~Ñ˜~jukcy~Ñ”~kappav~Ï°~kcedil~Ä·~kcy~Ðº~kfr~ð”¨~kgreen~Ä¸~khcy~Ñ…~kjcy~Ñœ~kopf~ð•œ~kscr~ð“€~lAarr~â‡š~lAtail~â¤›~lBarr~â¤Ž~lE~â‰¦~lEg~âª‹~lHar~â¥¢~lacute~Äº~laemptyv~â¦´~lagran~â„’~langd~â¦‘~langle~âŸ¨~lap~âª…~larrb~â‡¤~larrbfs~â¤Ÿ~larrfs~â¤~larrhk~â†©~larrlp~â†«~larrpl~â¤¹~larrsim~â¥³~larrtl~â†¢~lat~âª«~latail~â¤™~late~âª­~lates~âª­ï¸€~lbarr~â¤Œ~lbbrk~â²~lbrace~{~lbrack~[~lbrke~â¦‹~lbrksld~â¦~lbrkslu~â¦~lcaron~Ä¾~lcedil~Ä¼~lcub~{~lcy~Ð»~ldca~â¤¶~ldquor~â€ž~ldrdhar~â¥§~ldrushar~â¥‹~ldsh~â†²~leftarrow~â†~leftarrowtail~â†¢~leftharpoondown~â†½~leftharpoonup~â†¼~leftleftarrows~â‡‡~leftrightarrow~â†”~leftrightarrows~â‡†~leftrightharpoons~â‡‹~leftrightsquigarrow~â†­~leftthreetimes~â‹‹~leg~â‹š~leq~â‰¤~leqq~â‰¦~leqslant~â©½~les~â©½~lescc~âª¨~lesdot~â©¿~lesdoto~âª~lesdotor~âªƒ~lesg~â‹šï¸€~lesges~âª“~lessapprox~âª…~lessdot~â‹–~lesseqgtr~â‹š~lesseqqgtr~âª‹~lessgtr~â‰¶~lesssim~â‰²~lfisht~â¥¼~lfr~ð”©~lg~â‰¶~lgE~âª‘~lhard~â†½~lharu~â†¼~lharul~â¥ª~lhblk~â–„~ljcy~Ñ™~ll~â‰ª~llarr~â‡‡~llcorner~âŒž~llhard~â¥«~lltri~â—º~lmidot~Å€~lmoust~âŽ°~lmoustache~âŽ°~lnE~â‰¨~lnap~âª‰~lnapprox~âª‰~lne~âª‡~lneq~âª‡~lneqq~â‰¨~lnsim~â‹¦~loang~âŸ¬~loarr~â‡½~lobrk~âŸ¦~longleftarrow~âŸµ~longleftrightarrow~âŸ·~longmapsto~âŸ¼~longrightarrow~âŸ¶~looparrowleft~â†«~looparrowright~â†¬~lopar~â¦…~lopf~ð•~loplus~â¨­~lotimes~â¨´~lowbar~_~lozenge~â—Š~lozf~â§«~lpar~(~lparlt~â¦“~lrarr~â‡†~lrcorner~âŒŸ~lrhar~â‡‹~lrhard~â¥­~lrtri~âŠ¿~lscr~ð“~lsh~â†°~lsim~â‰²~lsime~âª~lsimg~âª~lsqb~[~lsquor~â€š~lstrok~Å‚~ltcc~âª¦~ltcir~â©¹~ltdot~â‹–~lthree~â‹‹~ltimes~â‹‰~ltlarr~â¥¶~ltquest~â©»~ltrPar~â¦–~ltri~â—ƒ~ltrie~âŠ´~ltrif~â—‚~lurdshar~â¥Š~luruhar~â¥¦~lvertneqq~â‰¨ï¸€~lvnE~â‰¨ï¸€~mDDot~âˆº~male~â™‚~malt~âœ ~maltese~âœ ~map~â†¦~mapsto~â†¦~mapstodown~â†§~mapstoleft~â†¤~mapstoup~â†¥~marker~â–®~mcomma~â¨©~mcy~Ð¼~measuredangle~âˆ¡~mfr~ð”ª~mho~â„§~mid~âˆ£~midast~*~midcir~â«°~minusb~âŠŸ~minusd~âˆ¸~minusdu~â¨ª~mlcp~â«›~mldr~â€¦~mnplus~âˆ“~models~âŠ§~mopf~ð•ž~mp~âˆ“~mscr~ð“‚~mstpos~âˆ¾~multimap~âŠ¸~mumap~âŠ¸~nGg~â‹™Ì¸~nGt~â‰«âƒ’~nGtv~â‰«Ì¸~nLeftarrow~â‡~nLeftrightarrow~â‡Ž~nLl~â‹˜Ì¸~nLt~â‰ªâƒ’~nLtv~â‰ªÌ¸~nRightarrow~â‡~nVDash~âŠ¯~nVdash~âŠ®~nacute~Å„~nang~âˆ âƒ’~nap~â‰‰~napE~â©°Ì¸~napid~â‰‹Ì¸~napos~Å‰~napprox~â‰‰~natur~â™®~natural~â™®~naturals~â„•~nbump~â‰ŽÌ¸~nbumpe~â‰Ì¸~ncap~â©ƒ~ncaron~Åˆ~ncedil~Å†~ncong~â‰‡~ncongdot~â©­Ì¸~ncup~â©‚~ncy~Ð½~neArr~â‡—~nearhk~â¤¤~nearr~â†—~nearrow~â†—~nedot~â‰Ì¸~nequiv~â‰¢~nesear~â¤¨~nesim~â‰‚Ì¸~nexist~âˆ„~nexists~âˆ„~nfr~ð”«~ngE~â‰§Ì¸~nge~â‰±~ngeq~â‰±~ngeqq~â‰§Ì¸~ngeqslant~â©¾Ì¸~nges~â©¾Ì¸~ngsim~â‰µ~ngt~â‰¯~ngtr~â‰¯~nhArr~â‡Ž~nharr~â†®~nhpar~â«²~nis~â‹¼~nisd~â‹º~niv~âˆ‹~njcy~Ñš~nlArr~â‡~nlE~â‰¦Ì¸~nlarr~â†š~nldr~â€¥~nle~â‰°~nleftarrow~â†š~nleftrightarrow~â†®~nleq~â‰°~nleqq~â‰¦Ì¸~nleqslant~â©½Ì¸~nles~â©½Ì¸~nless~â‰®~nlsim~â‰´~nlt~â‰®~nltri~â‹ª~nltrie~â‹¬~nmid~âˆ¤~nopf~ð•Ÿ~notinE~â‹¹Ì¸~notindot~â‹µÌ¸~notinva~âˆ‰~notinvb~â‹·~notinvc~â‹¶~notni~âˆŒ~notniva~âˆŒ~notnivb~â‹¾~notnivc~â‹½~npar~âˆ¦~nparallel~âˆ¦~nparsl~â«½âƒ¥~npart~âˆ‚Ì¸~npolint~â¨”~npr~âŠ€~nprcue~â‹ ~npre~âª¯Ì¸~nprec~âŠ€~npreceq~âª¯Ì¸~nrArr~â‡~nrarr~â†›~nrarrc~â¤³Ì¸~nrarrw~â†Ì¸~nrightarrow~â†›~nrtri~â‹«~nrtrie~â‹­~nsc~âŠ~nsccue~â‹¡~nsce~âª°Ì¸~nscr~ð“ƒ~nshortmid~âˆ¤~nshortparallel~âˆ¦~nsim~â‰~nsime~â‰„~nsimeq~â‰„~nsmid~âˆ¤~nspar~âˆ¦~nsqsube~â‹¢~nsqsupe~â‹£~nsubE~â«…Ì¸~nsube~âŠˆ~nsubset~âŠ‚âƒ’~nsubseteq~âŠˆ~nsubseteqq~â«…Ì¸~nsucc~âŠ~nsucceq~âª°Ì¸~nsup~âŠ…~nsupE~â«†Ì¸~nsupe~âŠ‰~nsupset~âŠƒâƒ’~nsupseteq~âŠ‰~nsupseteqq~â«†Ì¸~ntgl~â‰¹~ntlg~â‰¸~ntriangleleft~â‹ª~ntrianglelefteq~â‹¬~ntriangleright~â‹«~ntrianglerighteq~â‹­~num~#~numero~â„–~numsp~â€‡~nvDash~âŠ­~nvHarr~â¤„~nvap~â‰âƒ’~nvdash~âŠ¬~nvge~â‰¥âƒ’~nvgt~>âƒ’~nvinfin~â§ž~nvlArr~â¤‚~nvle~â‰¤âƒ’~nvlt~<âƒ’~nvltrie~âŠ´âƒ’~nvrArr~â¤ƒ~nvrtrie~âŠµâƒ’~nvsim~âˆ¼âƒ’~nwArr~â‡–~nwarhk~â¤£~nwarr~â†–~nwarrow~â†–~nwnear~â¤§~oS~â“ˆ~oast~âŠ›~ocir~âŠš~ocy~Ð¾~odash~âŠ~odblac~Å‘~odiv~â¨¸~odot~âŠ™~odsold~â¦¼~ofcir~â¦¿~ofr~ð”¬~ogon~Ë›~ogt~â§~ohbar~â¦µ~ohm~Î©~oint~âˆ®~olarr~â†º~olcir~â¦¾~olcross~â¦»~olt~â§€~omacr~Å~omid~â¦¶~ominus~âŠ–~oopf~ð• ~opar~â¦·~operp~â¦¹~orarr~â†»~ord~â©~order~â„´~orderof~â„´~origof~âŠ¶~oror~â©–~orslope~â©—~orv~â©›~oscr~â„´~osol~âŠ˜~otimesas~â¨¶~ovbar~âŒ½~par~âˆ¥~parallel~âˆ¥~parsim~â«³~parsl~â«½~pcy~Ð¿~percnt~%~period~.~pertenk~â€±~pfr~ð”­~phiv~Ï•~phmmat~â„³~phone~â˜Ž~pitchfork~â‹”~planck~â„~planckh~â„Ž~plankv~â„~plus~+~plusacir~â¨£~plusb~âŠž~pluscir~â¨¢~plusdo~âˆ”~plusdu~â¨¥~pluse~â©²~plussim~â¨¦~plustwo~â¨§~pm~Â±~pointint~â¨•~popf~ð•¡~pr~â‰º~prE~âª³~prap~âª·~prcue~â‰¼~pre~âª¯~prec~â‰º~precapprox~âª·~preccurlyeq~â‰¼~preceq~âª¯~precnapprox~âª¹~precneqq~âªµ~precnsim~â‹¨~precsim~â‰¾~primes~â„™~prnE~âªµ~prnap~âª¹~prnsim~â‹¨~profalar~âŒ®~profline~âŒ’~profsurf~âŒ“~propto~âˆ~prsim~â‰¾~prurel~âŠ°~pscr~ð“…~puncsp~â€ˆ~qfr~ð”®~qint~â¨Œ~qopf~ð•¢~qprime~â—~qscr~ð“†~quaternions~â„~quatint~â¨–~quest~?~questeq~â‰Ÿ~rAarr~â‡›~rAtail~â¤œ~rBarr~â¤~rHar~â¥¤~race~âˆ½Ì±~racute~Å•~raemptyv~â¦³~rangd~â¦’~range~â¦¥~rangle~âŸ©~rarrap~â¥µ~rarrb~â‡¥~rarrbfs~â¤ ~rarrc~â¤³~rarrfs~â¤ž~rarrhk~â†ª~rarrlp~â†¬~rarrpl~â¥…~rarrsim~â¥´~rarrtl~â†£~rarrw~â†~ratail~â¤š~ratio~âˆ¶~rationals~â„š~rbarr~â¤~rbbrk~â³~rbrace~}~rbrack~]~rbrke~â¦Œ~rbrksld~â¦Ž~rbrkslu~â¦~rcaron~Å™~rcedil~Å—~rcub~}~rcy~Ñ€~rdca~â¤·~rdldhar~â¥©~rdquor~â€~rdsh~â†³~realine~â„›~realpart~â„œ~reals~â„~rect~â–­~rfisht~â¥½~rfr~ð”¯~rhard~â‡~rharu~â‡€~rharul~â¥¬~rhov~Ï±~rightarrow~â†’~rightarrowtail~â†£~rightharpoondown~â‡~rightharpoonup~â‡€~rightleftarrows~â‡„~rightleftharpoons~â‡Œ~rightrightarrows~â‡‰~rightsquigarrow~â†~rightthreetimes~â‹Œ~ring~Ëš~risingdotseq~â‰“~rlarr~â‡„~rlhar~â‡Œ~rmoust~âŽ±~rmoustache~âŽ±~rnmid~â«®~roang~âŸ­~roarr~â‡¾~robrk~âŸ§~ropar~â¦†~ropf~ð•£~roplus~â¨®~rotimes~â¨µ~rpar~)~rpargt~â¦”~rppolint~â¨’~rrarr~â‡‰~rscr~ð“‡~rsh~â†±~rsqb~]~rsquor~â€™~rthree~â‹Œ~rtimes~â‹Š~rtri~â–¹~rtrie~âŠµ~rtrif~â–¸~rtriltri~â§Ž~ruluhar~â¥¨~rx~â„ž~sacute~Å›~sc~â‰»~scE~âª´~scap~âª¸~sccue~â‰½~sce~âª°~scedil~ÅŸ~scirc~Å~scnE~âª¶~scnap~âªº~scnsim~â‹©~scpolint~â¨“~scsim~â‰¿~scy~Ñ~sdotb~âŠ¡~sdote~â©¦~seArr~â‡˜~searhk~â¤¥~searr~â†˜~searrow~â†˜~semi~;~seswar~â¤©~setminus~âˆ–~setmn~âˆ–~sext~âœ¶~sfr~ð”°~sfrown~âŒ¢~sharp~â™¯~shchcy~Ñ‰~shcy~Ñˆ~shortmid~âˆ£~shortparallel~âˆ¥~sigmav~Ï‚~simdot~â©ª~sime~â‰ƒ~simeq~â‰ƒ~simg~âªž~simgE~âª ~siml~âª~simlE~âªŸ~simne~â‰†~simplus~â¨¤~simrarr~â¥²~slarr~â†~smallsetminus~âˆ–~smashp~â¨³~smeparsl~â§¤~smid~âˆ£~smile~âŒ£~smt~âªª~smte~âª¬~smtes~âª¬ï¸€~softcy~ÑŒ~sol~/~solb~â§„~solbar~âŒ¿~sopf~ð•¤~spadesuit~â™ ~spar~âˆ¥~sqcap~âŠ“~sqcaps~âŠ“ï¸€~sqcup~âŠ”~sqcups~âŠ”ï¸€~sqsub~âŠ~sqsube~âŠ‘~sqsubset~âŠ~sqsubseteq~âŠ‘~sqsup~âŠ~sqsupe~âŠ’~sqsupset~âŠ~sqsupseteq~âŠ’~squ~â–¡~square~â–¡~squarf~â–ª~squf~â–ª~srarr~â†’~sscr~ð“ˆ~ssetmn~âˆ–~ssmile~âŒ£~sstarf~â‹†~star~â˜†~starf~â˜…~straightepsilon~Ïµ~straightphi~Ï•~strns~Â¯~subE~â«…~subdot~âª½~subedot~â«ƒ~submult~â«~subnE~â«‹~subne~âŠŠ~subplus~âª¿~subrarr~â¥¹~subset~âŠ‚~subseteq~âŠ†~subseteqq~â«…~subsetneq~âŠŠ~subsetneqq~â«‹~subsim~â«‡~subsub~â«•~subsup~â«“~succ~â‰»~succapprox~âª¸~succcurlyeq~â‰½~succeq~âª°~succnapprox~âªº~succneqq~âª¶~succnsim~â‹©~succsim~â‰¿~sung~â™ª~supE~â«†~supdot~âª¾~supdsub~â«˜~supedot~â«„~suphsol~âŸ‰~suphsub~â«—~suplarr~â¥»~supmult~â«‚~supnE~â«Œ~supne~âŠ‹~supplus~â«€~supset~âŠƒ~supseteq~âŠ‡~supseteqq~â«†~supsetneq~âŠ‹~supsetneqq~â«Œ~supsim~â«ˆ~supsub~â«”~supsup~â«–~swArr~â‡™~swarhk~â¤¦~swarr~â†™~swarrow~â†™~swnwar~â¤ª~target~âŒ–~tbrk~âŽ´~tcaron~Å¥~tcedil~Å£~tcy~Ñ‚~tdot~âƒ›~telrec~âŒ•~tfr~ð”±~therefore~âˆ´~thetav~Ï‘~thickapprox~â‰ˆ~thicksim~âˆ¼~thkap~â‰ˆ~thksim~âˆ¼~timesb~âŠ ~timesbar~â¨±~timesd~â¨°~tint~âˆ­~toea~â¤¨~top~âŠ¤~topbot~âŒ¶~topcir~â«±~topf~ð•¥~topfork~â«š~tosa~â¤©~tprime~â€´~triangle~â–µ~triangledown~â–¿~triangleleft~â—ƒ~trianglelefteq~âŠ´~triangleq~â‰œ~triangleright~â–¹~trianglerighteq~âŠµ~tridot~â—¬~trie~â‰œ~triminus~â¨º~triplus~â¨¹~trisb~â§~tritime~â¨»~trpezium~â¢~tscr~ð“‰~tscy~Ñ†~tshcy~Ñ›~tstrok~Å§~twixt~â‰¬~twoheadleftarrow~â†ž~twoheadrightarrow~â† ~uHar~â¥£~ubrcy~Ñž~ubreve~Å­~ucy~Ñƒ~udarr~â‡…~udblac~Å±~udhar~â¥®~ufisht~â¥¾~ufr~ð”²~uharl~â†¿~uharr~â†¾~uhblk~â–€~ulcorn~âŒœ~ulcorner~âŒœ~ulcrop~âŒ~ultri~â—¸~umacr~Å«~uogon~Å³~uopf~ð•¦~uparrow~â†‘~updownarrow~â†•~upharpoonleft~â†¿~upharpoonright~â†¾~uplus~âŠŽ~upsi~Ï…~upuparrows~â‡ˆ~urcorn~âŒ~urcorner~âŒ~urcrop~âŒŽ~uring~Å¯~urtri~â—¹~uscr~ð“Š~utdot~â‹°~utilde~Å©~utri~â–µ~utrif~â–´~uuarr~â‡ˆ~uwangle~â¦§~vArr~â‡•~vBar~â«¨~vBarv~â«©~vDash~âŠ¨~vangrt~â¦œ~varepsilon~Ïµ~varkappa~Ï°~varnothing~âˆ…~varphi~Ï•~varpi~Ï–~varpropto~âˆ~varr~â†•~varrho~Ï±~varsigma~Ï‚~varsubsetneq~âŠŠï¸€~varsubsetneqq~â«‹ï¸€~varsupsetneq~âŠ‹ï¸€~varsupsetneqq~â«Œï¸€~vartheta~Ï‘~vartriangleleft~âŠ²~vartriangleright~âŠ³~vcy~Ð²~vdash~âŠ¢~vee~âˆ¨~veebar~âŠ»~veeeq~â‰š~vellip~â‹®~verbar~|~vert~|~vfr~ð”³~vltri~âŠ²~vnsub~âŠ‚âƒ’~vnsup~âŠƒâƒ’~vopf~ð•§~vprop~âˆ~vrtri~âŠ³~vscr~ð“‹~vsubnE~â«‹ï¸€~vsubne~âŠŠï¸€~vsupnE~â«Œï¸€~vsupne~âŠ‹ï¸€~vzigzag~â¦š~wcirc~Åµ~wedbar~â©Ÿ~wedge~âˆ§~wedgeq~â‰™~wfr~ð”´~wopf~ð•¨~wp~â„˜~wr~â‰€~wreath~â‰€~wscr~ð“Œ~xcap~â‹‚~xcirc~â—¯~xcup~â‹ƒ~xdtri~â–½~xfr~ð”µ~xhArr~âŸº~xharr~âŸ·~xlArr~âŸ¸~xlarr~âŸµ~xmap~âŸ¼~xnis~â‹»~xodot~â¨€~xopf~ð•©~xoplus~â¨~xotime~â¨‚~xrArr~âŸ¹~xrarr~âŸ¶~xscr~ð“~xsqcup~â¨†~xuplus~â¨„~xutri~â–³~xvee~â‹~xwedge~â‹€~yacy~Ñ~ycirc~Å·~ycy~Ñ‹~yfr~ð”¶~yicy~Ñ—~yopf~ð•ª~yscr~ð“Ž~yucy~ÑŽ~zacute~Åº~zcaron~Å¾~zcy~Ð·~zdot~Å¼~zeetrf~â„¨~zfr~ð”·~zhcy~Ð¶~zigrarr~â‡~zopf~ð•«~zscr~ð“~~AMP~&~COPY~Â©~GT~>~LT~<~QUOT~"~REG~Â®', namedReferences["html4"]);
var numericUnicodeMap = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
};
var fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
};
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var allNamedReferences = __assign(__assign({}, namedReferences), { all: namedReferences.html5 });
var defaultDecodeOptions = {
  scope: "body",
  level: "all"
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
  xml: {
    strict,
    attribute,
    body: bodyRegExps.xml
  },
  html4: {
    strict,
    attribute,
    body: bodyRegExps.html4
  },
  html5: {
    strict,
    attribute,
    body: bodyRegExps.html5
  }
};
var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
function getDecodedEntity(entity, references, isAttribute, isStrict) {
  var decodeResult = entity;
  var decodeEntityLastChar = entity[entity.length - 1];
  if (isAttribute && decodeEntityLastChar === "=") {
    decodeResult = entity;
  } else if (isStrict && decodeEntityLastChar !== ";") {
    decodeResult = entity;
  } else {
    var decodeResultByReference = references[entity];
    if (decodeResultByReference) {
      decodeResult = decodeResultByReference;
    } else if (entity[0] === "&" && entity[1] === "#") {
      var decodeSecondChar = entity[2];
      var decodeCode = decodeSecondChar == "x" || decodeSecondChar == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
      decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? fromCodePoint(decodeCode) : fromCharCode(numericUnicodeMap[decodeCode] || decodeCode);
    }
  }
  return decodeResult;
}
function decode(text, _a) {
  var _b = defaultDecodeOptions, _c = _b.level, level = _c === void 0 ? "all" : _c, _d = _b.scope, scope = _d === void 0 ? level === "xml" ? "strict" : "body" : _d;
  if (!text) {
    return "";
  }
  var decodeRegExp = decodeRegExps[level][scope];
  var references = allNamedReferences[level].entities;
  var isAttribute = scope === "attribute";
  var isStrict = scope === "strict";
  return text.replace(decodeRegExp, function(entity) {
    return getDecodedEntity(entity, references, isAttribute, isStrict);
  });
}
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName) return colorName;
  hasRequiredColorName = 1;
  colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  return colorName;
}
var colorNameExports = requireColorName();
const colorNames = /* @__PURE__ */ getDefaultExportFromCjs(colorNameExports);
var isVnode = function(x) {
  return x && "VirtualNode" === x.type && "2" === x.version;
};
var isWidget_1 = function(w) {
  return w && "Widget" === w.type;
};
var isThunk_1 = function(t) {
  return t && "Thunk" === t.type;
};
var isVhook = function(hook) {
  return hook && ("function" == typeof hook.hook && !hook.hasOwnProperty("hook") || "function" == typeof hook.unhook && !hook.hasOwnProperty("unhook"));
};
var vnode = VirtualNode, noProperties = {}, noChildren = [];
function VirtualNode(tagName, properties, children, key, namespace) {
  this.tagName = tagName, this.properties = properties || noProperties, this.children = children || noChildren, this.key = null != key ? String(key) : void 0, this.namespace = "string" == typeof namespace ? namespace : null;
  var hooks, count = children && children.length || 0, descendants = 0, hasWidgets = false, hasThunks = false, descendantHooks = false;
  for (var propName in properties) if (properties.hasOwnProperty(propName)) {
    var property = properties[propName];
    isVhook(property) && property.unhook && (hooks || (hooks = {}), hooks[propName] = property);
  }
  for (var i = 0; i < count; i++) {
    var child = children[i];
    isVnode(child) ? (descendants += child.count || 0, !hasWidgets && child.hasWidgets && (hasWidgets = true), !hasThunks && child.hasThunks && (hasThunks = true), descendantHooks || !child.hooks && !child.descendantHooks || (descendantHooks = true)) : !hasWidgets && isWidget_1(child) ? "function" == typeof child.destroy && (hasWidgets = true) : !hasThunks && isThunk_1(child) && (hasThunks = true);
  }
  this.count = count + descendants, this.hasWidgets = hasWidgets, this.hasThunks = hasThunks, this.hooks = hooks, this.descendantHooks = descendantHooks;
}
VirtualNode.prototype.version = "2", VirtualNode.prototype.type = "VirtualNode";
var vtext = VirtualText;
function VirtualText(text) {
  this.text = String(text);
}
VirtualText.prototype.version = "2", VirtualText.prototype.type = "VirtualText";
const namespaces_a = "http://schemas.openxmlformats.org/drawingml/2006/main", namespaces_cdr = "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing", namespaces_dc = "http://purl.org/dc/elements/1.1/", namespaces_dcmitype = "http://purl.org/dc/dcmitype/", namespaces_dcterms = "http://purl.org/dc/terms/", namespaces_o = "urn:schemas-microsoft-com:office:office", namespaces_pic = "http://schemas.openxmlformats.org/drawingml/2006/picture", namespaces_r = "http://schemas.openxmlformats.org/officeDocument/2006/relationships", namespaces_v = "urn:schemas-microsoft-com:vml", namespaces_ve = "http://schemas.openxmlformats.org/markup-compatibility/2006", namespaces_vt = "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", namespaces_w = "http://schemas.openxmlformats.org/wordprocessingml/2006/main", namespaces_w10 = "urn:schemas-microsoft-com:office:word", namespaces_wp = "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing", namespaces_wne = "http://schemas.microsoft.com/office/word/2006/wordml", namespaces_xsi = "http://www.w3.org/2001/XMLSchema-instance", namespaces_numbering = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering", namespaces_fontTable = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable", namespaces_hyperlinks = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", namespaces_images = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", namespaces_styles = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", namespaces_headers = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header", namespaces_footers = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer", namespaces_themes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", namespaces_coreProperties = "http://schemas.openxmlformats.org/package/2006/metadata/core-properties", namespaces_officeDocumentRelation = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", namespaces_corePropertiesRelation = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", namespaces_settingsRelation = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings", namespaces_webSettingsRelation = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings", namespaces_sl = "http://schemas.openxmlformats.org/schemaLibrary/2006/main", namespaces_contentTypes = "http://schemas.openxmlformats.org/package/2006/content-types", namespaces_relationship = "http://schemas.openxmlformats.org/package/2006/relationships";
var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function unwrapExports(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
function createCommonjsModule(fn, basedir, module) {
  return fn(module = { path: basedir, exports: {}, require: function(path2, base) {
    return (function() {
      throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
    })(null == base && module.path);
  } }, module.exports), module.exports;
}
function getCjsExportFromNamespace(n) {
  return n && n.default || n;
}
var lodash = createCommonjsModule((function(module, exports$1) {
  (function() {
    var FUNC_ERROR_TEXT = "Expected a function", PLACEHOLDER = "__lodash_placeholder__", wrapFlags = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]], argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrimStart = /^\s+/, reWhitespace = /\s/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", rsBreakRange = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsAstral = "[\\ud800-\\udfff]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[\\u2700-\\u27bf]", rsLower = "[a-z\\xdf-\\xf6\\xf8-\\xff]", rsMisc = "[^\\ud800-\\udfff" + rsBreakRange + rsDigits + "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsNonAstral = "[^\\ud800-\\udfff]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", reOptMod = "(?:" + rsCombo + "|" + rsFitz + ")?", rsSeq = "[\\ufe0e\\ufe0f]?" + reOptMod + ("(?:\\u200d(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")[\\ufe0e\\ufe0f]?" + reOptMod + ")*"), rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reApos = RegExp("['â€™]", "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+(?:['â€™](?:d|ll|m|re|s|t|ve))?(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+(?:['â€™](?:D|LL|M|RE|S|T|VE))?(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+(?:['â€™](?:d|ll|m|re|s|t|ve))?", rsUpper + "+(?:['â€™](?:D|LL|M|RE|S|T|VE))?", "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsDigits, rsEmoji].join("|"), "g"), reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff" + rsComboRange + "\\ufe0e\\ufe0f]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], templateCounter = -1, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags["[object Uint8ClampedArray]"] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags["[object Uint8ClampedArray]"] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var stringEscapes = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = exports$1 && !exports$1.nodeType && exports$1, freeModule = freeExports && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = (function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        return types2 || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    })(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length && false !== iteratee(array[index], index, array); ) ;
      return array;
    }
    function arrayEachRight(array, iteratee) {
      for (var length = null == array ? 0 : array.length; length-- && false !== iteratee(array[length], length, array); ) ;
      return array;
    }
    function arrayEvery(array, predicate) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (!predicate(array[index], index, array)) return false;
      return true;
    }
    function arrayFilter(array, predicate) {
      for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array[index];
        predicate(value, index, array) && (result[resIndex++] = value);
      }
      return result;
    }
    function arrayIncludes(array, value) {
      return !!(null == array ? 0 : array.length) && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (comparator(value, array[index])) return true;
      return false;
    }
    function arrayMap(array, iteratee) {
      for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
      return result;
    }
    function arrayPush(array, values) {
      for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = null == array ? 0 : array.length;
      for (initAccum && length && (accumulator = array[++index]); ++index < length; ) accumulator = iteratee(accumulator, array[index], index, array);
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = null == array ? 0 : array.length;
      for (initAccum && length && (accumulator = array[--length]); length--; ) accumulator = iteratee(accumulator, array[length], length, array);
      return accumulator;
    }
    function arraySome(array, predicate) {
      for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return true;
      return false;
    }
    var asciiSize = baseProperty("length");
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      return eachFunc(collection, (function(value, key, collection2) {
        if (predicate(value, key, collection2)) return result = key, false;
      })), result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value == value ? (function(array2, value2, fromIndex2) {
        var index = fromIndex2 - 1, length = array2.length;
        for (; ++index < length; ) if (array2[index] === value2) return index;
        return -1;
      })(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (comparator(array[index], value)) return index;
      return -1;
    }
    function baseIsNaN(value) {
      return value != value;
    }
    function baseMean(array, iteratee) {
      var length = null == array ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NaN;
    }
    function baseProperty(key) {
      return function(object2) {
        return null == object2 ? void 0 : object2[key];
      };
    }
    function basePropertyOf(object2) {
      return function(key) {
        return null == object2 ? void 0 : object2[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      return eachFunc(collection, (function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      })), accumulator;
    }
    function baseSum(array, iteratee) {
      for (var result, index = -1, length = array.length; ++index < length; ) {
        var current = iteratee(array[index]);
        void 0 !== current && (result = void 0 === result ? current : result + current);
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
      return result;
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object2, props2) {
      return arrayMap(props2, (function(key) {
        return object2[key];
      }));
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
      return index;
    }
    function countHolders(array, placeholder) {
      for (var length = array.length, result = 0; length--; ) array[length] === placeholder && ++result;
      return result;
    }
    var deburrLetter = basePropertyOf({ "Ã€": "A", "Ã": "A", "Ã‚": "A", "Ãƒ": "A", "Ã„": "A", "Ã…": "A", "Ã ": "a", "Ã¡": "a", "Ã¢": "a", "Ã£": "a", "Ã¤": "a", "Ã¥": "a", "Ã‡": "C", "Ã§": "c", "Ã": "D", "Ã°": "d", "Ãˆ": "E", "Ã‰": "E", "ÃŠ": "E", "Ã‹": "E", "Ã¨": "e", "Ã©": "e", "Ãª": "e", "Ã«": "e", "ÃŒ": "I", "Ã": "I", "ÃŽ": "I", "Ã": "I", "Ã¬": "i", "Ã­": "i", "Ã®": "i", "Ã¯": "i", "Ã‘": "N", "Ã±": "n", "Ã’": "O", "Ã“": "O", "Ã”": "O", "Ã•": "O", "Ã–": "O", "Ã˜": "O", "Ã²": "o", "Ã³": "o", "Ã´": "o", "Ãµ": "o", "Ã¶": "o", "Ã¸": "o", "Ã™": "U", "Ãš": "U", "Ã›": "U", "Ãœ": "U", "Ã¹": "u", "Ãº": "u", "Ã»": "u", "Ã¼": "u", "Ã": "Y", "Ã½": "y", "Ã¿": "y", "Ã†": "Ae", "Ã¦": "ae", "Ãž": "Th", "Ã¾": "th", "ÃŸ": "ss", "Ä€": "A", "Ä‚": "A", "Ä„": "A", "Ä": "a", "Äƒ": "a", "Ä…": "a", "Ä†": "C", "Äˆ": "C", "ÄŠ": "C", "ÄŒ": "C", "Ä‡": "c", "Ä‰": "c", "Ä‹": "c", "Ä": "c", "ÄŽ": "D", "Ä": "D", "Ä": "d", "Ä‘": "d", "Ä’": "E", "Ä”": "E", "Ä–": "E", "Ä˜": "E", "Äš": "E", "Ä“": "e", "Ä•": "e", "Ä—": "e", "Ä™": "e", "Ä›": "e", "Äœ": "G", "Äž": "G", "Ä ": "G", "Ä¢": "G", "Ä": "g", "ÄŸ": "g", "Ä¡": "g", "Ä£": "g", "Ä¤": "H", "Ä¦": "H", "Ä¥": "h", "Ä§": "h", "Ä¨": "I", "Äª": "I", "Ä¬": "I", "Ä®": "I", "Ä°": "I", "Ä©": "i", "Ä«": "i", "Ä­": "i", "Ä¯": "i", "Ä±": "i", "Ä´": "J", "Äµ": "j", "Ä¶": "K", "Ä·": "k", "Ä¸": "k", "Ä¹": "L", "Ä»": "L", "Ä½": "L", "Ä¿": "L", "Å": "L", "Äº": "l", "Ä¼": "l", "Ä¾": "l", "Å€": "l", "Å‚": "l", "Åƒ": "N", "Å…": "N", "Å‡": "N", "ÅŠ": "N", "Å„": "n", "Å†": "n", "Åˆ": "n", "Å‹": "n", "ÅŒ": "O", "ÅŽ": "O", "Å": "O", "Å": "o", "Å": "o", "Å‘": "o", "Å”": "R", "Å–": "R", "Å˜": "R", "Å•": "r", "Å—": "r", "Å™": "r", "Åš": "S", "Åœ": "S", "Åž": "S", "Å ": "S", "Å›": "s", "Å": "s", "ÅŸ": "s", "Å¡": "s", "Å¢": "T", "Å¤": "T", "Å¦": "T", "Å£": "t", "Å¥": "t", "Å§": "t", "Å¨": "U", "Åª": "U", "Å¬": "U", "Å®": "U", "Å°": "U", "Å²": "U", "Å©": "u", "Å«": "u", "Å­": "u", "Å¯": "u", "Å±": "u", "Å³": "u", "Å´": "W", "Åµ": "w", "Å¶": "Y", "Å·": "y", "Å¸": "Y", "Å¹": "Z", "Å»": "Z", "Å½": "Z", "Åº": "z", "Å¼": "z", "Å¾": "z", "Ä²": "IJ", "Ä³": "ij", "Å’": "Oe", "Å“": "oe", "Å‰": "'n", "Å¿": "s" }), escapeHtmlChar = basePropertyOf({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" });
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      return map2.forEach((function(value, key) {
        result[++index] = [key, value];
      })), result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array[index];
        value !== placeholder && value !== PLACEHOLDER || (array[index] = PLACEHOLDER, result[resIndex++] = index);
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      return set.forEach((function(value) {
        result[++index] = value;
      })), result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      return set.forEach((function(value) {
        result[++index] = [value, value];
      })), result;
    }
    function stringSize(string) {
      return hasUnicode(string) ? (function(string2) {
        var result = reUnicode.lastIndex = 0;
        for (; reUnicode.test(string2); ) ++result;
        return result;
      })(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? (function(string2) {
        return string2.match(reUnicode) || [];
      })(string) : (function(string2) {
        return string2.split("");
      })(string);
    }
    function trimmedEndIndex(string) {
      for (var index = string.length; index-- && reWhitespace.test(string.charAt(index)); ) ;
      return index;
    }
    var unescapeHtmlChar = basePropertyOf({ "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" });
    var _ = (function runInContext(context2) {
      var uid, Array2 = (context2 = null == context2 ? root : _.defaults(root.Object(), context2, _.pick(root, contextProps))).Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError, arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype, coreJsData = context2["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty2 = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "", nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object2), oldDash = root._, reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer2 = moduleExports ? context2.Buffer : void 0, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0, symIterator = Symbol2 ? Symbol2.iterator : void 0, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0, defineProperty = (function() {
        try {
          var func = getNative(Object2, "defineProperty");
          return func({}, "", {}), func;
        } catch (e) {
        }
      })(), ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout, nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse, DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create"), metaMap = WeakMap2 && new WeakMap2(), realNames = {}, dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2), symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) return value;
          if (hasOwnProperty2.call(value, "__wrapped__")) return wrapperClone(value);
        }
        return new LodashWrapper(value);
      }
      var baseCreate = /* @__PURE__ */ (function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject(proto)) return {};
          if (objectCreate) return objectCreate(proto);
          object2.prototype = proto;
          var result = new object2();
          return object2.prototype = void 0, result;
        };
      })();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = void 0;
      }
      function LazyWrapper(value) {
        this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = [];
      }
      function Hash(entries) {
        var index = -1, length = null == entries ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function ListCache(entries) {
        var index = -1, length = null == entries ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function MapCache(entries) {
        var index = -1, length = null == entries ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function SetCache(values2) {
        var index = -1, length = null == values2 ? 0 : values2.length;
        for (this.__data__ = new MapCache(); ++index < length; ) this.add(values2[index]);
      }
      function Stack2(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String2) : [], length = result.length;
        for (var key in value) !inherited && !hasOwnProperty2.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
        return result;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : void 0;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object2, key, value) {
        (void 0 !== value && !eq(object2[key], value) || void 0 === value && !(key in object2)) && baseAssignValue(object2, key, value);
      }
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        hasOwnProperty2.call(object2, key) && eq(objValue, value) && (void 0 !== value || key in object2) || baseAssignValue(object2, key, value);
      }
      function assocIndexOf(array, key) {
        for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        return baseEach(collection, (function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        })), accumulator;
      }
      function baseAssign(object2, source2) {
        return object2 && copyObject(source2, keys(source2), object2);
      }
      function baseAssignValue(object2, key, value) {
        "__proto__" == key && defineProperty ? defineProperty(object2, key, { configurable: true, enumerable: true, value, writable: true }) : object2[key] = value;
      }
      function baseAt(object2, paths) {
        for (var index = -1, length = paths.length, result = Array2(length), skip = null == object2; ++index < length; ) result[index] = skip ? void 0 : get2(object2, paths[index]);
        return result;
      }
      function baseClamp(number, lower, upper) {
        return number == number && (void 0 !== upper && (number = number <= upper ? number : upper), void 0 !== lower && (number = number >= lower ? number : lower)), number;
      }
      function baseClone(value, bitmask, customizer, key, object2, stack) {
        var result, isDeep = 1 & bitmask, isFlat = 2 & bitmask, isFull = 4 & bitmask;
        if (customizer && (result = object2 ? customizer(value, key, object2, stack) : customizer(value)), void 0 !== result) return result;
        if (!isObject(value)) return value;
        var isArr = isArray(value);
        if (isArr) {
          if (result = (function(array) {
            var length = array.length, result2 = new array.constructor(length);
            length && "string" == typeof array[0] && hasOwnProperty2.call(array, "index") && (result2.index = array.index, result2.input = array.input);
            return result2;
          })(value), !isDeep) return copyArray(value, result);
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) return cloneBuffer(value, isDeep);
          if (tag == objectTag || tag == argsTag || isFunc && !object2) {
            if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? (function(source2, object3) {
              return copyObject(source2, getSymbolsIn(source2), object3);
            })(value, (function(object3, source2) {
              return object3 && copyObject(source2, keysIn(source2), object3);
            })(result, value)) : (function(source2, object3) {
              return copyObject(source2, getSymbols(source2), object3);
            })(value, baseAssign(result, value));
          } else {
            if (!cloneableTags[tag]) return object2 ? value : {};
            result = (function(object3, tag2, isDeep2) {
              var Ctor = object3.constructor;
              switch (tag2) {
                case arrayBufferTag:
                  return cloneArrayBuffer(object3);
                case boolTag:
                case dateTag:
                  return new Ctor(+object3);
                case dataViewTag:
                  return (function(dataView, isDeep3) {
                    var buffer = isDeep3 ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                  })(object3, isDeep2);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                  return cloneTypedArray(object3, isDeep2);
                case mapTag:
                  return new Ctor();
                case numberTag:
                case stringTag:
                  return new Ctor(object3);
                case regexpTag:
                  return (function(regexp) {
                    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                    return result2.lastIndex = regexp.lastIndex, result2;
                  })(object3);
                case setTag:
                  return new Ctor();
                case symbolTag:
                  return symbol = object3, symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
              }
              var symbol;
            })(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) return stacked;
        stack.set(value, result), isSet(value) ? value.forEach((function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        })) : isMap(value) && value.forEach((function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        }));
        var props2 = isArr ? void 0 : (isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys)(value);
        return arrayEach(props2 || value, (function(subValue, key2) {
          props2 && (subValue = value[key2 = subValue]), assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        })), result;
      }
      function baseConformsTo(object2, source2, props2) {
        var length = props2.length;
        if (null == object2) return !length;
        for (object2 = Object2(object2); length--; ) {
          var key = props2[length], predicate = source2[key], value = object2[key];
          if (void 0 === value && !(key in object2) || !predicate(value)) return false;
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        return setTimeout2((function() {
          func.apply(void 0, args);
        }), wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values2.length;
        if (!length) return result;
        iteratee2 && (values2 = arrayMap(values2, baseUnary(iteratee2))), comparator ? (includes = arrayIncludesWith, isCommon = false) : values2.length >= 200 && (includes = cacheHas, isCommon = false, values2 = new SetCache(values2));
        outer: for (; ++index < length; ) {
          var value = array[index], computed = null == iteratee2 ? value : iteratee2(value);
          if (value = comparator || 0 !== value ? value : 0, isCommon && computed == computed) {
            for (var valuesIndex = valuesLength; valuesIndex--; ) if (values2[valuesIndex] === computed) continue outer;
            result.push(value);
          } else includes(values2, computed, comparator) || result.push(value);
        }
        return result;
      }
      lodash2.templateSettings = { escape: reEscape, evaluate: reEvaluate, interpolate: reInterpolate, variable: "", imports: { _: lodash2 } }, lodash2.prototype = baseLodash.prototype, lodash2.prototype.constructor = lodash2, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper, LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper, Hash.prototype.clear = function() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
      }, Hash.prototype.delete = function(key) {
        var result = this.has(key) && delete this.__data__[key];
        return this.size -= result ? 1 : 0, result;
      }, Hash.prototype.get = function(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return "__lodash_hash_undefined__" === result ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }, Hash.prototype.has = function(key) {
        var data = this.__data__;
        return nativeCreate ? void 0 !== data[key] : hasOwnProperty2.call(data, key);
      }, Hash.prototype.set = function(key, value) {
        var data = this.__data__;
        return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? "__lodash_hash_undefined__" : value, this;
      }, ListCache.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, ListCache.prototype.delete = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), --this.size, true);
      }, ListCache.prototype.get = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }, ListCache.prototype.has = function(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }, ListCache.prototype.set = function(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this;
      }, MapCache.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new Hash(), map: new (Map2 || ListCache)(), string: new Hash() };
      }, MapCache.prototype.delete = function(key) {
        var result = getMapData(this, key).delete(key);
        return this.size -= result ? 1 : 0, result;
      }, MapCache.prototype.get = function(key) {
        return getMapData(this, key).get(key);
      }, MapCache.prototype.has = function(key) {
        return getMapData(this, key).has(key);
      }, MapCache.prototype.set = function(key, value) {
        var data = getMapData(this, key), size = data.size;
        return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
      }, SetCache.prototype.add = SetCache.prototype.push = function(value) {
        return this.__data__.set(value, "__lodash_hash_undefined__"), this;
      }, SetCache.prototype.has = function(value) {
        return this.__data__.has(value);
      }, Stack2.prototype.clear = function() {
        this.__data__ = new ListCache(), this.size = 0;
      }, Stack2.prototype.delete = function(key) {
        var data = this.__data__, result = data.delete(key);
        return this.size = data.size, result;
      }, Stack2.prototype.get = function(key) {
        return this.__data__.get(key);
      }, Stack2.prototype.has = function(key) {
        return this.__data__.has(key);
      }, Stack2.prototype.set = function(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < 199) return pairs.push([key, value]), this.size = ++data.size, this;
          data = this.__data__ = new MapCache(pairs);
        }
        return data.set(key, value), this.size = data.size, this;
      };
      var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result = true;
        return baseEach(collection, (function(value, index, collection2) {
          return result = !!predicate(value, index, collection2);
        })), result;
      }
      function baseExtremum(array, iteratee2, comparator) {
        for (var index = -1, length = array.length; ++index < length; ) {
          var value = array[index], current = iteratee2(value);
          if (null != current && (void 0 === computed ? current == current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
        }
        return result;
      }
      function baseFilter(collection, predicate) {
        var result = [];
        return baseEach(collection, (function(value, index, collection2) {
          predicate(value, index, collection2) && result.push(value);
        })), result;
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length; ) {
          var value = array[index];
          depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value);
        }
        return result;
      }
      var baseFor = createBaseFor(), baseForRight = createBaseFor(true);
      function baseForOwn(object2, iteratee2) {
        return object2 && baseFor(object2, iteratee2, keys);
      }
      function baseForOwnRight(object2, iteratee2) {
        return object2 && baseForRight(object2, iteratee2, keys);
      }
      function baseFunctions(object2, props2) {
        return arrayFilter(props2, (function(key) {
          return isFunction(object2[key]);
        }));
      }
      function baseGet(object2, path2) {
        for (var index = 0, length = (path2 = castPath(path2, object2)).length; null != object2 && index < length; ) object2 = object2[toKey(path2[index++])];
        return index && index == length ? object2 : void 0;
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      function baseGetTag(value) {
        return null == value ? void 0 === value ? "[object Undefined]" : "[object Null]" : symToStringTag && symToStringTag in Object2(value) ? (function(value2) {
          var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
          try {
            value2[symToStringTag] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value2);
          unmasked && (isOwn ? value2[symToStringTag] = tag : delete value2[symToStringTag]);
          return result;
        })(value) : (function(value2) {
          return nativeObjectToString.call(value2);
        })(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object2, key) {
        return null != object2 && hasOwnProperty2.call(object2, key);
      }
      function baseHasIn(object2, key) {
        return null != object2 && key in Object2(object2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = 1 / 0, result = []; othIndex--; ) {
          var array = arrays[othIndex];
          othIndex && iteratee2 && (array = arrayMap(array, baseUnary(iteratee2))), maxLength = nativeMin(array.length, maxLength), caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer: for (; ++index < length && result.length < maxLength; ) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (value = comparator || 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            for (othIndex = othLength; --othIndex; ) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer;
            }
            seen && seen.push(computed), result.push(value);
          }
        }
        return result;
      }
      function baseInvoke(object2, path2, args) {
        var func = null == (object2 = parent(object2, path2 = castPath(path2, object2))) ? object2 : object2[toKey(last(path2))];
        return null == func ? void 0 : apply(func, object2, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value != value && other != other : (function(object2, other2, bitmask2, customizer2, equalFunc, stack2) {
          var objIsArr = isArray(object2), othIsArr = isArray(other2), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other2), objIsObj = (objTag = objTag == argsTag ? objectTag : objTag) == objectTag, othIsObj = (othTag = othTag == argsTag ? objectTag : othTag) == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object2)) {
            if (!isBuffer(other2)) return false;
            objIsArr = true, objIsObj = false;
          }
          if (isSameTag && !objIsObj) return stack2 || (stack2 = new Stack2()), objIsArr || isTypedArray(object2) ? equalArrays(object2, other2, bitmask2, customizer2, equalFunc, stack2) : (function(object3, other3, tag, bitmask3, customizer3, equalFunc2, stack3) {
            switch (tag) {
              case dataViewTag:
                if (object3.byteLength != other3.byteLength || object3.byteOffset != other3.byteOffset) return false;
                object3 = object3.buffer, other3 = other3.buffer;
              case arrayBufferTag:
                return !(object3.byteLength != other3.byteLength || !equalFunc2(new Uint8Array2(object3), new Uint8Array2(other3)));
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object3, +other3);
              case errorTag:
                return object3.name == other3.name && object3.message == other3.message;
              case regexpTag:
              case stringTag:
                return object3 == other3 + "";
              case mapTag:
                var convert2 = mapToArray;
              case setTag:
                var isPartial = 1 & bitmask3;
                if (convert2 || (convert2 = setToArray), object3.size != other3.size && !isPartial) return false;
                var stacked = stack3.get(object3);
                if (stacked) return stacked == other3;
                bitmask3 |= 2, stack3.set(object3, other3);
                var result = equalArrays(convert2(object3), convert2(other3), bitmask3, customizer3, equalFunc2, stack3);
                return stack3.delete(object3), result;
              case symbolTag:
                if (symbolValueOf) return symbolValueOf.call(object3) == symbolValueOf.call(other3);
            }
            return false;
          })(object2, other2, objTag, bitmask2, customizer2, equalFunc, stack2);
          if (!(1 & bitmask2)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other2, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other2.value() : other2;
              return stack2 || (stack2 = new Stack2()), equalFunc(objUnwrapped, othUnwrapped, bitmask2, customizer2, stack2);
            }
          }
          if (!isSameTag) return false;
          return stack2 || (stack2 = new Stack2()), (function(object3, other3, bitmask3, customizer3, equalFunc2, stack3) {
            var isPartial = 1 & bitmask3, objProps = getAllKeys(object3), objLength = objProps.length, othLength = getAllKeys(other3).length;
            if (objLength != othLength && !isPartial) return false;
            var index = objLength;
            for (; index--; ) {
              var key = objProps[index];
              if (!(isPartial ? key in other3 : hasOwnProperty2.call(other3, key))) return false;
            }
            var objStacked = stack3.get(object3), othStacked = stack3.get(other3);
            if (objStacked && othStacked) return objStacked == other3 && othStacked == object3;
            var result = true;
            stack3.set(object3, other3), stack3.set(other3, object3);
            var skipCtor = isPartial;
            for (; ++index < objLength; ) {
              var objValue = object3[key = objProps[index]], othValue = other3[key];
              if (customizer3) var compared = isPartial ? customizer3(othValue, objValue, key, other3, object3, stack3) : customizer3(objValue, othValue, key, object3, other3, stack3);
              if (!(void 0 === compared ? objValue === othValue || equalFunc2(objValue, othValue, bitmask3, customizer3, stack3) : compared)) {
                result = false;
                break;
              }
              skipCtor || (skipCtor = "constructor" == key);
            }
            if (result && !skipCtor) {
              var objCtor = object3.constructor, othCtor = other3.constructor;
              objCtor == othCtor || !("constructor" in object3) || !("constructor" in other3) || "function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor || (result = false);
            }
            return stack3.delete(object3), stack3.delete(other3), result;
          })(object2, other2, bitmask2, customizer2, equalFunc, stack2);
        })(value, other, bitmask, customizer, baseIsEqual, stack));
      }
      function baseIsMatch(object2, source2, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (null == object2) return !length;
        for (object2 = Object2(object2); index--; ) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) return false;
        }
        for (; ++index < length; ) {
          var key = (data = matchData[index])[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (void 0 === objValue && !(key in object2)) return false;
          } else {
            var stack = new Stack2();
            if (customizer) var result = customizer(objValue, srcValue, key, object2, source2, stack);
            if (!(void 0 === result ? baseIsEqual(srcValue, objValue, 3, customizer, stack) : result)) return false;
          }
        }
        return true;
      }
      function baseIsNative(value) {
        return !(!isObject(value) || (func = value, maskSrcKey && maskSrcKey in func)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
        var func;
      }
      function baseIteratee(value) {
        return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
      }
      function baseKeys(object2) {
        if (!isPrototype(object2)) return nativeKeys(object2);
        var result = [];
        for (var key in Object2(object2)) hasOwnProperty2.call(object2, key) && "constructor" != key && result.push(key);
        return result;
      }
      function baseKeysIn(object2) {
        if (!isObject(object2)) return (function(object3) {
          var result2 = [];
          if (null != object3) for (var key2 in Object2(object3)) result2.push(key2);
          return result2;
        })(object2);
        var isProto = isPrototype(object2), result = [];
        for (var key in object2) ("constructor" != key || !isProto && hasOwnProperty2.call(object2, key)) && result.push(key);
        return result;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result = isArrayLike(collection) ? Array2(collection.length) : [];
        return baseEach(collection, (function(value, key, collection2) {
          result[++index] = iteratee2(value, key, collection2);
        })), result;
      }
      function baseMatches(source2) {
        var matchData = getMatchData(source2);
        return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object2) {
          return object2 === source2 || baseIsMatch(object2, source2, matchData);
        };
      }
      function baseMatchesProperty(path2, srcValue) {
        return isKey(path2) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path2), srcValue) : function(object2) {
          var objValue = get2(object2, path2);
          return void 0 === objValue && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, 3);
        };
      }
      function baseMerge(object2, source2, srcIndex, customizer, stack) {
        object2 !== source2 && baseFor(source2, (function(srcValue, key) {
          if (stack || (stack = new Stack2()), isObject(srcValue)) !(function(object3, source3, key2, srcIndex2, mergeFunc, customizer2, stack2) {
            var objValue = safeGet(object3, key2), srcValue2 = safeGet(source3, key2), stacked = stack2.get(srcValue2);
            if (stacked) return void assignMergeValue(object3, key2, stacked);
            var newValue2 = customizer2 ? customizer2(objValue, srcValue2, key2 + "", object3, source3, stack2) : void 0, isCommon = void 0 === newValue2;
            if (isCommon) {
              var isArr = isArray(srcValue2), isBuff = !isArr && isBuffer(srcValue2), isTyped = !isArr && !isBuff && isTypedArray(srcValue2);
              newValue2 = srcValue2, isArr || isBuff || isTyped ? isArray(objValue) ? newValue2 = objValue : isArrayLikeObject(objValue) ? newValue2 = copyArray(objValue) : isBuff ? (isCommon = false, newValue2 = cloneBuffer(srcValue2, true)) : isTyped ? (isCommon = false, newValue2 = cloneTypedArray(srcValue2, true)) : newValue2 = [] : isPlainObject(srcValue2) || isArguments(srcValue2) ? (newValue2 = objValue, isArguments(objValue) ? newValue2 = toPlainObject(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue2 = initCloneObject(srcValue2))) : isCommon = false;
            }
            isCommon && (stack2.set(srcValue2, newValue2), mergeFunc(newValue2, srcValue2, srcIndex2, customizer2, stack2), stack2.delete(srcValue2));
            assignMergeValue(object3, key2, newValue2);
          })(object2, source2, key, srcIndex, baseMerge, customizer, stack);
          else {
            var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source2, stack) : void 0;
            void 0 === newValue && (newValue = srcValue), assignMergeValue(object2, key, newValue);
          }
        }), keysIn);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (length) return isIndex(n += n < 0 ? length : 0, length) ? array[n] : void 0;
      }
      function baseOrderBy(collection, iteratees, orders) {
        iteratees = iteratees.length ? arrayMap(iteratees, (function(iteratee2) {
          return isArray(iteratee2) ? function(value) {
            return baseGet(value, 1 === iteratee2.length ? iteratee2[0] : iteratee2);
          } : iteratee2;
        })) : [identity];
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result = baseMap(collection, (function(value, key, collection2) {
          var criteria = arrayMap(iteratees, (function(iteratee2) {
            return iteratee2(value);
          }));
          return { criteria, index: ++index, value };
        }));
        return (function(array, comparer) {
          var length = array.length;
          for (array.sort(comparer); length--; ) array[length] = array[length].value;
          return array;
        })(result, (function(object2, other) {
          return (function(object3, other2, orders2) {
            var index2 = -1, objCriteria = object3.criteria, othCriteria = other2.criteria, length = objCriteria.length, ordersLength = orders2.length;
            for (; ++index2 < length; ) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) return index2 >= ordersLength ? result2 : result2 * ("desc" == orders2[index2] ? -1 : 1);
            }
            return object3.index - other2.index;
          })(object2, other, orders);
        }));
      }
      function basePickBy(object2, paths, predicate) {
        for (var index = -1, length = paths.length, result = {}; ++index < length; ) {
          var path2 = paths[index], value = baseGet(object2, path2);
          predicate(value, path2) && baseSet(result, castPath(path2, object2), value);
        }
        return result;
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        for (array === values2 && (values2 = copyArray(values2)), iteratee2 && (seen = arrayMap(array, baseUnary(iteratee2))); ++index < length; ) for (var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value; (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1; ) seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1);
        return array;
      }
      function basePullAt(array, indexes) {
        for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRepeat(string, n) {
        var result = "";
        if (!string || n < 1 || n > 9007199254740991) return result;
        do {
          n % 2 && (result += string), (n = nativeFloor(n / 2)) && (string += string);
        } while (n);
        return result;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object2, path2, value, customizer) {
        if (!isObject(object2)) return object2;
        for (var index = -1, length = (path2 = castPath(path2, object2)).length, lastIndex = length - 1, nested = object2; null != nested && ++index < length; ) {
          var key = toKey(path2[index]), newValue = value;
          if ("__proto__" === key || "constructor" === key || "prototype" === key) return object2;
          if (index != lastIndex) {
            var objValue = nested[key];
            void 0 === (newValue = customizer ? customizer(objValue, key, nested) : void 0) && (newValue = isObject(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {});
          }
          assignValue(nested, key, newValue), nested = nested[key];
        }
        return object2;
      }
      var baseSetData = metaMap ? function(func, data) {
        return metaMap.set(func, data), func;
      } : identity, baseSetToString = defineProperty ? function(func, string) {
        return defineProperty(func, "toString", { configurable: true, enumerable: false, value: constant(string), writable: true });
      } : identity;
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        start < 0 && (start = -start > length ? 0 : length + start), (end = end > length ? length : end) < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
        for (var result = Array2(length); ++index < length; ) result[index] = array[index + start];
        return result;
      }
      function baseSome(collection, predicate) {
        var result;
        return baseEach(collection, (function(value, index, collection2) {
          return !(result = predicate(value, index, collection2));
        })), !!result;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = null == array ? low : array.length;
        if ("number" == typeof value && value == value && high <= 2147483647) {
          for (; low < high; ) {
            var mid2 = low + high >>> 1, computed = array[mid2];
            null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid2 + 1 : high = mid2;
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = null == array ? 0 : array.length;
        if (0 === high) return 0;
        for (var valIsNaN = (value = iteratee2(value)) != value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = void 0 === value; low < high; ) {
          var mid2 = nativeFloor((low + high) / 2), computed = iteratee2(array[mid2]), othIsDefined = void 0 !== computed, othIsNull = null === computed, othIsReflexive = computed == computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) var setLow = retHighest || othIsReflexive;
          else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
          setLow ? low = mid2 + 1 : high = mid2;
        }
        return nativeMin(high, 4294967294);
      }
      function baseSortedUniq(array, iteratee2) {
        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result[resIndex++] = 0 === value ? 0 : value;
          }
        }
        return result;
      }
      function baseToNumber(value) {
        return "number" == typeof value ? value : isSymbol(value) ? NaN : +value;
      }
      function baseToString(value) {
        if ("string" == typeof value) return value;
        if (isArray(value)) return arrayMap(value, baseToString) + "";
        if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
        var result = value + "";
        return "0" == result && 1 / value == -Infinity ? "-0" : result;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
        if (comparator) isCommon = false, includes = arrayIncludesWith;
        else if (length >= 200) {
          var set = iteratee2 ? null : createSet(array);
          if (set) return setToArray(set);
          isCommon = false, includes = cacheHas, seen = new SetCache();
        } else seen = iteratee2 ? [] : result;
        outer: for (; ++index < length; ) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (value = comparator || 0 !== value ? value : 0, isCommon && computed == computed) {
            for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer;
            iteratee2 && seen.push(computed), result.push(value);
          } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), result.push(value));
        }
        return result;
      }
      function baseUnset(object2, path2) {
        return null == (object2 = parent(object2, path2 = castPath(path2, object2))) || delete object2[toKey(last(path2))];
      }
      function baseUpdate(object2, path2, updater, customizer) {
        return baseSet(object2, path2, updater(baseGet(object2, path2)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); ) ;
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result = value;
        return result instanceof LazyWrapper && (result = result.value()), arrayReduce(actions, (function(result2, action) {
          return action.func.apply(action.thisArg, arrayPush([result2], action.args));
        }), result);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) return length ? baseUniq(arrays[0]) : [];
        for (var index = -1, result = Array2(length); ++index < length; ) for (var array = arrays[index], othIndex = -1; ++othIndex < length; ) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee2, comparator));
        return baseUniq(baseFlatten(result, 1), iteratee2, comparator);
      }
      function baseZipObject(props2, values2, assignFunc) {
        for (var index = -1, length = props2.length, valsLength = values2.length, result = {}; ++index < length; ) {
          var value = index < valsLength ? values2[index] : void 0;
          assignFunc(result, props2[index], value);
        }
        return result;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return "function" == typeof value ? value : identity;
      }
      function castPath(value, object2) {
        return isArray(value) ? value : isKey(value, object2) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        return end = void 0 === end ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) return buffer.slice();
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        return buffer.copy(result), result;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        return new Uint8Array2(result).set(new Uint8Array2(arrayBuffer)), result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = void 0 !== value, valIsNull = null === value, valIsReflexive = value == value, valIsSymbol = isSymbol(value), othIsDefined = void 0 !== other, othIsNull = null === other, othIsReflexive = other == other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
        }
        return 0;
      }
      function composeArgs(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array2(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; ) result[leftIndex] = partials[leftIndex];
        for (; ++argsIndex < holdersLength; ) (isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
        for (; rangeLength--; ) result[leftIndex++] = args[argsIndex++];
        return result;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array2(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; ) result[argsIndex] = args[argsIndex];
        for (var offset = argsIndex; ++rightIndex < rightLength; ) result[offset + rightIndex] = partials[rightIndex];
        for (; ++holdersIndex < holdersLength; ) (isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
        return result;
      }
      function copyArray(source2, array) {
        var index = -1, length = source2.length;
        for (array || (array = Array2(length)); ++index < length; ) array[index] = source2[index];
        return array;
      }
      function copyObject(source2, props2, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        for (var index = -1, length = props2.length; ++index < length; ) {
          var key = props2[index], newValue = customizer ? customizer(object2[key], source2[key], key, object2, source2) : void 0;
          void 0 === newValue && (newValue = source2[key]), isNew ? baseAssignValue(object2, key, newValue) : assignValue(object2, key, newValue);
        }
        return object2;
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest((function(object2, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, customizer) : void 0, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? void 0 : customizer, length = 1), object2 = Object2(object2); ++index < length; ) {
            var source2 = sources[index];
            source2 && assigner(object2, source2, index, customizer);
          }
          return object2;
        }));
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (null == collection) return collection;
          if (!isArrayLike(collection)) return eachFunc(collection, iteratee2);
          for (var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection); (fromRight ? index-- : ++index < length) && false !== iteratee2(iterable[index], index, iterable); ) ;
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object2, iteratee2, keysFunc) {
          for (var index = -1, iterable = Object2(object2), props2 = keysFunc(object2), length = props2.length; length--; ) {
            var key = props2[fromRight ? length : ++index];
            if (false === iteratee2(iterable[key], key, iterable)) break;
          }
          return object2;
        };
      }
      function createCaseFirst(methodName) {
        return function(string) {
          var strSymbols = hasUnicode(string = toString(string)) ? stringToArray(string) : void 0, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        };
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection), predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : void 0;
        };
      }
      function createFlow(fromRight) {
        return flatRest((function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          for (fromRight && funcs.reverse(); index--; ) {
            var func = funcs[index];
            if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
            if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], true);
          }
          for (index = wrapper ? index : length; ++index < length; ) {
            var funcName = getFuncName(func = funcs[index]), data = "wrapper" == funcName ? getData(func) : void 0;
            wrapper = data && isLaziable(data[0]) && 424 == data[1] && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
            for (var index2 = 0, result = length ? funcs[index2].apply(this, args) : value; ++index2 < length; ) result = funcs[index2].call(this, result);
            return result;
          };
        }));
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = 128 & bitmask, isBind = 1 & bitmask, isBindKey = 2 & bitmask, isCurried = 24 & bitmask, isFlip = 512 & bitmask, Ctor = isBindKey ? void 0 : createCtor(func);
        return function wrapper() {
          for (var length = arguments.length, args = Array2(length), index = length; index--; ) args[index] = arguments[index];
          if (isCurried) var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), isAry && ary2 < length && (args.length = ary2), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)), fn.apply(thisBinding, args);
        };
      }
      function createInverter(setter, toIteratee) {
        return function(object2, iteratee2) {
          return (function(object3, setter2, iteratee3, accumulator) {
            return baseForOwn(object3, (function(value, key, object4) {
              setter2(accumulator, iteratee3(value), key, object4);
            })), accumulator;
          })(object2, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result;
          if (void 0 === value && void 0 === other) return defaultValue;
          if (void 0 !== value && (result = value), void 0 !== other) {
            if (void 0 === result) return other;
            "string" == typeof value || "string" == typeof other ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result = operator(value, other);
          }
          return result;
        };
      }
      function createOver(arrayFunc) {
        return flatRest((function(iteratees) {
          return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest((function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, (function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            }));
          }));
        }));
      }
      function createPadding(length, chars) {
        var charsLength = (chars = void 0 === chars ? " " : baseToString(chars)).length;
        if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = void 0), start = toFinite(start), void 0 === end ? (end = start, start = 0) : end = toFinite(end), (function(start2, end2, step2, fromRight2) {
            for (var index = -1, length = nativeMax(nativeCeil((end2 - start2) / (step2 || 1)), 0), result = Array2(length); length--; ) result[fromRight2 ? length : ++index] = start2, start2 += step2;
            return result;
          })(start, end, step = void 0 === step ? start < end ? 1 : -1 : toFinite(step), fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          return "string" == typeof value && "string" == typeof other || (value = toNumber(value), other = toNumber(other)), operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = 8 & bitmask;
        bitmask |= isCurry ? 32 : 64, 4 & (bitmask &= ~(isCurry ? 64 : 32)) || (bitmask &= -4);
        var newData = [func, bitmask, thisArg, isCurry ? partials : void 0, isCurry ? holders : void 0, isCurry ? void 0 : partials, isCurry ? void 0 : holders, argPos, ary2, arity], result = wrapFunc.apply(void 0, newData);
        return isLaziable(func) && setData(result, newData), result.placeholder = placeholder, setWrapToString(result, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          if (number = toNumber(number), (precision = null == precision ? 0 : nativeMin(toInteger(precision), 292)) && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e");
            return +((pair = (toString(func(pair[0] + "e" + (+pair[1] + precision))) + "e").split("e"))[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = Set2 && 1 / setToArray(new Set2([, -0]))[1] == Infinity ? function(values2) {
        return new Set2(values2);
      } : noop;
      function createToPairs(keysFunc) {
        return function(object2) {
          var tag = getTag(object2);
          return tag == mapTag ? mapToArray(object2) : tag == setTag ? setToPairs(object2) : (function(object3, props2) {
            return arrayMap(props2, (function(key) {
              return [key, object3[key]];
            }));
          })(object2, keysFunc(object2));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = 2 & bitmask;
        if (!isBindKey && "function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        var length = partials ? partials.length : 0;
        if (length || (bitmask &= -97, partials = holders = void 0), ary2 = void 0 === ary2 ? ary2 : nativeMax(toInteger(ary2), 0), arity = void 0 === arity ? arity : toInteger(arity), length -= holders ? holders.length : 0, 64 & bitmask) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = void 0;
        }
        var data = isBindKey ? void 0 : getData(func), newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity];
        if (data && (function(data2, source2) {
          var bitmask2 = data2[1], srcBitmask = source2[1], newBitmask = bitmask2 | srcBitmask, isCommon = newBitmask < 131, isCombo = 128 == srcBitmask && 8 == bitmask2 || 128 == srcBitmask && 256 == bitmask2 && data2[7].length <= source2[8] || 384 == srcBitmask && source2[7].length <= source2[8] && 8 == bitmask2;
          if (!isCommon && !isCombo) return data2;
          1 & srcBitmask && (data2[2] = source2[2], newBitmask |= 1 & bitmask2 ? 0 : 4);
          var value = source2[3];
          if (value) {
            var partials2 = data2[3];
            data2[3] = partials2 ? composeArgs(partials2, value, source2[4]) : value, data2[4] = partials2 ? replaceHolders(data2[3], PLACEHOLDER) : source2[4];
          }
          (value = source2[5]) && (partials2 = data2[5], data2[5] = partials2 ? composeArgsRight(partials2, value, source2[6]) : value, data2[6] = partials2 ? replaceHolders(data2[5], PLACEHOLDER) : source2[6]);
          (value = source2[7]) && (data2[7] = value);
          128 & srcBitmask && (data2[8] = null == data2[8] ? source2[8] : nativeMin(data2[8], source2[8]));
          null == data2[9] && (data2[9] = source2[9]);
          data2[0] = source2[0], data2[1] = newBitmask;
        })(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], !(arity = newData[9] = void 0 === newData[9] ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0)) && 24 & bitmask && (bitmask &= -25), bitmask && 1 != bitmask) result = 8 == bitmask || 16 == bitmask ? (function(func2, bitmask2, arity2) {
          var Ctor = createCtor(func2);
          return function wrapper() {
            for (var length2 = arguments.length, args = Array2(length2), index = length2, placeholder = getHolder(wrapper); index--; ) args[index] = arguments[index];
            var holders2 = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            return (length2 -= holders2.length) < arity2 ? createRecurry(func2, bitmask2, createHybrid, wrapper.placeholder, void 0, args, holders2, void 0, void 0, arity2 - length2) : apply(this && this !== root && this instanceof wrapper ? Ctor : func2, this, args);
          };
        })(func, bitmask, arity) : 32 != bitmask && 33 != bitmask || holders.length ? createHybrid.apply(void 0, newData) : (function(func2, bitmask2, thisArg2, partials2) {
          var isBind = 1 & bitmask2, Ctor = createCtor(func2);
          return function wrapper() {
            for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials2.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func2; ++leftIndex < leftLength; ) args[leftIndex] = partials2[leftIndex];
            for (; argsLength--; ) args[leftIndex++] = arguments[++argsIndex];
            return apply(fn, isBind ? thisArg2 : this, args);
          };
        })(func, bitmask, thisArg, partials);
        else var result = (function(func2, bitmask2, thisArg2) {
          var isBind = 1 & bitmask2, Ctor = createCtor(func2);
          return function wrapper() {
            return (this && this !== root && this instanceof wrapper ? Ctor : func2).apply(isBind ? thisArg2 : this, arguments);
          };
        })(func, bitmask, thisArg);
        return setWrapToString((data ? baseSetData : setData)(result, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object2) {
        return void 0 === objValue || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object2, key) ? srcValue : objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object2, source2, stack) {
        return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue), baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack), stack.delete(srcValue)), objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? void 0 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = 1 & bitmask, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
        var arrStacked = stack.get(array), othStacked = stack.get(other);
        if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
        var index = -1, result = true, seen = 2 & bitmask ? new SetCache() : void 0;
        for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          if (void 0 !== compared) {
            if (compared) continue;
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, (function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) return seen.push(othIndex);
            }))) {
              result = false;
              break;
            }
          } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
            result = false;
            break;
          }
        }
        return stack.delete(array), stack.delete(other), result;
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols);
      }
      function getAllKeysIn(object2) {
        return baseGetAllKeys(object2, keysIn, getSymbolsIn);
      }
      var getData = metaMap ? function(func) {
        return metaMap.get(func);
      } : noop;
      function getFuncName(func) {
        for (var result = func.name + "", array = realNames[result], length = hasOwnProperty2.call(realNames, result) ? array.length : 0; length--; ) {
          var data = array[length], otherFunc = data.func;
          if (null == otherFunc || otherFunc == func) return data.name;
        }
        return result;
      }
      function getHolder(func) {
        return (hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func).placeholder;
      }
      function getIteratee() {
        var result = lodash2.iteratee || iteratee;
        return result = result === iteratee ? baseIteratee : result, arguments.length ? result(arguments[0], arguments[1]) : result;
      }
      function getMapData(map3, key) {
        var value, type2, data = map3.__data__;
        return ("string" == (type2 = typeof (value = key)) || "number" == type2 || "symbol" == type2 || "boolean" == type2 ? "__proto__" !== value : null === value) ? data["string" == typeof key ? "string" : "hash"] : data.map;
      }
      function getMatchData(object2) {
        for (var result = keys(object2), length = result.length; length--; ) {
          var key = result[length], value = object2[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function getNative(object2, key) {
        var value = (function(object3, key2) {
          return null == object3 ? void 0 : object3[key2];
        })(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      var getSymbols = nativeGetSymbols ? function(object2) {
        return null == object2 ? [] : (object2 = Object2(object2), arrayFilter(nativeGetSymbols(object2), (function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        })));
      } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object2) {
        for (var result = []; object2; ) arrayPush(result, getSymbols(object2)), object2 = getPrototype(object2);
        return result;
      } : stubArray, getTag = baseGetTag;
      function hasPath(object2, path2, hasFunc) {
        for (var index = -1, length = (path2 = castPath(path2, object2)).length, result = false; ++index < length; ) {
          var key = toKey(path2[index]);
          if (!(result = null != object2 && hasFunc(object2, key))) break;
          object2 = object2[key];
        }
        return result || ++index != length ? result : !!(length = null == object2 ? 0 : object2.length) && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
      }
      function initCloneObject(object2) {
        return "function" != typeof object2.constructor || isPrototype(object2) ? {} : baseCreate(getPrototype(object2));
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type2 = typeof value;
        return !!(length = null == length ? 9007199254740991 : length) && ("number" == type2 || "symbol" != type2 && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      function isIterateeCall(value, index, object2) {
        if (!isObject(object2)) return false;
        var type2 = typeof index;
        return !!("number" == type2 ? isArrayLike(object2) && isIndex(index, object2.length) : "string" == type2 && index in object2) && eq(object2[index], value);
      }
      function isKey(value, object2) {
        if (isArray(value)) return false;
        var type2 = typeof value;
        return !("number" != type2 && "symbol" != type2 && "boolean" != type2 && null != value && !isSymbol(value)) || (reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object2 && value in Object2(object2));
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return false;
        if (func === other) return true;
        var data = getData(other);
        return !!data && func === data[0];
      }
      (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && "[object Promise]" != getTag(Promise2.resolve()) || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) && (getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return "[object Promise]";
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
        return result;
      });
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor;
        return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
      }
      function isStrictComparable(value) {
        return value == value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          return null != object2 && (object2[key] === srcValue && (void 0 !== srcValue || key in Object2(object2)));
        };
      }
      function overRest(func, start, transform) {
        return start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function() {
          for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length); ++index < length; ) array[index] = args[start + index];
          index = -1;
          for (var otherArgs = Array2(start + 1); ++index < start; ) otherArgs[index] = args[index];
          return otherArgs[start] = transform(array), apply(func, this, otherArgs);
        };
      }
      function parent(object2, path2) {
        return path2.length < 2 ? object2 : baseGet(object2, baseSlice(path2, 0, -1));
      }
      function reorder(array, indexes) {
        for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : void 0;
        }
        return array;
      }
      function safeGet(object2, key) {
        if (("constructor" !== key || "function" != typeof object2[key]) && "__proto__" != key) return object2[key];
      }
      var setData = shortOut(baseSetData), setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      }, setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source2 = reference + "";
        return setToString(wrapper, (function(source3, details) {
          var length = details.length;
          if (!length) return source3;
          var lastIndex = length - 1;
          return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), source3.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        })(source2, (function(details, bitmask2) {
          return arrayEach(wrapFlags, (function(pair) {
            var value = "_." + pair[0];
            bitmask2 & pair[1] && !arrayIncludes(details, value) && details.push(value);
          })), details.sort();
        })((function(source3) {
          var match = source3.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        })(source2), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = 16 - (stamp - lastCalled);
          if (lastCalled = stamp, remaining > 0) {
            if (++count >= 800) return arguments[0];
          } else count = 0;
          return func.apply(void 0, arguments);
        };
      }
      function shuffleSelf(array, size) {
        var index = -1, length = array.length, lastIndex = length - 1;
        for (size = void 0 === size ? length : size; ++index < size; ) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index], array[index] = value;
        }
        return array.length = size, array;
      }
      var stringToPath = (function(func) {
        var result = memoize(func, (function(key) {
          return 500 === cache.size && cache.clear(), key;
        })), cache = result.cache;
        return result;
      })((function(string) {
        var result = [];
        return 46 === string.charCodeAt(0) && result.push(""), string.replace(rePropName, (function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        })), result;
      }));
      function toKey(value) {
        if ("string" == typeof value || isSymbol(value)) return value;
        var result = value + "";
        return "0" == result && 1 / value == -Infinity ? "-0" : result;
      }
      function toSource(func) {
        if (null != func) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) return wrapper.clone();
        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        return result.__actions__ = copyArray(wrapper.__actions__), result.__index__ = wrapper.__index__, result.__values__ = wrapper.__values__, result;
      }
      var difference = baseRest((function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      })), differenceBy = baseRest((function(array, values2) {
        var iteratee2 = last(values2);
        return isArrayLikeObject(iteratee2) && (iteratee2 = void 0), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      })), differenceWith = baseRest((function(array, values2) {
        var comparator = last(values2);
        return isArrayLikeObject(comparator) && (comparator = void 0), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), void 0, comparator) : [];
      }));
      function findIndex(array, predicate, fromIndex) {
        var length = null == array ? 0 : array.length;
        if (!length) return -1;
        var index = null == fromIndex ? 0 : toInteger(fromIndex);
        return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = null == array ? 0 : array.length;
        if (!length) return -1;
        var index = length - 1;
        return void 0 !== fromIndex && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        return (null == array ? 0 : array.length) ? baseFlatten(array, 1) : [];
      }
      function head(array) {
        return array && array.length ? array[0] : void 0;
      }
      var intersection = baseRest((function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      })), intersectionBy = baseRest((function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return iteratee2 === last(mapped) ? iteratee2 = void 0 : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      })), intersectionWith = baseRest((function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return (comparator = "function" == typeof comparator ? comparator : void 0) && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
      }));
      function last(array) {
        var length = null == array ? 0 : array.length;
        return length ? array[length - 1] : void 0;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      var pullAt = flatRest((function(array, indexes) {
        var length = null == array ? 0 : array.length, result = baseAt(array, indexes);
        return basePullAt(array, arrayMap(indexes, (function(index) {
          return isIndex(index, length) ? +index : index;
        })).sort(compareAscending)), result;
      }));
      function reverse(array) {
        return null == array ? array : nativeReverse.call(array);
      }
      var union = baseRest((function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      })), unionBy = baseRest((function(arrays) {
        var iteratee2 = last(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = void 0), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      })), unionWith = baseRest((function(arrays) {
        var comparator = last(arrays);
        return comparator = "function" == typeof comparator ? comparator : void 0, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), void 0, comparator);
      }));
      function unzip2(array) {
        if (!array || !array.length) return [];
        var length = 0;
        return array = arrayFilter(array, (function(group) {
          if (isArrayLikeObject(group)) return length = nativeMax(group.length, length), true;
        })), baseTimes(length, (function(index) {
          return arrayMap(array, baseProperty(index));
        }));
      }
      function unzipWith(array, iteratee2) {
        if (!array || !array.length) return [];
        var result = unzip2(array);
        return null == iteratee2 ? result : arrayMap(result, (function(group) {
          return apply(iteratee2, void 0, group);
        }));
      }
      var without = baseRest((function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      })), xor = baseRest((function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      })), xorBy = baseRest((function(arrays) {
        var iteratee2 = last(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = void 0), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      })), xorWith = baseRest((function(arrays) {
        var comparator = last(arrays);
        return comparator = "function" == typeof comparator ? comparator : void 0, baseXor(arrayFilter(arrays, isArrayLikeObject), void 0, comparator);
      })), zip = baseRest(unzip2);
      var zipWith = baseRest((function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
        return iteratee2 = "function" == typeof iteratee2 ? (arrays.pop(), iteratee2) : void 0, unzipWith(arrays, iteratee2);
      }));
      function chain(value) {
        var result = lodash2(value);
        return result.__chain__ = true, result;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest((function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
          return baseAt(object2, paths);
        };
        return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? ((value = value.slice(start, +start + (length ? 1 : 0))).__actions__.push({ func: thru, args: [interceptor], thisArg: void 0 }), new LodashWrapper(value, this.__chain__).thru((function(array) {
          return length && !array.length && array.push(void 0), array;
        }))) : this.thru(interceptor);
      }));
      var countBy = createAggregator((function(result, value, key) {
        hasOwnProperty2.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1);
      }));
      var find2 = createFind(findIndex), findLast = createFind(findLastIndex);
      function forEach(collection, iteratee2) {
        return (isArray(collection) ? arrayEach : baseEach)(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        return (isArray(collection) ? arrayEachRight : baseEachRight)(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator((function(result, value, key) {
        hasOwnProperty2.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [value]);
      }));
      var invokeMap = baseRest((function(collection, path2, args) {
        var index = -1, isFunc = "function" == typeof path2, result = isArrayLike(collection) ? Array2(collection.length) : [];
        return baseEach(collection, (function(value) {
          result[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
        })), result;
      })), keyBy = createAggregator((function(result, value, key) {
        baseAssignValue(result, key, value);
      }));
      function map2(collection, iteratee2) {
        return (isArray(collection) ? arrayMap : baseMap)(collection, getIteratee(iteratee2, 3));
      }
      var partition = createAggregator((function(result, value, key) {
        result[key ? 0 : 1].push(value);
      }), (function() {
        return [[], []];
      }));
      var sortBy = baseRest((function(collection, iteratees) {
        if (null == collection) return [];
        var length = iteratees.length;
        return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      })), now = ctxNow || function() {
        return root.Date.now();
      };
      function ary(func, n, guard) {
        return n = guard ? void 0 : n, createWrap(func, 128, void 0, void 0, void 0, void 0, n = func && null == n ? func.length : n);
      }
      function before(n, func) {
        var result;
        if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        return n = toInteger(n), function() {
          return --n > 0 && (result = func.apply(this, arguments)), n <= 1 && (func = void 0), result;
        };
      }
      var bind2 = baseRest((function(func, thisArg, partials) {
        var bitmask = 1;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= 32;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      })), bindKey = baseRest((function(object2, key, partials) {
        var bitmask = 3;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= 32;
        }
        return createWrap(key, bitmask, object2, partials, holders);
      }));
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
        }
        function leadingEdge(time) {
          return lastInvokeTime = time, timerId = setTimeout2(timerExpired, wait), leading ? invokeFunc(time) : result;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime;
          return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) return trailingEdge(time);
          timerId = setTimeout2(timerExpired, (function(time2) {
            var timeWaiting = wait - (time2 - lastCallTime);
            return maxing ? nativeMin(timeWaiting, maxWait - (time2 - lastInvokeTime)) : timeWaiting;
          })(time));
        }
        function trailingEdge(time) {
          return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, result);
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
            if (void 0 === timerId) return leadingEdge(lastCallTime);
            if (maxing) return clearTimeout2(timerId), timerId = setTimeout2(timerExpired, wait), invokeFunc(lastCallTime);
          }
          return void 0 === timerId && (timerId = setTimeout2(timerExpired, wait)), result;
        }
        return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, maxWait = (maxing = "maxWait" in options) ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function() {
          void 0 !== timerId && clearTimeout2(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
        }, debounced.flush = function() {
          return void 0 === timerId ? result : trailingEdge(now());
        }, debounced;
      }
      var defer = baseRest((function(func, args) {
        return baseDelay(func, 1, args);
      })), delay = baseRest((function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      }));
      function memoize(func, resolver) {
        if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError2(FUNC_ERROR_TEXT);
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) return cache.get(key);
          var result = func.apply(this, args);
          return memoized.cache = cache.set(key, result) || cache, result;
        };
        return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
      }
      function negate(predicate) {
        if ("function" != typeof predicate) throw new TypeError2(FUNC_ERROR_TEXT);
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      memoize.Cache = MapCache;
      var overArgs = castRest((function(func, transforms2) {
        var funcsLength = (transforms2 = 1 == transforms2.length && isArray(transforms2[0]) ? arrayMap(transforms2[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms2, 1), baseUnary(getIteratee()))).length;
        return baseRest((function(args) {
          for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; ) args[index] = transforms2[index].call(this, args[index]);
          return apply(func, this, args);
        }));
      })), partial = baseRest((function(func, partials) {
        return createWrap(func, 32, void 0, partials, replaceHolders(partials, getHolder(partial)));
      })), partialRight = baseRest((function(func, partials) {
        return createWrap(func, 64, void 0, partials, replaceHolders(partials, getHolder(partialRight)));
      })), rearg = flatRest((function(func, indexes) {
        return createWrap(func, 256, void 0, void 0, void 0, indexes);
      }));
      function eq(value, other) {
        return value === other || value != value && other != other;
      }
      var gt2 = createRelationalOperation(baseGt), gte = createRelationalOperation((function(value, other) {
        return value >= other;
      })), isArguments = baseIsArguments(/* @__PURE__ */ (function() {
        return arguments;
      })()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      }, isArray = Array2.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : function(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      };
      function isArrayLike(value) {
        return null != value && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      var isBuffer = nativeIsBuffer || stubFalse, isDate = nodeIsDate ? baseUnary(nodeIsDate) : function(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      };
      function isError(value) {
        if (!isObjectLike(value)) return false;
        var tag = baseGetTag(value);
        return tag == errorTag || "[object DOMException]" == tag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value);
      }
      function isFunction(value) {
        if (!isObject(value)) return false;
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || "[object AsyncFunction]" == tag || "[object Proxy]" == tag;
      }
      function isInteger(value) {
        return "number" == typeof value && value == toInteger(value);
      }
      function isLength(value) {
        return "number" == typeof value && value > -1 && value % 1 == 0 && value <= 9007199254740991;
      }
      function isObject(value) {
        var type2 = typeof value;
        return null != value && ("object" == type2 || "function" == type2);
      }
      function isObjectLike(value) {
        return null != value && "object" == typeof value;
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : function(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      };
      function isNumber(value) {
        return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) return false;
        var proto = getPrototype(value);
        if (null === proto) return true;
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : function(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      };
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : function(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      };
      function isString(value) {
        return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : function(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      };
      var lt2 = createRelationalOperation(baseLt), lte = createRelationalOperation((function(value, other) {
        return value <= other;
      }));
      function toArray(value) {
        if (!value) return [];
        if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
        if (symIterator && value[symIterator]) return (function(iterator) {
          for (var data, result = []; !(data = iterator.next()).done; ) result.push(data.value);
          return result;
        })(value[symIterator]());
        var tag = getTag(value);
        return (tag == mapTag ? mapToArray : tag == setTag ? setToArray : values)(value);
      }
      function toFinite(value) {
        return value ? Infinity === (value = toNumber(value)) || -Infinity === value ? 17976931348623157e292 * (value < 0 ? -1 : 1) : value == value ? value : 0 : 0 === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result == result ? remainder ? result - remainder : result : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, 4294967295) : 0;
      }
      function toNumber(value) {
        if ("number" == typeof value) return value;
        if (isSymbol(value)) return NaN;
        if (isObject(value)) {
          var other = "function" == typeof value.valueOf ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if ("string" != typeof value) return 0 === value ? value : +value;
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NaN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toString(value) {
        return null == value ? "" : baseToString(value);
      }
      var assign = createAssigner((function(object2, source2) {
        if (isPrototype(source2) || isArrayLike(source2)) copyObject(source2, keys(source2), object2);
        else for (var key in source2) hasOwnProperty2.call(source2, key) && assignValue(object2, key, source2[key]);
      })), assignIn = createAssigner((function(object2, source2) {
        copyObject(source2, keysIn(source2), object2);
      })), assignInWith = createAssigner((function(object2, source2, srcIndex, customizer) {
        copyObject(source2, keysIn(source2), object2, customizer);
      })), assignWith = createAssigner((function(object2, source2, srcIndex, customizer) {
        copyObject(source2, keys(source2), object2, customizer);
      })), at = flatRest(baseAt);
      var defaults2 = baseRest((function(object2, sources) {
        object2 = Object2(object2);
        var index = -1, length = sources.length, guard = length > 2 ? sources[2] : void 0;
        for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; ) for (var source2 = sources[index], props2 = keysIn(source2), propsIndex = -1, propsLength = props2.length; ++propsIndex < propsLength; ) {
          var key = props2[propsIndex], value = object2[key];
          (void 0 === value || eq(value, objectProto[key]) && !hasOwnProperty2.call(object2, key)) && (object2[key] = source2[key]);
        }
        return object2;
      })), defaultsDeep = baseRest((function(args) {
        return args.push(void 0, customDefaultsMerge), apply(mergeWith, void 0, args);
      }));
      function get2(object2, path2, defaultValue) {
        var result = null == object2 ? void 0 : baseGet(object2, path2);
        return void 0 === result ? defaultValue : result;
      }
      function hasIn(object2, path2) {
        return null != object2 && hasPath(object2, path2, baseHasIn);
      }
      var invert = createInverter((function(result, value, key) {
        null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)), result[value] = key;
      }), constant(identity)), invertBy = createInverter((function(result, value, key) {
        null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)), hasOwnProperty2.call(result, value) ? result[value].push(key) : result[value] = [key];
      }), getIteratee), invoke = baseRest(baseInvoke);
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      var merge = createAssigner((function(object2, source2, srcIndex) {
        baseMerge(object2, source2, srcIndex);
      })), mergeWith = createAssigner((function(object2, source2, srcIndex, customizer) {
        baseMerge(object2, source2, srcIndex, customizer);
      })), omit = flatRest((function(object2, paths) {
        var result = {};
        if (null == object2) return result;
        var isDeep = false;
        paths = arrayMap(paths, (function(path2) {
          return path2 = castPath(path2, object2), isDeep || (isDeep = path2.length > 1), path2;
        })), copyObject(object2, getAllKeysIn(object2), result), isDeep && (result = baseClone(result, 7, customOmitClone));
        for (var length = paths.length; length--; ) baseUnset(result, paths[length]);
        return result;
      }));
      var pick = flatRest((function(object2, paths) {
        return null == object2 ? {} : (function(object3, paths2) {
          return basePickBy(object3, paths2, (function(value, path2) {
            return hasIn(object3, path2);
          }));
        })(object2, paths);
      }));
      function pickBy(object2, predicate) {
        if (null == object2) return {};
        var props2 = arrayMap(getAllKeysIn(object2), (function(prop2) {
          return [prop2];
        }));
        return predicate = getIteratee(predicate), basePickBy(object2, props2, (function(value, path2) {
          return predicate(value, path2[0]);
        }));
      }
      var toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn);
      function values(object2) {
        return null == object2 ? [] : baseValues(object2, keys(object2));
      }
      var camelCase = createCompounder((function(result, word, index) {
        return word = word.toLowerCase(), result + (index ? capitalize(word) : word);
      }));
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        return (string = toString(string)) && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      var kebabCase = createCompounder((function(result, word, index) {
        return result + (index ? "-" : "") + word.toLowerCase();
      })), lowerCase = createCompounder((function(result, word, index) {
        return result + (index ? " " : "") + word.toLowerCase();
      })), lowerFirst = createCaseFirst("toLowerCase");
      var snakeCase = createCompounder((function(result, word, index) {
        return result + (index ? "_" : "") + word.toLowerCase();
      }));
      var startCase = createCompounder((function(result, word, index) {
        return result + (index ? " " : "") + upperFirst(word);
      }));
      var upperCase = createCompounder((function(result, word, index) {
        return result + (index ? " " : "") + word.toUpperCase();
      })), upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        return string = toString(string), void 0 === (pattern = guard ? void 0 : pattern) ? (function(string2) {
          return reHasUnicodeWord.test(string2);
        })(string) ? (function(string2) {
          return string2.match(reUnicodeWord) || [];
        })(string) : (function(string2) {
          return string2.match(reAsciiWord) || [];
        })(string) : string.match(pattern) || [];
      }
      var attempt = baseRest((function(func, args) {
        try {
          return apply(func, void 0, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      })), bindAll = flatRest((function(object2, methodNames) {
        return arrayEach(methodNames, (function(key) {
          key = toKey(key), baseAssignValue(object2, key, bind2(object2[key], object2));
        })), object2;
      }));
      function constant(value) {
        return function() {
          return value;
        };
      }
      var flow = createFlow(), flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee("function" == typeof func ? func : baseClone(func, 1));
      }
      var method2 = baseRest((function(path2, args) {
        return function(object2) {
          return baseInvoke(object2, path2, args);
        };
      })), methodOf = baseRest((function(object2, args) {
        return function(path2) {
          return baseInvoke(object2, path2, args);
        };
      }));
      function mixin(object2, source2, options) {
        var props2 = keys(source2), methodNames = baseFunctions(source2, props2);
        null != options || isObject(source2) && (methodNames.length || !props2.length) || (options = source2, source2 = object2, object2 = this, methodNames = baseFunctions(source2, keys(source2)));
        var chain2 = !(isObject(options) && "chain" in options && !options.chain), isFunc = isFunction(object2);
        return arrayEach(methodNames, (function(methodName) {
          var func = source2[methodName];
          object2[methodName] = func, isFunc && (object2.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain2 || chainAll) {
              var result = object2(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
              return actions.push({ func, args: arguments, thisArg: object2 }), result.__chain__ = chainAll, result;
            }
            return func.apply(object2, arrayPush([this.value()], arguments));
          });
        })), object2;
      }
      function noop() {
      }
      var over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome);
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : /* @__PURE__ */ (function(path3) {
          return function(object2) {
            return baseGet(object2, path3);
          };
        })(path2);
      }
      var range2 = createRange(), rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      var add = createMathOperation((function(augend, addend) {
        return augend + addend;
      }), 0), ceil = createRound("ceil"), divide2 = createMathOperation((function(dividend, divisor) {
        return dividend / divisor;
      }), 1), floor2 = createRound("floor");
      var source, multiply = createMathOperation((function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }), 1), round2 = createRound("round"), subtract = createMathOperation((function(minuend, subtrahend) {
        return minuend - subtrahend;
      }), 0);
      return lodash2.after = function(n, func) {
        if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        return n = toInteger(n), function() {
          if (--n < 1) return func.apply(this, arguments);
        };
      }, lodash2.ary = ary, lodash2.assign = assign, lodash2.assignIn = assignIn, lodash2.assignInWith = assignInWith, lodash2.assignWith = assignWith, lodash2.at = at, lodash2.before = before, lodash2.bind = bind2, lodash2.bindAll = bindAll, lodash2.bindKey = bindKey, lodash2.castArray = function() {
        if (!arguments.length) return [];
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }, lodash2.chain = chain, lodash2.chunk = function(array, size, guard) {
        size = (guard ? isIterateeCall(array, size, guard) : void 0 === size) ? 1 : nativeMax(toInteger(size), 0);
        var length = null == array ? 0 : array.length;
        if (!length || size < 1) return [];
        for (var index = 0, resIndex = 0, result = Array2(nativeCeil(length / size)); index < length; ) result[resIndex++] = baseSlice(array, index, index += size);
        return result;
      }, lodash2.compact = function(array) {
        for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
          var value = array[index];
          value && (result[resIndex++] = value);
        }
        return result;
      }, lodash2.concat = function() {
        var length = arguments.length;
        if (!length) return [];
        for (var args = Array2(length - 1), array = arguments[0], index = length; index--; ) args[index - 1] = arguments[index];
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }, lodash2.cond = function(pairs) {
        var length = null == pairs ? 0 : pairs.length, toIteratee = getIteratee();
        return pairs = length ? arrayMap(pairs, (function(pair) {
          if ("function" != typeof pair[1]) throw new TypeError2(FUNC_ERROR_TEXT);
          return [toIteratee(pair[0]), pair[1]];
        })) : [], baseRest((function(args) {
          for (var index = -1; ++index < length; ) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) return apply(pair[1], this, args);
          }
        }));
      }, lodash2.conforms = function(source2) {
        return (function(source3) {
          var props2 = keys(source3);
          return function(object2) {
            return baseConformsTo(object2, source3, props2);
          };
        })(baseClone(source2, 1));
      }, lodash2.constant = constant, lodash2.countBy = countBy, lodash2.create = function(prototype, properties) {
        var result = baseCreate(prototype);
        return null == properties ? result : baseAssign(result, properties);
      }, lodash2.curry = function curry(func, arity, guard) {
        var result = createWrap(func, 8, void 0, void 0, void 0, void 0, void 0, arity = guard ? void 0 : arity);
        return result.placeholder = curry.placeholder, result;
      }, lodash2.curryRight = function curryRight(func, arity, guard) {
        var result = createWrap(func, 16, void 0, void 0, void 0, void 0, void 0, arity = guard ? void 0 : arity);
        return result.placeholder = curryRight.placeholder, result;
      }, lodash2.debounce = debounce, lodash2.defaults = defaults2, lodash2.defaultsDeep = defaultsDeep, lodash2.defer = defer, lodash2.delay = delay, lodash2.difference = difference, lodash2.differenceBy = differenceBy, lodash2.differenceWith = differenceWith, lodash2.drop = function(array, n, guard) {
        var length = null == array ? 0 : array.length;
        return length ? baseSlice(array, (n = guard || void 0 === n ? 1 : toInteger(n)) < 0 ? 0 : n, length) : [];
      }, lodash2.dropRight = function(array, n, guard) {
        var length = null == array ? 0 : array.length;
        return length ? baseSlice(array, 0, (n = length - (n = guard || void 0 === n ? 1 : toInteger(n))) < 0 ? 0 : n) : [];
      }, lodash2.dropRightWhile = function(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }, lodash2.dropWhile = function(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }, lodash2.fill = function(array, value, start, end) {
        var length = null == array ? 0 : array.length;
        return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0, end = length), (function(array2, value2, start2, end2) {
          var length2 = array2.length;
          for ((start2 = toInteger(start2)) < 0 && (start2 = -start2 > length2 ? 0 : length2 + start2), (end2 = void 0 === end2 || end2 > length2 ? length2 : toInteger(end2)) < 0 && (end2 += length2), end2 = start2 > end2 ? 0 : toLength(end2); start2 < end2; ) array2[start2++] = value2;
          return array2;
        })(array, value, start, end)) : [];
      }, lodash2.filter = function(collection, predicate) {
        return (isArray(collection) ? arrayFilter : baseFilter)(collection, getIteratee(predicate, 3));
      }, lodash2.flatMap = function(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }, lodash2.flatMapDeep = function(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), Infinity);
      }, lodash2.flatMapDepth = function(collection, iteratee2, depth) {
        return depth = void 0 === depth ? 1 : toInteger(depth), baseFlatten(map2(collection, iteratee2), depth);
      }, lodash2.flatten = flatten, lodash2.flattenDeep = function(array) {
        return (null == array ? 0 : array.length) ? baseFlatten(array, Infinity) : [];
      }, lodash2.flattenDepth = function(array, depth) {
        return (null == array ? 0 : array.length) ? baseFlatten(array, depth = void 0 === depth ? 1 : toInteger(depth)) : [];
      }, lodash2.flip = function(func) {
        return createWrap(func, 512);
      }, lodash2.flow = flow, lodash2.flowRight = flowRight, lodash2.fromPairs = function(pairs) {
        for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length; ) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }, lodash2.functions = function(object2) {
        return null == object2 ? [] : baseFunctions(object2, keys(object2));
      }, lodash2.functionsIn = function(object2) {
        return null == object2 ? [] : baseFunctions(object2, keysIn(object2));
      }, lodash2.groupBy = groupBy, lodash2.initial = function(array) {
        return (null == array ? 0 : array.length) ? baseSlice(array, 0, -1) : [];
      }, lodash2.intersection = intersection, lodash2.intersectionBy = intersectionBy, lodash2.intersectionWith = intersectionWith, lodash2.invert = invert, lodash2.invertBy = invertBy, lodash2.invokeMap = invokeMap, lodash2.iteratee = iteratee, lodash2.keyBy = keyBy, lodash2.keys = keys, lodash2.keysIn = keysIn, lodash2.map = map2, lodash2.mapKeys = function(object2, iteratee2) {
        var result = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object2, (function(value, key, object3) {
          baseAssignValue(result, iteratee2(value, key, object3), value);
        })), result;
      }, lodash2.mapValues = function(object2, iteratee2) {
        var result = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object2, (function(value, key, object3) {
          baseAssignValue(result, key, iteratee2(value, key, object3));
        })), result;
      }, lodash2.matches = function(source2) {
        return baseMatches(baseClone(source2, 1));
      }, lodash2.matchesProperty = function(path2, srcValue) {
        return baseMatchesProperty(path2, baseClone(srcValue, 1));
      }, lodash2.memoize = memoize, lodash2.merge = merge, lodash2.mergeWith = mergeWith, lodash2.method = method2, lodash2.methodOf = methodOf, lodash2.mixin = mixin, lodash2.negate = negate, lodash2.nthArg = function(n) {
        return n = toInteger(n), baseRest((function(args) {
          return baseNth(args, n);
        }));
      }, lodash2.omit = omit, lodash2.omitBy = function(object2, predicate) {
        return pickBy(object2, negate(getIteratee(predicate)));
      }, lodash2.once = function(func) {
        return before(2, func);
      }, lodash2.orderBy = function(collection, iteratees, orders, guard) {
        return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]), isArray(orders = guard ? void 0 : orders) || (orders = null == orders ? [] : [orders]), baseOrderBy(collection, iteratees, orders));
      }, lodash2.over = over, lodash2.overArgs = overArgs, lodash2.overEvery = overEvery, lodash2.overSome = overSome, lodash2.partial = partial, lodash2.partialRight = partialRight, lodash2.partition = partition, lodash2.pick = pick, lodash2.pickBy = pickBy, lodash2.property = property, lodash2.propertyOf = function(object2) {
        return function(path2) {
          return null == object2 ? void 0 : baseGet(object2, path2);
        };
      }, lodash2.pull = pull, lodash2.pullAll = pullAll, lodash2.pullAllBy = function(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }, lodash2.pullAllWith = function(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, void 0, comparator) : array;
      }, lodash2.pullAt = pullAt, lodash2.range = range2, lodash2.rangeRight = rangeRight, lodash2.rearg = rearg, lodash2.reject = function(collection, predicate) {
        return (isArray(collection) ? arrayFilter : baseFilter)(collection, negate(getIteratee(predicate, 3)));
      }, lodash2.remove = function(array, predicate) {
        var result = [];
        if (!array || !array.length) return result;
        var index = -1, indexes = [], length = array.length;
        for (predicate = getIteratee(predicate, 3); ++index < length; ) {
          var value = array[index];
          predicate(value, index, array) && (result.push(value), indexes.push(index));
        }
        return basePullAt(array, indexes), result;
      }, lodash2.rest = function(func, start) {
        if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        return baseRest(func, start = void 0 === start ? start : toInteger(start));
      }, lodash2.reverse = reverse, lodash2.sampleSize = function(collection, n, guard) {
        return n = (guard ? isIterateeCall(collection, n, guard) : void 0 === n) ? 1 : toInteger(n), (isArray(collection) ? arraySampleSize : baseSampleSize)(collection, n);
      }, lodash2.set = function(object2, path2, value) {
        return null == object2 ? object2 : baseSet(object2, path2, value);
      }, lodash2.setWith = function(object2, path2, value, customizer) {
        return customizer = "function" == typeof customizer ? customizer : void 0, null == object2 ? object2 : baseSet(object2, path2, value, customizer);
      }, lodash2.shuffle = function(collection) {
        return (isArray(collection) ? arrayShuffle : baseShuffle)(collection);
      }, lodash2.slice = function(array, start, end) {
        var length = null == array ? 0 : array.length;
        return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0, end = length) : (start = null == start ? 0 : toInteger(start), end = void 0 === end ? length : toInteger(end)), baseSlice(array, start, end)) : [];
      }, lodash2.sortBy = sortBy, lodash2.sortedUniq = function(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }, lodash2.sortedUniqBy = function(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }, lodash2.split = function(string, separator, limit) {
        return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = void 0), (limit = void 0 === limit ? 4294967295 : limit >>> 0) ? (string = toString(string)) && ("string" == typeof separator || null != separator && !isRegExp(separator)) && !(separator = baseToString(separator)) && hasUnicode(string) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit) : [];
      }, lodash2.spread = function(func, start) {
        if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        return start = null == start ? 0 : nativeMax(toInteger(start), 0), baseRest((function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          return array && arrayPush(otherArgs, array), apply(func, this, otherArgs);
        }));
      }, lodash2.tail = function(array) {
        var length = null == array ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }, lodash2.take = function(array, n, guard) {
        return array && array.length ? baseSlice(array, 0, (n = guard || void 0 === n ? 1 : toInteger(n)) < 0 ? 0 : n) : [];
      }, lodash2.takeRight = function(array, n, guard) {
        var length = null == array ? 0 : array.length;
        return length ? baseSlice(array, (n = length - (n = guard || void 0 === n ? 1 : toInteger(n))) < 0 ? 0 : n, length) : [];
      }, lodash2.takeRightWhile = function(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }, lodash2.takeWhile = function(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }, lodash2.tap = function(value, interceptor) {
        return interceptor(value), value;
      }, lodash2.throttle = function(func, wait, options) {
        var leading = true, trailing = true;
        if ("function" != typeof func) throw new TypeError2(FUNC_ERROR_TEXT);
        return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, { leading, maxWait: wait, trailing });
      }, lodash2.thru = thru, lodash2.toArray = toArray, lodash2.toPairs = toPairs, lodash2.toPairsIn = toPairsIn, lodash2.toPath = function(value) {
        return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }, lodash2.toPlainObject = toPlainObject, lodash2.transform = function(object2, iteratee2, accumulator) {
        var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
        if (iteratee2 = getIteratee(iteratee2, 4), null == accumulator) {
          var Ctor = object2 && object2.constructor;
          accumulator = isArrLike ? isArr ? new Ctor() : [] : isObject(object2) && isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
        }
        return (isArrLike ? arrayEach : baseForOwn)(object2, (function(value, index, object3) {
          return iteratee2(accumulator, value, index, object3);
        })), accumulator;
      }, lodash2.unary = function(func) {
        return ary(func, 1);
      }, lodash2.union = union, lodash2.unionBy = unionBy, lodash2.unionWith = unionWith, lodash2.uniq = function(array) {
        return array && array.length ? baseUniq(array) : [];
      }, lodash2.uniqBy = function(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }, lodash2.uniqWith = function(array, comparator) {
        return comparator = "function" == typeof comparator ? comparator : void 0, array && array.length ? baseUniq(array, void 0, comparator) : [];
      }, lodash2.unset = function(object2, path2) {
        return null == object2 || baseUnset(object2, path2);
      }, lodash2.unzip = unzip2, lodash2.unzipWith = unzipWith, lodash2.update = function(object2, path2, updater) {
        return null == object2 ? object2 : baseUpdate(object2, path2, castFunction(updater));
      }, lodash2.updateWith = function(object2, path2, updater, customizer) {
        return customizer = "function" == typeof customizer ? customizer : void 0, null == object2 ? object2 : baseUpdate(object2, path2, castFunction(updater), customizer);
      }, lodash2.values = values, lodash2.valuesIn = function(object2) {
        return null == object2 ? [] : baseValues(object2, keysIn(object2));
      }, lodash2.without = without, lodash2.words = words, lodash2.wrap = function(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }, lodash2.xor = xor, lodash2.xorBy = xorBy, lodash2.xorWith = xorWith, lodash2.zip = zip, lodash2.zipObject = function(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], assignValue);
      }, lodash2.zipObjectDeep = function(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], baseSet);
      }, lodash2.zipWith = zipWith, lodash2.entries = toPairs, lodash2.entriesIn = toPairsIn, lodash2.extend = assignIn, lodash2.extendWith = assignInWith, mixin(lodash2, lodash2), lodash2.add = add, lodash2.attempt = attempt, lodash2.camelCase = camelCase, lodash2.capitalize = capitalize, lodash2.ceil = ceil, lodash2.clamp = function(number, lower, upper) {
        return void 0 === upper && (upper = lower, lower = void 0), void 0 !== upper && (upper = (upper = toNumber(upper)) == upper ? upper : 0), void 0 !== lower && (lower = (lower = toNumber(lower)) == lower ? lower : 0), baseClamp(toNumber(number), lower, upper);
      }, lodash2.clone = function(value) {
        return baseClone(value, 4);
      }, lodash2.cloneDeep = function(value) {
        return baseClone(value, 5);
      }, lodash2.cloneDeepWith = function(value, customizer) {
        return baseClone(value, 5, customizer = "function" == typeof customizer ? customizer : void 0);
      }, lodash2.cloneWith = function(value, customizer) {
        return baseClone(value, 4, customizer = "function" == typeof customizer ? customizer : void 0);
      }, lodash2.conformsTo = function(object2, source2) {
        return null == source2 || baseConformsTo(object2, source2, keys(source2));
      }, lodash2.deburr = deburr, lodash2.defaultTo = function(value, defaultValue) {
        return null == value || value != value ? defaultValue : value;
      }, lodash2.divide = divide2, lodash2.endsWith = function(string, target2, position) {
        string = toString(string), target2 = baseToString(target2);
        var length = string.length, end = position = void 0 === position ? length : baseClamp(toInteger(position), 0, length);
        return (position -= target2.length) >= 0 && string.slice(position, end) == target2;
      }, lodash2.eq = eq, lodash2.escape = function(string) {
        return (string = toString(string)) && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }, lodash2.escapeRegExp = function(string) {
        return (string = toString(string)) && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }, lodash2.every = function(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = void 0), func(collection, getIteratee(predicate, 3));
      }, lodash2.find = find2, lodash2.findIndex = findIndex, lodash2.findKey = function(object2, predicate) {
        return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
      }, lodash2.findLast = findLast, lodash2.findLastIndex = findLastIndex, lodash2.findLastKey = function(object2, predicate) {
        return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
      }, lodash2.floor = floor2, lodash2.forEach = forEach, lodash2.forEachRight = forEachRight, lodash2.forIn = function(object2, iteratee2) {
        return null == object2 ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
      }, lodash2.forInRight = function(object2, iteratee2) {
        return null == object2 ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
      }, lodash2.forOwn = function(object2, iteratee2) {
        return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
      }, lodash2.forOwnRight = function(object2, iteratee2) {
        return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
      }, lodash2.get = get2, lodash2.gt = gt2, lodash2.gte = gte, lodash2.has = function(object2, path2) {
        return null != object2 && hasPath(object2, path2, baseHas);
      }, lodash2.hasIn = hasIn, lodash2.head = head, lodash2.identity = identity, lodash2.includes = function(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }, lodash2.indexOf = function(array, value, fromIndex) {
        var length = null == array ? 0 : array.length;
        if (!length) return -1;
        var index = null == fromIndex ? 0 : toInteger(fromIndex);
        return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index);
      }, lodash2.inRange = function(number, start, end) {
        return start = toFinite(start), void 0 === end ? (end = start, start = 0) : end = toFinite(end), (function(number2, start2, end2) {
          return number2 >= nativeMin(start2, end2) && number2 < nativeMax(start2, end2);
        })(number = toNumber(number), start, end);
      }, lodash2.invoke = invoke, lodash2.isArguments = isArguments, lodash2.isArray = isArray, lodash2.isArrayBuffer = isArrayBuffer, lodash2.isArrayLike = isArrayLike, lodash2.isArrayLikeObject = isArrayLikeObject, lodash2.isBoolean = function(value) {
        return true === value || false === value || isObjectLike(value) && baseGetTag(value) == boolTag;
      }, lodash2.isBuffer = isBuffer, lodash2.isDate = isDate, lodash2.isElement = function(value) {
        return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value);
      }, lodash2.isEmpty = function(value) {
        if (null == value) return true;
        if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) return !value.size;
        if (isPrototype(value)) return !baseKeys(value).length;
        for (var key in value) if (hasOwnProperty2.call(value, key)) return false;
        return true;
      }, lodash2.isEqual = function(value, other) {
        return baseIsEqual(value, other);
      }, lodash2.isEqualWith = function(value, other, customizer) {
        var result = (customizer = "function" == typeof customizer ? customizer : void 0) ? customizer(value, other) : void 0;
        return void 0 === result ? baseIsEqual(value, other, void 0, customizer) : !!result;
      }, lodash2.isError = isError, lodash2.isFinite = function(value) {
        return "number" == typeof value && nativeIsFinite(value);
      }, lodash2.isFunction = isFunction, lodash2.isInteger = isInteger, lodash2.isLength = isLength, lodash2.isMap = isMap, lodash2.isMatch = function(object2, source2) {
        return object2 === source2 || baseIsMatch(object2, source2, getMatchData(source2));
      }, lodash2.isMatchWith = function(object2, source2, customizer) {
        return customizer = "function" == typeof customizer ? customizer : void 0, baseIsMatch(object2, source2, getMatchData(source2), customizer);
      }, lodash2.isNaN = function(value) {
        return isNumber(value) && value != +value;
      }, lodash2.isNative = function(value) {
        if (isMaskable(value)) throw new Error2("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
        return baseIsNative(value);
      }, lodash2.isNil = function(value) {
        return null == value;
      }, lodash2.isNull = function(value) {
        return null === value;
      }, lodash2.isNumber = isNumber, lodash2.isObject = isObject, lodash2.isObjectLike = isObjectLike, lodash2.isPlainObject = isPlainObject, lodash2.isRegExp = isRegExp, lodash2.isSafeInteger = function(value) {
        return isInteger(value) && value >= -9007199254740991 && value <= 9007199254740991;
      }, lodash2.isSet = isSet, lodash2.isString = isString, lodash2.isSymbol = isSymbol, lodash2.isTypedArray = isTypedArray, lodash2.isUndefined = function(value) {
        return void 0 === value;
      }, lodash2.isWeakMap = function(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }, lodash2.isWeakSet = function(value) {
        return isObjectLike(value) && "[object WeakSet]" == baseGetTag(value);
      }, lodash2.join = function(array, separator) {
        return null == array ? "" : nativeJoin.call(array, separator);
      }, lodash2.kebabCase = kebabCase, lodash2.last = last, lodash2.lastIndexOf = function(array, value, fromIndex) {
        var length = null == array ? 0 : array.length;
        if (!length) return -1;
        var index = length;
        return void 0 !== fromIndex && (index = (index = toInteger(fromIndex)) < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), value == value ? (function(array2, value2, fromIndex2) {
          for (var index2 = fromIndex2 + 1; index2--; ) if (array2[index2] === value2) return index2;
          return index2;
        })(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }, lodash2.lowerCase = lowerCase, lodash2.lowerFirst = lowerFirst, lodash2.lt = lt2, lodash2.lte = lte, lodash2.max = function(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : void 0;
      }, lodash2.maxBy = function(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : void 0;
      }, lodash2.mean = function(array) {
        return baseMean(array, identity);
      }, lodash2.meanBy = function(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }, lodash2.min = function(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : void 0;
      }, lodash2.minBy = function(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : void 0;
      }, lodash2.stubArray = stubArray, lodash2.stubFalse = stubFalse, lodash2.stubObject = function() {
        return {};
      }, lodash2.stubString = function() {
        return "";
      }, lodash2.stubTrue = function() {
        return true;
      }, lodash2.multiply = multiply, lodash2.nth = function(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : void 0;
      }, lodash2.noConflict = function() {
        return root._ === this && (root._ = oldDash), this;
      }, lodash2.noop = noop, lodash2.now = now, lodash2.pad = function(string, length, chars) {
        string = toString(string);
        var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
        if (!length || strLength >= length) return string;
        var mid2 = (length - strLength) / 2;
        return createPadding(nativeFloor(mid2), chars) + string + createPadding(nativeCeil(mid2), chars);
      }, lodash2.padEnd = function(string, length, chars) {
        string = toString(string);
        var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }, lodash2.padStart = function(string, length, chars) {
        string = toString(string);
        var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }, lodash2.parseInt = function(string, radix, guard) {
        return guard || null == radix ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }, lodash2.random = function(lower, upper, floating) {
        if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = void 0), void 0 === floating && ("boolean" == typeof upper ? (floating = upper, upper = void 0) : "boolean" == typeof lower && (floating = lower, lower = void 0)), void 0 === lower && void 0 === upper ? (lower = 0, upper = 1) : (lower = toFinite(lower), void 0 === upper ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
          var temp = lower;
          lower = upper, upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }, lodash2.reduce = function(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }, lodash2.reduceRight = function(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }, lodash2.repeat = function(string, n, guard) {
        return n = (guard ? isIterateeCall(string, n, guard) : void 0 === n) ? 1 : toInteger(n), baseRepeat(toString(string), n);
      }, lodash2.replace = function() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }, lodash2.result = function(object2, path2, defaultValue) {
        var index = -1, length = (path2 = castPath(path2, object2)).length;
        for (length || (length = 1, object2 = void 0); ++index < length; ) {
          var value = null == object2 ? void 0 : object2[toKey(path2[index])];
          void 0 === value && (index = length, value = defaultValue), object2 = isFunction(value) ? value.call(object2) : value;
        }
        return object2;
      }, lodash2.round = round2, lodash2.runInContext = runInContext, lodash2.sample = function(collection) {
        return (isArray(collection) ? arraySample : baseSample)(collection);
      }, lodash2.size = function(collection) {
        if (null == collection) return 0;
        if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
        var tag = getTag(collection);
        return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
      }, lodash2.snakeCase = snakeCase, lodash2.some = function(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = void 0), func(collection, getIteratee(predicate, 3));
      }, lodash2.sortedIndex = function(array, value) {
        return baseSortedIndex(array, value);
      }, lodash2.sortedIndexBy = function(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }, lodash2.sortedIndexOf = function(array, value) {
        var length = null == array ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) return index;
        }
        return -1;
      }, lodash2.sortedLastIndex = function(array, value) {
        return baseSortedIndex(array, value, true);
      }, lodash2.sortedLastIndexBy = function(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }, lodash2.sortedLastIndexOf = function(array, value) {
        if (null == array ? 0 : array.length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) return index;
        }
        return -1;
      }, lodash2.startCase = startCase, lodash2.startsWith = function(string, target2, position) {
        return string = toString(string), position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length), target2 = baseToString(target2), string.slice(position, position + target2.length) == target2;
      }, lodash2.subtract = subtract, lodash2.sum = function(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }, lodash2.sumBy = function(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }, lodash2.template = function(string, options, guard) {
        var settings = lodash2.templateSettings;
        guard && isIterateeCall(string, options, guard) && (options = void 0), string = toString(string), options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), index = 0, interpolate = options.interpolate || reNoMatch, source2 = "__p += '", reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"), sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, (function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          return interpolateValue || (interpolateValue = esTemplateValue), source2 += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = true, source2 += "' +\n__e(" + escapeValue + ") +\n'"), evaluateValue && (isEvaluating = true, source2 += "';\n" + evaluateValue + ";\n__p += '"), interpolateValue && (source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), index = offset + match.length, match;
        })), source2 += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (variable) {
          if (reForbiddenIdentifierChars.test(variable)) throw new Error2("Invalid `variable` option passed into `_.template`");
        } else source2 = "with (obj) {\n" + source2 + "\n}\n";
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
        var result = attempt((function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(void 0, importsValues);
        }));
        if (result.source = source2, isError(result)) throw result;
        return result;
      }, lodash2.times = function(n, iteratee2) {
        if ((n = toInteger(n)) < 1 || n > 9007199254740991) return [];
        var index = 4294967295, length = nativeMin(n, 4294967295);
        n -= 4294967295;
        for (var result = baseTimes(length, iteratee2 = getIteratee(iteratee2)); ++index < n; ) iteratee2(index);
        return result;
      }, lodash2.toFinite = toFinite, lodash2.toInteger = toInteger, lodash2.toLength = toLength, lodash2.toLower = function(value) {
        return toString(value).toLowerCase();
      }, lodash2.toNumber = toNumber, lodash2.toSafeInteger = function(value) {
        return value ? baseClamp(toInteger(value), -9007199254740991, 9007199254740991) : 0 === value ? value : 0;
      }, lodash2.toString = toString, lodash2.toUpper = function(value) {
        return toString(value).toUpperCase();
      }, lodash2.trim = function(string, chars, guard) {
        if ((string = toString(string)) && (guard || void 0 === chars)) return baseTrim(string);
        if (!string || !(chars = baseToString(chars))) return string;
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars);
        return castSlice(strSymbols, charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join("");
      }, lodash2.trimEnd = function(string, chars, guard) {
        if ((string = toString(string)) && (guard || void 0 === chars)) return string.slice(0, trimmedEndIndex(string) + 1);
        if (!string || !(chars = baseToString(chars))) return string;
        var strSymbols = stringToArray(string);
        return castSlice(strSymbols, 0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join("");
      }, lodash2.trimStart = function(string, chars, guard) {
        if ((string = toString(string)) && (guard || void 0 === chars)) return string.replace(reTrimStart, "");
        if (!string || !(chars = baseToString(chars))) return string;
        var strSymbols = stringToArray(string);
        return castSlice(strSymbols, charsStartIndex(strSymbols, stringToArray(chars))).join("");
      }, lodash2.truncate = function(string, options) {
        var length = 30, omission = "...";
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        var strLength = (string = toString(string)).length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) return string;
        var end = length - stringSize(omission);
        if (end < 1) return omission;
        var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (void 0 === separator) return result + omission;
        if (strSymbols && (end += result.length - end), isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result;
            for (separator.global || (separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g")), separator.lastIndex = 0; match = separator.exec(substring); ) var newEnd = match.index;
            result = result.slice(0, void 0 === newEnd ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result.lastIndexOf(separator);
          index > -1 && (result = result.slice(0, index));
        }
        return result + omission;
      }, lodash2.unescape = function(string) {
        return (string = toString(string)) && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }, lodash2.uniqueId = function(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }, lodash2.upperCase = upperCase, lodash2.upperFirst = upperFirst, lodash2.each = forEach, lodash2.eachRight = forEachRight, lodash2.first = head, mixin(lodash2, (source = {}, baseForOwn(lodash2, (function(func, methodName) {
        hasOwnProperty2.call(lodash2.prototype, methodName) || (source[methodName] = func);
      })), source), { chain: false }), lodash2.VERSION = "4.17.21", arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], (function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      })), arrayEach(["drop", "take"], (function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = void 0 === n ? 1 : nativeMax(toInteger(n), 0);
          var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          return result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({ size: nativeMin(n, 4294967295), type: methodName + (result.__dir__ < 0 ? "Right" : "") }), result;
        }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      })), arrayEach(["filter", "map", "takeWhile"], (function(methodName, index) {
        var type2 = index + 1, isFilter = 1 == type2 || 3 == type2;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result = this.clone();
          return result.__iteratees__.push({ iteratee: getIteratee(iteratee2, 3), type: type2 }), result.__filtered__ = result.__filtered__ || isFilter, result;
        };
      })), arrayEach(["head", "last"], (function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      })), arrayEach(["initial", "tail"], (function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      })), LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      }, LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      }, LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      }, LazyWrapper.prototype.invokeMap = baseRest((function(path2, args) {
        return "function" == typeof path2 ? new LazyWrapper(this) : this.map((function(value) {
          return baseInvoke(value, path2, args);
        }));
      })), LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      }, LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result = this;
        return result.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result) : (start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start)), void 0 !== end && (result = (end = toInteger(end)) < 0 ? result.dropRight(-end) : result.take(end - start)), result);
      }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      }, LazyWrapper.prototype.toArray = function() {
        return this.take(4294967295);
      }, baseForOwn(LazyWrapper.prototype, (function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        lodashFunc && (lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value), interceptor = function(value2) {
            var result2 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result2[0] : result2;
          };
          useLazy && checkIteratee && "function" == typeof iteratee2 && 1 != iteratee2.length && (isLazy = useLazy = false);
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result = func.apply(value, args);
            return result.__actions__.push({ func: thru, args: [interceptor], thisArg: void 0 }), new LodashWrapper(result, chainAll);
          }
          return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor), isUnwrapped ? isTaker ? result.value()[0] : result.value() : result);
        });
      })), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], (function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName]((function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          }));
        };
      })), baseForOwn(LazyWrapper.prototype, (function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          hasOwnProperty2.call(realNames, key) || (realNames[key] = []), realNames[key].push({ name: methodName, func: lodashFunc });
        }
      })), realNames[createHybrid(void 0, 2).name] = [{ name: "wrapper", func: void 0 }], LazyWrapper.prototype.clone = function() {
        var result = new LazyWrapper(this.__wrapped__);
        return result.__actions__ = copyArray(this.__actions__), result.__dir__ = this.__dir__, result.__filtered__ = this.__filtered__, result.__iteratees__ = copyArray(this.__iteratees__), result.__takeCount__ = this.__takeCount__, result.__views__ = copyArray(this.__views__), result;
      }, LazyWrapper.prototype.reverse = function() {
        if (this.__filtered__) {
          var result = new LazyWrapper(this);
          result.__dir__ = -1, result.__filtered__ = true;
        } else (result = this.clone()).__dir__ *= -1;
        return result;
      }, LazyWrapper.prototype.value = function() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = (function(start2, end2, transforms2) {
          var index2 = -1, length2 = transforms2.length;
          for (; ++index2 < length2; ) {
            var data2 = transforms2[index2], size = data2.size;
            switch (data2.type) {
              case "drop":
                start2 += size;
                break;
              case "dropRight":
                end2 -= size;
                break;
              case "take":
                end2 = nativeMin(end2, start2 + size);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end2 - size);
            }
          }
          return { start: start2, end: end2 };
        })(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
        var result = [];
        outer: for (; length-- && resIndex < takeCount; ) {
          for (var iterIndex = -1, value = array[index += dir]; ++iterIndex < iterLength; ) {
            var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
            if (2 == type2) value = computed;
            else if (!computed) {
              if (1 == type2) continue outer;
              break outer;
            }
          }
          result[resIndex++] = value;
        }
        return result;
      }, lodash2.prototype.at = wrapperAt, lodash2.prototype.chain = function() {
        return chain(this);
      }, lodash2.prototype.commit = function() {
        return new LodashWrapper(this.value(), this.__chain__);
      }, lodash2.prototype.next = function() {
        void 0 === this.__values__ && (this.__values__ = toArray(this.value()));
        var done2 = this.__index__ >= this.__values__.length;
        return { done: done2, value: done2 ? void 0 : this.__values__[this.__index__++] };
      }, lodash2.prototype.plant = function(value) {
        for (var result, parent2 = this; parent2 instanceof baseLodash; ) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0, clone2.__values__ = void 0, result ? previous.__wrapped__ = clone2 : result = clone2;
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        return previous.__wrapped__ = value, result;
      }, lodash2.prototype.reverse = function() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          return this.__actions__.length && (wrapped = new LazyWrapper(this)), (wrapped = wrapped.reverse()).__actions__.push({ func: thru, args: [reverse], thisArg: void 0 }), new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }, lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = function() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }, lodash2.prototype.first = lodash2.prototype.head, symIterator && (lodash2.prototype[symIterator] = function() {
        return this;
      }), lodash2;
    })();
    freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root._ = _;
  }).call(commonjsGlobal);
}));
const landscapeMargins = { top: 1800, right: 1440, bottom: 1800, left: 1440, header: 720, footer: 720, gutter: 0 }, portraitMargins = { top: 1440, right: 1800, bottom: 1440, left: 1800, header: 720, footer: 720, gutter: 0 }, defaultDocumentOptions = { orientation: "portrait", margins: lodash.cloneDeep(portraitMargins), title: "", subject: "", creator: "html-to-docx", keywords: ["html-to-docx"], description: "", lastModifiedBy: "html-to-docx", revision: 1, createdAt: /* @__PURE__ */ new Date(), modifiedAt: /* @__PURE__ */ new Date(), headerType: "default", header: false, footerType: "default", footer: false, font: "Times New Roman", fontSize: 22, complexScriptFontSize: 22, table: { row: { cantSplit: false } }, pageSize: { width: 12240, height: 15840 }, pageNumber: false, skipFirstHeaderFooter: false, lineNumber: false, lineNumberOptions: { countBy: 1, start: 0, restart: "continuous" }, numbering: { defaultOrderedListStyleType: "decimal" }, decodeUnicode: false, defaultLang: "en-US" }, paragraphBordersObject = { top: { size: 0, spacing: 3, color: "FFFFFF" }, left: { size: 0, spacing: 3, color: "FFFFFF" }, bottom: { size: 0, spacing: 3, color: "FFFFFF" }, right: { size: 0, spacing: 3, color: "FFFFFF" } }, colorlessColors = ["transparent", "auto"], verticalAlignValues = ["top", "middle", "bottom"], documentRelsXML = `
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

  <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="${namespaces_numbering}" Target="numbering.xml"/>
    <Relationship Id="rId2" Type="${namespaces_styles}" Target="styles.xml"/>
    <Relationship Id="rId3" Type="${namespaces_settingsRelation}" Target="settings.xml"/>
    <Relationship Id="rId4" Type="${namespaces_webSettingsRelation}" Target="webSettings.xml"/>
    <Relationship Id="rId5" Type="${namespaces_fontTable}" Target="fontTable.xml"/>
  </Relationships>
`, relsXML = `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
        <Relationship Id="rId1" Type="${namespaces_officeDocumentRelation}" Target="word/document.xml"/>
        <Relationship Id="rId2" Type="${namespaces_corePropertiesRelation}" Target="docProps/core.xml"/>
    </Relationships>
`, fontTableXML = `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:fonts
      xmlns:r="${namespaces_r}"
      xmlns:w="${namespaces_w}"
      >
        <w:font w:name="Arial">
            <w:panose1 w:val="020B0604020202020204"/>
            <w:charset w:val="00"/>
            <w:family w:val="auto"/>
            <w:pitch w:val="variable"/>
            <w:sig w:usb0="00000003" w:usb1="00000000" w:usb2="00000000" w:usb3="00000000" w:csb0="00000001" w:csb1="00000000"/>
        </w:font>
        <w:font w:name="Calibri">
            <w:panose1 w:val="020F0502020204030204"/>
            <w:charset w:val="00"/>
            <w:family w:val="swiss"/>
            <w:pitch w:val="variable"/>
            <w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
        </w:font>
        <w:font w:name="Calibri Light">
            <w:panose1 w:val="020F0302020204030204"/>
            <w:charset w:val="00"/>
            <w:family w:val="swiss"/>
            <w:pitch w:val="variable"/>
            <w:sig w:usb0="E4002EFF" w:usb1="C000247B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
        </w:font>
        <w:font w:name="Courier New">
            <w:panose1 w:val="02070309020205020404"/>
            <w:charset w:val="00"/>
            <w:family w:val="auto"/>
            <w:pitch w:val="variable"/>
            <w:sig w:usb0="00000003" w:usb1="00000000" w:usb2="00000000" w:usb3="00000000" w:csb0="00000001" w:csb1="00000000"/>
        </w:font>
        <w:font w:name="Symbol">
            <w:panose1 w:val="05050102010706020507"/>
            <w:charset w:val="02"/>
            <w:family w:val="decorative"/>
            <w:pitch w:val="variable"/>
            <w:sig w:usb0="00000000" w:usb1="10000000" w:usb2="00000000" w:usb3="00000000" w:csb0="80000000" w:csb1="00000000"/>
        </w:font>
        <w:font w:name="Times New Roman">
            <w:panose1 w:val="02020603050405020304"/>
            <w:charset w:val="00"/>
            <w:family w:val="roman"/>
            <w:pitch w:val="variable"/>
            <w:sig w:usb0="E0002EFF" w:usb1="C000785B" w:usb2="00000009" w:usb3="00000000" w:csb0="000001FF" w:csb1="00000000"/>
        </w:font>
    </w:fonts>
`, settingsXML = `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:settings xmlns:w="${namespaces_w}" xmlns:o="${namespaces_o}" xmlns:r="${namespaces_r}" xmlns:v="${namespaces_v}" xmlns:w10="${namespaces_w10}" xmlns:sl="${namespaces_sl}">
        <w:zoom w:percent="100"/>
        <w:defaultTabStop w:val="720"/>
        <w:decimalSymbol w:val="."/>
        <w:listSeparator w:val=","/>
    </w:settings>
`, webSettingsXML = `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:webSettings xmlns:w="${namespaces_w}" xmlns:r="${namespaces_r}">
    </w:webSettings>
`;
let pool, poolOffset, nanoid = (size = 21) => {
  var bytes;
  bytes = size -= 0, !pool || pool.length < bytes ? (pool = Buffer.allocUnsafe(128 * bytes), crypto.randomFillSync(pool), poolOffset = 0) : poolOffset + bytes > pool.length && (crypto.randomFillSync(pool), poolOffset = 0), poolOffset += bytes;
  let id = "";
  for (let i = poolOffset - size; i < poolOffset; i++) id += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[63 & pool[i]];
  return id;
};
var isVtext = function(x) {
  return x && "VirtualText" === x.type && "2" === x.version;
};
var inherits_browser = createCommonjsModule((function(module) {
  "function" == typeof Object.create ? module.exports = function(ctor, superCtor) {
    superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } }));
  } : module.exports = function(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
    }
  };
})), inherits = createCommonjsModule((function(module) {
  try {
    var util$12 = require$$1$3;
    if ("function" != typeof util$12.inherits) throw "";
    module.exports = util$12.inherits;
  } catch (e) {
    module.exports = inherits_browser;
  }
})), EventEmitter = require$$2$3.EventEmitter, queue = Queue, _default = Queue;
function Queue(options) {
  if (!(this instanceof Queue)) return new Queue(options);
  EventEmitter.call(this), options = options || {}, this.concurrency = options.concurrency || 1 / 0, this.timeout = options.timeout || 0, this.autostart = options.autostart || false, this.results = options.results || null, this.pending = 0, this.session = 0, this.running = false, this.jobs = [], this.timers = {};
}
inherits(Queue, EventEmitter);
["pop", "shift", "indexOf", "lastIndexOf"].forEach((function(method2) {
  Queue.prototype[method2] = function() {
    return Array.prototype[method2].apply(this.jobs, arguments);
  };
})), Queue.prototype.slice = function(begin, end) {
  return this.jobs = this.jobs.slice(begin, end), this;
}, Queue.prototype.reverse = function() {
  return this.jobs.reverse(), this;
};
function clearTimers() {
  for (var key in this.timers) {
    var timeoutId = this.timers[key];
    delete this.timers[key], clearTimeout(timeoutId);
  }
}
function callOnErrorOrEnd(cb) {
  var self2 = this;
  function onerror(err) {
    self2.end(err);
  }
  this.on("error", onerror), this.on("end", (function onend(err) {
    self2.removeListener("error", onerror), self2.removeListener("end", onend), cb(err, this.results);
  }));
}
function done(err) {
  this.session++, this.running = false, this.emit("end", err);
}
["push", "unshift", "splice"].forEach((function(method2) {
  Queue.prototype[method2] = function() {
    var methodResult = Array.prototype[method2].apply(this.jobs, arguments);
    return this.autostart && this.start(), methodResult;
  };
})), Object.defineProperty(Queue.prototype, "length", { get: function() {
  return this.pending + this.jobs.length;
} }), Queue.prototype.start = function(cb) {
  if (cb && callOnErrorOrEnd.call(this, cb), this.running = true, !(this.pending >= this.concurrency)) if (0 !== this.jobs.length) {
    var self2 = this, job = this.jobs.shift(), once = true, session = this.session, timeoutId = null, didTimeout = false, resultIndex = null, timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
    timeout && (timeoutId = setTimeout((function() {
      didTimeout = true, self2.listeners("timeout").length > 0 ? self2.emit("timeout", next, job) : next();
    }), timeout), this.timers[timeoutId] = timeoutId), this.results && (resultIndex = this.results.length, this.results[resultIndex] = null), this.pending++, self2.emit("start", job);
    var promise2 = job(next);
    promise2 && promise2.then && "function" == typeof promise2.then && promise2.then((function(result) {
      return next(null, result);
    })).catch((function(err) {
      return next(err || true);
    })), this.running && this.jobs.length > 0 && this.start();
  } else 0 === this.pending && done.call(this);
  function next(err, result) {
    once && self2.session === session && (once = false, self2.pending--, null !== timeoutId && (delete self2.timers[timeoutId], clearTimeout(timeoutId)), err ? self2.emit("error", err, job) : false === didTimeout && (null !== resultIndex && (self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1)), self2.emit("success", result, job)), self2.session === session && (0 === self2.pending && 0 === self2.jobs.length ? done.call(self2) : self2.running && self2.start()));
  }
}, Queue.prototype.stop = function() {
  this.running = false;
}, Queue.prototype.end = function(err) {
  clearTimers.call(this), this.jobs.length = 0, this.pending = 0, done.call(this, err);
}, queue.default = _default;
var bmp = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.BMP = void 0, exports$1.BMP = { validate: (buffer) => "BM" === buffer.toString("ascii", 0, 2), calculate: (buffer) => ({ height: Math.abs(buffer.readInt32LE(22)), width: buffer.readUInt32LE(18) }) };
}));
unwrapExports(bmp), bmp.BMP;
var ico = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.ICO = void 0;
  function getSizeFromOffset(buffer, offset) {
    const value = buffer.readUInt8(offset);
    return 0 === value ? 256 : value;
  }
  function getImageSize(buffer, imageIndex) {
    const offset = 6 + 16 * imageIndex;
    return { height: getSizeFromOffset(buffer, offset + 1), width: getSizeFromOffset(buffer, offset) };
  }
  exports$1.ICO = { validate(buffer) {
    const reserved = buffer.readUInt16LE(0), imageCount = buffer.readUInt16LE(4);
    if (0 !== reserved || 0 === imageCount) return false;
    return 1 === buffer.readUInt16LE(2);
  }, calculate(buffer) {
    const nbImages = buffer.readUInt16LE(4), imageSize = getImageSize(buffer, 0);
    if (1 === nbImages) return imageSize;
    const imgs = [imageSize];
    for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) imgs.push(getImageSize(buffer, imageIndex));
    return { height: imageSize.height, images: imgs, width: imageSize.width };
  } };
}));
unwrapExports(ico), ico.ICO;
var cur = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.CUR = void 0;
  exports$1.CUR = { validate(buffer) {
    const reserved = buffer.readUInt16LE(0), imageCount = buffer.readUInt16LE(4);
    if (0 !== reserved || 0 === imageCount) return false;
    return 2 === buffer.readUInt16LE(2);
  }, calculate: (buffer) => ico.ICO.calculate(buffer) };
}));
unwrapExports(cur), cur.CUR;
var dds = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.DDS = void 0, exports$1.DDS = { validate: (buffer) => 542327876 === buffer.readUInt32LE(0), calculate: (buffer) => ({ height: buffer.readUInt32LE(12), width: buffer.readUInt32LE(16) }) };
}));
unwrapExports(dds), dds.DDS;
var gif = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.GIF = void 0;
  const gifRegexp = /^GIF8[79]a/;
  exports$1.GIF = { validate(buffer) {
    const signature2 = buffer.toString("ascii", 0, 6);
    return gifRegexp.test(signature2);
  }, calculate: (buffer) => ({ height: buffer.readUInt16LE(8), width: buffer.readUInt16LE(6) }) };
}));
unwrapExports(gif), gif.GIF;
var icns = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.ICNS = void 0;
  const ICON_TYPE_SIZE = { ICON: 32, "ICN#": 32, "icm#": 16, icm4: 16, icm8: 16, "ics#": 16, ics4: 16, ics8: 16, is32: 16, s8mk: 16, icp4: 16, icl4: 32, icl8: 32, il32: 32, l8mk: 32, icp5: 32, ic11: 32, ich4: 48, ich8: 48, ih32: 48, h8mk: 48, icp6: 64, ic12: 32, it32: 128, t8mk: 128, ic07: 128, ic08: 256, ic13: 256, ic09: 512, ic14: 512, ic10: 1024 };
  function readImageHeader(buffer, imageOffset) {
    const imageLengthOffset = imageOffset + 4;
    return [buffer.toString("ascii", imageOffset, imageLengthOffset), buffer.readUInt32BE(imageLengthOffset)];
  }
  function getImageSize(type2) {
    const size = ICON_TYPE_SIZE[type2];
    return { width: size, height: size, type: type2 };
  }
  exports$1.ICNS = { validate: (buffer) => "icns" === buffer.toString("ascii", 0, 4), calculate(buffer) {
    const bufferLength = buffer.length, fileLength = buffer.readUInt32BE(4);
    let imageOffset = 8, imageHeader = readImageHeader(buffer, imageOffset), imageSize = getImageSize(imageHeader[0]);
    if (imageOffset += imageHeader[1], imageOffset === fileLength) return imageSize;
    const result = { height: imageSize.height, images: [imageSize], width: imageSize.width };
    for (; imageOffset < fileLength && imageOffset < bufferLength; ) imageHeader = readImageHeader(buffer, imageOffset), imageSize = getImageSize(imageHeader[0]), imageOffset += imageHeader[1], result.images.push(imageSize);
    return result;
  } };
}));
unwrapExports(icns), icns.ICNS;
var j2c = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.J2C = void 0, exports$1.J2C = { validate: (buffer) => "ff4fff51" === buffer.toString("hex", 0, 4), calculate: (buffer) => ({ height: buffer.readUInt32BE(12), width: buffer.readUInt32BE(8) }) };
}));
unwrapExports(j2c), j2c.J2C;
var jp2 = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.JP2 = void 0;
  const BoxTypes_ftyp = "66747970", BoxTypes_jp2h = "6a703268", BoxTypes_jp__ = "6a502020", BoxTypes_rreq = "72726571", parseIHDR = (box) => ({ height: box.readUInt32BE(4), width: box.readUInt32BE(8) });
  exports$1.JP2 = { validate(buffer) {
    const signature2 = buffer.toString("hex", 4, 8), signatureLength = buffer.readUInt32BE(0);
    if (signature2 !== BoxTypes_jp__ || signatureLength < 1) return false;
    const ftypeBoxStart = signatureLength + 4, ftypBoxLength = buffer.readUInt32BE(signatureLength);
    return buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength).toString("hex", 0, 4) === BoxTypes_ftyp;
  }, calculate(buffer) {
    const signatureLength = buffer.readUInt32BE(0);
    let offset = signatureLength + 4 + buffer.readUInt16BE(signatureLength + 2);
    switch (buffer.toString("hex", offset, offset + 4)) {
      case BoxTypes_rreq:
        return offset = offset + 4 + 4 + ((box) => {
          const unit = box.readUInt8(0);
          let offset2 = 1 + 2 * unit;
          return offset2 = offset2 + 2 + box.readUInt16BE(offset2) * (2 + unit), offset2 + 2 + box.readUInt16BE(offset2) * (16 + unit);
        })(buffer.slice(offset + 4)), parseIHDR(buffer.slice(offset + 8, offset + 24));
      case BoxTypes_jp2h:
        return parseIHDR(buffer.slice(offset + 8, offset + 24));
      default:
        throw new TypeError("Unsupported header found: " + buffer.toString("ascii", offset, offset + 4));
    }
  } };
}));
unwrapExports(jp2), jp2.JP2;
var readUInt_1 = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.readUInt = void 0, exports$1.readUInt = function(buffer, bits, offset, isBigEndian) {
    return offset = offset || 0, buffer["readUInt" + bits + (isBigEndian ? "BE" : "LE")].call(buffer, offset);
  };
}));
unwrapExports(readUInt_1), readUInt_1.readUInt;
var jpg = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.JPG = void 0;
  function isEXIF(buffer) {
    return "45786966" === buffer.toString("hex", 2, 6);
  }
  function extractSize(buffer, index) {
    return { height: buffer.readUInt16BE(index), width: buffer.readUInt16BE(index + 2) };
  }
  function validateExifBlock(buffer, index) {
    const exifBlock = buffer.slice(2, index), byteAlign = exifBlock.toString("hex", 6, 8), isBigEndian = "4d4d" === byteAlign;
    if (isBigEndian || "4949" === byteAlign) return (function(exifBlock2, isBigEndian2) {
      const idfDirectoryEntries = (0, readUInt_1.readUInt)(exifBlock2, 16, 14, isBigEndian2);
      for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
        const start = 16 + 12 * directoryEntryNumber, end = start + 12;
        if (start > exifBlock2.length) return;
        const block2 = exifBlock2.slice(start, end);
        if (274 === (0, readUInt_1.readUInt)(block2, 16, 0, isBigEndian2)) {
          if (3 !== (0, readUInt_1.readUInt)(block2, 16, 2, isBigEndian2)) return;
          if (1 !== (0, readUInt_1.readUInt)(block2, 32, 4, isBigEndian2)) return;
          return (0, readUInt_1.readUInt)(block2, 16, 8, isBigEndian2);
        }
      }
    })(exifBlock, isBigEndian);
  }
  function validateBuffer(buffer, index) {
    if (index > buffer.length) throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (255 !== buffer[index]) throw new TypeError("Invalid JPG, marker table corrupted");
  }
  exports$1.JPG = { validate: (buffer) => "ffd8" === buffer.toString("hex", 0, 2), calculate(buffer) {
    let orientation, next;
    for (buffer = buffer.slice(4); buffer.length; ) {
      const i = buffer.readUInt16BE(0);
      if (isEXIF(buffer) && (orientation = validateExifBlock(buffer, i)), validateBuffer(buffer, i), next = buffer[i + 1], 192 === next || 193 === next || 194 === next) {
        const size = extractSize(buffer, i + 5);
        return orientation ? { height: size.height, orientation, width: size.width } : size;
      }
      buffer = buffer.slice(i + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  } };
}));
unwrapExports(jpg), jpg.JPG;
var ktx = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.KTX = void 0;
  exports$1.KTX = { validate: (buffer) => "KTX 11" === buffer.toString("ascii", 1, 7), calculate: (buffer) => ({ height: buffer.readUInt32LE(40), width: buffer.readUInt32LE(36) }) };
}));
unwrapExports(ktx), ktx.KTX;
var png = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.PNG = void 0;
  exports$1.PNG = { validate(buffer) {
    if ("PNG\r\n\n" === buffer.toString("ascii", 1, 8)) {
      let chunkName = buffer.toString("ascii", 12, 16);
      if ("CgBI" === chunkName && (chunkName = buffer.toString("ascii", 28, 32)), "IHDR" !== chunkName) throw new TypeError("Invalid PNG");
      return true;
    }
    return false;
  }, calculate: (buffer) => "CgBI" === buffer.toString("ascii", 12, 16) ? { height: buffer.readUInt32BE(36), width: buffer.readUInt32BE(32) } : { height: buffer.readUInt32BE(20), width: buffer.readUInt32BE(16) } };
}));
unwrapExports(png), png.PNG;
var pnm = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.PNM = void 0;
  const PNMTypes = { P1: "pbm/ascii", P2: "pgm/ascii", P3: "ppm/ascii", P4: "pbm", P5: "pgm", P6: "ppm", P7: "pam", PF: "pfm" }, Signatures = Object.keys(PNMTypes), handlers = { default: (lines) => {
    let dimensions = [];
    for (; lines.length > 0; ) {
      const line = lines.shift();
      if ("#" !== line[0]) {
        dimensions = line.split(" ");
        break;
      }
    }
    if (2 === dimensions.length) return { height: parseInt(dimensions[1], 10), width: parseInt(dimensions[0], 10) };
    throw new TypeError("Invalid PNM");
  }, pam: (lines) => {
    const size = {};
    for (; lines.length > 0; ) {
      const line = lines.shift();
      if (line.length > 16 || line.charCodeAt(0) > 128) continue;
      const [key, value] = line.split(" ");
      if (key && value && (size[key.toLowerCase()] = parseInt(value, 10)), size.height && size.width) break;
    }
    if (size.height && size.width) return { height: size.height, width: size.width };
    throw new TypeError("Invalid PAM");
  } };
  exports$1.PNM = { validate(buffer) {
    const signature2 = buffer.toString("ascii", 0, 2);
    return Signatures.includes(signature2);
  }, calculate(buffer) {
    const signature2 = buffer.toString("ascii", 0, 2), type2 = PNMTypes[signature2], lines = buffer.toString("ascii", 3).split(/[\r\n]+/);
    return (handlers[type2] || handlers.default)(lines);
  } };
}));
unwrapExports(pnm), pnm.PNM;
var psd = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.PSD = void 0, exports$1.PSD = { validate: (buffer) => "8BPS" === buffer.toString("ascii", 0, 4), calculate: (buffer) => ({ height: buffer.readUInt32BE(14), width: buffer.readUInt32BE(18) }) };
}));
unwrapExports(psd), psd.PSD;
var svg = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.SVG = void 0;
  const svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/, extractorRegExps = { height: /\sheight=(['"])([^%]+?)\1/, root: svgReg, viewbox: /\sviewBox=(['"])(.+?)\1/i, width: /\swidth=(['"])([^%]+?)\1/ }, units = { in: 96, cm: 96 / 2.54, em: 16, ex: 8, m: 96 / 2.54 * 100, mm: 96 / 2.54 / 10, pc: 96 / 72 / 12, pt: 96 / 72, px: 1 }, unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`);
  function parseLength(len) {
    const m = unitsReg.exec(len);
    if (m) return Math.round(Number(m[1]) * (units[m[2]] || 1));
  }
  function parseViewbox(viewbox) {
    const bounds = viewbox.split(" ");
    return { height: parseLength(bounds[3]), width: parseLength(bounds[2]) };
  }
  exports$1.SVG = { validate(buffer) {
    const str = String(buffer);
    return svgReg.test(str);
  }, calculate(buffer) {
    const root = buffer.toString("utf8").match(extractorRegExps.root);
    if (root) {
      const attrs = (function(root2) {
        const width = root2.match(extractorRegExps.width), height = root2.match(extractorRegExps.height), viewbox = root2.match(extractorRegExps.viewbox);
        return { height: height && parseLength(height[2]), viewbox: viewbox && parseViewbox(viewbox[2]), width: width && parseLength(width[2]) };
      })(root[0]);
      if (attrs.width && attrs.height) return (function(attrs2) {
        return { height: attrs2.height, width: attrs2.width };
      })(attrs);
      if (attrs.viewbox) return (function(attrs2, viewbox) {
        const ratio2 = viewbox.width / viewbox.height;
        return attrs2.width ? { height: Math.floor(attrs2.width / ratio2), width: attrs2.width } : attrs2.height ? { height: attrs2.height, width: Math.floor(attrs2.height * ratio2) } : { height: viewbox.height, width: viewbox.width };
      })(attrs, attrs.viewbox);
    }
    throw new TypeError("Invalid SVG");
  } };
}));
unwrapExports(svg), svg.SVG;
var tga = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.TGA = void 0, exports$1.TGA = { validate: (buffer) => 0 === buffer.readUInt16LE(0) && 0 === buffer.readUInt16LE(4), calculate: (buffer) => ({ height: buffer.readUInt16LE(14), width: buffer.readUInt16LE(12) }) };
}));
unwrapExports(tga), tga.TGA;
var tiff = createCommonjsModule((function(module, exports$1) {
  function readValue(buffer, isBigEndian) {
    const low = (0, readUInt_1.readUInt)(buffer, 16, 8, isBigEndian);
    return ((0, readUInt_1.readUInt)(buffer, 16, 10, isBigEndian) << 16) + low;
  }
  function nextTag(buffer) {
    if (buffer.length > 24) return buffer.slice(12);
  }
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.TIFF = void 0;
  const signatures = ["49492a00", "4d4d002a"];
  exports$1.TIFF = { validate: (buffer) => signatures.includes(buffer.toString("hex", 0, 4)), calculate(buffer, filepath) {
    if (!filepath) throw new TypeError("Tiff doesn't support buffer");
    const isBigEndian = "BE" === (function(buffer2) {
      const signature2 = buffer2.toString("ascii", 0, 2);
      return "II" === signature2 ? "LE" : "MM" === signature2 ? "BE" : void 0;
    })(buffer), ifdBuffer = (function(buffer2, filepath2, isBigEndian2) {
      const ifdOffset = (0, readUInt_1.readUInt)(buffer2, 32, 4, isBigEndian2);
      let bufferSize = 1024;
      const fileSize = fs.statSync(filepath2).size;
      ifdOffset + bufferSize > fileSize && (bufferSize = fileSize - ifdOffset - 10);
      const endBuffer = Buffer.alloc(bufferSize), descriptor = fs.openSync(filepath2, "r");
      return fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset), fs.closeSync(descriptor), endBuffer.slice(2);
    })(buffer, filepath, isBigEndian), tags = (function(buffer2, isBigEndian2) {
      const tags2 = {};
      let temp = buffer2;
      for (; temp && temp.length; ) {
        const code = (0, readUInt_1.readUInt)(temp, 16, 0, isBigEndian2), type2 = (0, readUInt_1.readUInt)(temp, 16, 2, isBigEndian2), length = (0, readUInt_1.readUInt)(temp, 32, 4, isBigEndian2);
        if (0 === code) break;
        1 !== length || 3 !== type2 && 4 !== type2 || (tags2[code] = readValue(temp, isBigEndian2)), temp = nextTag(temp);
      }
      return tags2;
    })(ifdBuffer, isBigEndian), width = tags[256], height = tags[257];
    if (!width || !height) throw new TypeError("Invalid Tiff. Missing tags");
    return { height, width };
  } };
}));
unwrapExports(tiff), tiff.TIFF;
var webp = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.WEBP = void 0, exports$1.WEBP = { validate(buffer) {
    const riffHeader = "RIFF" === buffer.toString("ascii", 0, 4), webpHeader = "WEBP" === buffer.toString("ascii", 8, 12), vp8Header = "VP8" === buffer.toString("ascii", 12, 15);
    return riffHeader && webpHeader && vp8Header;
  }, calculate(buffer) {
    const chunkHeader = buffer.toString("ascii", 12, 16);
    if (buffer = buffer.slice(20, 30), "VP8X" === chunkHeader) {
      const extendedHeader = buffer[0], validEnd = 0 == (1 & extendedHeader);
      if (0 == (192 & extendedHeader) && validEnd) return (function(buffer2) {
        return { height: 1 + buffer2.readUIntLE(7, 3), width: 1 + buffer2.readUIntLE(4, 3) };
      })(buffer);
      throw new TypeError("Invalid WebP");
    }
    if ("VP8 " === chunkHeader && 47 !== buffer[0]) return (function(buffer2) {
      return { height: 16383 & buffer2.readInt16LE(8), width: 16383 & buffer2.readInt16LE(6) };
    })(buffer);
    const signature2 = buffer.toString("hex", 3, 6);
    if ("VP8L" === chunkHeader && "9d012a" !== signature2) return (function(buffer2) {
      return { height: 1 + ((15 & buffer2[4]) << 10 | buffer2[3] << 2 | (192 & buffer2[2]) >> 6), width: 1 + ((63 & buffer2[2]) << 8 | buffer2[1]) };
    })(buffer);
    throw new TypeError("Invalid WebP");
  } };
}));
unwrapExports(webp), webp.WEBP;
var types = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.typeHandlers = void 0, exports$1.typeHandlers = { bmp: bmp.BMP, cur: cur.CUR, dds: dds.DDS, gif: gif.GIF, icns: icns.ICNS, ico: ico.ICO, j2c: j2c.J2C, jp2: jp2.JP2, jpg: jpg.JPG, ktx: ktx.KTX, png: png.PNG, pnm: pnm.PNM, psd: psd.PSD, svg: svg.SVG, tga: tga.TGA, tiff: tiff.TIFF, webp: webp.WEBP };
}));
unwrapExports(types), types.typeHandlers;
var detector_1 = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.detector = void 0;
  const keys = Object.keys(types.typeHandlers), firstBytes = { 56: "psd", 66: "bmp", 68: "dds", 71: "gif", 73: "tiff", 77: "tiff", 82: "webp", 105: "icns", 137: "png", 255: "jpg" };
  exports$1.detector = function(buffer) {
    const byte = buffer[0];
    if (byte in firstBytes) {
      const type2 = firstBytes[byte];
      if (type2 && types.typeHandlers[type2].validate(buffer)) return type2;
    }
    return keys.find(((key) => types.typeHandlers[key].validate(buffer)));
  };
}));
unwrapExports(detector_1), detector_1.detector;
var dist = createCommonjsModule((function(module, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true }), exports$1.types = exports$1.setConcurrency = exports$1.disableTypes = exports$1.disableFS = exports$1.imageSize = void 0;
  const queue$12 = new queue.default({ concurrency: 100, autostart: true }), globalOptions = { disabledFS: false, disabledTypes: [] };
  function lookup(buffer, filepath) {
    const type2 = (0, detector_1.detector)(buffer);
    if (void 0 !== type2) {
      if (globalOptions.disabledTypes.indexOf(type2) > -1) throw new TypeError("disabled file type: " + type2);
      if (type2 in types.typeHandlers) {
        const size = types.typeHandlers[type2].calculate(buffer, filepath);
        if (void 0 !== size) return size.type = type2, size;
      }
    }
    throw new TypeError("unsupported file type: " + type2 + " (file: " + filepath + ")");
  }
  function imageSize(input, callback) {
    if (Buffer.isBuffer(input)) return lookup(input);
    if ("string" != typeof input || globalOptions.disabledFS) throw new TypeError("invalid invocation. input should be a Buffer");
    const filepath = path.resolve(input);
    if ("function" != typeof callback) {
      const buffer = (function(filepath2) {
        const descriptor = fs.openSync(filepath2, "r");
        try {
          const { size } = fs.fstatSync(descriptor);
          if (size <= 0) throw new Error("Empty file");
          const bufferSize = Math.min(size, 524288), buffer2 = Buffer.alloc(bufferSize);
          return fs.readSync(descriptor, buffer2, 0, bufferSize, 0), buffer2;
        } finally {
          fs.closeSync(descriptor);
        }
      })(filepath);
      return lookup(buffer, filepath);
    }
    queue$12.push((() => (async function(filepath2) {
      const handle = await fs.promises.open(filepath2, "r");
      try {
        const { size } = await handle.stat();
        if (size <= 0) throw new Error("Empty file");
        const bufferSize = Math.min(size, 524288), buffer = Buffer.alloc(bufferSize);
        return await handle.read(buffer, 0, bufferSize, 0), buffer;
      } finally {
        await handle.close();
      }
    })(filepath).then(((buffer) => process.nextTick(callback, null, lookup(buffer, filepath)))).catch(callback)));
  }
  module.exports = exports$1 = imageSize, exports$1.default = imageSize, exports$1.imageSize = imageSize;
  exports$1.disableFS = (v) => {
    globalOptions.disabledFS = v;
  };
  exports$1.disableTypes = (types2) => {
    globalOptions.disabledTypes = types2;
  };
  exports$1.setConcurrency = (c) => {
    queue$12.concurrency = c;
  }, exports$1.types = Object.keys(types.typeHandlers);
})), sizeOf = unwrapExports(dist);
dist.types, dist.setConcurrency, dist.disableTypes, dist.disableFS, dist.imageSize;
var conversions = {}, lib$1 = conversions;
function sign(x) {
  return x < 0 ? -1 : 1;
}
function createNumberConversion(bitLength, typeOpts) {
  typeOpts.unsigned || --bitLength;
  const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength), upperBound = Math.pow(2, bitLength) - 1, moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength), moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
  return function(V, opts) {
    opts || (opts = {});
    let x = +V;
    if (opts.enforceRange) {
      if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
      if (x = sign(x) * Math.floor(Math.abs(x)), x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
      return x;
    }
    if (!isNaN(x) && opts.clamp) return x = (function(x2) {
      return x2 % 1 == 0.5 && 0 == (1 & x2) ? Math.floor(x2) : Math.round(x2);
    })(x), x < lowerBound && (x = lowerBound), x > upperBound && (x = upperBound), x;
    if (!Number.isFinite(x) || 0 === x) return 0;
    if (x = sign(x) * Math.floor(Math.abs(x)), x %= moduloVal, !typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
    if (typeOpts.unsigned) {
      if (x < 0) x += moduloVal;
      else if (-0 === x) return 0;
    }
    return x;
  };
}
conversions.void = function() {
}, conversions.boolean = function(val) {
  return !!val;
}, conversions.byte = createNumberConversion(8, { unsigned: false }), conversions.octet = createNumberConversion(8, { unsigned: true }), conversions.short = createNumberConversion(16, { unsigned: false }), conversions["unsigned short"] = createNumberConversion(16, { unsigned: true }), conversions.long = createNumberConversion(32, { unsigned: false }), conversions["unsigned long"] = createNumberConversion(32, { unsigned: true }), conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 }), conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 }), conversions.double = function(V) {
  const x = +V;
  if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
  return x;
}, conversions["unrestricted double"] = function(V) {
  const x = +V;
  if (isNaN(x)) throw new TypeError("Argument is NaN");
  return x;
}, conversions.float = conversions.double, conversions["unrestricted float"] = conversions["unrestricted double"], conversions.DOMString = function(V, opts) {
  return opts || (opts = {}), opts.treatNullAsEmptyString && null === V ? "" : String(V);
}, conversions.ByteString = function(V, opts) {
  const x = String(V);
  let c;
  for (let i = 0; void 0 !== (c = x.codePointAt(i)); ++i) if (c > 255) throw new TypeError("Argument is not a valid bytestring");
  return x;
}, conversions.USVString = function(V) {
  const S = String(V), n = S.length, U = [];
  for (let i = 0; i < n; ++i) {
    const c = S.charCodeAt(i);
    if (c < 55296 || c > 57343) U.push(String.fromCodePoint(c));
    else if (56320 <= c && c <= 57343) U.push(String.fromCodePoint(65533));
    else if (i === n - 1) U.push(String.fromCodePoint(65533));
    else {
      const d = S.charCodeAt(i + 1);
      if (56320 <= d && d <= 57343) {
        const a = 1023 & c, b = 1023 & d;
        U.push(String.fromCodePoint(65536 + 1024 * a + b)), ++i;
      } else U.push(String.fromCodePoint(65533));
    }
  }
  return U.join("");
}, conversions.Date = function(V, opts) {
  if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
  if (!isNaN(V)) return V;
}, conversions.RegExp = function(V, opts) {
  return V instanceof RegExp || (V = new RegExp(V)), V;
};
var utils = createCommonjsModule((function(module) {
  module.exports.mixin = function(target2, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i = 0; i < keys.length; ++i) Object.defineProperty(target2, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
  }, module.exports.wrapperSymbol = Symbol("wrapper"), module.exports.implSymbol = Symbol("impl"), module.exports.wrapperForImpl = function(impl) {
    return impl[module.exports.wrapperSymbol];
  }, module.exports.implForWrapper = function(wrapper) {
    return wrapper[module.exports.implSymbol];
  };
}));
utils.mixin, utils.wrapperSymbol, utils.implSymbol, utils.wrapperForImpl, utils.implForWrapper;
var mappingTable = getCjsExportFromNamespace(Object.freeze({ __proto__: null, default: [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]] })), PROCESSING_OPTIONS = { TRANSITIONAL: 0, NONTRANSITIONAL: 1 };
function normalize(str) {
  return str.split("\0").map((function(s) {
    return s.normalize("NFC");
  })).join("\0");
}
function findStatus(val) {
  for (var start = 0, end = mappingTable.length - 1; start <= end; ) {
    var mid2 = Math.floor((start + end) / 2), target2 = mappingTable[mid2];
    if (target2[0][0] <= val && target2[0][1] >= val) return target2;
    target2[0][0] > val ? end = mid2 - 1 : start = mid2 + 1;
  }
  return null;
}
var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
function countSymbols(string) {
  return string.replace(regexAstralSymbols, "_").length;
}
var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
function validateLabel(label, processing_option) {
  "xn--" === label.substr(0, 4) && (label = punycode$2.toUnicode(label));
  var error = false;
  (normalize(label) !== label || "-" === label[3] && "-" === label[4] || "-" === label[0] || "-" === label[label.length - 1] || -1 !== label.indexOf(".") || 0 === label.search(combiningMarksRegex)) && (error = true);
  for (var len = countSymbols(label), i = 0; i < len; ++i) {
    var status = findStatus(label.codePointAt(i));
    if (processing === PROCESSING_OPTIONS.TRANSITIONAL && "valid" !== status[1] || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && "valid" !== status[1] && "deviation" !== status[1]) {
      error = true;
      break;
    }
  }
  return { label, error };
}
function processing(domain_name, useSTD3, processing_option) {
  var result = (function(domain_name2, useSTD32, processing_option2) {
    for (var hasError = false, processed = "", len = countSymbols(domain_name2), i2 = 0; i2 < len; ++i2) {
      var codePoint = domain_name2.codePointAt(i2), status = findStatus(codePoint);
      switch (status[1]) {
        case "disallowed":
          hasError = true, processed += String.fromCodePoint(codePoint);
          break;
        case "ignored":
          break;
        case "mapped":
          processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "deviation":
          processed += processing_option2 === PROCESSING_OPTIONS.TRANSITIONAL ? String.fromCodePoint.apply(String, status[2]) : String.fromCodePoint(codePoint);
          break;
        case "valid":
          processed += String.fromCodePoint(codePoint);
          break;
        case "disallowed_STD3_mapped":
          useSTD32 ? (hasError = true, processed += String.fromCodePoint(codePoint)) : processed += String.fromCodePoint.apply(String, status[2]);
          break;
        case "disallowed_STD3_valid":
          useSTD32 && (hasError = true), processed += String.fromCodePoint(codePoint);
      }
    }
    return { string: processed, error: hasError };
  })(domain_name, useSTD3, processing_option);
  result.string = normalize(result.string);
  for (var labels = result.string.split("."), i = 0; i < labels.length; ++i) try {
    var validation = validateLabel(labels[i]);
    labels[i] = validation.label, result.error = result.error || validation.error;
  } catch (e) {
    result.error = true;
  }
  return { string: labels.join("."), error: result.error };
}
var tr46 = { toASCII: function(domain_name, useSTD3, processing_option, verifyDnsLength) {
  var result = processing(domain_name, useSTD3, processing_option), labels = result.string.split(".");
  if (labels = labels.map((function(l) {
    try {
      return punycode$2.toASCII(l);
    } catch (e) {
      return result.error = true, l;
    }
  })), verifyDnsLength) {
    var total = labels.slice(0, labels.length - 1).join(".").length;
    (total.length > 253 || 0 === total.length) && (result.error = true);
    for (var i = 0; i < labels.length; ++i) if (labels.length > 63 || 0 === labels.length) {
      result.error = true;
      break;
    }
  }
  return result.error ? null : labels.join(".");
}, toUnicode: function(domain_name, useSTD3) {
  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
  return { domain: result.string, error: result.error };
}, PROCESSING_OPTIONS }, urlStateMachine = createCommonjsModule((function(module) {
  const specialSchemes = { ftp: 21, file: null, gopher: 70, http: 80, https: 443, ws: 80, wss: 443 }, failure = Symbol("failure");
  function countSymbols2(str) {
    return punycode$2.ucs2.decode(str).length;
  }
  function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? void 0 : String.fromCodePoint(c);
  }
  function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
  }
  function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  }
  function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  function isSingleDot(buffer) {
    return "." === buffer || "%2e" === buffer.toLowerCase();
  }
  function isWindowsDriveLetterString(string) {
    return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && (":" === string[1] || "|" === string[1]);
  }
  function isSpecialScheme(scheme) {
    return void 0 !== specialSchemes[scheme];
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    return 1 === hex.length && (hex = "0" + hex), "%" + hex;
  }
  function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
  }
  const extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
  function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  }
  const extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
  function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  }
  function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    return encodeSetPredicate(c) ? (function(c2) {
      const buf = new Buffer(c2);
      let str = "";
      for (let i = 0; i < buf.length; ++i) str += percentEncode(buf[i]);
      return str;
    })(cStr) : cStr;
  }
  function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && "0" === input.charAt(0) && "x" === input.charAt(1).toLowerCase() ? (input = input.substring(2), R = 16) : input.length >= 2 && "0" === input.charAt(0) && (input = input.substring(1), R = 8), "" === input) return 0;
    return (10 === R ? /[^0-9]/ : 16 === R ? /[^0-9A-Fa-f]/ : /[^0-7]/).test(input) ? failure : parseInt(input, R);
  }
  function parseHost(input, isSpecialArg) {
    if ("[" === input[0]) return "]" !== input[input.length - 1] ? failure : (function(input2) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0, compress = null, pointer = 0;
      if (58 === (input2 = punycode$2.ucs2.decode(input2))[pointer]) {
        if (58 !== input2[pointer + 1]) return failure;
        pointer += 2, ++pieceIndex, compress = pieceIndex;
      }
      for (; pointer < input2.length; ) {
        if (8 === pieceIndex) return failure;
        if (58 === input2[pointer]) {
          if (null !== compress) return failure;
          ++pointer, ++pieceIndex, compress = pieceIndex;
          continue;
        }
        let value = 0, length = 0;
        for (; length < 4 && isASCIIHex(input2[pointer]); ) value = 16 * value + parseInt(at(input2, pointer), 16), ++pointer, ++length;
        if (46 === input2[pointer]) {
          if (0 === length) return failure;
          if (pointer -= length, pieceIndex > 6) return failure;
          let numbersSeen = 0;
          for (; void 0 !== input2[pointer]; ) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (!(46 === input2[pointer] && numbersSeen < 4)) return failure;
              ++pointer;
            }
            if (!isASCIIDigit(input2[pointer])) return failure;
            for (; isASCIIDigit(input2[pointer]); ) {
              const number = parseInt(at(input2, pointer));
              if (null === ipv4Piece) ipv4Piece = number;
              else {
                if (0 === ipv4Piece) return failure;
                ipv4Piece = 10 * ipv4Piece + number;
              }
              if (ipv4Piece > 255) return failure;
              ++pointer;
            }
            address[pieceIndex] = 256 * address[pieceIndex] + ipv4Piece, ++numbersSeen, 2 !== numbersSeen && 4 !== numbersSeen || ++pieceIndex;
          }
          if (4 !== numbersSeen) return failure;
          break;
        }
        if (58 === input2[pointer]) {
          if (++pointer, void 0 === input2[pointer]) return failure;
        } else if (void 0 !== input2[pointer]) return failure;
        address[pieceIndex] = value, ++pieceIndex;
      }
      if (null !== compress) {
        let swaps = pieceIndex - compress;
        for (pieceIndex = 7; 0 !== pieceIndex && swaps > 0; ) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex], address[pieceIndex] = temp, --pieceIndex, --swaps;
        }
      } else if (null === compress && 8 !== pieceIndex) return failure;
      return address;
    })(input.substring(1, input.length - 1));
    if (!isSpecialArg) return (function(input2) {
      if (string = input2, -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/)) return failure;
      var string;
      let output = "";
      const decoded = punycode$2.ucs2.decode(input2);
      for (let i = 0; i < decoded.length; ++i) output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      return output;
    })(input);
    const domain = (function(str) {
      const input2 = new Buffer(str), output = [];
      for (let i = 0; i < input2.length; ++i) 37 !== input2[i] ? output.push(input2[i]) : 37 === input2[i] && isASCIIHex(input2[i + 1]) && isASCIIHex(input2[i + 2]) ? (output.push(parseInt(input2.slice(i + 1, i + 3).toString(), 16)), i += 2) : output.push(input2[i]);
      return new Buffer(output).toString();
    })(input), asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (null === asciiDomain) return failure;
    if (-1 !== asciiDomain.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/)) return failure;
    const ipv4Host = (function(input2) {
      const parts = input2.split(".");
      if ("" === parts[parts.length - 1] && parts.length > 1 && parts.pop(), parts.length > 4) return input2;
      const numbers = [];
      for (const part2 of parts) {
        if ("" === part2) return input2;
        const n = parseIPv4Number(part2);
        if (n === failure) return input2;
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) if (numbers[i] > 255) return failure;
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
      let ipv4 = numbers.pop(), counter = 0;
      for (const n of numbers) ipv4 += n * Math.pow(256, 3 - counter), ++counter;
      return ipv4;
    })(asciiDomain);
    return "number" == typeof ipv4Host || ipv4Host === failure ? ipv4Host : asciiDomain;
  }
  function serializeHost(host) {
    return "number" == typeof host ? (function(address) {
      let output = "", n = address;
      for (let i = 1; i <= 4; ++i) output = String(n % 256) + output, 4 !== i && (output = "." + output), n = Math.floor(n / 256);
      return output;
    })(host) : host instanceof Array ? "[" + (function(address) {
      let output = "";
      const compress = (function(arr) {
        let maxIdx = null, maxLen = 1, currStart = null, currLen = 0;
        for (let i = 0; i < arr.length; ++i) 0 !== arr[i] ? (currLen > maxLen && (maxIdx = currStart, maxLen = currLen), currStart = null, currLen = 0) : (null === currStart && (currStart = i), ++currLen);
        return currLen > maxLen && (maxIdx = currStart, maxLen = currLen), { idx: maxIdx, len: maxLen };
      })(address).idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) ignore0 && 0 === address[pieceIndex] || (ignore0 && (ignore0 = false), compress !== pieceIndex ? (output += address[pieceIndex].toString(16), 7 !== pieceIndex && (output += ":")) : (output += 0 === pieceIndex ? "::" : ":", ignore0 = true));
      return output;
    })(host) + "]" : host;
  }
  function shortenPath(url) {
    const path2 = url.path;
    var string;
    0 !== path2.length && ("file" === url.scheme && 1 === path2.length && (string = path2[0], /^[A-Za-z]:$/.test(string)) || path2.pop());
  }
  function includesCredentials(url) {
    return "" !== url.username || "" !== url.password;
  }
  function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    if (this.pointer = 0, this.input = input, this.base = base || null, this.encodingOverride = encodingOverride || "utf-8", this.stateOverride = stateOverride, this.url = url, this.failure = false, this.parseError = false, !this.url) {
      this.url = { scheme: "", username: "", password: "", host: null, port: null, path: [], query: null, fragment: null, cannotBeABaseURL: false };
      const res2 = (function(url2) {
        return url2.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
      })(this.input);
      res2 !== this.input && (this.parseError = true), this.input = res2;
    }
    const res = (function(url2) {
      return url2.replace(/\u0009|\u000A|\u000D/g, "");
    })(this.input);
    for (res !== this.input && (this.parseError = true), this.input = res, this.state = stateOverride || "scheme start", this.buffer = "", this.atFlag = false, this.arrFlag = false, this.passwordTokenSeenFlag = false, this.input = punycode$2.ucs2.decode(this.input); this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer], cStr = isNaN(c) ? void 0 : String.fromCodePoint(c), ret = this["parse " + this.state](c, cStr);
      if (!ret) break;
      if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  URLStateMachine.prototype["parse scheme start"] = function(c, cStr) {
    if (isASCIIAlpha(c)) this.buffer += cStr.toLowerCase(), this.state = "scheme";
    else {
      if (this.stateOverride) return this.parseError = true, failure;
      this.state = "no scheme", --this.pointer;
    }
    return true;
  }, URLStateMachine.prototype["parse scheme"] = function(c, cStr) {
    if ((function(c2) {
      return isASCIIAlpha(c2) || isASCIIDigit(c2);
    })(c) || 43 === c || 45 === c || 46 === c) this.buffer += cStr.toLowerCase();
    else if (58 === c) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return false;
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return false;
        if ((includesCredentials(this.url) || null !== this.url.port) && "file" === this.buffer) return false;
        if ("file" === this.url.scheme && ("" === this.url.host || null === this.url.host)) return false;
      }
      if (this.url.scheme = this.buffer, this.buffer = "", this.stateOverride) return false;
      "file" === this.url.scheme ? (47 === this.input[this.pointer + 1] && 47 === this.input[this.pointer + 2] || (this.parseError = true), this.state = "file") : isSpecial(this.url) && null !== this.base && this.base.scheme === this.url.scheme ? this.state = "special relative or authority" : isSpecial(this.url) ? this.state = "special authority slashes" : 47 === this.input[this.pointer + 1] ? (this.state = "path or authority", ++this.pointer) : (this.url.cannotBeABaseURL = true, this.url.path.push(""), this.state = "cannot-be-a-base-URL path");
    } else {
      if (this.stateOverride) return this.parseError = true, failure;
      this.buffer = "", this.state = "no scheme", this.pointer = -1;
    }
    return true;
  }, URLStateMachine.prototype["parse no scheme"] = function(c) {
    return null === this.base || this.base.cannotBeABaseURL && 35 !== c ? failure : (this.base.cannotBeABaseURL && 35 === c ? (this.url.scheme = this.base.scheme, this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", this.url.cannotBeABaseURL = true, this.state = "fragment") : "file" === this.base.scheme ? (this.state = "file", --this.pointer) : (this.state = "relative", --this.pointer), true);
  }, URLStateMachine.prototype["parse special relative or authority"] = function(c) {
    return 47 === c && 47 === this.input[this.pointer + 1] ? (this.state = "special authority ignore slashes", ++this.pointer) : (this.parseError = true, this.state = "relative", --this.pointer), true;
  }, URLStateMachine.prototype["parse path or authority"] = function(c) {
    return 47 === c ? this.state = "authority" : (this.state = "path", --this.pointer), true;
  }, URLStateMachine.prototype["parse relative"] = function(c) {
    return this.url.scheme = this.base.scheme, isNaN(c) ? (this.url.username = this.base.username, this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, this.url.path = this.base.path.slice(), this.url.query = this.base.query) : 47 === c ? this.state = "relative slash" : 63 === c ? (this.url.username = this.base.username, this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, this.url.path = this.base.path.slice(), this.url.query = "", this.state = "query") : 35 === c ? (this.url.username = this.base.username, this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", this.state = "fragment") : isSpecial(this.url) && 92 === c ? (this.parseError = true, this.state = "relative slash") : (this.url.username = this.base.username, this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, this.url.path = this.base.path.slice(0, this.base.path.length - 1), this.state = "path", --this.pointer), true;
  }, URLStateMachine.prototype["parse relative slash"] = function(c) {
    return !isSpecial(this.url) || 47 !== c && 92 !== c ? 47 === c ? this.state = "authority" : (this.url.username = this.base.username, this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, this.state = "path", --this.pointer) : (92 === c && (this.parseError = true), this.state = "special authority ignore slashes"), true;
  }, URLStateMachine.prototype["parse special authority slashes"] = function(c) {
    return 47 === c && 47 === this.input[this.pointer + 1] ? (this.state = "special authority ignore slashes", ++this.pointer) : (this.parseError = true, this.state = "special authority ignore slashes", --this.pointer), true;
  }, URLStateMachine.prototype["parse special authority ignore slashes"] = function(c) {
    return 47 !== c && 92 !== c ? (this.state = "authority", --this.pointer) : this.parseError = true, true;
  }, URLStateMachine.prototype["parse authority"] = function(c, cStr) {
    if (64 === c) {
      this.parseError = true, this.atFlag && (this.buffer = "%40" + this.buffer), this.atFlag = true;
      const len = countSymbols2(this.buffer);
      for (let pointer = 0; pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (58 === codePoint && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
        this.passwordTokenSeenFlag ? this.url.password += encodedCodePoints : this.url.username += encodedCodePoints;
      }
      this.buffer = "";
    } else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
      if (this.atFlag && "" === this.buffer) return this.parseError = true, failure;
      this.pointer -= countSymbols2(this.buffer) + 1, this.buffer = "", this.state = "host";
    } else this.buffer += cStr;
    return true;
  }, URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function(c, cStr) {
    if (this.stateOverride && "file" === this.url.scheme) --this.pointer, this.state = "file host";
    else if (58 !== c || this.arrFlag) if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
      if (--this.pointer, isSpecial(this.url) && "" === this.buffer) return this.parseError = true, failure;
      if (this.stateOverride && "" === this.buffer && (includesCredentials(this.url) || null !== this.url.port)) return this.parseError = true, false;
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) return failure;
      if (this.url.host = host, this.buffer = "", this.state = "path start", this.stateOverride) return false;
    } else 91 === c ? this.arrFlag = true : 93 === c && (this.arrFlag = false), this.buffer += cStr;
    else {
      if ("" === this.buffer) return this.parseError = true, failure;
      const host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) return failure;
      if (this.url.host = host, this.buffer = "", this.state = "port", "hostname" === this.stateOverride) return false;
    }
    return true;
  }, URLStateMachine.prototype["parse port"] = function(c, cStr) {
    if (isASCIIDigit(c)) this.buffer += cStr;
    else {
      if (!(isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c || this.stateOverride)) return this.parseError = true, failure;
      if ("" !== this.buffer) {
        const port = parseInt(this.buffer);
        if (port > Math.pow(2, 16) - 1) return this.parseError = true, failure;
        this.url.port = port === (scheme = this.url.scheme, specialSchemes[scheme]) ? null : port, this.buffer = "";
      }
      if (this.stateOverride) return false;
      this.state = "path start", --this.pointer;
    }
    var scheme;
    return true;
  };
  const fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
  URLStateMachine.prototype["parse file"] = function(c) {
    var cp1, cp2;
    return this.url.scheme = "file", 47 === c || 92 === c ? (92 === c && (this.parseError = true), this.state = "file slash") : null !== this.base && "file" === this.base.scheme ? isNaN(c) ? (this.url.host = this.base.host, this.url.path = this.base.path.slice(), this.url.query = this.base.query) : 63 === c ? (this.url.host = this.base.host, this.url.path = this.base.path.slice(), this.url.query = "", this.state = "query") : 35 === c ? (this.url.host = this.base.host, this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", this.state = "fragment") : (this.input.length - this.pointer - 1 == 0 || (cp1 = c, cp2 = this.input[this.pointer + 1], !isASCIIAlpha(cp1) || 58 !== cp2 && 124 !== cp2) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]) ? (this.url.host = this.base.host, this.url.path = this.base.path.slice(), shortenPath(this.url)) : this.parseError = true, this.state = "path", --this.pointer) : (this.state = "path", --this.pointer), true;
  }, URLStateMachine.prototype["parse file slash"] = function(c) {
    var string;
    return 47 === c || 92 === c ? (92 === c && (this.parseError = true), this.state = "file host") : (null !== this.base && "file" === this.base.scheme && (2 === (string = this.base.path[0]).length && isASCIIAlpha(string.codePointAt(0)) && ":" === string[1] ? this.url.path.push(this.base.path[0]) : this.url.host = this.base.host), this.state = "path", --this.pointer), true;
  }, URLStateMachine.prototype["parse file host"] = function(c, cStr) {
    if (isNaN(c) || 47 === c || 92 === c || 63 === c || 35 === c) if (--this.pointer, !this.stateOverride && isWindowsDriveLetterString(this.buffer)) this.parseError = true, this.state = "path";
    else if ("" === this.buffer) {
      if (this.url.host = "", this.stateOverride) return false;
      this.state = "path start";
    } else {
      let host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) return failure;
      if ("localhost" === host && (host = ""), this.url.host = host, this.stateOverride) return false;
      this.buffer = "", this.state = "path start";
    }
    else this.buffer += cStr;
    return true;
  }, URLStateMachine.prototype["parse path start"] = function(c) {
    return isSpecial(this.url) ? (92 === c && (this.parseError = true), this.state = "path", 47 !== c && 92 !== c && --this.pointer) : this.stateOverride || 63 !== c ? this.stateOverride || 35 !== c ? void 0 !== c && (this.state = "path", 47 !== c && --this.pointer) : (this.url.fragment = "", this.state = "fragment") : (this.url.query = "", this.state = "query"), true;
  }, URLStateMachine.prototype["parse path"] = function(c) {
    if (isNaN(c) || 47 === c || isSpecial(this.url) && 92 === c || !this.stateOverride && (63 === c || 35 === c)) {
      if (isSpecial(this.url) && 92 === c && (this.parseError = true), ".." === (buffer = (buffer = this.buffer).toLowerCase()) || "%2e." === buffer || ".%2e" === buffer || "%2e%2e" === buffer ? (shortenPath(this.url), 47 === c || isSpecial(this.url) && 92 === c || this.url.path.push("")) : !isSingleDot(this.buffer) || 47 === c || isSpecial(this.url) && 92 === c ? isSingleDot(this.buffer) || ("file" === this.url.scheme && 0 === this.url.path.length && isWindowsDriveLetterString(this.buffer) && ("" !== this.url.host && null !== this.url.host && (this.parseError = true, this.url.host = ""), this.buffer = this.buffer[0] + ":"), this.url.path.push(this.buffer)) : this.url.path.push(""), this.buffer = "", "file" === this.url.scheme && (void 0 === c || 63 === c || 35 === c)) for (; this.url.path.length > 1 && "" === this.url.path[0]; ) this.parseError = true, this.url.path.shift();
      63 === c && (this.url.query = "", this.state = "query"), 35 === c && (this.url.fragment = "", this.state = "fragment");
    } else 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = true), this.buffer += percentEncodeChar(c, isPathPercentEncode);
    var buffer;
    return true;
  }, URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function(c) {
    return 63 === c ? (this.url.query = "", this.state = "query") : 35 === c ? (this.url.fragment = "", this.state = "fragment") : (isNaN(c) || 37 === c || (this.parseError = true), 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = true), isNaN(c) || (this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode))), true;
  }, URLStateMachine.prototype["parse query"] = function(c, cStr) {
    if (isNaN(c) || !this.stateOverride && 35 === c) {
      isSpecial(this.url) && "ws" !== this.url.scheme && "wss" !== this.url.scheme || (this.encodingOverride = "utf-8");
      const buffer = new Buffer(this.buffer);
      for (let i = 0; i < buffer.length; ++i) buffer[i] < 33 || buffer[i] > 126 || 34 === buffer[i] || 35 === buffer[i] || 60 === buffer[i] || 62 === buffer[i] ? this.url.query += percentEncode(buffer[i]) : this.url.query += String.fromCodePoint(buffer[i]);
      this.buffer = "", 35 === c && (this.url.fragment = "", this.state = "fragment");
    } else 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = true), this.buffer += cStr;
    return true;
  }, URLStateMachine.prototype["parse fragment"] = function(c) {
    return isNaN(c) || (0 === c ? this.parseError = true : (37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = true), this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode))), true;
  }, module.exports.serializeURL = function(url, excludeFragment) {
    let output = url.scheme + ":";
    if (null !== url.host ? (output += "//", "" === url.username && "" === url.password || (output += url.username, "" !== url.password && (output += ":" + url.password), output += "@"), output += serializeHost(url.host), null !== url.port && (output += ":" + url.port)) : null === url.host && "file" === url.scheme && (output += "//"), url.cannotBeABaseURL) output += url.path[0];
    else for (const string of url.path) output += "/" + string;
    return null !== url.query && (output += "?" + url.query), excludeFragment || null === url.fragment || (output += "#" + url.fragment), output;
  }, module.exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
        } catch (e) {
          return "null";
        }
      case "ftp":
      case "gopher":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return (function(tuple) {
          let result = tuple.scheme + "://";
          return result += serializeHost(tuple.host), null !== tuple.port && (result += ":" + tuple.port), result;
        })({ scheme: url.scheme, host: url.host, port: url.port });
      case "file":
        return "file://";
      default:
        return "null";
    }
  }, module.exports.basicURLParse = function(input, options) {
    void 0 === options && (options = {});
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    return usm.failure ? "failure" : usm.url;
  }, module.exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode$2.ucs2.decode(username);
    for (let i = 0; i < decoded.length; ++i) url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }, module.exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode$2.ucs2.decode(password);
    for (let i = 0; i < decoded.length; ++i) url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }, module.exports.serializeHost = serializeHost, module.exports.cannotHaveAUsernamePasswordPort = function(url) {
    return null === url.host || "" === url.host || url.cannotBeABaseURL || "file" === url.scheme;
  }, module.exports.serializeInteger = function(integer) {
    return String(integer);
  }, module.exports.parseURL = function(input, options) {
    return void 0 === options && (options = {}), module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
}));
urlStateMachine.serializeURL, urlStateMachine.serializeURLOrigin, urlStateMachine.basicURLParse, urlStateMachine.setTheUsername, urlStateMachine.setThePassword, urlStateMachine.serializeHost, urlStateMachine.cannotHaveAUsernamePasswordPort, urlStateMachine.serializeInteger, urlStateMachine.parseURL;
var URLImpl_1_implementation = class {
  constructor(constructorArgs) {
    const url = constructorArgs[0], base = constructorArgs[1];
    let parsedBase = null;
    if (void 0 !== base && (parsedBase = urlStateMachine.basicURLParse(base), "failure" === parsedBase)) throw new TypeError("Invalid base URL");
    const parsedURL = urlStateMachine.basicURLParse(url, { baseURL: parsedBase });
    if ("failure" === parsedURL) throw new TypeError("Invalid URL");
    this._url = parsedURL;
  }
  get href() {
    return urlStateMachine.serializeURL(this._url);
  }
  set href(v) {
    const parsedURL = urlStateMachine.basicURLParse(v);
    if ("failure" === parsedURL) throw new TypeError("Invalid URL");
    this._url = parsedURL;
  }
  get origin() {
    return urlStateMachine.serializeURLOrigin(this._url);
  }
  get protocol() {
    return this._url.scheme + ":";
  }
  set protocol(v) {
    urlStateMachine.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
  }
  get username() {
    return this._url.username;
  }
  set username(v) {
    urlStateMachine.cannotHaveAUsernamePasswordPort(this._url) || urlStateMachine.setTheUsername(this._url, v);
  }
  get password() {
    return this._url.password;
  }
  set password(v) {
    urlStateMachine.cannotHaveAUsernamePasswordPort(this._url) || urlStateMachine.setThePassword(this._url, v);
  }
  get host() {
    const url = this._url;
    return null === url.host ? "" : null === url.port ? urlStateMachine.serializeHost(url.host) : urlStateMachine.serializeHost(url.host) + ":" + urlStateMachine.serializeInteger(url.port);
  }
  set host(v) {
    this._url.cannotBeABaseURL || urlStateMachine.basicURLParse(v, { url: this._url, stateOverride: "host" });
  }
  get hostname() {
    return null === this._url.host ? "" : urlStateMachine.serializeHost(this._url.host);
  }
  set hostname(v) {
    this._url.cannotBeABaseURL || urlStateMachine.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
  }
  get port() {
    return null === this._url.port ? "" : urlStateMachine.serializeInteger(this._url.port);
  }
  set port(v) {
    urlStateMachine.cannotHaveAUsernamePasswordPort(this._url) || ("" === v ? this._url.port = null : urlStateMachine.basicURLParse(v, { url: this._url, stateOverride: "port" }));
  }
  get pathname() {
    return this._url.cannotBeABaseURL ? this._url.path[0] : 0 === this._url.path.length ? "" : "/" + this._url.path.join("/");
  }
  set pathname(v) {
    this._url.cannotBeABaseURL || (this._url.path = [], urlStateMachine.basicURLParse(v, { url: this._url, stateOverride: "path start" }));
  }
  get search() {
    return null === this._url.query || "" === this._url.query ? "" : "?" + this._url.query;
  }
  set search(v) {
    const url = this._url;
    if ("" === v) return void (url.query = null);
    const input = "?" === v[0] ? v.substring(1) : v;
    url.query = "", urlStateMachine.basicURLParse(input, { url, stateOverride: "query" });
  }
  get hash() {
    return null === this._url.fragment || "" === this._url.fragment ? "" : "#" + this._url.fragment;
  }
  set hash(v) {
    if ("" === v) return void (this._url.fragment = null);
    const input = "#" === v[0] ? v.substring(1) : v;
    this._url.fragment = "", urlStateMachine.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
  }
  toJSON() {
    return this.href;
  }
}, URL_1 = createCommonjsModule((function(module) {
  const impl = utils.implSymbol;
  function URL2(url) {
    if (!this || this[impl] || !(this instanceof URL2)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    const args = [];
    for (let i = 0; i < arguments.length && i < 2; ++i) args[i] = arguments[i];
    args[0] = lib$1.USVString(args[0]), void 0 !== args[1] && (args[1] = lib$1.USVString(args[1])), module.exports.setup(this, args);
  }
  URL2.prototype.toJSON = function() {
    if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
    const args = [];
    for (let i = 0; i < arguments.length && i < 0; ++i) args[i] = arguments[i];
    return this[impl].toJSON.apply(this[impl], args);
  }, Object.defineProperty(URL2.prototype, "href", { get() {
    return this[impl].href;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].href = V;
  }, enumerable: true, configurable: true }), URL2.prototype.toString = function() {
    if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
    return this.href;
  }, Object.defineProperty(URL2.prototype, "origin", { get() {
    return this[impl].origin;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "protocol", { get() {
    return this[impl].protocol;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].protocol = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "username", { get() {
    return this[impl].username;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].username = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "password", { get() {
    return this[impl].password;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].password = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "host", { get() {
    return this[impl].host;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].host = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "hostname", { get() {
    return this[impl].hostname;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].hostname = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "port", { get() {
    return this[impl].port;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].port = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "pathname", { get() {
    return this[impl].pathname;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].pathname = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "search", { get() {
    return this[impl].search;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].search = V;
  }, enumerable: true, configurable: true }), Object.defineProperty(URL2.prototype, "hash", { get() {
    return this[impl].hash;
  }, set(V) {
    V = lib$1.USVString(V), this[impl].hash = V;
  }, enumerable: true, configurable: true }), module.exports = { is: (obj) => !!obj && obj[impl] instanceof URLImpl_1_implementation, create(constructorArgs, privateData) {
    let obj = Object.create(URL2.prototype);
    return this.setup(obj, constructorArgs, privateData), obj;
  }, setup(obj, constructorArgs, privateData) {
    privateData || (privateData = {}), privateData.wrapper = obj, obj[impl] = new URLImpl_1_implementation(constructorArgs, privateData), obj[impl][utils.wrapperSymbol] = obj;
  }, interface: URL2, expose: { Window: { URL: URL2 }, Worker: { URL: URL2 } } };
}));
URL_1.is, URL_1.create, URL_1.setup, URL_1.expose;
var publicApi = { URL: URL_1.interface, serializeURL: urlStateMachine.serializeURL, serializeURLOrigin: urlStateMachine.serializeURLOrigin, basicURLParse: urlStateMachine.basicURLParse, setTheUsername: urlStateMachine.setTheUsername, setThePassword: urlStateMachine.setThePassword, serializeHost: urlStateMachine.serializeHost, serializeInteger: urlStateMachine.serializeInteger, parseURL: urlStateMachine.parseURL };
const Readable = Stream.Readable, BUFFER = Symbol("buffer"), TYPE = Symbol("type");
class Blob$1 {
  constructor() {
    this[TYPE] = "";
    const blobParts = arguments[0], options = arguments[1], buffers = [];
    let size = 0;
    if (blobParts) {
      const a = blobParts, length = Number(a.length);
      for (let i = 0; i < length; i++) {
        const element2 = a[i];
        let buffer;
        buffer = element2 instanceof Buffer ? element2 : ArrayBuffer.isView(element2) ? Buffer.from(element2.buffer, element2.byteOffset, element2.byteLength) : element2 instanceof ArrayBuffer ? Buffer.from(element2) : element2 instanceof Blob$1 ? element2[BUFFER] : Buffer.from("string" == typeof element2 ? element2 : String(element2)), size += buffer.length, buffers.push(buffer);
      }
    }
    this[BUFFER] = Buffer.concat(buffers);
    let type2 = options && void 0 !== options.type && String(options.type).toLowerCase();
    type2 && !/[^\u0020-\u007E]/.test(type2) && (this[TYPE] = type2);
  }
  get size() {
    return this[BUFFER].length;
  }
  get type() {
    return this[TYPE];
  }
  text() {
    return Promise.resolve(this[BUFFER].toString());
  }
  arrayBuffer() {
    const buf = this[BUFFER], ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    return Promise.resolve(ab);
  }
  stream() {
    const readable2 = new Readable();
    return readable2._read = function() {
    }, readable2.push(this[BUFFER]), readable2.push(null), readable2;
  }
  toString() {
    return "[object Blob]";
  }
  slice() {
    const size = this.size, start = arguments[0], end = arguments[1];
    let relativeStart, relativeEnd;
    relativeStart = void 0 === start ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size), relativeEnd = void 0 === end ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(relativeEnd - relativeStart, 0), slicedBuffer = this[BUFFER].slice(relativeStart, relativeStart + span), blob = new Blob$1([], { type: arguments[2] });
    return blob[BUFFER] = slicedBuffer, blob;
  }
}
function FetchError(message, type2, systemError) {
  Error.call(this, message), this.message = message, this.type = type2, systemError && (this.code = this.errno = systemError.code), Error.captureStackTrace(this, this.constructor);
}
let convert;
Object.defineProperties(Blob$1.prototype, { size: { enumerable: true }, type: { enumerable: true }, slice: { enumerable: true } }), Object.defineProperty(Blob$1.prototype, Symbol.toStringTag, { value: "Blob", writable: false, enumerable: false, configurable: true }), FetchError.prototype = Object.create(Error.prototype), FetchError.prototype.constructor = FetchError, FetchError.prototype.name = "FetchError";
try {
  convert = require("encoding").convert;
} catch (e) {
}
const INTERNALS = Symbol("Body internals"), PassThrough = Stream.PassThrough;
function Body(body) {
  var _this = this, _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref$size = _ref.size;
  let size = void 0 === _ref$size ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
  null == body ? body = null : isURLSearchParams(body) ? body = Buffer.from(body.toString()) : isBlob(body) || Buffer.isBuffer(body) || ("[object ArrayBuffer]" === Object.prototype.toString.call(body) ? body = Buffer.from(body) : ArrayBuffer.isView(body) ? body = Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof Stream || (body = Buffer.from(String(body)))), this[INTERNALS] = { body, disturbed: false, error: null }, this.size = size, this.timeout = timeout, body instanceof Stream && body.on("error", (function(err) {
    const error = "AbortError" === err.name ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
    _this[INTERNALS].error = error;
  }));
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  if (this[INTERNALS].disturbed = true, this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
  let body = this.body;
  if (null === body) return Body.Promise.resolve(Buffer.alloc(0));
  if (isBlob(body) && (body = body.stream()), Buffer.isBuffer(body)) return Body.Promise.resolve(body);
  if (!(body instanceof Stream)) return Body.Promise.resolve(Buffer.alloc(0));
  let accum = [], accumBytes = 0, abort = false;
  return new Body.Promise((function(resolve, reject) {
    let resTimeout;
    _this4.timeout && (resTimeout = setTimeout((function() {
      abort = true, reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
    }), _this4.timeout)), body.on("error", (function(err) {
      "AbortError" === err.name ? (abort = true, reject(err)) : reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
    })), body.on("data", (function(chunk) {
      if (!abort && null !== chunk) {
        if (_this4.size && accumBytes + chunk.length > _this4.size) return abort = true, void reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        accumBytes += chunk.length, accum.push(chunk);
      }
    })), body.on("end", (function() {
      if (!abort) {
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      }
    }));
  }));
}
function isURLSearchParams(obj) {
  return "object" == typeof obj && "function" == typeof obj.append && "function" == typeof obj.delete && "function" == typeof obj.get && "function" == typeof obj.getAll && "function" == typeof obj.has && "function" == typeof obj.set && ("URLSearchParams" === obj.constructor.name || "[object URLSearchParams]" === Object.prototype.toString.call(obj) || "function" == typeof obj.sort);
}
function isBlob(obj) {
  return "object" == typeof obj && "function" == typeof obj.arrayBuffer && "string" == typeof obj.type && "function" == typeof obj.stream && "function" == typeof obj.constructor && "string" == typeof obj.constructor.name && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
function clone(instance) {
  let p1, p2, body = instance.body;
  if (instance.bodyUsed) throw new Error("cannot clone body after it is used");
  return body instanceof Stream && "function" != typeof body.getBoundary && (p1 = new PassThrough(), p2 = new PassThrough(), body.pipe(p1), body.pipe(p2), instance[INTERNALS].body = p1, body = p2), body;
}
function extractContentType(body) {
  return null === body ? null : "string" == typeof body ? "text/plain;charset=UTF-8" : isURLSearchParams(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : Buffer.isBuffer(body) || "[object ArrayBuffer]" === Object.prototype.toString.call(body) || ArrayBuffer.isView(body) ? null : "function" == typeof body.getBoundary ? `multipart/form-data;boundary=${body.getBoundary()}` : body instanceof Stream ? null : "text/plain;charset=UTF-8";
}
function getTotalBytes(instance) {
  const body = instance.body;
  return null === body ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && "function" == typeof body.getLengthSync && (body._lengthRetrievers && 0 == body._lengthRetrievers.length || body.hasKnownLength && body.hasKnownLength()) ? body.getLengthSync() : null;
}
Body.prototype = { get body() {
  return this[INTERNALS].body;
}, get bodyUsed() {
  return this[INTERNALS].disturbed;
}, arrayBuffer() {
  return consumeBody.call(this).then((function(buf) {
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }));
}, blob() {
  let ct = this.headers && this.headers.get("content-type") || "";
  return consumeBody.call(this).then((function(buf) {
    return Object.assign(new Blob$1([], { type: ct.toLowerCase() }), { [BUFFER]: buf });
  }));
}, json() {
  var _this2 = this;
  return consumeBody.call(this).then((function(buffer) {
    try {
      return JSON.parse(buffer.toString());
    } catch (err) {
      return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
    }
  }));
}, text() {
  return consumeBody.call(this).then((function(buffer) {
    return buffer.toString();
  }));
}, buffer() {
  return consumeBody.call(this);
}, textConverted() {
  var _this3 = this;
  return consumeBody.call(this).then((function(buffer) {
    return (function(buffer2, headers) {
      if ("function" != typeof convert) throw new Error("The package `encoding` must be installed to use the textConverted() function");
      const ct = headers.get("content-type");
      let res, str, charset = "utf-8";
      ct && (res = /charset=([^;]*)/i.exec(ct));
      str = buffer2.slice(0, 1024).toString(), !res && str && (res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str));
      !res && str && (res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str), res || (res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str), res && res.pop()), res && (res = /charset=(.*)/i.exec(res.pop())));
      !res && str && (res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str));
      res && (charset = res.pop(), "gb2312" !== charset && "gbk" !== charset || (charset = "gb18030"));
      return convert(buffer2, "UTF-8", charset).toString();
    })(buffer, _this3.headers);
  }));
} }, Object.defineProperties(Body.prototype, { body: { enumerable: true }, bodyUsed: { enumerable: true }, arrayBuffer: { enumerable: true }, blob: { enumerable: true }, json: { enumerable: true }, text: { enumerable: true } }), Body.mixIn = function(proto) {
  for (const name of Object.getOwnPropertyNames(Body.prototype)) if (!(name in proto)) {
    const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
    Object.defineProperty(proto, name, desc);
  }
}, Body.Promise = global.Promise;
const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/, invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
  if (name = `${name}`, invalidTokenRegex.test(name) || "" === name) throw new TypeError(`${name} is not a legal HTTP header name`);
}
function validateValue(value) {
  if (value = `${value}`, invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
}
function find(map2, name) {
  name = name.toLowerCase();
  for (const key in map2) if (key.toLowerCase() === name) return key;
}
const MAP = Symbol("map");
class Headers {
  constructor() {
    let init = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (this[MAP] = /* @__PURE__ */ Object.create(null), init instanceof Headers) {
      const rawHeaders = init.raw(), headerNames = Object.keys(rawHeaders);
      for (const headerName of headerNames) for (const value of rawHeaders[headerName]) this.append(headerName, value);
    } else if (null == init) ;
    else {
      if ("object" != typeof init) throw new TypeError("Provided initializer must be an object");
      {
        const method2 = init[Symbol.iterator];
        if (null != method2) {
          if ("function" != typeof method2) throw new TypeError("Header pairs must be iterable");
          const pairs = [];
          for (const pair of init) {
            if ("object" != typeof pair || "function" != typeof pair[Symbol.iterator]) throw new TypeError("Each header pair must be iterable");
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (2 !== pair.length) throw new TypeError("Each header pair must be a name/value tuple");
            this.append(pair[0], pair[1]);
          }
        } else for (const key of Object.keys(init)) {
          const value = init[key];
          this.append(key, value);
        }
      }
    }
  }
  get(name) {
    validateName(name = `${name}`);
    const key = find(this[MAP], name);
    return void 0 === key ? null : this[MAP][key].join(", ");
  }
  forEach(callback) {
    let thisArg = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, pairs = getHeaders(this), i = 0;
    for (; i < pairs.length; ) {
      var _pairs$i = pairs[i];
      const name = _pairs$i[0], value = _pairs$i[1];
      callback.call(thisArg, value, name, this), pairs = getHeaders(this), i++;
    }
  }
  set(name, value) {
    value = `${value}`, validateName(name = `${name}`), validateValue(value);
    const key = find(this[MAP], name);
    this[MAP][void 0 !== key ? key : name] = [value];
  }
  append(name, value) {
    value = `${value}`, validateName(name = `${name}`), validateValue(value);
    const key = find(this[MAP], name);
    void 0 !== key ? this[MAP][key].push(value) : this[MAP][name] = [value];
  }
  has(name) {
    return validateName(name = `${name}`), void 0 !== find(this[MAP], name);
  }
  delete(name) {
    validateName(name = `${name}`);
    const key = find(this[MAP], name);
    void 0 !== key && delete this[MAP][key];
  }
  raw() {
    return this[MAP];
  }
  keys() {
    return createHeadersIterator(this, "key");
  }
  values() {
    return createHeadersIterator(this, "value");
  }
  [Symbol.iterator]() {
    return createHeadersIterator(this, "key+value");
  }
}
function getHeaders(headers) {
  let kind = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map("key" === kind ? function(k) {
    return k.toLowerCase();
  } : "value" === kind ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator], Object.defineProperty(Headers.prototype, Symbol.toStringTag, { value: "Headers", writable: false, enumerable: false, configurable: true }), Object.defineProperties(Headers.prototype, { get: { enumerable: true }, forEach: { enumerable: true }, set: { enumerable: true }, append: { enumerable: true }, has: { enumerable: true }, delete: { enumerable: true }, keys: { enumerable: true }, values: { enumerable: true }, entries: { enumerable: true } });
const INTERNAL = Symbol("internal");
function createHeadersIterator(target2, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  return iterator[INTERNAL] = { target: target2, kind, index: 0 }, iterator;
}
const HeadersIteratorPrototype = Object.setPrototypeOf({ next() {
  if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError("Value of `this` is not a HeadersIterator");
  var _INTERNAL = this[INTERNAL];
  const target2 = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index, values = getHeaders(target2, kind);
  return index >= values.length ? { value: void 0, done: true } : (this[INTERNAL].index = index + 1, { value: values[index], done: false });
} }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]), hostHeaderKey = find(headers[MAP], "Host");
  return void 0 !== hostHeaderKey && (obj[hostHeaderKey] = obj[hostHeaderKey][0]), obj;
}
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, { value: "HeadersIterator", writable: false, enumerable: false, configurable: true });
const INTERNALS$1 = Symbol("Response internals"), STATUS_CODES = http.STATUS_CODES;
class Response {
  constructor() {
    let body = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    Body.call(this, body, opts);
    const status = opts.status || 200, headers = new Headers(opts.headers);
    if (null != body && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      contentType && headers.append("Content-Type", contentType);
    }
    this[INTERNALS$1] = { url: opts.url, status, statusText: opts.statusText || STATUS_CODES[status], headers, counter: opts.counter };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  clone() {
    return new Response(clone(this), { url: this.url, status: this.status, statusText: this.statusText, headers: this.headers, ok: this.ok, redirected: this.redirected });
  }
}
Body.mixIn(Response.prototype), Object.defineProperties(Response.prototype, { url: { enumerable: true }, status: { enumerable: true }, ok: { enumerable: true }, redirected: { enumerable: true }, statusText: { enumerable: true }, headers: { enumerable: true }, clone: { enumerable: true } }), Object.defineProperty(Response.prototype, Symbol.toStringTag, { value: "Response", writable: false, enumerable: false, configurable: true });
const INTERNALS$2 = Symbol("Request internals"), URL = Url.URL || publicApi.URL, parse_url = Url.parse, format_url = Url.format;
function parseURL(urlStr) {
  return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr) && (urlStr = new URL(urlStr).toString()), parse_url(urlStr);
}
const streamDestructionSupported = "destroy" in Stream.Readable.prototype;
function isRequest(input) {
  return "object" == typeof input && "object" == typeof input[INTERNALS$2];
}
class Request {
  constructor(input) {
    let parsedURL, init = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    isRequest(input) ? parsedURL = parseURL(input.url) : (parsedURL = input && input.href ? parseURL(input.href) : parseURL(`${input}`), input = {});
    let method2 = init.method || input.method || "GET";
    if (method2 = method2.toUpperCase(), (null != init.body || isRequest(input) && null !== input.body) && ("GET" === method2 || "HEAD" === method2)) throw new TypeError("Request with GET/HEAD method cannot have body");
    let inputBody = null != init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
    Body.call(this, inputBody, { timeout: init.timeout || input.timeout || 0, size: init.size || input.size || 0 });
    const headers = new Headers(init.headers || input.headers || {});
    if (null != inputBody && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody);
      contentType && headers.append("Content-Type", contentType);
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init && (signal = init.signal), null != signal && !(function(signal2) {
      const proto = signal2 && "object" == typeof signal2 && Object.getPrototypeOf(signal2);
      return !(!proto || "AbortSignal" !== proto.constructor.name);
    })(signal)) throw new TypeError("Expected signal to be an instanceof AbortSignal");
    this[INTERNALS$2] = { method: method2, redirect: init.redirect || input.redirect || "follow", headers, parsedURL, signal }, this.follow = void 0 !== init.follow ? init.follow : void 0 !== input.follow ? input.follow : 20, this.compress = void 0 !== init.compress ? init.compress : void 0 === input.compress || input.compress, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent;
  }
  get method() {
    return this[INTERNALS$2].method;
  }
  get url() {
    return format_url(this[INTERNALS$2].parsedURL);
  }
  get headers() {
    return this[INTERNALS$2].headers;
  }
  get redirect() {
    return this[INTERNALS$2].redirect;
  }
  get signal() {
    return this[INTERNALS$2].signal;
  }
  clone() {
    return new Request(this);
  }
}
function AbortError(message) {
  Error.call(this, message), this.type = "aborted", this.message = message, Error.captureStackTrace(this, this.constructor);
}
Body.mixIn(Request.prototype), Object.defineProperty(Request.prototype, Symbol.toStringTag, { value: "Request", writable: false, enumerable: false, configurable: true }), Object.defineProperties(Request.prototype, { method: { enumerable: true }, url: { enumerable: true }, headers: { enumerable: true }, redirect: { enumerable: true }, clone: { enumerable: true }, signal: { enumerable: true } }), AbortError.prototype = Object.create(Error.prototype), AbortError.prototype.constructor = AbortError, AbortError.prototype.name = "AbortError";
const URL$1 = Url.URL || publicApi.URL, PassThrough$1 = Stream.PassThrough;
function fetch(url, opts) {
  if (!fetch.Promise) throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  return Body.Promise = fetch.Promise, new fetch.Promise((function(resolve, reject) {
    const request = new Request(url, opts), options = (function(request2) {
      const parsedURL = request2[INTERNALS$2].parsedURL, headers = new Headers(request2[INTERNALS$2].headers);
      if (headers.has("Accept") || headers.set("Accept", "*/*"), !parsedURL.protocol || !parsedURL.hostname) throw new TypeError("Only absolute URLs are supported");
      if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError("Only HTTP(S) protocols are supported");
      if (request2.signal && request2.body instanceof Stream.Readable && !streamDestructionSupported) throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      let contentLengthValue = null;
      if (null == request2.body && /^(POST|PUT)$/i.test(request2.method) && (contentLengthValue = "0"), null != request2.body) {
        const totalBytes = getTotalBytes(request2);
        "number" == typeof totalBytes && (contentLengthValue = String(totalBytes));
      }
      contentLengthValue && headers.set("Content-Length", contentLengthValue), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"), request2.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip,deflate");
      let agent = request2.agent;
      return "function" == typeof agent && (agent = agent(parsedURL)), headers.has("Connection") || agent || headers.set("Connection", "close"), Object.assign({}, parsedURL, { method: request2.method, headers: exportNodeCompatibleHeaders(headers), agent });
    })(request), send = ("https:" === options.protocol ? https : http).request, signal = request.signal;
    let response = null;
    const abort = function() {
      let error = new AbortError("The user aborted a request.");
      reject(error), request.body && request.body instanceof Stream.Readable && request.body.destroy(error), response && response.body && response.body.emit("error", error);
    };
    if (signal && signal.aborted) return void abort();
    const abortAndFinalize = function() {
      abort(), finalize();
    }, req = send(options);
    let reqTimeout;
    function finalize() {
      req.abort(), signal && signal.removeEventListener("abort", abortAndFinalize), clearTimeout(reqTimeout);
    }
    signal && signal.addEventListener("abort", abortAndFinalize), request.timeout && req.once("socket", (function(socket) {
      reqTimeout = setTimeout((function() {
        reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout")), finalize();
      }), request.timeout);
    })), req.on("error", (function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err)), finalize();
    })), req.on("response", (function(res) {
      clearTimeout(reqTimeout);
      const headers = (function(obj) {
        const headers2 = new Headers();
        for (const name of Object.keys(obj)) if (!invalidTokenRegex.test(name)) if (Array.isArray(obj[name])) for (const val of obj[name]) invalidHeaderCharRegex.test(val) || (void 0 === headers2[MAP][name] ? headers2[MAP][name] = [val] : headers2[MAP][name].push(val));
        else invalidHeaderCharRegex.test(obj[name]) || (headers2[MAP][name] = [obj[name]]);
        return headers2;
      })(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = null === location ? null : new URL$1(location, request.url).toString();
        } catch (err) {
          if ("manual" !== request.redirect) return reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect")), void finalize();
        }
        switch (request.redirect) {
          case "error":
            return reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), void finalize();
          case "manual":
            if (null !== locationURL) try {
              headers.set("Location", locationURL);
            } catch (err) {
              reject(err);
            }
            break;
          case "follow":
            if (null === locationURL) break;
            if (request.counter >= request.follow) return reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), void finalize();
            const requestOpts = { headers: new Headers(request.headers), follow: request.follow, counter: request.counter + 1, agent: request.agent, compress: request.compress, method: request.method, body: request.body, signal: request.signal, timeout: request.timeout, size: request.size };
            if (!(function(destination, original) {
              const orig = new URL$1(original).hostname, dest = new URL$1(destination).hostname;
              return orig === dest || "." === orig[orig.length - dest.length - 1] && orig.endsWith(dest);
            })(request.url, locationURL)) for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) requestOpts.headers.delete(name);
            return 303 !== res.statusCode && request.body && null === getTotalBytes(request) ? (reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), void finalize()) : (303 !== res.statusCode && (301 !== res.statusCode && 302 !== res.statusCode || "POST" !== request.method) || (requestOpts.method = "GET", requestOpts.body = void 0, requestOpts.headers.delete("content-length")), resolve(fetch(new Request(locationURL, requestOpts))), void finalize());
        }
      }
      res.once("end", (function() {
        signal && signal.removeEventListener("abort", abortAndFinalize);
      }));
      let body = res.pipe(new PassThrough$1());
      const response_options = { url: request.url, status: res.statusCode, statusText: res.statusMessage, headers, size: request.size, timeout: request.timeout, counter: request.counter }, codings = headers.get("Content-Encoding");
      if (!request.compress || "HEAD" === request.method || null === codings || 204 === res.statusCode || 304 === res.statusCode) return response = new Response(body, response_options), void resolve(response);
      const zlibOptions = { flush: zlib.Z_SYNC_FLUSH, finishFlush: zlib.Z_SYNC_FLUSH };
      if ("gzip" == codings || "x-gzip" == codings) return body = body.pipe(zlib.createGunzip(zlibOptions)), response = new Response(body, response_options), void resolve(response);
      if ("deflate" != codings && "x-deflate" != codings) {
        if ("br" == codings && "function" == typeof zlib.createBrotliDecompress) return body = body.pipe(zlib.createBrotliDecompress()), response = new Response(body, response_options), void resolve(response);
        response = new Response(body, response_options), resolve(response);
      } else {
        res.pipe(new PassThrough$1()).once("data", (function(chunk) {
          body = 8 == (15 & chunk[0]) ? body.pipe(zlib.createInflate()) : body.pipe(zlib.createInflateRaw()), response = new Response(body, response_options), resolve(response);
        }));
      }
    })), (function(dest, instance) {
      const body = instance.body;
      null === body ? dest.end() : isBlob(body) ? body.stream().pipe(dest) : Buffer.isBuffer(body) ? (dest.write(body), dest.end()) : body.pipe(dest);
    })(req, request);
  }));
}
fetch.isRedirect = function(code) {
  return 301 === code || 302 === code || 303 === code || 307 === code || 308 === code;
}, fetch.Promise = global.Promise;
var require$$2 = getCjsExportFromNamespace(Object.freeze({ __proto__: null, default: fetch, Headers, Request, Response, FetchError }));
function base64ToNode(e) {
  return e.toString("base64");
}
function isImage(e) {
  return (function(e2) {
    return new RegExp("(?<=\\S+)\\.(jpg|png|jpeg)", "gi").test(e2);
  })(e) ? Promise.resolve((function(e2) {
    var r = fs, t = path;
    return r.statSync(e2).isFile() ? base64ToNode(r.readFileSync(t.resolve(e2)).toString("base64")) : null;
  })(e)) : Promise.reject("[*] Occurent some error... [validTypeImage] == false");
}
var imageToBase64_min = function(e) {
  return (function(e2) {
    return new RegExp("http(s)?:\\/\\/(\\w+:?\\w*@)?(\\S+)(:\\d+)?((?<=\\.)\\w+)+(\\/([\\w#!:.?+=&%@!\\-/])*)?", "gi").test(e2);
  })(e) ? require$$2(e).then((function(e2) {
    return e2.buffer();
  })).then(base64ToNode) : isImage(e);
}, mimeDb = getCjsExportFromNamespace(Object.freeze({ __proto__: null, default: { "application/1d-interleaved-parityfec": { source: "iana" }, "application/3gpdash-qoe-report+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/3gpp-ims+xml": { source: "iana", compressible: true }, "application/3gpphal+json": { source: "iana", compressible: true }, "application/3gpphalforms+json": { source: "iana", compressible: true }, "application/a2l": { source: "iana" }, "application/ace+cbor": { source: "iana" }, "application/activemessage": { source: "iana" }, "application/activity+json": { source: "iana", compressible: true }, "application/alto-costmap+json": { source: "iana", compressible: true }, "application/alto-costmapfilter+json": { source: "iana", compressible: true }, "application/alto-directory+json": { source: "iana", compressible: true }, "application/alto-endpointcost+json": { source: "iana", compressible: true }, "application/alto-endpointcostparams+json": { source: "iana", compressible: true }, "application/alto-endpointprop+json": { source: "iana", compressible: true }, "application/alto-endpointpropparams+json": { source: "iana", compressible: true }, "application/alto-error+json": { source: "iana", compressible: true }, "application/alto-networkmap+json": { source: "iana", compressible: true }, "application/alto-networkmapfilter+json": { source: "iana", compressible: true }, "application/alto-updatestreamcontrol+json": { source: "iana", compressible: true }, "application/alto-updatestreamparams+json": { source: "iana", compressible: true }, "application/aml": { source: "iana" }, "application/andrew-inset": { source: "iana", extensions: ["ez"] }, "application/applefile": { source: "iana" }, "application/applixware": { source: "apache", extensions: ["aw"] }, "application/at+jwt": { source: "iana" }, "application/atf": { source: "iana" }, "application/atfx": { source: "iana" }, "application/atom+xml": { source: "iana", compressible: true, extensions: ["atom"] }, "application/atomcat+xml": { source: "iana", compressible: true, extensions: ["atomcat"] }, "application/atomdeleted+xml": { source: "iana", compressible: true, extensions: ["atomdeleted"] }, "application/atomicmail": { source: "iana" }, "application/atomsvc+xml": { source: "iana", compressible: true, extensions: ["atomsvc"] }, "application/atsc-dwd+xml": { source: "iana", compressible: true, extensions: ["dwd"] }, "application/atsc-dynamic-event-message": { source: "iana" }, "application/atsc-held+xml": { source: "iana", compressible: true, extensions: ["held"] }, "application/atsc-rdt+json": { source: "iana", compressible: true }, "application/atsc-rsat+xml": { source: "iana", compressible: true, extensions: ["rsat"] }, "application/atxml": { source: "iana" }, "application/auth-policy+xml": { source: "iana", compressible: true }, "application/bacnet-xdd+zip": { source: "iana", compressible: false }, "application/batch-smtp": { source: "iana" }, "application/bdoc": { compressible: false, extensions: ["bdoc"] }, "application/beep+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/calendar+json": { source: "iana", compressible: true }, "application/calendar+xml": { source: "iana", compressible: true, extensions: ["xcs"] }, "application/call-completion": { source: "iana" }, "application/cals-1840": { source: "iana" }, "application/captive+json": { source: "iana", compressible: true }, "application/cbor": { source: "iana" }, "application/cbor-seq": { source: "iana" }, "application/cccex": { source: "iana" }, "application/ccmp+xml": { source: "iana", compressible: true }, "application/ccxml+xml": { source: "iana", compressible: true, extensions: ["ccxml"] }, "application/cdfx+xml": { source: "iana", compressible: true, extensions: ["cdfx"] }, "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] }, "application/cdmi-container": { source: "iana", extensions: ["cdmic"] }, "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] }, "application/cdmi-object": { source: "iana", extensions: ["cdmio"] }, "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] }, "application/cdni": { source: "iana" }, "application/cea": { source: "iana" }, "application/cea-2018+xml": { source: "iana", compressible: true }, "application/cellml+xml": { source: "iana", compressible: true }, "application/cfw": { source: "iana" }, "application/city+json": { source: "iana", compressible: true }, "application/clr": { source: "iana" }, "application/clue+xml": { source: "iana", compressible: true }, "application/clue_info+xml": { source: "iana", compressible: true }, "application/cms": { source: "iana" }, "application/cnrp+xml": { source: "iana", compressible: true }, "application/coap-group+json": { source: "iana", compressible: true }, "application/coap-payload": { source: "iana" }, "application/commonground": { source: "iana" }, "application/conference-info+xml": { source: "iana", compressible: true }, "application/cose": { source: "iana" }, "application/cose-key": { source: "iana" }, "application/cose-key-set": { source: "iana" }, "application/cpl+xml": { source: "iana", compressible: true, extensions: ["cpl"] }, "application/csrattrs": { source: "iana" }, "application/csta+xml": { source: "iana", compressible: true }, "application/cstadata+xml": { source: "iana", compressible: true }, "application/csvm+json": { source: "iana", compressible: true }, "application/cu-seeme": { source: "apache", extensions: ["cu"] }, "application/cwt": { source: "iana" }, "application/cybercash": { source: "iana" }, "application/dart": { compressible: true }, "application/dash+xml": { source: "iana", compressible: true, extensions: ["mpd"] }, "application/dash-patch+xml": { source: "iana", compressible: true, extensions: ["mpp"] }, "application/dashdelta": { source: "iana" }, "application/davmount+xml": { source: "iana", compressible: true, extensions: ["davmount"] }, "application/dca-rft": { source: "iana" }, "application/dcd": { source: "iana" }, "application/dec-dx": { source: "iana" }, "application/dialog-info+xml": { source: "iana", compressible: true }, "application/dicom": { source: "iana" }, "application/dicom+json": { source: "iana", compressible: true }, "application/dicom+xml": { source: "iana", compressible: true }, "application/dii": { source: "iana" }, "application/dit": { source: "iana" }, "application/dns": { source: "iana" }, "application/dns+json": { source: "iana", compressible: true }, "application/dns-message": { source: "iana" }, "application/docbook+xml": { source: "apache", compressible: true, extensions: ["dbk"] }, "application/dots+cbor": { source: "iana" }, "application/dskpp+xml": { source: "iana", compressible: true }, "application/dssc+der": { source: "iana", extensions: ["dssc"] }, "application/dssc+xml": { source: "iana", compressible: true, extensions: ["xdssc"] }, "application/dvcs": { source: "iana" }, "application/ecmascript": { source: "iana", compressible: true, extensions: ["es", "ecma"] }, "application/edi-consent": { source: "iana" }, "application/edi-x12": { source: "iana", compressible: false }, "application/edifact": { source: "iana", compressible: false }, "application/efi": { source: "iana" }, "application/elm+json": { source: "iana", charset: "UTF-8", compressible: true }, "application/elm+xml": { source: "iana", compressible: true }, "application/emergencycalldata.cap+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/emergencycalldata.comment+xml": { source: "iana", compressible: true }, "application/emergencycalldata.control+xml": { source: "iana", compressible: true }, "application/emergencycalldata.deviceinfo+xml": { source: "iana", compressible: true }, "application/emergencycalldata.ecall.msd": { source: "iana" }, "application/emergencycalldata.providerinfo+xml": { source: "iana", compressible: true }, "application/emergencycalldata.serviceinfo+xml": { source: "iana", compressible: true }, "application/emergencycalldata.subscriberinfo+xml": { source: "iana", compressible: true }, "application/emergencycalldata.veds+xml": { source: "iana", compressible: true }, "application/emma+xml": { source: "iana", compressible: true, extensions: ["emma"] }, "application/emotionml+xml": { source: "iana", compressible: true, extensions: ["emotionml"] }, "application/encaprtp": { source: "iana" }, "application/epp+xml": { source: "iana", compressible: true }, "application/epub+zip": { source: "iana", compressible: false, extensions: ["epub"] }, "application/eshop": { source: "iana" }, "application/exi": { source: "iana", extensions: ["exi"] }, "application/expect-ct-report+json": { source: "iana", compressible: true }, "application/express": { source: "iana", extensions: ["exp"] }, "application/fastinfoset": { source: "iana" }, "application/fastsoap": { source: "iana" }, "application/fdt+xml": { source: "iana", compressible: true, extensions: ["fdt"] }, "application/fhir+json": { source: "iana", charset: "UTF-8", compressible: true }, "application/fhir+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/fido.trusted-apps+json": { compressible: true }, "application/fits": { source: "iana" }, "application/flexfec": { source: "iana" }, "application/font-sfnt": { source: "iana" }, "application/font-tdpfr": { source: "iana", extensions: ["pfr"] }, "application/font-woff": { source: "iana", compressible: false }, "application/framework-attributes+xml": { source: "iana", compressible: true }, "application/geo+json": { source: "iana", compressible: true, extensions: ["geojson"] }, "application/geo+json-seq": { source: "iana" }, "application/geopackage+sqlite3": { source: "iana" }, "application/geoxacml+xml": { source: "iana", compressible: true }, "application/gltf-buffer": { source: "iana" }, "application/gml+xml": { source: "iana", compressible: true, extensions: ["gml"] }, "application/gpx+xml": { source: "apache", compressible: true, extensions: ["gpx"] }, "application/gxf": { source: "apache", extensions: ["gxf"] }, "application/gzip": { source: "iana", compressible: false, extensions: ["gz"] }, "application/h224": { source: "iana" }, "application/held+xml": { source: "iana", compressible: true }, "application/hjson": { extensions: ["hjson"] }, "application/http": { source: "iana" }, "application/hyperstudio": { source: "iana", extensions: ["stk"] }, "application/ibe-key-request+xml": { source: "iana", compressible: true }, "application/ibe-pkg-reply+xml": { source: "iana", compressible: true }, "application/ibe-pp-data": { source: "iana" }, "application/iges": { source: "iana" }, "application/im-iscomposing+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/index": { source: "iana" }, "application/index.cmd": { source: "iana" }, "application/index.obj": { source: "iana" }, "application/index.response": { source: "iana" }, "application/index.vnd": { source: "iana" }, "application/inkml+xml": { source: "iana", compressible: true, extensions: ["ink", "inkml"] }, "application/iotp": { source: "iana" }, "application/ipfix": { source: "iana", extensions: ["ipfix"] }, "application/ipp": { source: "iana" }, "application/isup": { source: "iana" }, "application/its+xml": { source: "iana", compressible: true, extensions: ["its"] }, "application/java-archive": { source: "apache", compressible: false, extensions: ["jar", "war", "ear"] }, "application/java-serialized-object": { source: "apache", compressible: false, extensions: ["ser"] }, "application/java-vm": { source: "apache", compressible: false, extensions: ["class"] }, "application/javascript": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["js", "mjs"] }, "application/jf2feed+json": { source: "iana", compressible: true }, "application/jose": { source: "iana" }, "application/jose+json": { source: "iana", compressible: true }, "application/jrd+json": { source: "iana", compressible: true }, "application/jscalendar+json": { source: "iana", compressible: true }, "application/json": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["json", "map"] }, "application/json-patch+json": { source: "iana", compressible: true }, "application/json-seq": { source: "iana" }, "application/json5": { extensions: ["json5"] }, "application/jsonml+json": { source: "apache", compressible: true, extensions: ["jsonml"] }, "application/jwk+json": { source: "iana", compressible: true }, "application/jwk-set+json": { source: "iana", compressible: true }, "application/jwt": { source: "iana" }, "application/kpml-request+xml": { source: "iana", compressible: true }, "application/kpml-response+xml": { source: "iana", compressible: true }, "application/ld+json": { source: "iana", compressible: true, extensions: ["jsonld"] }, "application/lgr+xml": { source: "iana", compressible: true, extensions: ["lgr"] }, "application/link-format": { source: "iana" }, "application/load-control+xml": { source: "iana", compressible: true }, "application/lost+xml": { source: "iana", compressible: true, extensions: ["lostxml"] }, "application/lostsync+xml": { source: "iana", compressible: true }, "application/lpf+zip": { source: "iana", compressible: false }, "application/lxf": { source: "iana" }, "application/mac-binhex40": { source: "iana", extensions: ["hqx"] }, "application/mac-compactpro": { source: "apache", extensions: ["cpt"] }, "application/macwriteii": { source: "iana" }, "application/mads+xml": { source: "iana", compressible: true, extensions: ["mads"] }, "application/manifest+json": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["webmanifest"] }, "application/marc": { source: "iana", extensions: ["mrc"] }, "application/marcxml+xml": { source: "iana", compressible: true, extensions: ["mrcx"] }, "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] }, "application/mathml+xml": { source: "iana", compressible: true, extensions: ["mathml"] }, "application/mathml-content+xml": { source: "iana", compressible: true }, "application/mathml-presentation+xml": { source: "iana", compressible: true }, "application/mbms-associated-procedure-description+xml": { source: "iana", compressible: true }, "application/mbms-deregister+xml": { source: "iana", compressible: true }, "application/mbms-envelope+xml": { source: "iana", compressible: true }, "application/mbms-msk+xml": { source: "iana", compressible: true }, "application/mbms-msk-response+xml": { source: "iana", compressible: true }, "application/mbms-protection-description+xml": { source: "iana", compressible: true }, "application/mbms-reception-report+xml": { source: "iana", compressible: true }, "application/mbms-register+xml": { source: "iana", compressible: true }, "application/mbms-register-response+xml": { source: "iana", compressible: true }, "application/mbms-schedule+xml": { source: "iana", compressible: true }, "application/mbms-user-service-description+xml": { source: "iana", compressible: true }, "application/mbox": { source: "iana", extensions: ["mbox"] }, "application/media-policy-dataset+xml": { source: "iana", compressible: true, extensions: ["mpf"] }, "application/media_control+xml": { source: "iana", compressible: true }, "application/mediaservercontrol+xml": { source: "iana", compressible: true, extensions: ["mscml"] }, "application/merge-patch+json": { source: "iana", compressible: true }, "application/metalink+xml": { source: "apache", compressible: true, extensions: ["metalink"] }, "application/metalink4+xml": { source: "iana", compressible: true, extensions: ["meta4"] }, "application/mets+xml": { source: "iana", compressible: true, extensions: ["mets"] }, "application/mf4": { source: "iana" }, "application/mikey": { source: "iana" }, "application/mipc": { source: "iana" }, "application/missing-blocks+cbor-seq": { source: "iana" }, "application/mmt-aei+xml": { source: "iana", compressible: true, extensions: ["maei"] }, "application/mmt-usd+xml": { source: "iana", compressible: true, extensions: ["musd"] }, "application/mods+xml": { source: "iana", compressible: true, extensions: ["mods"] }, "application/moss-keys": { source: "iana" }, "application/moss-signature": { source: "iana" }, "application/mosskey-data": { source: "iana" }, "application/mosskey-request": { source: "iana" }, "application/mp21": { source: "iana", extensions: ["m21", "mp21"] }, "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] }, "application/mpeg4-generic": { source: "iana" }, "application/mpeg4-iod": { source: "iana" }, "application/mpeg4-iod-xmt": { source: "iana" }, "application/mrb-consumer+xml": { source: "iana", compressible: true }, "application/mrb-publish+xml": { source: "iana", compressible: true }, "application/msc-ivr+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/msc-mixer+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/msword": { source: "iana", compressible: false, extensions: ["doc", "dot"] }, "application/mud+json": { source: "iana", compressible: true }, "application/multipart-core": { source: "iana" }, "application/mxf": { source: "iana", extensions: ["mxf"] }, "application/n-quads": { source: "iana", extensions: ["nq"] }, "application/n-triples": { source: "iana", extensions: ["nt"] }, "application/nasdata": { source: "iana" }, "application/news-checkgroups": { source: "iana", charset: "US-ASCII" }, "application/news-groupinfo": { source: "iana", charset: "US-ASCII" }, "application/news-transmission": { source: "iana" }, "application/nlsml+xml": { source: "iana", compressible: true }, "application/node": { source: "iana", extensions: ["cjs"] }, "application/nss": { source: "iana" }, "application/oauth-authz-req+jwt": { source: "iana" }, "application/oblivious-dns-message": { source: "iana" }, "application/ocsp-request": { source: "iana" }, "application/ocsp-response": { source: "iana" }, "application/octet-stream": { source: "iana", compressible: false, extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] }, "application/oda": { source: "iana", extensions: ["oda"] }, "application/odm+xml": { source: "iana", compressible: true }, "application/odx": { source: "iana" }, "application/oebps-package+xml": { source: "iana", compressible: true, extensions: ["opf"] }, "application/ogg": { source: "iana", compressible: false, extensions: ["ogx"] }, "application/omdoc+xml": { source: "apache", compressible: true, extensions: ["omdoc"] }, "application/onenote": { source: "apache", extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"] }, "application/opc-nodeset+xml": { source: "iana", compressible: true }, "application/oscore": { source: "iana" }, "application/oxps": { source: "iana", extensions: ["oxps"] }, "application/p21": { source: "iana" }, "application/p21+zip": { source: "iana", compressible: false }, "application/p2p-overlay+xml": { source: "iana", compressible: true, extensions: ["relo"] }, "application/parityfec": { source: "iana" }, "application/passport": { source: "iana" }, "application/patch-ops-error+xml": { source: "iana", compressible: true, extensions: ["xer"] }, "application/pdf": { source: "iana", compressible: false, extensions: ["pdf"] }, "application/pdx": { source: "iana" }, "application/pem-certificate-chain": { source: "iana" }, "application/pgp-encrypted": { source: "iana", compressible: false, extensions: ["pgp"] }, "application/pgp-keys": { source: "iana", extensions: ["asc"] }, "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] }, "application/pics-rules": { source: "apache", extensions: ["prf"] }, "application/pidf+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/pidf-diff+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/pkcs10": { source: "iana", extensions: ["p10"] }, "application/pkcs12": { source: "iana" }, "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] }, "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] }, "application/pkcs8": { source: "iana", extensions: ["p8"] }, "application/pkcs8-encrypted": { source: "iana" }, "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] }, "application/pkix-cert": { source: "iana", extensions: ["cer"] }, "application/pkix-crl": { source: "iana", extensions: ["crl"] }, "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] }, "application/pkixcmp": { source: "iana", extensions: ["pki"] }, "application/pls+xml": { source: "iana", compressible: true, extensions: ["pls"] }, "application/poc-settings+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/postscript": { source: "iana", compressible: true, extensions: ["ai", "eps", "ps"] }, "application/ppsp-tracker+json": { source: "iana", compressible: true }, "application/problem+json": { source: "iana", compressible: true }, "application/problem+xml": { source: "iana", compressible: true }, "application/provenance+xml": { source: "iana", compressible: true, extensions: ["provx"] }, "application/prs.alvestrand.titrax-sheet": { source: "iana" }, "application/prs.cww": { source: "iana", extensions: ["cww"] }, "application/prs.cyn": { source: "iana", charset: "7-BIT" }, "application/prs.hpub+zip": { source: "iana", compressible: false }, "application/prs.nprend": { source: "iana" }, "application/prs.plucker": { source: "iana" }, "application/prs.rdf-xml-crypt": { source: "iana" }, "application/prs.xsf+xml": { source: "iana", compressible: true }, "application/pskc+xml": { source: "iana", compressible: true, extensions: ["pskcxml"] }, "application/pvd+json": { source: "iana", compressible: true }, "application/qsig": { source: "iana" }, "application/raml+yaml": { compressible: true, extensions: ["raml"] }, "application/raptorfec": { source: "iana" }, "application/rdap+json": { source: "iana", compressible: true }, "application/rdf+xml": { source: "iana", compressible: true, extensions: ["rdf", "owl"] }, "application/reginfo+xml": { source: "iana", compressible: true, extensions: ["rif"] }, "application/relax-ng-compact-syntax": { source: "iana", extensions: ["rnc"] }, "application/remote-printing": { source: "iana" }, "application/reputon+json": { source: "iana", compressible: true }, "application/resource-lists+xml": { source: "iana", compressible: true, extensions: ["rl"] }, "application/resource-lists-diff+xml": { source: "iana", compressible: true, extensions: ["rld"] }, "application/rfc+xml": { source: "iana", compressible: true }, "application/riscos": { source: "iana" }, "application/rlmi+xml": { source: "iana", compressible: true }, "application/rls-services+xml": { source: "iana", compressible: true, extensions: ["rs"] }, "application/route-apd+xml": { source: "iana", compressible: true, extensions: ["rapd"] }, "application/route-s-tsid+xml": { source: "iana", compressible: true, extensions: ["sls"] }, "application/route-usd+xml": { source: "iana", compressible: true, extensions: ["rusd"] }, "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] }, "application/rpki-manifest": { source: "iana", extensions: ["mft"] }, "application/rpki-publication": { source: "iana" }, "application/rpki-roa": { source: "iana", extensions: ["roa"] }, "application/rpki-updown": { source: "iana" }, "application/rsd+xml": { source: "apache", compressible: true, extensions: ["rsd"] }, "application/rss+xml": { source: "apache", compressible: true, extensions: ["rss"] }, "application/rtf": { source: "iana", compressible: true, extensions: ["rtf"] }, "application/rtploopback": { source: "iana" }, "application/rtx": { source: "iana" }, "application/samlassertion+xml": { source: "iana", compressible: true }, "application/samlmetadata+xml": { source: "iana", compressible: true }, "application/sarif+json": { source: "iana", compressible: true }, "application/sarif-external-properties+json": { source: "iana", compressible: true }, "application/sbe": { source: "iana" }, "application/sbml+xml": { source: "iana", compressible: true, extensions: ["sbml"] }, "application/scaip+xml": { source: "iana", compressible: true }, "application/scim+json": { source: "iana", compressible: true }, "application/scvp-cv-request": { source: "iana", extensions: ["scq"] }, "application/scvp-cv-response": { source: "iana", extensions: ["scs"] }, "application/scvp-vp-request": { source: "iana", extensions: ["spq"] }, "application/scvp-vp-response": { source: "iana", extensions: ["spp"] }, "application/sdp": { source: "iana", extensions: ["sdp"] }, "application/secevent+jwt": { source: "iana" }, "application/senml+cbor": { source: "iana" }, "application/senml+json": { source: "iana", compressible: true }, "application/senml+xml": { source: "iana", compressible: true, extensions: ["senmlx"] }, "application/senml-etch+cbor": { source: "iana" }, "application/senml-etch+json": { source: "iana", compressible: true }, "application/senml-exi": { source: "iana" }, "application/sensml+cbor": { source: "iana" }, "application/sensml+json": { source: "iana", compressible: true }, "application/sensml+xml": { source: "iana", compressible: true, extensions: ["sensmlx"] }, "application/sensml-exi": { source: "iana" }, "application/sep+xml": { source: "iana", compressible: true }, "application/sep-exi": { source: "iana" }, "application/session-info": { source: "iana" }, "application/set-payment": { source: "iana" }, "application/set-payment-initiation": { source: "iana", extensions: ["setpay"] }, "application/set-registration": { source: "iana" }, "application/set-registration-initiation": { source: "iana", extensions: ["setreg"] }, "application/sgml": { source: "iana" }, "application/sgml-open-catalog": { source: "iana" }, "application/shf+xml": { source: "iana", compressible: true, extensions: ["shf"] }, "application/sieve": { source: "iana", extensions: ["siv", "sieve"] }, "application/simple-filter+xml": { source: "iana", compressible: true }, "application/simple-message-summary": { source: "iana" }, "application/simplesymbolcontainer": { source: "iana" }, "application/sipc": { source: "iana" }, "application/slate": { source: "iana" }, "application/smil": { source: "iana" }, "application/smil+xml": { source: "iana", compressible: true, extensions: ["smi", "smil"] }, "application/smpte336m": { source: "iana" }, "application/soap+fastinfoset": { source: "iana" }, "application/soap+xml": { source: "iana", compressible: true }, "application/sparql-query": { source: "iana", extensions: ["rq"] }, "application/sparql-results+xml": { source: "iana", compressible: true, extensions: ["srx"] }, "application/spdx+json": { source: "iana", compressible: true }, "application/spirits-event+xml": { source: "iana", compressible: true }, "application/sql": { source: "iana" }, "application/srgs": { source: "iana", extensions: ["gram"] }, "application/srgs+xml": { source: "iana", compressible: true, extensions: ["grxml"] }, "application/sru+xml": { source: "iana", compressible: true, extensions: ["sru"] }, "application/ssdl+xml": { source: "apache", compressible: true, extensions: ["ssdl"] }, "application/ssml+xml": { source: "iana", compressible: true, extensions: ["ssml"] }, "application/stix+json": { source: "iana", compressible: true }, "application/swid+xml": { source: "iana", compressible: true, extensions: ["swidtag"] }, "application/tamp-apex-update": { source: "iana" }, "application/tamp-apex-update-confirm": { source: "iana" }, "application/tamp-community-update": { source: "iana" }, "application/tamp-community-update-confirm": { source: "iana" }, "application/tamp-error": { source: "iana" }, "application/tamp-sequence-adjust": { source: "iana" }, "application/tamp-sequence-adjust-confirm": { source: "iana" }, "application/tamp-status-query": { source: "iana" }, "application/tamp-status-response": { source: "iana" }, "application/tamp-update": { source: "iana" }, "application/tamp-update-confirm": { source: "iana" }, "application/tar": { compressible: true }, "application/taxii+json": { source: "iana", compressible: true }, "application/td+json": { source: "iana", compressible: true }, "application/tei+xml": { source: "iana", compressible: true, extensions: ["tei", "teicorpus"] }, "application/tetra_isi": { source: "iana" }, "application/thraud+xml": { source: "iana", compressible: true, extensions: ["tfi"] }, "application/timestamp-query": { source: "iana" }, "application/timestamp-reply": { source: "iana" }, "application/timestamped-data": { source: "iana", extensions: ["tsd"] }, "application/tlsrpt+gzip": { source: "iana" }, "application/tlsrpt+json": { source: "iana", compressible: true }, "application/tnauthlist": { source: "iana" }, "application/token-introspection+jwt": { source: "iana" }, "application/toml": { compressible: true, extensions: ["toml"] }, "application/trickle-ice-sdpfrag": { source: "iana" }, "application/trig": { source: "iana", extensions: ["trig"] }, "application/ttml+xml": { source: "iana", compressible: true, extensions: ["ttml"] }, "application/tve-trigger": { source: "iana" }, "application/tzif": { source: "iana" }, "application/tzif-leap": { source: "iana" }, "application/ubjson": { compressible: false, extensions: ["ubj"] }, "application/ulpfec": { source: "iana" }, "application/urc-grpsheet+xml": { source: "iana", compressible: true }, "application/urc-ressheet+xml": { source: "iana", compressible: true, extensions: ["rsheet"] }, "application/urc-targetdesc+xml": { source: "iana", compressible: true, extensions: ["td"] }, "application/urc-uisocketdesc+xml": { source: "iana", compressible: true }, "application/vcard+json": { source: "iana", compressible: true }, "application/vcard+xml": { source: "iana", compressible: true }, "application/vemmi": { source: "iana" }, "application/vividence.scriptfile": { source: "apache" }, "application/vnd.1000minds.decision-model+xml": { source: "iana", compressible: true, extensions: ["1km"] }, "application/vnd.3gpp-prose+xml": { source: "iana", compressible: true }, "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: true }, "application/vnd.3gpp-v2x-local-service-information": { source: "iana" }, "application/vnd.3gpp.5gnas": { source: "iana" }, "application/vnd.3gpp.access-transfer-events+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.gtpc": { source: "iana" }, "application/vnd.3gpp.interworking-data": { source: "iana" }, "application/vnd.3gpp.lpp": { source: "iana" }, "application/vnd.3gpp.mc-signalling-ear": { source: "iana" }, "application/vnd.3gpp.mcdata-affiliation-command+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcdata-payload": { source: "iana" }, "application/vnd.3gpp.mcdata-service-config+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcdata-signalling": { source: "iana" }, "application/vnd.3gpp.mcdata-ue-config+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcdata-user-profile+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-affiliation-command+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-floor-request+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-location-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-service-config+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-ue-config+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-ue-init-config+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcptt-user-profile+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-affiliation-command+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-affiliation-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-location-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-service-config+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-transmission-request+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-ue-config+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mcvideo-user-profile+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.ngap": { source: "iana" }, "application/vnd.3gpp.pfcp": { source: "iana" }, "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] }, "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] }, "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] }, "application/vnd.3gpp.s1ap": { source: "iana" }, "application/vnd.3gpp.sms": { source: "iana" }, "application/vnd.3gpp.sms+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.state-and-event-info+xml": { source: "iana", compressible: true }, "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: true }, "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: true }, "application/vnd.3gpp2.sms": { source: "iana" }, "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] }, "application/vnd.3lightssoftware.imagescal": { source: "iana" }, "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] }, "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] }, "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] }, "application/vnd.acucobol": { source: "iana", extensions: ["acu"] }, "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] }, "application/vnd.adobe.air-application-installer-package+zip": { source: "apache", compressible: false, extensions: ["air"] }, "application/vnd.adobe.flash.movie": { source: "iana" }, "application/vnd.adobe.formscentral.fcdt": { source: "iana", extensions: ["fcdt"] }, "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] }, "application/vnd.adobe.partial-upload": { source: "iana" }, "application/vnd.adobe.xdp+xml": { source: "iana", compressible: true, extensions: ["xdp"] }, "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] }, "application/vnd.aether.imp": { source: "iana" }, "application/vnd.afpc.afplinedata": { source: "iana" }, "application/vnd.afpc.afplinedata-pagedef": { source: "iana" }, "application/vnd.afpc.cmoca-cmresource": { source: "iana" }, "application/vnd.afpc.foca-charset": { source: "iana" }, "application/vnd.afpc.foca-codedfont": { source: "iana" }, "application/vnd.afpc.foca-codepage": { source: "iana" }, "application/vnd.afpc.modca": { source: "iana" }, "application/vnd.afpc.modca-cmtable": { source: "iana" }, "application/vnd.afpc.modca-formdef": { source: "iana" }, "application/vnd.afpc.modca-mediummap": { source: "iana" }, "application/vnd.afpc.modca-objectcontainer": { source: "iana" }, "application/vnd.afpc.modca-overlay": { source: "iana" }, "application/vnd.afpc.modca-pagesegment": { source: "iana" }, "application/vnd.age": { source: "iana", extensions: ["age"] }, "application/vnd.ah-barcode": { source: "iana" }, "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] }, "application/vnd.airzip.filesecure.azf": { source: "iana", extensions: ["azf"] }, "application/vnd.airzip.filesecure.azs": { source: "iana", extensions: ["azs"] }, "application/vnd.amadeus+json": { source: "iana", compressible: true }, "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] }, "application/vnd.amazon.mobi8-ebook": { source: "iana" }, "application/vnd.americandynamics.acc": { source: "iana", extensions: ["acc"] }, "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] }, "application/vnd.amundsen.maze+xml": { source: "iana", compressible: true }, "application/vnd.android.ota": { source: "iana" }, "application/vnd.android.package-archive": { source: "apache", compressible: false, extensions: ["apk"] }, "application/vnd.anki": { source: "iana" }, "application/vnd.anser-web-certificate-issue-initiation": { source: "iana", extensions: ["cii"] }, "application/vnd.anser-web-funds-transfer-initiation": { source: "apache", extensions: ["fti"] }, "application/vnd.antix.game-component": { source: "iana", extensions: ["atx"] }, "application/vnd.apache.arrow.file": { source: "iana" }, "application/vnd.apache.arrow.stream": { source: "iana" }, "application/vnd.apache.thrift.binary": { source: "iana" }, "application/vnd.apache.thrift.compact": { source: "iana" }, "application/vnd.apache.thrift.json": { source: "iana" }, "application/vnd.api+json": { source: "iana", compressible: true }, "application/vnd.aplextor.warrp+json": { source: "iana", compressible: true }, "application/vnd.apothekende.reservation+json": { source: "iana", compressible: true }, "application/vnd.apple.installer+xml": { source: "iana", compressible: true, extensions: ["mpkg"] }, "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] }, "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] }, "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] }, "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] }, "application/vnd.apple.pkpass": { compressible: false, extensions: ["pkpass"] }, "application/vnd.arastra.swi": { source: "iana" }, "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] }, "application/vnd.artisan+json": { source: "iana", compressible: true }, "application/vnd.artsquare": { source: "iana" }, "application/vnd.astraea-software.iota": { source: "iana", extensions: ["iota"] }, "application/vnd.audiograph": { source: "iana", extensions: ["aep"] }, "application/vnd.autopackage": { source: "iana" }, "application/vnd.avalon+json": { source: "iana", compressible: true }, "application/vnd.avistar+xml": { source: "iana", compressible: true }, "application/vnd.balsamiq.bmml+xml": { source: "iana", compressible: true, extensions: ["bmml"] }, "application/vnd.balsamiq.bmpr": { source: "iana" }, "application/vnd.banana-accounting": { source: "iana" }, "application/vnd.bbf.usp.error": { source: "iana" }, "application/vnd.bbf.usp.msg": { source: "iana" }, "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: true }, "application/vnd.bekitzur-stech+json": { source: "iana", compressible: true }, "application/vnd.bint.med-content": { source: "iana" }, "application/vnd.biopax.rdf+xml": { source: "iana", compressible: true }, "application/vnd.blink-idb-value-wrapper": { source: "iana" }, "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] }, "application/vnd.bluetooth.ep.oob": { source: "iana" }, "application/vnd.bluetooth.le.oob": { source: "iana" }, "application/vnd.bmi": { source: "iana", extensions: ["bmi"] }, "application/vnd.bpf": { source: "iana" }, "application/vnd.bpf3": { source: "iana" }, "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] }, "application/vnd.byu.uapi+json": { source: "iana", compressible: true }, "application/vnd.cab-jscript": { source: "iana" }, "application/vnd.canon-cpdl": { source: "iana" }, "application/vnd.canon-lips": { source: "iana" }, "application/vnd.capasystems-pg+json": { source: "iana", compressible: true }, "application/vnd.cendio.thinlinc.clientconf": { source: "iana" }, "application/vnd.century-systems.tcp_stream": { source: "iana" }, "application/vnd.chemdraw+xml": { source: "iana", compressible: true, extensions: ["cdxml"] }, "application/vnd.chess-pgn": { source: "iana" }, "application/vnd.chipnuts.karaoke-mmd": { source: "iana", extensions: ["mmd"] }, "application/vnd.ciedi": { source: "iana" }, "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] }, "application/vnd.cirpack.isdn-ext": { source: "iana" }, "application/vnd.citationstyles.style+xml": { source: "iana", compressible: true, extensions: ["csl"] }, "application/vnd.claymore": { source: "iana", extensions: ["cla"] }, "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] }, "application/vnd.clonk.c4group": { source: "iana", extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"] }, "application/vnd.cluetrust.cartomobile-config": { source: "iana", extensions: ["c11amc"] }, "application/vnd.cluetrust.cartomobile-config-pkg": { source: "iana", extensions: ["c11amz"] }, "application/vnd.coffeescript": { source: "iana" }, "application/vnd.collabio.xodocuments.document": { source: "iana" }, "application/vnd.collabio.xodocuments.document-template": { source: "iana" }, "application/vnd.collabio.xodocuments.presentation": { source: "iana" }, "application/vnd.collabio.xodocuments.presentation-template": { source: "iana" }, "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" }, "application/vnd.collabio.xodocuments.spreadsheet-template": { source: "iana" }, "application/vnd.collection+json": { source: "iana", compressible: true }, "application/vnd.collection.doc+json": { source: "iana", compressible: true }, "application/vnd.collection.next+json": { source: "iana", compressible: true }, "application/vnd.comicbook+zip": { source: "iana", compressible: false }, "application/vnd.comicbook-rar": { source: "iana" }, "application/vnd.commerce-battelle": { source: "iana" }, "application/vnd.commonspace": { source: "iana", extensions: ["csp"] }, "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] }, "application/vnd.coreos.ignition+json": { source: "iana", compressible: true }, "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] }, "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] }, "application/vnd.crick.clicker.keyboard": { source: "iana", extensions: ["clkk"] }, "application/vnd.crick.clicker.palette": { source: "iana", extensions: ["clkp"] }, "application/vnd.crick.clicker.template": { source: "iana", extensions: ["clkt"] }, "application/vnd.crick.clicker.wordbank": { source: "iana", extensions: ["clkw"] }, "application/vnd.criticaltools.wbs+xml": { source: "iana", compressible: true, extensions: ["wbs"] }, "application/vnd.cryptii.pipe+json": { source: "iana", compressible: true }, "application/vnd.crypto-shade-file": { source: "iana" }, "application/vnd.cryptomator.encrypted": { source: "iana" }, "application/vnd.cryptomator.vault": { source: "iana" }, "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] }, "application/vnd.ctct.ws+xml": { source: "iana", compressible: true }, "application/vnd.cups-pdf": { source: "iana" }, "application/vnd.cups-postscript": { source: "iana" }, "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] }, "application/vnd.cups-raster": { source: "iana" }, "application/vnd.cups-raw": { source: "iana" }, "application/vnd.curl": { source: "iana" }, "application/vnd.curl.car": { source: "apache", extensions: ["car"] }, "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] }, "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: true }, "application/vnd.cybank": { source: "iana" }, "application/vnd.cyclonedx+json": { source: "iana", compressible: true }, "application/vnd.cyclonedx+xml": { source: "iana", compressible: true }, "application/vnd.d2l.coursepackage1p0+zip": { source: "iana", compressible: false }, "application/vnd.d3m-dataset": { source: "iana" }, "application/vnd.d3m-problem": { source: "iana" }, "application/vnd.dart": { source: "iana", compressible: true, extensions: ["dart"] }, "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] }, "application/vnd.datapackage+json": { source: "iana", compressible: true }, "application/vnd.dataresource+json": { source: "iana", compressible: true }, "application/vnd.dbf": { source: "iana", extensions: ["dbf"] }, "application/vnd.debian.binary-package": { source: "iana" }, "application/vnd.dece.data": { source: "iana", extensions: ["uvf", "uvvf", "uvd", "uvvd"] }, "application/vnd.dece.ttml+xml": { source: "iana", compressible: true, extensions: ["uvt", "uvvt"] }, "application/vnd.dece.unspecified": { source: "iana", extensions: ["uvx", "uvvx"] }, "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] }, "application/vnd.denovo.fcselayout-link": { source: "iana", extensions: ["fe_launch"] }, "application/vnd.desmume.movie": { source: "iana" }, "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" }, "application/vnd.dm.delegation+xml": { source: "iana", compressible: true }, "application/vnd.dna": { source: "iana", extensions: ["dna"] }, "application/vnd.document+json": { source: "iana", compressible: true }, "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] }, "application/vnd.dolby.mobile.1": { source: "iana" }, "application/vnd.dolby.mobile.2": { source: "iana" }, "application/vnd.doremir.scorecloud-binary-document": { source: "iana" }, "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] }, "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] }, "application/vnd.drive+json": { source: "iana", compressible: true }, "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] }, "application/vnd.dtg.local": { source: "iana" }, "application/vnd.dtg.local.flash": { source: "iana" }, "application/vnd.dtg.local.html": { source: "iana" }, "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] }, "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: true }, "application/vnd.dvb.dvbj": { source: "iana" }, "application/vnd.dvb.esgcontainer": { source: "iana" }, "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" }, "application/vnd.dvb.ipdcesgaccess": { source: "iana" }, "application/vnd.dvb.ipdcesgaccess2": { source: "iana" }, "application/vnd.dvb.ipdcesgpdd": { source: "iana" }, "application/vnd.dvb.ipdcroaming": { source: "iana" }, "application/vnd.dvb.iptv.alfec-base": { source: "iana" }, "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" }, "application/vnd.dvb.notif-aggregate-root+xml": { source: "iana", compressible: true }, "application/vnd.dvb.notif-container+xml": { source: "iana", compressible: true }, "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: true }, "application/vnd.dvb.notif-ia-msglist+xml": { source: "iana", compressible: true }, "application/vnd.dvb.notif-ia-registration-request+xml": { source: "iana", compressible: true }, "application/vnd.dvb.notif-ia-registration-response+xml": { source: "iana", compressible: true }, "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: true }, "application/vnd.dvb.pfr": { source: "iana" }, "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] }, "application/vnd.dxr": { source: "iana" }, "application/vnd.dynageo": { source: "iana", extensions: ["geo"] }, "application/vnd.dzr": { source: "iana" }, "application/vnd.easykaraoke.cdgdownload": { source: "iana" }, "application/vnd.ecdis-update": { source: "iana" }, "application/vnd.ecip.rlp": { source: "iana" }, "application/vnd.eclipse.ditto+json": { source: "iana", compressible: true }, "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] }, "application/vnd.ecowin.filerequest": { source: "iana" }, "application/vnd.ecowin.fileupdate": { source: "iana" }, "application/vnd.ecowin.series": { source: "iana" }, "application/vnd.ecowin.seriesrequest": { source: "iana" }, "application/vnd.ecowin.seriesupdate": { source: "iana" }, "application/vnd.efi.img": { source: "iana" }, "application/vnd.efi.iso": { source: "iana" }, "application/vnd.emclient.accessrequest+xml": { source: "iana", compressible: true }, "application/vnd.enliven": { source: "iana", extensions: ["nml"] }, "application/vnd.enphase.envoy": { source: "iana" }, "application/vnd.eprints.data+xml": { source: "iana", compressible: true }, "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] }, "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] }, "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] }, "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] }, "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] }, "application/vnd.ericsson.quickcall": { source: "iana" }, "application/vnd.espass-espass+zip": { source: "iana", compressible: false }, "application/vnd.eszigno3+xml": { source: "iana", compressible: true, extensions: ["es3", "et3"] }, "application/vnd.etsi.aoc+xml": { source: "iana", compressible: true }, "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: false }, "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: false }, "application/vnd.etsi.cug+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvdiscovery+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: true }, "application/vnd.etsi.iptvueprofile+xml": { source: "iana", compressible: true }, "application/vnd.etsi.mcid+xml": { source: "iana", compressible: true }, "application/vnd.etsi.mheg5": { source: "iana" }, "application/vnd.etsi.overload-control-policy-dataset+xml": { source: "iana", compressible: true }, "application/vnd.etsi.pstn+xml": { source: "iana", compressible: true }, "application/vnd.etsi.sci+xml": { source: "iana", compressible: true }, "application/vnd.etsi.simservs+xml": { source: "iana", compressible: true }, "application/vnd.etsi.timestamp-token": { source: "iana" }, "application/vnd.etsi.tsl+xml": { source: "iana", compressible: true }, "application/vnd.etsi.tsl.der": { source: "iana" }, "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: true }, "application/vnd.eudora.data": { source: "iana" }, "application/vnd.evolv.ecig.profile": { source: "iana" }, "application/vnd.evolv.ecig.settings": { source: "iana" }, "application/vnd.evolv.ecig.theme": { source: "iana" }, "application/vnd.exstream-empower+zip": { source: "iana", compressible: false }, "application/vnd.exstream-package": { source: "iana" }, "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] }, "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] }, "application/vnd.f-secure.mobile": { source: "iana" }, "application/vnd.familysearch.gedcom+zip": { source: "iana", compressible: false }, "application/vnd.fastcopy-disk-image": { source: "iana" }, "application/vnd.fdf": { source: "iana", extensions: ["fdf"] }, "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] }, "application/vnd.fdsn.seed": { source: "iana", extensions: ["seed", "dataless"] }, "application/vnd.ffsns": { source: "iana" }, "application/vnd.ficlab.flb+zip": { source: "iana", compressible: false }, "application/vnd.filmit.zfc": { source: "iana" }, "application/vnd.fints": { source: "iana" }, "application/vnd.firemonkeys.cloudcell": { source: "iana" }, "application/vnd.flographit": { source: "iana", extensions: ["gph"] }, "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] }, "application/vnd.font-fontforge-sfd": { source: "iana" }, "application/vnd.framemaker": { source: "iana", extensions: ["fm", "frame", "maker", "book"] }, "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] }, "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] }, "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] }, "application/vnd.fujifilm.fb.docuworks": { source: "iana" }, "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" }, "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" }, "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: true }, "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] }, "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] }, "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] }, "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] }, "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] }, "application/vnd.fujixerox.art-ex": { source: "iana" }, "application/vnd.fujixerox.art4": { source: "iana" }, "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] }, "application/vnd.fujixerox.docuworks": { source: "iana", extensions: ["xdw"] }, "application/vnd.fujixerox.docuworks.binder": { source: "iana", extensions: ["xbd"] }, "application/vnd.fujixerox.docuworks.container": { source: "iana" }, "application/vnd.fujixerox.hbpl": { source: "iana" }, "application/vnd.fut-misnet": { source: "iana" }, "application/vnd.futoin+cbor": { source: "iana" }, "application/vnd.futoin+json": { source: "iana", compressible: true }, "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] }, "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] }, "application/vnd.gentics.grd+json": { source: "iana", compressible: true }, "application/vnd.geo+json": { source: "iana", compressible: true }, "application/vnd.geocube+xml": { source: "iana", compressible: true }, "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] }, "application/vnd.geogebra.slides": { source: "iana" }, "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] }, "application/vnd.geometry-explorer": { source: "iana", extensions: ["gex", "gre"] }, "application/vnd.geonext": { source: "iana", extensions: ["gxt"] }, "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] }, "application/vnd.geospace": { source: "iana", extensions: ["g3w"] }, "application/vnd.gerber": { source: "iana" }, "application/vnd.globalplatform.card-content-mgt": { source: "iana" }, "application/vnd.globalplatform.card-content-mgt-response": { source: "iana" }, "application/vnd.gmx": { source: "iana", extensions: ["gmx"] }, "application/vnd.google-apps.document": { compressible: false, extensions: ["gdoc"] }, "application/vnd.google-apps.presentation": { compressible: false, extensions: ["gslides"] }, "application/vnd.google-apps.spreadsheet": { compressible: false, extensions: ["gsheet"] }, "application/vnd.google-earth.kml+xml": { source: "iana", compressible: true, extensions: ["kml"] }, "application/vnd.google-earth.kmz": { source: "iana", compressible: false, extensions: ["kmz"] }, "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: true }, "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: false }, "application/vnd.gov.sk.xmldatacontainer+xml": { source: "iana", compressible: true }, "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] }, "application/vnd.gridmp": { source: "iana" }, "application/vnd.groove-account": { source: "iana", extensions: ["gac"] }, "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] }, "application/vnd.groove-identity-message": { source: "iana", extensions: ["gim"] }, "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] }, "application/vnd.groove-tool-message": { source: "iana", extensions: ["gtm"] }, "application/vnd.groove-tool-template": { source: "iana", extensions: ["tpl"] }, "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] }, "application/vnd.hal+json": { source: "iana", compressible: true }, "application/vnd.hal+xml": { source: "iana", compressible: true, extensions: ["hal"] }, "application/vnd.handheld-entertainment+xml": { source: "iana", compressible: true, extensions: ["zmm"] }, "application/vnd.hbci": { source: "iana", extensions: ["hbci"] }, "application/vnd.hc+json": { source: "iana", compressible: true }, "application/vnd.hcl-bireports": { source: "iana" }, "application/vnd.hdt": { source: "iana" }, "application/vnd.heroku+json": { source: "iana", compressible: true }, "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] }, "application/vnd.hl7cda+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/vnd.hl7v2+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] }, "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] }, "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] }, "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] }, "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] }, "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] }, "application/vnd.httphone": { source: "iana" }, "application/vnd.hydrostatix.sof-data": { source: "iana", extensions: ["sfd-hdstx"] }, "application/vnd.hyper+json": { source: "iana", compressible: true }, "application/vnd.hyper-item+json": { source: "iana", compressible: true }, "application/vnd.hyperdrive+json": { source: "iana", compressible: true }, "application/vnd.hzn-3d-crossword": { source: "iana" }, "application/vnd.ibm.afplinedata": { source: "iana" }, "application/vnd.ibm.electronic-media": { source: "iana" }, "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] }, "application/vnd.ibm.modcap": { source: "iana", extensions: ["afp", "listafp", "list3820"] }, "application/vnd.ibm.rights-management": { source: "iana", extensions: ["irm"] }, "application/vnd.ibm.secure-container": { source: "iana", extensions: ["sc"] }, "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] }, "application/vnd.ieee.1905": { source: "iana" }, "application/vnd.igloader": { source: "iana", extensions: ["igl"] }, "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: false }, "application/vnd.imagemeter.image+zip": { source: "iana", compressible: false }, "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] }, "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] }, "application/vnd.ims.imsccv1p1": { source: "iana" }, "application/vnd.ims.imsccv1p2": { source: "iana" }, "application/vnd.ims.imsccv1p3": { source: "iana" }, "application/vnd.ims.lis.v2.result+json": { source: "iana", compressible: true }, "application/vnd.ims.lti.v2.toolconsumerprofile+json": { source: "iana", compressible: true }, "application/vnd.ims.lti.v2.toolproxy+json": { source: "iana", compressible: true }, "application/vnd.ims.lti.v2.toolproxy.id+json": { source: "iana", compressible: true }, "application/vnd.ims.lti.v2.toolsettings+json": { source: "iana", compressible: true }, "application/vnd.ims.lti.v2.toolsettings.simple+json": { source: "iana", compressible: true }, "application/vnd.informedcontrol.rms+xml": { source: "iana", compressible: true }, "application/vnd.informix-visionary": { source: "iana" }, "application/vnd.infotech.project": { source: "iana" }, "application/vnd.infotech.project+xml": { source: "iana", compressible: true }, "application/vnd.innopath.wamp.notification": { source: "iana" }, "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] }, "application/vnd.intercon.formnet": { source: "iana", extensions: ["xpw", "xpx"] }, "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] }, "application/vnd.intertrust.digibox": { source: "iana" }, "application/vnd.intertrust.nncp": { source: "iana" }, "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] }, "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] }, "application/vnd.iptc.g2.catalogitem+xml": { source: "iana", compressible: true }, "application/vnd.iptc.g2.conceptitem+xml": { source: "iana", compressible: true }, "application/vnd.iptc.g2.knowledgeitem+xml": { source: "iana", compressible: true }, "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: true }, "application/vnd.iptc.g2.newsmessage+xml": { source: "iana", compressible: true }, "application/vnd.iptc.g2.packageitem+xml": { source: "iana", compressible: true }, "application/vnd.iptc.g2.planningitem+xml": { source: "iana", compressible: true }, "application/vnd.ipunplugged.rcprofile": { source: "iana", extensions: ["rcprofile"] }, "application/vnd.irepository.package+xml": { source: "iana", compressible: true, extensions: ["irp"] }, "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] }, "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] }, "application/vnd.iso11783-10+zip": { source: "iana", compressible: false }, "application/vnd.jam": { source: "iana", extensions: ["jam"] }, "application/vnd.japannet-directory-service": { source: "iana" }, "application/vnd.japannet-jpnstore-wakeup": { source: "iana" }, "application/vnd.japannet-payment-wakeup": { source: "iana" }, "application/vnd.japannet-registration": { source: "iana" }, "application/vnd.japannet-registration-wakeup": { source: "iana" }, "application/vnd.japannet-setstore-wakeup": { source: "iana" }, "application/vnd.japannet-verification": { source: "iana" }, "application/vnd.japannet-verification-wakeup": { source: "iana" }, "application/vnd.jcp.javame.midlet-rms": { source: "iana", extensions: ["rms"] }, "application/vnd.jisp": { source: "iana", extensions: ["jisp"] }, "application/vnd.joost.joda-archive": { source: "iana", extensions: ["joda"] }, "application/vnd.jsk.isdn-ngn": { source: "iana" }, "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] }, "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] }, "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] }, "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] }, "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] }, "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] }, "application/vnd.kde.kpresenter": { source: "iana", extensions: ["kpr", "kpt"] }, "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] }, "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] }, "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] }, "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] }, "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] }, "application/vnd.koan": { source: "iana", extensions: ["skp", "skd", "skt", "skm"] }, "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] }, "application/vnd.las": { source: "iana" }, "application/vnd.las.las+json": { source: "iana", compressible: true }, "application/vnd.las.las+xml": { source: "iana", compressible: true, extensions: ["lasxml"] }, "application/vnd.laszip": { source: "iana" }, "application/vnd.leap+json": { source: "iana", compressible: true }, "application/vnd.liberty-request+xml": { source: "iana", compressible: true }, "application/vnd.llamagraphics.life-balance.desktop": { source: "iana", extensions: ["lbd"] }, "application/vnd.llamagraphics.life-balance.exchange+xml": { source: "iana", compressible: true, extensions: ["lbe"] }, "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: false }, "application/vnd.loom": { source: "iana" }, "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] }, "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] }, "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] }, "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] }, "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] }, "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] }, "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] }, "application/vnd.macports.portpkg": { source: "iana", extensions: ["portpkg"] }, "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] }, "application/vnd.marlin.drm.actiontoken+xml": { source: "iana", compressible: true }, "application/vnd.marlin.drm.conftoken+xml": { source: "iana", compressible: true }, "application/vnd.marlin.drm.license+xml": { source: "iana", compressible: true }, "application/vnd.marlin.drm.mdcf": { source: "iana" }, "application/vnd.mason+json": { source: "iana", compressible: true }, "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: false }, "application/vnd.maxmind.maxmind-db": { source: "iana" }, "application/vnd.mcd": { source: "iana", extensions: ["mcd"] }, "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] }, "application/vnd.mediastation.cdkey": { source: "iana", extensions: ["cdkey"] }, "application/vnd.meridian-slingshot": { source: "iana" }, "application/vnd.mfer": { source: "iana", extensions: ["mwf"] }, "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] }, "application/vnd.micro+json": { source: "iana", compressible: true }, "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] }, "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] }, "application/vnd.microsoft.portable-executable": { source: "iana" }, "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" }, "application/vnd.miele+json": { source: "iana", compressible: true }, "application/vnd.mif": { source: "iana", extensions: ["mif"] }, "application/vnd.minisoft-hp3000-save": { source: "iana" }, "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" }, "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] }, "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] }, "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] }, "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] }, "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] }, "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] }, "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] }, "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] }, "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] }, "application/vnd.motorola.flexsuite": { source: "iana" }, "application/vnd.motorola.flexsuite.adsi": { source: "iana" }, "application/vnd.motorola.flexsuite.fis": { source: "iana" }, "application/vnd.motorola.flexsuite.gotap": { source: "iana" }, "application/vnd.motorola.flexsuite.kmr": { source: "iana" }, "application/vnd.motorola.flexsuite.ttc": { source: "iana" }, "application/vnd.motorola.flexsuite.wem": { source: "iana" }, "application/vnd.motorola.iprm": { source: "iana" }, "application/vnd.mozilla.xul+xml": { source: "iana", compressible: true, extensions: ["xul"] }, "application/vnd.ms-3mfdocument": { source: "iana" }, "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] }, "application/vnd.ms-asf": { source: "iana" }, "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] }, "application/vnd.ms-color.iccprofile": { source: "apache" }, "application/vnd.ms-excel": { source: "iana", compressible: false, extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] }, "application/vnd.ms-excel.addin.macroenabled.12": { source: "iana", extensions: ["xlam"] }, "application/vnd.ms-excel.sheet.binary.macroenabled.12": { source: "iana", extensions: ["xlsb"] }, "application/vnd.ms-excel.sheet.macroenabled.12": { source: "iana", extensions: ["xlsm"] }, "application/vnd.ms-excel.template.macroenabled.12": { source: "iana", extensions: ["xltm"] }, "application/vnd.ms-fontobject": { source: "iana", compressible: true, extensions: ["eot"] }, "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] }, "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] }, "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] }, "application/vnd.ms-office.activex+xml": { source: "iana", compressible: true }, "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] }, "application/vnd.ms-opentype": { source: "apache", compressible: true }, "application/vnd.ms-outlook": { compressible: false, extensions: ["msg"] }, "application/vnd.ms-package.obfuscated-opentype": { source: "apache" }, "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] }, "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] }, "application/vnd.ms-playready.initiator+xml": { source: "iana", compressible: true }, "application/vnd.ms-powerpoint": { source: "iana", compressible: false, extensions: ["ppt", "pps", "pot"] }, "application/vnd.ms-powerpoint.addin.macroenabled.12": { source: "iana", extensions: ["ppam"] }, "application/vnd.ms-powerpoint.presentation.macroenabled.12": { source: "iana", extensions: ["pptm"] }, "application/vnd.ms-powerpoint.slide.macroenabled.12": { source: "iana", extensions: ["sldm"] }, "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { source: "iana", extensions: ["ppsm"] }, "application/vnd.ms-powerpoint.template.macroenabled.12": { source: "iana", extensions: ["potm"] }, "application/vnd.ms-printdevicecapabilities+xml": { source: "iana", compressible: true }, "application/vnd.ms-printing.printticket+xml": { source: "apache", compressible: true }, "application/vnd.ms-printschematicket+xml": { source: "iana", compressible: true }, "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] }, "application/vnd.ms-tnef": { source: "iana" }, "application/vnd.ms-windows.devicepairing": { source: "iana" }, "application/vnd.ms-windows.nwprinting.oob": { source: "iana" }, "application/vnd.ms-windows.printerpairing": { source: "iana" }, "application/vnd.ms-windows.wsd.oob": { source: "iana" }, "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" }, "application/vnd.ms-wmdrm.lic-resp": { source: "iana" }, "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" }, "application/vnd.ms-wmdrm.meter-resp": { source: "iana" }, "application/vnd.ms-word.document.macroenabled.12": { source: "iana", extensions: ["docm"] }, "application/vnd.ms-word.template.macroenabled.12": { source: "iana", extensions: ["dotm"] }, "application/vnd.ms-works": { source: "iana", extensions: ["wps", "wks", "wcm", "wdb"] }, "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] }, "application/vnd.ms-xpsdocument": { source: "iana", compressible: false, extensions: ["xps"] }, "application/vnd.msa-disk-image": { source: "iana" }, "application/vnd.mseq": { source: "iana", extensions: ["mseq"] }, "application/vnd.msign": { source: "iana" }, "application/vnd.multiad.creator": { source: "iana" }, "application/vnd.multiad.creator.cif": { source: "iana" }, "application/vnd.music-niff": { source: "iana" }, "application/vnd.musician": { source: "iana", extensions: ["mus"] }, "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] }, "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] }, "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: true }, "application/vnd.ncd.control": { source: "iana" }, "application/vnd.ncd.reference": { source: "iana" }, "application/vnd.nearst.inv+json": { source: "iana", compressible: true }, "application/vnd.nebumind.line": { source: "iana" }, "application/vnd.nervana": { source: "iana" }, "application/vnd.netfpx": { source: "iana" }, "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] }, "application/vnd.nimn": { source: "iana" }, "application/vnd.nintendo.nitro.rom": { source: "iana" }, "application/vnd.nintendo.snes.rom": { source: "iana" }, "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] }, "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] }, "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] }, "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] }, "application/vnd.nokia.catalogs": { source: "iana" }, "application/vnd.nokia.conml+wbxml": { source: "iana" }, "application/vnd.nokia.conml+xml": { source: "iana", compressible: true }, "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: true }, "application/vnd.nokia.isds-radio-presets": { source: "iana" }, "application/vnd.nokia.landmark+wbxml": { source: "iana" }, "application/vnd.nokia.landmark+xml": { source: "iana", compressible: true }, "application/vnd.nokia.landmarkcollection+xml": { source: "iana", compressible: true }, "application/vnd.nokia.n-gage.ac+xml": { source: "iana", compressible: true, extensions: ["ac"] }, "application/vnd.nokia.n-gage.data": { source: "iana", extensions: ["ngdat"] }, "application/vnd.nokia.n-gage.symbian.install": { source: "iana", extensions: ["n-gage"] }, "application/vnd.nokia.ncd": { source: "iana" }, "application/vnd.nokia.pcd+wbxml": { source: "iana" }, "application/vnd.nokia.pcd+xml": { source: "iana", compressible: true }, "application/vnd.nokia.radio-preset": { source: "iana", extensions: ["rpst"] }, "application/vnd.nokia.radio-presets": { source: "iana", extensions: ["rpss"] }, "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] }, "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] }, "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] }, "application/vnd.ntt-local.content-share": { source: "iana" }, "application/vnd.ntt-local.file-transfer": { source: "iana" }, "application/vnd.ntt-local.ogw_remote-access": { source: "iana" }, "application/vnd.ntt-local.sip-ta_remote": { source: "iana" }, "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" }, "application/vnd.oasis.opendocument.chart": { source: "iana", extensions: ["odc"] }, "application/vnd.oasis.opendocument.chart-template": { source: "iana", extensions: ["otc"] }, "application/vnd.oasis.opendocument.database": { source: "iana", extensions: ["odb"] }, "application/vnd.oasis.opendocument.formula": { source: "iana", extensions: ["odf"] }, "application/vnd.oasis.opendocument.formula-template": { source: "iana", extensions: ["odft"] }, "application/vnd.oasis.opendocument.graphics": { source: "iana", compressible: false, extensions: ["odg"] }, "application/vnd.oasis.opendocument.graphics-template": { source: "iana", extensions: ["otg"] }, "application/vnd.oasis.opendocument.image": { source: "iana", extensions: ["odi"] }, "application/vnd.oasis.opendocument.image-template": { source: "iana", extensions: ["oti"] }, "application/vnd.oasis.opendocument.presentation": { source: "iana", compressible: false, extensions: ["odp"] }, "application/vnd.oasis.opendocument.presentation-template": { source: "iana", extensions: ["otp"] }, "application/vnd.oasis.opendocument.spreadsheet": { source: "iana", compressible: false, extensions: ["ods"] }, "application/vnd.oasis.opendocument.spreadsheet-template": { source: "iana", extensions: ["ots"] }, "application/vnd.oasis.opendocument.text": { source: "iana", compressible: false, extensions: ["odt"] }, "application/vnd.oasis.opendocument.text-master": { source: "iana", extensions: ["odm"] }, "application/vnd.oasis.opendocument.text-template": { source: "iana", extensions: ["ott"] }, "application/vnd.oasis.opendocument.text-web": { source: "iana", extensions: ["oth"] }, "application/vnd.obn": { source: "iana" }, "application/vnd.ocf+cbor": { source: "iana" }, "application/vnd.oci.image.manifest.v1+json": { source: "iana", compressible: true }, "application/vnd.oftn.l10n+json": { source: "iana", compressible: true }, "application/vnd.oipf.contentaccessdownload+xml": { source: "iana", compressible: true }, "application/vnd.oipf.contentaccessstreaming+xml": { source: "iana", compressible: true }, "application/vnd.oipf.cspg-hexbinary": { source: "iana" }, "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: true }, "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: true }, "application/vnd.oipf.mippvcontrolmessage+xml": { source: "iana", compressible: true }, "application/vnd.oipf.pae.gem": { source: "iana" }, "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: true }, "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: true }, "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: true }, "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: true }, "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] }, "application/vnd.oma-scws-config": { source: "iana" }, "application/vnd.oma-scws-http-request": { source: "iana" }, "application/vnd.oma-scws-http-response": { source: "iana" }, "application/vnd.oma.bcast.associated-procedure-parameter+xml": { source: "iana", compressible: true }, "application/vnd.oma.bcast.drm-trigger+xml": { source: "iana", compressible: true }, "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: true }, "application/vnd.oma.bcast.ltkm": { source: "iana" }, "application/vnd.oma.bcast.notification+xml": { source: "iana", compressible: true }, "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" }, "application/vnd.oma.bcast.sgboot": { source: "iana" }, "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: true }, "application/vnd.oma.bcast.sgdu": { source: "iana" }, "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" }, "application/vnd.oma.bcast.smartcard-trigger+xml": { source: "iana", compressible: true }, "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: true }, "application/vnd.oma.bcast.stkm": { source: "iana" }, "application/vnd.oma.cab-address-book+xml": { source: "iana", compressible: true }, "application/vnd.oma.cab-feature-handler+xml": { source: "iana", compressible: true }, "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: true }, "application/vnd.oma.cab-subs-invite+xml": { source: "iana", compressible: true }, "application/vnd.oma.cab-user-prefs+xml": { source: "iana", compressible: true }, "application/vnd.oma.dcd": { source: "iana" }, "application/vnd.oma.dcdc": { source: "iana" }, "application/vnd.oma.dd2+xml": { source: "iana", compressible: true, extensions: ["dd2"] }, "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: true }, "application/vnd.oma.group-usage-list+xml": { source: "iana", compressible: true }, "application/vnd.oma.lwm2m+cbor": { source: "iana" }, "application/vnd.oma.lwm2m+json": { source: "iana", compressible: true }, "application/vnd.oma.lwm2m+tlv": { source: "iana" }, "application/vnd.oma.pal+xml": { source: "iana", compressible: true }, "application/vnd.oma.poc.detailed-progress-report+xml": { source: "iana", compressible: true }, "application/vnd.oma.poc.final-report+xml": { source: "iana", compressible: true }, "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: true }, "application/vnd.oma.poc.invocation-descriptor+xml": { source: "iana", compressible: true }, "application/vnd.oma.poc.optimized-progress-report+xml": { source: "iana", compressible: true }, "application/vnd.oma.push": { source: "iana" }, "application/vnd.oma.scidm.messages+xml": { source: "iana", compressible: true }, "application/vnd.oma.xcap-directory+xml": { source: "iana", compressible: true }, "application/vnd.omads-email+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/vnd.omads-file+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/vnd.omads-folder+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/vnd.omaloc-supl-init": { source: "iana" }, "application/vnd.onepager": { source: "iana" }, "application/vnd.onepagertamp": { source: "iana" }, "application/vnd.onepagertamx": { source: "iana" }, "application/vnd.onepagertat": { source: "iana" }, "application/vnd.onepagertatp": { source: "iana" }, "application/vnd.onepagertatx": { source: "iana" }, "application/vnd.openblox.game+xml": { source: "iana", compressible: true, extensions: ["obgx"] }, "application/vnd.openblox.game-binary": { source: "iana" }, "application/vnd.openeye.oeb": { source: "iana" }, "application/vnd.openofficeorg.extension": { source: "apache", extensions: ["oxt"] }, "application/vnd.openstreetmap.data+xml": { source: "iana", compressible: true, extensions: ["osm"] }, "application/vnd.opentimestamps.ots": { source: "iana" }, "application/vnd.openxmlformats-officedocument.custom-properties+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.drawing+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.extended-properties+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.presentation": { source: "iana", compressible: false, extensions: ["pptx"] }, "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.slide": { source: "iana", extensions: ["sldx"] }, "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { source: "iana", extensions: ["ppsx"] }, "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.template": { source: "iana", extensions: ["potx"] }, "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { source: "iana", compressible: false, extensions: ["xlsx"] }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { source: "iana", extensions: ["xltx"] }, "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.theme+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.themeoverride+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.vmldrawing": { source: "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { source: "iana", compressible: false, extensions: ["docx"] }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { source: "iana", extensions: ["dotx"] }, "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-package.core-properties+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { source: "iana", compressible: true }, "application/vnd.openxmlformats-package.relationships+xml": { source: "iana", compressible: true }, "application/vnd.oracle.resource+json": { source: "iana", compressible: true }, "application/vnd.orange.indata": { source: "iana" }, "application/vnd.osa.netdeploy": { source: "iana" }, "application/vnd.osgeo.mapguide.package": { source: "iana", extensions: ["mgp"] }, "application/vnd.osgi.bundle": { source: "iana" }, "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] }, "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] }, "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: true }, "application/vnd.oxli.countgraph": { source: "iana" }, "application/vnd.pagerduty+json": { source: "iana", compressible: true }, "application/vnd.palm": { source: "iana", extensions: ["pdb", "pqa", "oprc"] }, "application/vnd.panoply": { source: "iana" }, "application/vnd.paos.xml": { source: "iana" }, "application/vnd.patentdive": { source: "iana" }, "application/vnd.patientecommsdoc": { source: "iana" }, "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] }, "application/vnd.pcos": { source: "iana" }, "application/vnd.pg.format": { source: "iana", extensions: ["str"] }, "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] }, "application/vnd.piaccess.application-licence": { source: "iana" }, "application/vnd.picsel": { source: "iana", extensions: ["efif"] }, "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] }, "application/vnd.poc.group-advertisement+xml": { source: "iana", compressible: true }, "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] }, "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] }, "application/vnd.powerbuilder6-s": { source: "iana" }, "application/vnd.powerbuilder7": { source: "iana" }, "application/vnd.powerbuilder7-s": { source: "iana" }, "application/vnd.powerbuilder75": { source: "iana" }, "application/vnd.powerbuilder75-s": { source: "iana" }, "application/vnd.preminet": { source: "iana" }, "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] }, "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] }, "application/vnd.psfs": { source: "iana" }, "application/vnd.publishare-delta-tree": { source: "iana", extensions: ["qps"] }, "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] }, "application/vnd.pwg-multiplexed": { source: "iana" }, "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: true }, "application/vnd.qualcomm.brew-app-res": { source: "iana" }, "application/vnd.quarantainenet": { source: "iana" }, "application/vnd.quark.quarkxpress": { source: "iana", extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] }, "application/vnd.quobject-quoxdocument": { source: "iana" }, "application/vnd.radisys.moml+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-audit+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-audit-conf+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-audit-conn+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-audit-dialog+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-audit-stream+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-dialog+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-dialog-base+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-dialog-fax-detect+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-dialog-group+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-dialog-speech+xml": { source: "iana", compressible: true }, "application/vnd.radisys.msml-dialog-transform+xml": { source: "iana", compressible: true }, "application/vnd.rainstor.data": { source: "iana" }, "application/vnd.rapid": { source: "iana" }, "application/vnd.rar": { source: "iana", extensions: ["rar"] }, "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] }, "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] }, "application/vnd.recordare.musicxml+xml": { source: "iana", compressible: true, extensions: ["musicxml"] }, "application/vnd.renlearn.rlprint": { source: "iana" }, "application/vnd.resilient.logic": { source: "iana" }, "application/vnd.restful+json": { source: "iana", compressible: true }, "application/vnd.rig.cryptonote": { source: "iana", extensions: ["cryptonote"] }, "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] }, "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] }, "application/vnd.rn-realmedia-vbr": { source: "apache", extensions: ["rmvb"] }, "application/vnd.route66.link66+xml": { source: "iana", compressible: true, extensions: ["link66"] }, "application/vnd.rs-274x": { source: "iana" }, "application/vnd.ruckus.download": { source: "iana" }, "application/vnd.s3sms": { source: "iana" }, "application/vnd.sailingtracker.track": { source: "iana", extensions: ["st"] }, "application/vnd.sar": { source: "iana" }, "application/vnd.sbm.cid": { source: "iana" }, "application/vnd.sbm.mid2": { source: "iana" }, "application/vnd.scribus": { source: "iana" }, "application/vnd.sealed.3df": { source: "iana" }, "application/vnd.sealed.csf": { source: "iana" }, "application/vnd.sealed.doc": { source: "iana" }, "application/vnd.sealed.eml": { source: "iana" }, "application/vnd.sealed.mht": { source: "iana" }, "application/vnd.sealed.net": { source: "iana" }, "application/vnd.sealed.ppt": { source: "iana" }, "application/vnd.sealed.tiff": { source: "iana" }, "application/vnd.sealed.xls": { source: "iana" }, "application/vnd.sealedmedia.softseal.html": { source: "iana" }, "application/vnd.sealedmedia.softseal.pdf": { source: "iana" }, "application/vnd.seemail": { source: "iana", extensions: ["see"] }, "application/vnd.seis+json": { source: "iana", compressible: true }, "application/vnd.sema": { source: "iana", extensions: ["sema"] }, "application/vnd.semd": { source: "iana", extensions: ["semd"] }, "application/vnd.semf": { source: "iana", extensions: ["semf"] }, "application/vnd.shade-save-file": { source: "iana" }, "application/vnd.shana.informed.formdata": { source: "iana", extensions: ["ifm"] }, "application/vnd.shana.informed.formtemplate": { source: "iana", extensions: ["itp"] }, "application/vnd.shana.informed.interchange": { source: "iana", extensions: ["iif"] }, "application/vnd.shana.informed.package": { source: "iana", extensions: ["ipk"] }, "application/vnd.shootproof+json": { source: "iana", compressible: true }, "application/vnd.shopkick+json": { source: "iana", compressible: true }, "application/vnd.shp": { source: "iana" }, "application/vnd.shx": { source: "iana" }, "application/vnd.sigrok.session": { source: "iana" }, "application/vnd.simtech-mindmapper": { source: "iana", extensions: ["twd", "twds"] }, "application/vnd.siren+json": { source: "iana", compressible: true }, "application/vnd.smaf": { source: "iana", extensions: ["mmf"] }, "application/vnd.smart.notebook": { source: "iana" }, "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] }, "application/vnd.snesdev-page-table": { source: "iana" }, "application/vnd.software602.filler.form+xml": { source: "iana", compressible: true, extensions: ["fo"] }, "application/vnd.software602.filler.form-xml-zip": { source: "iana" }, "application/vnd.solent.sdkm+xml": { source: "iana", compressible: true, extensions: ["sdkm", "sdkd"] }, "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] }, "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] }, "application/vnd.sqlite3": { source: "iana" }, "application/vnd.sss-cod": { source: "iana" }, "application/vnd.sss-dtf": { source: "iana" }, "application/vnd.sss-ntf": { source: "iana" }, "application/vnd.stardivision.calc": { source: "apache", extensions: ["sdc"] }, "application/vnd.stardivision.draw": { source: "apache", extensions: ["sda"] }, "application/vnd.stardivision.impress": { source: "apache", extensions: ["sdd"] }, "application/vnd.stardivision.math": { source: "apache", extensions: ["smf"] }, "application/vnd.stardivision.writer": { source: "apache", extensions: ["sdw", "vor"] }, "application/vnd.stardivision.writer-global": { source: "apache", extensions: ["sgl"] }, "application/vnd.stepmania.package": { source: "iana", extensions: ["smzip"] }, "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] }, "application/vnd.street-stream": { source: "iana" }, "application/vnd.sun.wadl+xml": { source: "iana", compressible: true, extensions: ["wadl"] }, "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] }, "application/vnd.sun.xml.calc.template": { source: "apache", extensions: ["stc"] }, "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] }, "application/vnd.sun.xml.draw.template": { source: "apache", extensions: ["std"] }, "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] }, "application/vnd.sun.xml.impress.template": { source: "apache", extensions: ["sti"] }, "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] }, "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] }, "application/vnd.sun.xml.writer.global": { source: "apache", extensions: ["sxg"] }, "application/vnd.sun.xml.writer.template": { source: "apache", extensions: ["stw"] }, "application/vnd.sus-calendar": { source: "iana", extensions: ["sus", "susp"] }, "application/vnd.svd": { source: "iana", extensions: ["svd"] }, "application/vnd.swiftview-ics": { source: "iana" }, "application/vnd.sycle+xml": { source: "iana", compressible: true }, "application/vnd.syft+json": { source: "iana", compressible: true }, "application/vnd.symbian.install": { source: "apache", extensions: ["sis", "sisx"] }, "application/vnd.syncml+xml": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["xsm"] }, "application/vnd.syncml.dm+wbxml": { source: "iana", charset: "UTF-8", extensions: ["bdm"] }, "application/vnd.syncml.dm+xml": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["xdm"] }, "application/vnd.syncml.dm.notification": { source: "iana" }, "application/vnd.syncml.dmddf+wbxml": { source: "iana" }, "application/vnd.syncml.dmddf+xml": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["ddf"] }, "application/vnd.syncml.dmtnds+wbxml": { source: "iana" }, "application/vnd.syncml.dmtnds+xml": { source: "iana", charset: "UTF-8", compressible: true }, "application/vnd.syncml.ds.notification": { source: "iana" }, "application/vnd.tableschema+json": { source: "iana", compressible: true }, "application/vnd.tao.intent-module-archive": { source: "iana", extensions: ["tao"] }, "application/vnd.tcpdump.pcap": { source: "iana", extensions: ["pcap", "cap", "dmp"] }, "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: true }, "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: true }, "application/vnd.tml": { source: "iana" }, "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] }, "application/vnd.tri.onesource": { source: "iana" }, "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] }, "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] }, "application/vnd.trueapp": { source: "iana", extensions: ["tra"] }, "application/vnd.truedoc": { source: "iana" }, "application/vnd.ubisoft.webplayer": { source: "iana" }, "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] }, "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] }, "application/vnd.umajin": { source: "iana", extensions: ["umj"] }, "application/vnd.unity": { source: "iana", extensions: ["unityweb"] }, "application/vnd.uoml+xml": { source: "iana", compressible: true, extensions: ["uoml"] }, "application/vnd.uplanet.alert": { source: "iana" }, "application/vnd.uplanet.alert-wbxml": { source: "iana" }, "application/vnd.uplanet.bearer-choice": { source: "iana" }, "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" }, "application/vnd.uplanet.cacheop": { source: "iana" }, "application/vnd.uplanet.cacheop-wbxml": { source: "iana" }, "application/vnd.uplanet.channel": { source: "iana" }, "application/vnd.uplanet.channel-wbxml": { source: "iana" }, "application/vnd.uplanet.list": { source: "iana" }, "application/vnd.uplanet.list-wbxml": { source: "iana" }, "application/vnd.uplanet.listcmd": { source: "iana" }, "application/vnd.uplanet.listcmd-wbxml": { source: "iana" }, "application/vnd.uplanet.signal": { source: "iana" }, "application/vnd.uri-map": { source: "iana" }, "application/vnd.valve.source.material": { source: "iana" }, "application/vnd.vcx": { source: "iana", extensions: ["vcx"] }, "application/vnd.vd-study": { source: "iana" }, "application/vnd.vectorworks": { source: "iana" }, "application/vnd.vel+json": { source: "iana", compressible: true }, "application/vnd.verimatrix.vcas": { source: "iana" }, "application/vnd.veritone.aion+json": { source: "iana", compressible: true }, "application/vnd.veryant.thin": { source: "iana" }, "application/vnd.ves.encrypted": { source: "iana" }, "application/vnd.vidsoft.vidconference": { source: "iana" }, "application/vnd.visio": { source: "iana", extensions: ["vsd", "vst", "vss", "vsw"] }, "application/vnd.visionary": { source: "iana", extensions: ["vis"] }, "application/vnd.vividence.scriptfile": { source: "iana" }, "application/vnd.vsf": { source: "iana", extensions: ["vsf"] }, "application/vnd.wap.sic": { source: "iana" }, "application/vnd.wap.slc": { source: "iana" }, "application/vnd.wap.wbxml": { source: "iana", charset: "UTF-8", extensions: ["wbxml"] }, "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] }, "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] }, "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] }, "application/vnd.wfa.dpp": { source: "iana" }, "application/vnd.wfa.p2p": { source: "iana" }, "application/vnd.wfa.wsc": { source: "iana" }, "application/vnd.windows.devicepairing": { source: "iana" }, "application/vnd.wmc": { source: "iana" }, "application/vnd.wmf.bootstrap": { source: "iana" }, "application/vnd.wolfram.mathematica": { source: "iana" }, "application/vnd.wolfram.mathematica.package": { source: "iana" }, "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] }, "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] }, "application/vnd.wqd": { source: "iana", extensions: ["wqd"] }, "application/vnd.wrq-hp3000-labelled": { source: "iana" }, "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] }, "application/vnd.wv.csp+wbxml": { source: "iana" }, "application/vnd.wv.csp+xml": { source: "iana", compressible: true }, "application/vnd.wv.ssp+xml": { source: "iana", compressible: true }, "application/vnd.xacml+json": { source: "iana", compressible: true }, "application/vnd.xara": { source: "iana", extensions: ["xar"] }, "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] }, "application/vnd.xfdl.webform": { source: "iana" }, "application/vnd.xmi+xml": { source: "iana", compressible: true }, "application/vnd.xmpie.cpkg": { source: "iana" }, "application/vnd.xmpie.dpkg": { source: "iana" }, "application/vnd.xmpie.plan": { source: "iana" }, "application/vnd.xmpie.ppkg": { source: "iana" }, "application/vnd.xmpie.xlim": { source: "iana" }, "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] }, "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] }, "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] }, "application/vnd.yamaha.openscoreformat": { source: "iana", extensions: ["osf"] }, "application/vnd.yamaha.openscoreformat.osfpvg+xml": { source: "iana", compressible: true, extensions: ["osfpvg"] }, "application/vnd.yamaha.remote-setup": { source: "iana" }, "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] }, "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] }, "application/vnd.yamaha.through-ngn": { source: "iana" }, "application/vnd.yamaha.tunnel-udpencap": { source: "iana" }, "application/vnd.yaoweme": { source: "iana" }, "application/vnd.yellowriver-custom-menu": { source: "iana", extensions: ["cmp"] }, "application/vnd.youtube.yt": { source: "iana" }, "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] }, "application/vnd.zzazz.deck+xml": { source: "iana", compressible: true, extensions: ["zaz"] }, "application/voicexml+xml": { source: "iana", compressible: true, extensions: ["vxml"] }, "application/voucher-cms+json": { source: "iana", compressible: true }, "application/vq-rtcpxr": { source: "iana" }, "application/wasm": { source: "iana", compressible: true, extensions: ["wasm"] }, "application/watcherinfo+xml": { source: "iana", compressible: true, extensions: ["wif"] }, "application/webpush-options+json": { source: "iana", compressible: true }, "application/whoispp-query": { source: "iana" }, "application/whoispp-response": { source: "iana" }, "application/widget": { source: "iana", extensions: ["wgt"] }, "application/winhlp": { source: "apache", extensions: ["hlp"] }, "application/wita": { source: "iana" }, "application/wordperfect5.1": { source: "iana" }, "application/wsdl+xml": { source: "iana", compressible: true, extensions: ["wsdl"] }, "application/wspolicy+xml": { source: "iana", compressible: true, extensions: ["wspolicy"] }, "application/x-7z-compressed": { source: "apache", compressible: false, extensions: ["7z"] }, "application/x-abiword": { source: "apache", extensions: ["abw"] }, "application/x-ace-compressed": { source: "apache", extensions: ["ace"] }, "application/x-amf": { source: "apache" }, "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] }, "application/x-arj": { compressible: false, extensions: ["arj"] }, "application/x-authorware-bin": { source: "apache", extensions: ["aab", "x32", "u32", "vox"] }, "application/x-authorware-map": { source: "apache", extensions: ["aam"] }, "application/x-authorware-seg": { source: "apache", extensions: ["aas"] }, "application/x-bcpio": { source: "apache", extensions: ["bcpio"] }, "application/x-bdoc": { compressible: false, extensions: ["bdoc"] }, "application/x-bittorrent": { source: "apache", extensions: ["torrent"] }, "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] }, "application/x-bzip": { source: "apache", compressible: false, extensions: ["bz"] }, "application/x-bzip2": { source: "apache", compressible: false, extensions: ["bz2", "boz"] }, "application/x-cbr": { source: "apache", extensions: ["cbr", "cba", "cbt", "cbz", "cb7"] }, "application/x-cdlink": { source: "apache", extensions: ["vcd"] }, "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] }, "application/x-chat": { source: "apache", extensions: ["chat"] }, "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] }, "application/x-chrome-extension": { extensions: ["crx"] }, "application/x-cocoa": { source: "nginx", extensions: ["cco"] }, "application/x-compress": { source: "apache" }, "application/x-conference": { source: "apache", extensions: ["nsc"] }, "application/x-cpio": { source: "apache", extensions: ["cpio"] }, "application/x-csh": { source: "apache", extensions: ["csh"] }, "application/x-deb": { compressible: false }, "application/x-debian-package": { source: "apache", extensions: ["deb", "udeb"] }, "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] }, "application/x-director": { source: "apache", extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] }, "application/x-doom": { source: "apache", extensions: ["wad"] }, "application/x-dtbncx+xml": { source: "apache", compressible: true, extensions: ["ncx"] }, "application/x-dtbook+xml": { source: "apache", compressible: true, extensions: ["dtb"] }, "application/x-dtbresource+xml": { source: "apache", compressible: true, extensions: ["res"] }, "application/x-dvi": { source: "apache", compressible: false, extensions: ["dvi"] }, "application/x-envoy": { source: "apache", extensions: ["evy"] }, "application/x-eva": { source: "apache", extensions: ["eva"] }, "application/x-font-bdf": { source: "apache", extensions: ["bdf"] }, "application/x-font-dos": { source: "apache" }, "application/x-font-framemaker": { source: "apache" }, "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] }, "application/x-font-libgrx": { source: "apache" }, "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] }, "application/x-font-pcf": { source: "apache", extensions: ["pcf"] }, "application/x-font-snf": { source: "apache", extensions: ["snf"] }, "application/x-font-speedo": { source: "apache" }, "application/x-font-sunos-news": { source: "apache" }, "application/x-font-type1": { source: "apache", extensions: ["pfa", "pfb", "pfm", "afm"] }, "application/x-font-vfont": { source: "apache" }, "application/x-freearc": { source: "apache", extensions: ["arc"] }, "application/x-futuresplash": { source: "apache", extensions: ["spl"] }, "application/x-gca-compressed": { source: "apache", extensions: ["gca"] }, "application/x-glulx": { source: "apache", extensions: ["ulx"] }, "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] }, "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] }, "application/x-gtar": { source: "apache", extensions: ["gtar"] }, "application/x-gzip": { source: "apache" }, "application/x-hdf": { source: "apache", extensions: ["hdf"] }, "application/x-httpd-php": { compressible: true, extensions: ["php"] }, "application/x-install-instructions": { source: "apache", extensions: ["install"] }, "application/x-iso9660-image": { source: "apache", extensions: ["iso"] }, "application/x-iwork-keynote-sffkey": { extensions: ["key"] }, "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] }, "application/x-iwork-pages-sffpages": { extensions: ["pages"] }, "application/x-java-archive-diff": { source: "nginx", extensions: ["jardiff"] }, "application/x-java-jnlp-file": { source: "apache", compressible: false, extensions: ["jnlp"] }, "application/x-javascript": { compressible: true }, "application/x-keepass2": { extensions: ["kdbx"] }, "application/x-latex": { source: "apache", compressible: false, extensions: ["latex"] }, "application/x-lua-bytecode": { extensions: ["luac"] }, "application/x-lzh-compressed": { source: "apache", extensions: ["lzh", "lha"] }, "application/x-makeself": { source: "nginx", extensions: ["run"] }, "application/x-mie": { source: "apache", extensions: ["mie"] }, "application/x-mobipocket-ebook": { source: "apache", extensions: ["prc", "mobi"] }, "application/x-mpegurl": { compressible: false }, "application/x-ms-application": { source: "apache", extensions: ["application"] }, "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] }, "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] }, "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] }, "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] }, "application/x-msaccess": { source: "apache", extensions: ["mdb"] }, "application/x-msbinder": { source: "apache", extensions: ["obd"] }, "application/x-mscardfile": { source: "apache", extensions: ["crd"] }, "application/x-msclip": { source: "apache", extensions: ["clp"] }, "application/x-msdos-program": { extensions: ["exe"] }, "application/x-msdownload": { source: "apache", extensions: ["exe", "dll", "com", "bat", "msi"] }, "application/x-msmediaview": { source: "apache", extensions: ["mvb", "m13", "m14"] }, "application/x-msmetafile": { source: "apache", extensions: ["wmf", "wmz", "emf", "emz"] }, "application/x-msmoney": { source: "apache", extensions: ["mny"] }, "application/x-mspublisher": { source: "apache", extensions: ["pub"] }, "application/x-msschedule": { source: "apache", extensions: ["scd"] }, "application/x-msterminal": { source: "apache", extensions: ["trm"] }, "application/x-mswrite": { source: "apache", extensions: ["wri"] }, "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] }, "application/x-ns-proxy-autoconfig": { compressible: true, extensions: ["pac"] }, "application/x-nzb": { source: "apache", extensions: ["nzb"] }, "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] }, "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] }, "application/x-pkcs12": { source: "apache", compressible: false, extensions: ["p12", "pfx"] }, "application/x-pkcs7-certificates": { source: "apache", extensions: ["p7b", "spc"] }, "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] }, "application/x-pki-message": { source: "iana" }, "application/x-rar-compressed": { source: "apache", compressible: false, extensions: ["rar"] }, "application/x-redhat-package-manager": { source: "nginx", extensions: ["rpm"] }, "application/x-research-info-systems": { source: "apache", extensions: ["ris"] }, "application/x-sea": { source: "nginx", extensions: ["sea"] }, "application/x-sh": { source: "apache", compressible: true, extensions: ["sh"] }, "application/x-shar": { source: "apache", extensions: ["shar"] }, "application/x-shockwave-flash": { source: "apache", compressible: false, extensions: ["swf"] }, "application/x-silverlight-app": { source: "apache", extensions: ["xap"] }, "application/x-sql": { source: "apache", extensions: ["sql"] }, "application/x-stuffit": { source: "apache", compressible: false, extensions: ["sit"] }, "application/x-stuffitx": { source: "apache", extensions: ["sitx"] }, "application/x-subrip": { source: "apache", extensions: ["srt"] }, "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] }, "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] }, "application/x-t3vm-image": { source: "apache", extensions: ["t3"] }, "application/x-tads": { source: "apache", extensions: ["gam"] }, "application/x-tar": { source: "apache", compressible: true, extensions: ["tar"] }, "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] }, "application/x-tex": { source: "apache", extensions: ["tex"] }, "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] }, "application/x-texinfo": { source: "apache", extensions: ["texinfo", "texi"] }, "application/x-tgif": { source: "apache", extensions: ["obj"] }, "application/x-ustar": { source: "apache", extensions: ["ustar"] }, "application/x-virtualbox-hdd": { compressible: true, extensions: ["hdd"] }, "application/x-virtualbox-ova": { compressible: true, extensions: ["ova"] }, "application/x-virtualbox-ovf": { compressible: true, extensions: ["ovf"] }, "application/x-virtualbox-vbox": { compressible: true, extensions: ["vbox"] }, "application/x-virtualbox-vbox-extpack": { compressible: false, extensions: ["vbox-extpack"] }, "application/x-virtualbox-vdi": { compressible: true, extensions: ["vdi"] }, "application/x-virtualbox-vhd": { compressible: true, extensions: ["vhd"] }, "application/x-virtualbox-vmdk": { compressible: true, extensions: ["vmdk"] }, "application/x-wais-source": { source: "apache", extensions: ["src"] }, "application/x-web-app-manifest+json": { compressible: true, extensions: ["webapp"] }, "application/x-www-form-urlencoded": { source: "iana", compressible: true }, "application/x-x509-ca-cert": { source: "iana", extensions: ["der", "crt", "pem"] }, "application/x-x509-ca-ra-cert": { source: "iana" }, "application/x-x509-next-ca-cert": { source: "iana" }, "application/x-xfig": { source: "apache", extensions: ["fig"] }, "application/x-xliff+xml": { source: "apache", compressible: true, extensions: ["xlf"] }, "application/x-xpinstall": { source: "apache", compressible: false, extensions: ["xpi"] }, "application/x-xz": { source: "apache", extensions: ["xz"] }, "application/x-zmachine": { source: "apache", extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] }, "application/x400-bp": { source: "iana" }, "application/xacml+xml": { source: "iana", compressible: true }, "application/xaml+xml": { source: "apache", compressible: true, extensions: ["xaml"] }, "application/xcap-att+xml": { source: "iana", compressible: true, extensions: ["xav"] }, "application/xcap-caps+xml": { source: "iana", compressible: true, extensions: ["xca"] }, "application/xcap-diff+xml": { source: "iana", compressible: true, extensions: ["xdf"] }, "application/xcap-el+xml": { source: "iana", compressible: true, extensions: ["xel"] }, "application/xcap-error+xml": { source: "iana", compressible: true }, "application/xcap-ns+xml": { source: "iana", compressible: true, extensions: ["xns"] }, "application/xcon-conference-info+xml": { source: "iana", compressible: true }, "application/xcon-conference-info-diff+xml": { source: "iana", compressible: true }, "application/xenc+xml": { source: "iana", compressible: true, extensions: ["xenc"] }, "application/xhtml+xml": { source: "iana", compressible: true, extensions: ["xhtml", "xht"] }, "application/xhtml-voice+xml": { source: "apache", compressible: true }, "application/xliff+xml": { source: "iana", compressible: true, extensions: ["xlf"] }, "application/xml": { source: "iana", compressible: true, extensions: ["xml", "xsl", "xsd", "rng"] }, "application/xml-dtd": { source: "iana", compressible: true, extensions: ["dtd"] }, "application/xml-external-parsed-entity": { source: "iana" }, "application/xml-patch+xml": { source: "iana", compressible: true }, "application/xmpp+xml": { source: "iana", compressible: true }, "application/xop+xml": { source: "iana", compressible: true, extensions: ["xop"] }, "application/xproc+xml": { source: "apache", compressible: true, extensions: ["xpl"] }, "application/xslt+xml": { source: "iana", compressible: true, extensions: ["xsl", "xslt"] }, "application/xspf+xml": { source: "apache", compressible: true, extensions: ["xspf"] }, "application/xv+xml": { source: "iana", compressible: true, extensions: ["mxml", "xhvml", "xvml", "xvm"] }, "application/yang": { source: "iana", extensions: ["yang"] }, "application/yang-data+json": { source: "iana", compressible: true }, "application/yang-data+xml": { source: "iana", compressible: true }, "application/yang-patch+json": { source: "iana", compressible: true }, "application/yang-patch+xml": { source: "iana", compressible: true }, "application/yin+xml": { source: "iana", compressible: true, extensions: ["yin"] }, "application/zip": { source: "iana", compressible: false, extensions: ["zip"] }, "application/zlib": { source: "iana" }, "application/zstd": { source: "iana" }, "audio/1d-interleaved-parityfec": { source: "iana" }, "audio/32kadpcm": { source: "iana" }, "audio/3gpp": { source: "iana", compressible: false, extensions: ["3gpp"] }, "audio/3gpp2": { source: "iana" }, "audio/aac": { source: "iana" }, "audio/ac3": { source: "iana" }, "audio/adpcm": { source: "apache", extensions: ["adp"] }, "audio/amr": { source: "iana", extensions: ["amr"] }, "audio/amr-wb": { source: "iana" }, "audio/amr-wb+": { source: "iana" }, "audio/aptx": { source: "iana" }, "audio/asc": { source: "iana" }, "audio/atrac-advanced-lossless": { source: "iana" }, "audio/atrac-x": { source: "iana" }, "audio/atrac3": { source: "iana" }, "audio/basic": { source: "iana", compressible: false, extensions: ["au", "snd"] }, "audio/bv16": { source: "iana" }, "audio/bv32": { source: "iana" }, "audio/clearmode": { source: "iana" }, "audio/cn": { source: "iana" }, "audio/dat12": { source: "iana" }, "audio/dls": { source: "iana" }, "audio/dsr-es201108": { source: "iana" }, "audio/dsr-es202050": { source: "iana" }, "audio/dsr-es202211": { source: "iana" }, "audio/dsr-es202212": { source: "iana" }, "audio/dv": { source: "iana" }, "audio/dvi4": { source: "iana" }, "audio/eac3": { source: "iana" }, "audio/encaprtp": { source: "iana" }, "audio/evrc": { source: "iana" }, "audio/evrc-qcp": { source: "iana" }, "audio/evrc0": { source: "iana" }, "audio/evrc1": { source: "iana" }, "audio/evrcb": { source: "iana" }, "audio/evrcb0": { source: "iana" }, "audio/evrcb1": { source: "iana" }, "audio/evrcnw": { source: "iana" }, "audio/evrcnw0": { source: "iana" }, "audio/evrcnw1": { source: "iana" }, "audio/evrcwb": { source: "iana" }, "audio/evrcwb0": { source: "iana" }, "audio/evrcwb1": { source: "iana" }, "audio/evs": { source: "iana" }, "audio/flexfec": { source: "iana" }, "audio/fwdred": { source: "iana" }, "audio/g711-0": { source: "iana" }, "audio/g719": { source: "iana" }, "audio/g722": { source: "iana" }, "audio/g7221": { source: "iana" }, "audio/g723": { source: "iana" }, "audio/g726-16": { source: "iana" }, "audio/g726-24": { source: "iana" }, "audio/g726-32": { source: "iana" }, "audio/g726-40": { source: "iana" }, "audio/g728": { source: "iana" }, "audio/g729": { source: "iana" }, "audio/g7291": { source: "iana" }, "audio/g729d": { source: "iana" }, "audio/g729e": { source: "iana" }, "audio/gsm": { source: "iana" }, "audio/gsm-efr": { source: "iana" }, "audio/gsm-hr-08": { source: "iana" }, "audio/ilbc": { source: "iana" }, "audio/ip-mr_v2.5": { source: "iana" }, "audio/isac": { source: "apache" }, "audio/l16": { source: "iana" }, "audio/l20": { source: "iana" }, "audio/l24": { source: "iana", compressible: false }, "audio/l8": { source: "iana" }, "audio/lpc": { source: "iana" }, "audio/melp": { source: "iana" }, "audio/melp1200": { source: "iana" }, "audio/melp2400": { source: "iana" }, "audio/melp600": { source: "iana" }, "audio/mhas": { source: "iana" }, "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] }, "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] }, "audio/mp3": { compressible: false, extensions: ["mp3"] }, "audio/mp4": { source: "iana", compressible: false, extensions: ["m4a", "mp4a"] }, "audio/mp4a-latm": { source: "iana" }, "audio/mpa": { source: "iana" }, "audio/mpa-robust": { source: "iana" }, "audio/mpeg": { source: "iana", compressible: false, extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] }, "audio/mpeg4-generic": { source: "iana" }, "audio/musepack": { source: "apache" }, "audio/ogg": { source: "iana", compressible: false, extensions: ["oga", "ogg", "spx", "opus"] }, "audio/opus": { source: "iana" }, "audio/parityfec": { source: "iana" }, "audio/pcma": { source: "iana" }, "audio/pcma-wb": { source: "iana" }, "audio/pcmu": { source: "iana" }, "audio/pcmu-wb": { source: "iana" }, "audio/prs.sid": { source: "iana" }, "audio/qcelp": { source: "iana" }, "audio/raptorfec": { source: "iana" }, "audio/red": { source: "iana" }, "audio/rtp-enc-aescm128": { source: "iana" }, "audio/rtp-midi": { source: "iana" }, "audio/rtploopback": { source: "iana" }, "audio/rtx": { source: "iana" }, "audio/s3m": { source: "apache", extensions: ["s3m"] }, "audio/scip": { source: "iana" }, "audio/silk": { source: "apache", extensions: ["sil"] }, "audio/smv": { source: "iana" }, "audio/smv-qcp": { source: "iana" }, "audio/smv0": { source: "iana" }, "audio/sofa": { source: "iana" }, "audio/sp-midi": { source: "iana" }, "audio/speex": { source: "iana" }, "audio/t140c": { source: "iana" }, "audio/t38": { source: "iana" }, "audio/telephone-event": { source: "iana" }, "audio/tetra_acelp": { source: "iana" }, "audio/tetra_acelp_bb": { source: "iana" }, "audio/tone": { source: "iana" }, "audio/tsvcis": { source: "iana" }, "audio/uemclip": { source: "iana" }, "audio/ulpfec": { source: "iana" }, "audio/usac": { source: "iana" }, "audio/vdvi": { source: "iana" }, "audio/vmr-wb": { source: "iana" }, "audio/vnd.3gpp.iufp": { source: "iana" }, "audio/vnd.4sb": { source: "iana" }, "audio/vnd.audiokoz": { source: "iana" }, "audio/vnd.celp": { source: "iana" }, "audio/vnd.cisco.nse": { source: "iana" }, "audio/vnd.cmles.radio-events": { source: "iana" }, "audio/vnd.cns.anp1": { source: "iana" }, "audio/vnd.cns.inf1": { source: "iana" }, "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] }, "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] }, "audio/vnd.dlna.adts": { source: "iana" }, "audio/vnd.dolby.heaac.1": { source: "iana" }, "audio/vnd.dolby.heaac.2": { source: "iana" }, "audio/vnd.dolby.mlp": { source: "iana" }, "audio/vnd.dolby.mps": { source: "iana" }, "audio/vnd.dolby.pl2": { source: "iana" }, "audio/vnd.dolby.pl2x": { source: "iana" }, "audio/vnd.dolby.pl2z": { source: "iana" }, "audio/vnd.dolby.pulse.1": { source: "iana" }, "audio/vnd.dra": { source: "iana", extensions: ["dra"] }, "audio/vnd.dts": { source: "iana", extensions: ["dts"] }, "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] }, "audio/vnd.dts.uhd": { source: "iana" }, "audio/vnd.dvb.file": { source: "iana" }, "audio/vnd.everad.plj": { source: "iana" }, "audio/vnd.hns.audio": { source: "iana" }, "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] }, "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] }, "audio/vnd.nokia.mobile-xmf": { source: "iana" }, "audio/vnd.nortel.vbk": { source: "iana" }, "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] }, "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] }, "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] }, "audio/vnd.octel.sbc": { source: "iana" }, "audio/vnd.presonus.multitrack": { source: "iana" }, "audio/vnd.qcelp": { source: "iana" }, "audio/vnd.rhetorex.32kadpcm": { source: "iana" }, "audio/vnd.rip": { source: "iana", extensions: ["rip"] }, "audio/vnd.rn-realaudio": { compressible: false }, "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" }, "audio/vnd.vmx.cvsd": { source: "iana" }, "audio/vnd.wave": { compressible: false }, "audio/vorbis": { source: "iana", compressible: false }, "audio/vorbis-config": { source: "iana" }, "audio/wav": { compressible: false, extensions: ["wav"] }, "audio/wave": { compressible: false, extensions: ["wav"] }, "audio/webm": { source: "apache", compressible: false, extensions: ["weba"] }, "audio/x-aac": { source: "apache", compressible: false, extensions: ["aac"] }, "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] }, "audio/x-caf": { source: "apache", compressible: false, extensions: ["caf"] }, "audio/x-flac": { source: "apache", extensions: ["flac"] }, "audio/x-m4a": { source: "nginx", extensions: ["m4a"] }, "audio/x-matroska": { source: "apache", extensions: ["mka"] }, "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] }, "audio/x-ms-wax": { source: "apache", extensions: ["wax"] }, "audio/x-ms-wma": { source: "apache", extensions: ["wma"] }, "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] }, "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] }, "audio/x-realaudio": { source: "nginx", extensions: ["ra"] }, "audio/x-tta": { source: "apache" }, "audio/x-wav": { source: "apache", extensions: ["wav"] }, "audio/xm": { source: "apache", extensions: ["xm"] }, "chemical/x-cdx": { source: "apache", extensions: ["cdx"] }, "chemical/x-cif": { source: "apache", extensions: ["cif"] }, "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] }, "chemical/x-cml": { source: "apache", extensions: ["cml"] }, "chemical/x-csml": { source: "apache", extensions: ["csml"] }, "chemical/x-pdb": { source: "apache" }, "chemical/x-xyz": { source: "apache", extensions: ["xyz"] }, "font/collection": { source: "iana", extensions: ["ttc"] }, "font/otf": { source: "iana", compressible: true, extensions: ["otf"] }, "font/sfnt": { source: "iana" }, "font/ttf": { source: "iana", compressible: true, extensions: ["ttf"] }, "font/woff": { source: "iana", extensions: ["woff"] }, "font/woff2": { source: "iana", extensions: ["woff2"] }, "image/aces": { source: "iana", extensions: ["exr"] }, "image/apng": { compressible: false, extensions: ["apng"] }, "image/avci": { source: "iana", extensions: ["avci"] }, "image/avcs": { source: "iana", extensions: ["avcs"] }, "image/avif": { source: "iana", compressible: false, extensions: ["avif"] }, "image/bmp": { source: "iana", compressible: true, extensions: ["bmp"] }, "image/cgm": { source: "iana", extensions: ["cgm"] }, "image/dicom-rle": { source: "iana", extensions: ["drle"] }, "image/emf": { source: "iana", extensions: ["emf"] }, "image/fits": { source: "iana", extensions: ["fits"] }, "image/g3fax": { source: "iana", extensions: ["g3"] }, "image/gif": { source: "iana", compressible: false, extensions: ["gif"] }, "image/heic": { source: "iana", extensions: ["heic"] }, "image/heic-sequence": { source: "iana", extensions: ["heics"] }, "image/heif": { source: "iana", extensions: ["heif"] }, "image/heif-sequence": { source: "iana", extensions: ["heifs"] }, "image/hej2k": { source: "iana", extensions: ["hej2"] }, "image/hsj2": { source: "iana", extensions: ["hsj2"] }, "image/ief": { source: "iana", extensions: ["ief"] }, "image/jls": { source: "iana", extensions: ["jls"] }, "image/jp2": { source: "iana", compressible: false, extensions: ["jp2", "jpg2"] }, "image/jpeg": { source: "iana", compressible: false, extensions: ["jpeg", "jpg", "jpe"] }, "image/jph": { source: "iana", extensions: ["jph"] }, "image/jphc": { source: "iana", extensions: ["jhc"] }, "image/jpm": { source: "iana", compressible: false, extensions: ["jpm"] }, "image/jpx": { source: "iana", compressible: false, extensions: ["jpx", "jpf"] }, "image/jxr": { source: "iana", extensions: ["jxr"] }, "image/jxra": { source: "iana", extensions: ["jxra"] }, "image/jxrs": { source: "iana", extensions: ["jxrs"] }, "image/jxs": { source: "iana", extensions: ["jxs"] }, "image/jxsc": { source: "iana", extensions: ["jxsc"] }, "image/jxsi": { source: "iana", extensions: ["jxsi"] }, "image/jxss": { source: "iana", extensions: ["jxss"] }, "image/ktx": { source: "iana", extensions: ["ktx"] }, "image/ktx2": { source: "iana", extensions: ["ktx2"] }, "image/naplps": { source: "iana" }, "image/pjpeg": { compressible: false }, "image/png": { source: "iana", compressible: false, extensions: ["png"] }, "image/prs.btif": { source: "iana", extensions: ["btif"] }, "image/prs.pti": { source: "iana", extensions: ["pti"] }, "image/pwg-raster": { source: "iana" }, "image/sgi": { source: "apache", extensions: ["sgi"] }, "image/svg+xml": { source: "iana", compressible: true, extensions: ["svg", "svgz"] }, "image/t38": { source: "iana", extensions: ["t38"] }, "image/tiff": { source: "iana", compressible: false, extensions: ["tif", "tiff"] }, "image/tiff-fx": { source: "iana", extensions: ["tfx"] }, "image/vnd.adobe.photoshop": { source: "iana", compressible: true, extensions: ["psd"] }, "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] }, "image/vnd.cns.inf2": { source: "iana" }, "image/vnd.dece.graphic": { source: "iana", extensions: ["uvi", "uvvi", "uvg", "uvvg"] }, "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] }, "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] }, "image/vnd.dwg": { source: "iana", extensions: ["dwg"] }, "image/vnd.dxf": { source: "iana", extensions: ["dxf"] }, "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] }, "image/vnd.fpx": { source: "iana", extensions: ["fpx"] }, "image/vnd.fst": { source: "iana", extensions: ["fst"] }, "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] }, "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] }, "image/vnd.globalgraphics.pgb": { source: "iana" }, "image/vnd.microsoft.icon": { source: "iana", compressible: true, extensions: ["ico"] }, "image/vnd.mix": { source: "iana" }, "image/vnd.mozilla.apng": { source: "iana" }, "image/vnd.ms-dds": { compressible: true, extensions: ["dds"] }, "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] }, "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] }, "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] }, "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] }, "image/vnd.radiance": { source: "iana" }, "image/vnd.sealed.png": { source: "iana" }, "image/vnd.sealedmedia.softseal.gif": { source: "iana" }, "image/vnd.sealedmedia.softseal.jpg": { source: "iana" }, "image/vnd.svf": { source: "iana" }, "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] }, "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] }, "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] }, "image/vnd.xiff": { source: "iana", extensions: ["xif"] }, "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] }, "image/webp": { source: "apache", extensions: ["webp"] }, "image/wmf": { source: "iana", extensions: ["wmf"] }, "image/x-3ds": { source: "apache", extensions: ["3ds"] }, "image/x-cmu-raster": { source: "apache", extensions: ["ras"] }, "image/x-cmx": { source: "apache", extensions: ["cmx"] }, "image/x-freehand": { source: "apache", extensions: ["fh", "fhc", "fh4", "fh5", "fh7"] }, "image/x-icon": { source: "apache", compressible: true, extensions: ["ico"] }, "image/x-jng": { source: "nginx", extensions: ["jng"] }, "image/x-mrsid-image": { source: "apache", extensions: ["sid"] }, "image/x-ms-bmp": { source: "nginx", compressible: true, extensions: ["bmp"] }, "image/x-pcx": { source: "apache", extensions: ["pcx"] }, "image/x-pict": { source: "apache", extensions: ["pic", "pct"] }, "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] }, "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] }, "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] }, "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] }, "image/x-rgb": { source: "apache", extensions: ["rgb"] }, "image/x-tga": { source: "apache", extensions: ["tga"] }, "image/x-xbitmap": { source: "apache", extensions: ["xbm"] }, "image/x-xcf": { compressible: false }, "image/x-xpixmap": { source: "apache", extensions: ["xpm"] }, "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] }, "message/cpim": { source: "iana" }, "message/delivery-status": { source: "iana" }, "message/disposition-notification": { source: "iana", extensions: ["disposition-notification"] }, "message/external-body": { source: "iana" }, "message/feedback-report": { source: "iana" }, "message/global": { source: "iana", extensions: ["u8msg"] }, "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] }, "message/global-disposition-notification": { source: "iana", extensions: ["u8mdn"] }, "message/global-headers": { source: "iana", extensions: ["u8hdr"] }, "message/http": { source: "iana", compressible: false }, "message/imdn+xml": { source: "iana", compressible: true }, "message/news": { source: "iana" }, "message/partial": { source: "iana", compressible: false }, "message/rfc822": { source: "iana", compressible: true, extensions: ["eml", "mime"] }, "message/s-http": { source: "iana" }, "message/sip": { source: "iana" }, "message/sipfrag": { source: "iana" }, "message/tracking-status": { source: "iana" }, "message/vnd.si.simp": { source: "iana" }, "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] }, "model/3mf": { source: "iana", extensions: ["3mf"] }, "model/e57": { source: "iana" }, "model/gltf+json": { source: "iana", compressible: true, extensions: ["gltf"] }, "model/gltf-binary": { source: "iana", compressible: true, extensions: ["glb"] }, "model/iges": { source: "iana", compressible: false, extensions: ["igs", "iges"] }, "model/mesh": { source: "iana", compressible: false, extensions: ["msh", "mesh", "silo"] }, "model/mtl": { source: "iana", extensions: ["mtl"] }, "model/obj": { source: "iana", extensions: ["obj"] }, "model/step": { source: "iana" }, "model/step+xml": { source: "iana", compressible: true, extensions: ["stpx"] }, "model/step+zip": { source: "iana", compressible: false, extensions: ["stpz"] }, "model/step-xml+zip": { source: "iana", compressible: false, extensions: ["stpxz"] }, "model/stl": { source: "iana", extensions: ["stl"] }, "model/vnd.collada+xml": { source: "iana", compressible: true, extensions: ["dae"] }, "model/vnd.dwf": { source: "iana", extensions: ["dwf"] }, "model/vnd.flatland.3dml": { source: "iana" }, "model/vnd.gdl": { source: "iana", extensions: ["gdl"] }, "model/vnd.gs-gdl": { source: "apache" }, "model/vnd.gs.gdl": { source: "iana" }, "model/vnd.gtw": { source: "iana", extensions: ["gtw"] }, "model/vnd.moml+xml": { source: "iana", compressible: true }, "model/vnd.mts": { source: "iana", extensions: ["mts"] }, "model/vnd.opengex": { source: "iana", extensions: ["ogex"] }, "model/vnd.parasolid.transmit.binary": { source: "iana", extensions: ["x_b"] }, "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] }, "model/vnd.pytha.pyox": { source: "iana" }, "model/vnd.rosette.annotated-data-model": { source: "iana" }, "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] }, "model/vnd.usdz+zip": { source: "iana", compressible: false, extensions: ["usdz"] }, "model/vnd.valve.source.compiled-map": { source: "iana", extensions: ["bsp"] }, "model/vnd.vtu": { source: "iana", extensions: ["vtu"] }, "model/vrml": { source: "iana", compressible: false, extensions: ["wrl", "vrml"] }, "model/x3d+binary": { source: "apache", compressible: false, extensions: ["x3db", "x3dbz"] }, "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] }, "model/x3d+vrml": { source: "apache", compressible: false, extensions: ["x3dv", "x3dvz"] }, "model/x3d+xml": { source: "iana", compressible: true, extensions: ["x3d", "x3dz"] }, "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] }, "multipart/alternative": { source: "iana", compressible: false }, "multipart/appledouble": { source: "iana" }, "multipart/byteranges": { source: "iana" }, "multipart/digest": { source: "iana" }, "multipart/encrypted": { source: "iana", compressible: false }, "multipart/form-data": { source: "iana", compressible: false }, "multipart/header-set": { source: "iana" }, "multipart/mixed": { source: "iana" }, "multipart/multilingual": { source: "iana" }, "multipart/parallel": { source: "iana" }, "multipart/related": { source: "iana", compressible: false }, "multipart/report": { source: "iana" }, "multipart/signed": { source: "iana", compressible: false }, "multipart/vnd.bint.med-plus": { source: "iana" }, "multipart/voice-message": { source: "iana" }, "multipart/x-mixed-replace": { source: "iana" }, "text/1d-interleaved-parityfec": { source: "iana" }, "text/cache-manifest": { source: "iana", compressible: true, extensions: ["appcache", "manifest"] }, "text/calendar": { source: "iana", extensions: ["ics", "ifb"] }, "text/calender": { compressible: true }, "text/cmd": { compressible: true }, "text/coffeescript": { extensions: ["coffee", "litcoffee"] }, "text/cql": { source: "iana" }, "text/cql-expression": { source: "iana" }, "text/cql-identifier": { source: "iana" }, "text/css": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["css"] }, "text/csv": { source: "iana", compressible: true, extensions: ["csv"] }, "text/csv-schema": { source: "iana" }, "text/directory": { source: "iana" }, "text/dns": { source: "iana" }, "text/ecmascript": { source: "iana" }, "text/encaprtp": { source: "iana" }, "text/enriched": { source: "iana" }, "text/fhirpath": { source: "iana" }, "text/flexfec": { source: "iana" }, "text/fwdred": { source: "iana" }, "text/gff3": { source: "iana" }, "text/grammar-ref-list": { source: "iana" }, "text/html": { source: "iana", compressible: true, extensions: ["html", "htm", "shtml"] }, "text/jade": { extensions: ["jade"] }, "text/javascript": { source: "iana", compressible: true }, "text/jcr-cnd": { source: "iana" }, "text/jsx": { compressible: true, extensions: ["jsx"] }, "text/less": { compressible: true, extensions: ["less"] }, "text/markdown": { source: "iana", compressible: true, extensions: ["markdown", "md"] }, "text/mathml": { source: "nginx", extensions: ["mml"] }, "text/mdx": { compressible: true, extensions: ["mdx"] }, "text/mizar": { source: "iana" }, "text/n3": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["n3"] }, "text/parameters": { source: "iana", charset: "UTF-8" }, "text/parityfec": { source: "iana" }, "text/plain": { source: "iana", compressible: true, extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"] }, "text/provenance-notation": { source: "iana", charset: "UTF-8" }, "text/prs.fallenstein.rst": { source: "iana" }, "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] }, "text/prs.prop.logic": { source: "iana" }, "text/raptorfec": { source: "iana" }, "text/red": { source: "iana" }, "text/rfc822-headers": { source: "iana" }, "text/richtext": { source: "iana", compressible: true, extensions: ["rtx"] }, "text/rtf": { source: "iana", compressible: true, extensions: ["rtf"] }, "text/rtp-enc-aescm128": { source: "iana" }, "text/rtploopback": { source: "iana" }, "text/rtx": { source: "iana" }, "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] }, "text/shaclc": { source: "iana" }, "text/shex": { source: "iana", extensions: ["shex"] }, "text/slim": { extensions: ["slim", "slm"] }, "text/spdx": { source: "iana", extensions: ["spdx"] }, "text/strings": { source: "iana" }, "text/stylus": { extensions: ["stylus", "styl"] }, "text/t140": { source: "iana" }, "text/tab-separated-values": { source: "iana", compressible: true, extensions: ["tsv"] }, "text/troff": { source: "iana", extensions: ["t", "tr", "roff", "man", "me", "ms"] }, "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] }, "text/ulpfec": { source: "iana" }, "text/uri-list": { source: "iana", compressible: true, extensions: ["uri", "uris", "urls"] }, "text/vcard": { source: "iana", compressible: true, extensions: ["vcard"] }, "text/vnd.a": { source: "iana" }, "text/vnd.abc": { source: "iana" }, "text/vnd.ascii-art": { source: "iana" }, "text/vnd.curl": { source: "iana", extensions: ["curl"] }, "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] }, "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] }, "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] }, "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" }, "text/vnd.dmclientscript": { source: "iana" }, "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] }, "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" }, "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] }, "text/vnd.ficlab.flt": { source: "iana" }, "text/vnd.fly": { source: "iana", extensions: ["fly"] }, "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] }, "text/vnd.gml": { source: "iana" }, "text/vnd.graphviz": { source: "iana", extensions: ["gv"] }, "text/vnd.hans": { source: "iana" }, "text/vnd.hgl": { source: "iana" }, "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] }, "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] }, "text/vnd.iptc.newsml": { source: "iana" }, "text/vnd.iptc.nitf": { source: "iana" }, "text/vnd.latex-z": { source: "iana" }, "text/vnd.motorola.reflex": { source: "iana" }, "text/vnd.ms-mediapackage": { source: "iana" }, "text/vnd.net2phone.commcenter.command": { source: "iana" }, "text/vnd.radisys.msml-basic-layout": { source: "iana" }, "text/vnd.senx.warpscript": { source: "iana" }, "text/vnd.si.uricatalogue": { source: "iana" }, "text/vnd.sosi": { source: "iana" }, "text/vnd.sun.j2me.app-descriptor": { source: "iana", charset: "UTF-8", extensions: ["jad"] }, "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" }, "text/vnd.wap.si": { source: "iana" }, "text/vnd.wap.sl": { source: "iana" }, "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] }, "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] }, "text/vtt": { source: "iana", charset: "UTF-8", compressible: true, extensions: ["vtt"] }, "text/x-asm": { source: "apache", extensions: ["s", "asm"] }, "text/x-c": { source: "apache", extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] }, "text/x-component": { source: "nginx", extensions: ["htc"] }, "text/x-fortran": { source: "apache", extensions: ["f", "for", "f77", "f90"] }, "text/x-gwt-rpc": { compressible: true }, "text/x-handlebars-template": { extensions: ["hbs"] }, "text/x-java-source": { source: "apache", extensions: ["java"] }, "text/x-jquery-tmpl": { compressible: true }, "text/x-lua": { extensions: ["lua"] }, "text/x-markdown": { compressible: true, extensions: ["mkd"] }, "text/x-nfo": { source: "apache", extensions: ["nfo"] }, "text/x-opml": { source: "apache", extensions: ["opml"] }, "text/x-org": { compressible: true, extensions: ["org"] }, "text/x-pascal": { source: "apache", extensions: ["p", "pas"] }, "text/x-processing": { compressible: true, extensions: ["pde"] }, "text/x-sass": { extensions: ["sass"] }, "text/x-scss": { extensions: ["scss"] }, "text/x-setext": { source: "apache", extensions: ["etx"] }, "text/x-sfv": { source: "apache", extensions: ["sfv"] }, "text/x-suse-ymp": { compressible: true, extensions: ["ymp"] }, "text/x-uuencode": { source: "apache", extensions: ["uu"] }, "text/x-vcalendar": { source: "apache", extensions: ["vcs"] }, "text/x-vcard": { source: "apache", extensions: ["vcf"] }, "text/xml": { source: "iana", compressible: true, extensions: ["xml"] }, "text/xml-external-parsed-entity": { source: "iana" }, "text/yaml": { compressible: true, extensions: ["yaml", "yml"] }, "video/1d-interleaved-parityfec": { source: "iana" }, "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] }, "video/3gpp-tt": { source: "iana" }, "video/3gpp2": { source: "iana", extensions: ["3g2"] }, "video/av1": { source: "iana" }, "video/bmpeg": { source: "iana" }, "video/bt656": { source: "iana" }, "video/celb": { source: "iana" }, "video/dv": { source: "iana" }, "video/encaprtp": { source: "iana" }, "video/ffv1": { source: "iana" }, "video/flexfec": { source: "iana" }, "video/h261": { source: "iana", extensions: ["h261"] }, "video/h263": { source: "iana", extensions: ["h263"] }, "video/h263-1998": { source: "iana" }, "video/h263-2000": { source: "iana" }, "video/h264": { source: "iana", extensions: ["h264"] }, "video/h264-rcdo": { source: "iana" }, "video/h264-svc": { source: "iana" }, "video/h265": { source: "iana" }, "video/iso.segment": { source: "iana", extensions: ["m4s"] }, "video/jpeg": { source: "iana", extensions: ["jpgv"] }, "video/jpeg2000": { source: "iana" }, "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] }, "video/jxsv": { source: "iana" }, "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] }, "video/mp1s": { source: "iana" }, "video/mp2p": { source: "iana" }, "video/mp2t": { source: "iana", extensions: ["ts"] }, "video/mp4": { source: "iana", compressible: false, extensions: ["mp4", "mp4v", "mpg4"] }, "video/mp4v-es": { source: "iana" }, "video/mpeg": { source: "iana", compressible: false, extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"] }, "video/mpeg4-generic": { source: "iana" }, "video/mpv": { source: "iana" }, "video/nv": { source: "iana" }, "video/ogg": { source: "iana", compressible: false, extensions: ["ogv"] }, "video/parityfec": { source: "iana" }, "video/pointer": { source: "iana" }, "video/quicktime": { source: "iana", compressible: false, extensions: ["qt", "mov"] }, "video/raptorfec": { source: "iana" }, "video/raw": { source: "iana" }, "video/rtp-enc-aescm128": { source: "iana" }, "video/rtploopback": { source: "iana" }, "video/rtx": { source: "iana" }, "video/scip": { source: "iana" }, "video/smpte291": { source: "iana" }, "video/smpte292m": { source: "iana" }, "video/ulpfec": { source: "iana" }, "video/vc1": { source: "iana" }, "video/vc2": { source: "iana" }, "video/vnd.cctv": { source: "iana" }, "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] }, "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] }, "video/vnd.dece.mp4": { source: "iana" }, "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] }, "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] }, "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] }, "video/vnd.directv.mpeg": { source: "iana" }, "video/vnd.directv.mpeg-tts": { source: "iana" }, "video/vnd.dlna.mpeg-tts": { source: "iana" }, "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] }, "video/vnd.fvt": { source: "iana", extensions: ["fvt"] }, "video/vnd.hns.video": { source: "iana" }, "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" }, "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" }, "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" }, "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" }, "video/vnd.iptvforum.ttsavc": { source: "iana" }, "video/vnd.iptvforum.ttsmpeg2": { source: "iana" }, "video/vnd.motorola.video": { source: "iana" }, "video/vnd.motorola.videop": { source: "iana" }, "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] }, "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] }, "video/vnd.nokia.interleaved-multimedia": { source: "iana" }, "video/vnd.nokia.mp4vr": { source: "iana" }, "video/vnd.nokia.videovoip": { source: "iana" }, "video/vnd.objectvideo": { source: "iana" }, "video/vnd.radgamettools.bink": { source: "iana" }, "video/vnd.radgamettools.smacker": { source: "iana" }, "video/vnd.sealed.mpeg1": { source: "iana" }, "video/vnd.sealed.mpeg4": { source: "iana" }, "video/vnd.sealed.swf": { source: "iana" }, "video/vnd.sealedmedia.softseal.mov": { source: "iana" }, "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] }, "video/vnd.vivo": { source: "iana", extensions: ["viv"] }, "video/vnd.youtube.yt": { source: "iana" }, "video/vp8": { source: "iana" }, "video/vp9": { source: "iana" }, "video/webm": { source: "apache", compressible: false, extensions: ["webm"] }, "video/x-f4v": { source: "apache", extensions: ["f4v"] }, "video/x-fli": { source: "apache", extensions: ["fli"] }, "video/x-flv": { source: "apache", compressible: false, extensions: ["flv"] }, "video/x-m4v": { source: "apache", extensions: ["m4v"] }, "video/x-matroska": { source: "apache", compressible: false, extensions: ["mkv", "mk3d", "mks"] }, "video/x-mng": { source: "apache", extensions: ["mng"] }, "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] }, "video/x-ms-vob": { source: "apache", extensions: ["vob"] }, "video/x-ms-wm": { source: "apache", extensions: ["wm"] }, "video/x-ms-wmv": { source: "apache", compressible: false, extensions: ["wmv"] }, "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] }, "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] }, "video/x-msvideo": { source: "apache", extensions: ["avi"] }, "video/x-sgi-movie": { source: "apache", extensions: ["movie"] }, "video/x-smv": { source: "apache", extensions: ["smv"] }, "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] }, "x-shader/x-fragment": { compressible: true }, "x-shader/x-vertex": { compressible: true } } })), mimeTypes = createCommonjsModule((function(module, exports$1) {
  var extname = path.extname, EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/, TEXT_TYPE_REGEXP = /^text\//i;
  function charset(type2) {
    if (!type2 || "string" != typeof type2) return false;
    var match = EXTRACT_TYPE_REGEXP.exec(type2), mime = match && mimeDb[match[1].toLowerCase()];
    return mime && mime.charset ? mime.charset : !(!match || !TEXT_TYPE_REGEXP.test(match[1])) && "UTF-8";
  }
  exports$1.charset = charset, exports$1.charsets = { lookup: charset }, exports$1.contentType = function(str) {
    if (!str || "string" != typeof str) return false;
    var mime = -1 === str.indexOf("/") ? exports$1.lookup(str) : str;
    if (!mime) return false;
    if (-1 === mime.indexOf("charset")) {
      var charset2 = exports$1.charset(mime);
      charset2 && (mime += "; charset=" + charset2.toLowerCase());
    }
    return mime;
  }, exports$1.extension = function(type2) {
    if (!type2 || "string" != typeof type2) return false;
    var match = EXTRACT_TYPE_REGEXP.exec(type2), exts = match && exports$1.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) return false;
    return exts[0];
  }, exports$1.extensions = /* @__PURE__ */ Object.create(null), exports$1.lookup = function(path2) {
    if (!path2 || "string" != typeof path2) return false;
    var extension = extname("x." + path2).toLowerCase().substr(1);
    if (!extension) return false;
    return exports$1.types[extension] || false;
  }, exports$1.types = /* @__PURE__ */ Object.create(null), (function(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(mimeDb).forEach((function(type2) {
      var mime = mimeDb[type2], exts = mime.extensions;
      if (exts && exts.length) {
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension = exts[i];
          if (types2[extension]) {
            var from = preference.indexOf(mimeDb[types2[extension]].source), to = preference.indexOf(mime.source);
            if ("application/octet-stream" !== types2[extension] && (from > to || from === to && "application/" === types2[extension].substr(0, 12))) continue;
          }
          types2[extension] = type2;
        }
      }
    }));
  })(exports$1.extensions, exports$1.types);
}));
mimeTypes.charset, mimeTypes.charsets, mimeTypes.contentType, mimeTypes.extension, mimeTypes.extensions, mimeTypes.lookup, mimeTypes.types;
const rgbRegex = /rgb\((\d+),\s*([\d.]+),\s*([\d.]+)\)/i, hslRegex = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/i, hexRegex = /#([0-9A-F]{6})/i, hex3Regex = /#([0-9A-F])([0-9A-F])([0-9A-F])/i, rgbToHex = (red, green, blue) => [red, green, blue].map(((x) => 1 === (x = parseInt(x).toString(16)).length ? `0${x}` : x)).join(""), pixelRegex = /([\d.]+)px/i, percentageRegex = /([\d.]+)%/i, pointRegex = /([\d.]+)pt/i, cmRegex = /([\d.]+)cm/i, inchRegex = /([\d.]+)in/i, pixelToEMU = (pixelValue) => Math.round(9525 * pixelValue), EMUToTWIP = (EMUValue) => Math.round(EMUValue / 635), pointToTWIP = (pointValue) => Math.round(20 * pointValue), pointToHIP = (pointValue) => Math.round(2 * pointValue), pixelToTWIP = (pixelValue) => EMUToTWIP(pixelToEMU(pixelValue)), pixelToHIP = (pixelValue) => {
  return TWIPValue = EMUToTWIP(pixelToEMU(pixelValue)), Math.round(TWIPValue / 10);
  var TWIPValue;
}, inchToTWIP = (inchValue) => pointToTWIP(((inchValue2) => Math.round(72 * inchValue2))(inchValue)), cmToTWIP = (cmValue) => inchToTWIP(((cmValue2) => 0.3937008 * cmValue2)(cmValue)), pixelToPoint = (pixelValue) => {
  return HIPValue = pixelToHIP(pixelValue), Math.round(HIPValue / 2);
  var HIPValue;
}, pointToEIP = (PointValue) => Math.round(8 * PointValue), vNodeHasChildren = (vNode) => vNode && vNode.children && Array.isArray(vNode.children) && vNode.children.length, isValidUrl = (urlString) => Boolean(new RegExp("http(s)?:\\/\\/(\\w+:?\\w*@)?(\\S+)(:\\d+)?((?<=\\.)\\w+)+(\\/([\\w#!:.?+=&%@!\\-/])*)?", "gi").test(urlString)), fixupColorCode = (colorCodeString) => {
  if (Object.prototype.hasOwnProperty.call(colorNames, colorCodeString.toLowerCase())) {
    const [red, green, blue] = colorNames[colorCodeString.toLowerCase()];
    return rgbToHex(red, green, blue);
  }
  if (rgbRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(rgbRegex), red = matchedParts[1], green = matchedParts[2], blue = matchedParts[3];
    return rgbToHex(red, green, blue);
  }
  if (hslRegex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hslRegex);
    return ((hue, saturation, luminosity) => {
      let red, green, blue;
      if (hue /= 360, luminosity /= 100, 0 == (saturation /= 100)) red = green = blue = luminosity;
      else {
        const hue2rgb = (p2, q2, t) => (t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p2 + 6 * (q2 - p2) * t : t < 0.5 ? q2 : t < 2 / 3 ? p2 + (q2 - p2) * (2 / 3 - t) * 6 : p2), q = luminosity < 0.5 ? luminosity * (1 + saturation) : luminosity + saturation - luminosity * saturation, p = 2 * luminosity - q;
        red = hue2rgb(p, q, hue + 1 / 3), green = hue2rgb(p, q, hue), blue = hue2rgb(p, q, hue - 1 / 3);
      }
      return [red, green, blue].map(((x) => {
        const hex = Math.round(255 * x).toString(16);
        return 1 === hex.length ? `0${hex}` : hex;
      })).join("");
    })(matchedParts[1], matchedParts[2], matchedParts[3]);
  }
  if (hexRegex.test(colorCodeString)) {
    return colorCodeString.match(hexRegex)[1];
  }
  if (hex3Regex.test(colorCodeString)) {
    const matchedParts = colorCodeString.match(hex3Regex);
    return ((red, green, blue) => [red, green, blue].map(((x) => `${x}${x}`)).join(""))(matchedParts[1], matchedParts[2], matchedParts[3]);
  }
  return "000000";
}, buildRunFontFragment = (fontName = "Times New Roman") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "rFonts").att("@w", "ascii", fontName).att("@w", "hAnsi", fontName).up(), buildShading = (colorCode) => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "shd").att("@w", "val", "clear").att("@w", "fill", colorCode).up(), buildHighlight = (color = "yellow") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "highlight").att("@w", "val", color).up(), buildVertAlign = (type2 = "baseline") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "vertAlign").att("@w", "val", type2).up(), buildBorder = (borderSide = "top", borderSize = 0, borderSpacing = 0, borderColor = fixupColorCode("black"), borderStroke = "single") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", borderSide).att("@w", "val", borderStroke).att("@w", "sz", borderSize).att("@w", "space", borderSpacing).att("@w", "color", borderColor).up(), buildTextElement = (text) => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "t").att("@xml", "space", "preserve").txt(text).up(), fixupLineHeight = (lineHeight, fontSize) => {
  if (isNaN(lineHeight)) return 240;
  if (fontSize) {
    return HIPValue = +lineHeight * fontSize, Math.round(10 * HIPValue);
  }
  return 240 * +lineHeight;
  var HIPValue;
}, fixupFontSize$1 = (fontSizeString) => {
  if (pointRegex.test(fontSizeString)) {
    const matchedParts = fontSizeString.match(pointRegex);
    return pointToHIP(matchedParts[1]);
  }
  if (pixelRegex.test(fontSizeString)) {
    const matchedParts = fontSizeString.match(pixelRegex);
    return pixelToHIP(matchedParts[1]);
  }
}, fixupMargin = (marginString) => {
  if (pointRegex.test(marginString)) {
    const matchedParts = marginString.match(pointRegex);
    return pointToTWIP(matchedParts[1]);
  }
  if (pixelRegex.test(marginString)) {
    const matchedParts = marginString.match(pixelRegex);
    return pixelToTWIP(matchedParts[1]);
  }
}, modifiedStyleAttributesBuilder = (docxDocumentInstance, vNode, attributes, options) => {
  const modifiedAttributes = { ...attributes };
  if (isVnode(vNode) && vNode.properties && vNode.properties.style) {
    if (vNode.properties.style.color && !colorlessColors.includes(vNode.properties.style.color) && (modifiedAttributes.color = fixupColorCode(vNode.properties.style.color)), vNode.properties.style["background-color"] && !colorlessColors.includes(vNode.properties.style["background-color"]) && (modifiedAttributes.backgroundColor = fixupColorCode(vNode.properties.style["background-color"])), vNode.properties.style["vertical-align"] && verticalAlignValues.includes(vNode.properties.style["vertical-align"]) && (modifiedAttributes.verticalAlign = vNode.properties.style["vertical-align"]), vNode.properties.style["text-align"] && ["left", "right", "center", "justify"].includes(vNode.properties.style["text-align"]) && (modifiedAttributes.textAlign = vNode.properties.style["text-align"]), vNode.properties.style["font-weight"] && "bold" === vNode.properties.style["font-weight"] && (modifiedAttributes.strong = vNode.properties.style["font-weight"]), vNode.properties.style["font-family"] && (modifiedAttributes.font = docxDocumentInstance.createFont(vNode.properties.style["font-family"])), vNode.properties.style["font-size"] && (modifiedAttributes.fontSize = fixupFontSize$1(vNode.properties.style["font-size"])), vNode.properties.style["line-height"] && (modifiedAttributes.lineHeight = fixupLineHeight(vNode.properties.style["line-height"], vNode.properties.style["font-size"] ? fixupFontSize$1(vNode.properties.style["font-size"]) : null)), vNode.properties.style["margin-left"] || vNode.properties.style["margin-right"]) {
      const leftMargin = fixupMargin(vNode.properties.style["margin-left"]), rightMargin = fixupMargin(vNode.properties.style["margin-right"]), indentation = {};
      leftMargin && (indentation.left = leftMargin), rightMargin && (indentation.right = rightMargin), (leftMargin || rightMargin) && (modifiedAttributes.indentation = indentation);
    }
    vNode.properties.style.display && (modifiedAttributes.display = vNode.properties.style.display), vNode.properties.style.width && (modifiedAttributes.width = vNode.properties.style.width);
  }
  return options && options.isParagraph && (isVnode(vNode) && "blockquote" === vNode.tagName ? (modifiedAttributes.indentation = { left: 284 }, modifiedAttributes.textAlign = "justify") : isVnode(vNode) && "code" === vNode.tagName ? modifiedAttributes.highlightColor = "lightGray" : isVnode(vNode) && "pre" === vNode.tagName && (modifiedAttributes.font = "Courier")), modifiedAttributes;
}, buildFormatting = (htmlTag, options) => {
  switch (htmlTag) {
    case "strong":
    case "b":
      return libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "b").up();
    case "em":
    case "i":
      return libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "i").up();
    case "ins":
    case "u":
      return ((type2 = "single") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "u").att("@w", "val", type2).up())();
    case "strike":
    case "del":
    case "s":
      return libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "strike").att("@w", "val", true).up();
    case "sub":
      return buildVertAlign("subscript");
    case "sup":
      return buildVertAlign("superscript");
    case "mark":
      return buildHighlight();
    case "code":
      return buildHighlight("lightGray");
    case "highlightColor":
      return buildHighlight(options && options.color ? options.color : "lightGray");
    case "font":
      return buildRunFontFragment(options.font);
    case "pre":
      return buildRunFontFragment("Courier");
    case "color":
      return colorCode = options && options.color ? options.color : "black", libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "color").att("@w", "val", colorCode).up();
    case "backgroundColor":
      return buildShading(options && options.color ? options.color : "black");
    case "fontSize":
      return fontSize = options && options.fontSize ? options.fontSize : 10, libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "sz").att("@w", "val", fontSize).up();
    case "hyperlink":
      return ((type2 = "Hyperlink") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "rStyle").att("@w", "val", type2).up())("Hyperlink");
  }
  var fontSize, colorCode;
  return null;
}, buildRunProperties = (attributes) => {
  const runPropertiesFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "rPr");
  return attributes && attributes.constructor === Object && Object.keys(attributes).forEach(((key) => {
    const options = {};
    "color" !== key && "backgroundColor" !== key && "highlightColor" !== key || (options.color = attributes[key]), "fontSize" !== key && "font" !== key || (options[key] = attributes[key]);
    const formattingFragment = buildFormatting(key, options);
    formattingFragment && runPropertiesFragment.import(formattingFragment);
  })), runPropertiesFragment.up(), runPropertiesFragment;
}, buildRun = async (vNode, attributes, docxDocumentInstance) => {
  const runFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "r"), runPropertiesFragment = buildRunProperties(lodash.cloneDeep(attributes));
  if (isVnode(vNode) && "span" === vNode.tagName) return buildRunOrRuns(vNode, attributes, docxDocumentInstance);
  if (isVnode(vNode) && ["strong", "b", "em", "i", "u", "ins", "strike", "del", "s", "sub", "sup", "mark", "blockquote", "code", "pre"].includes(vNode.tagName)) {
    const runFragmentsArray = [];
    let vNodes = [vNode], tempAttributes = lodash.cloneDeep(attributes), tempRunFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "r");
    for (; vNodes.length; ) {
      const tempVNode = vNodes.shift();
      if (isVtext(tempVNode)) {
        const textFragment = buildTextElement(tempVNode.text), tempRunPropertiesFragment = buildRunProperties({ ...attributes, ...tempAttributes });
        tempRunFragment.import(tempRunPropertiesFragment), tempRunFragment.import(textFragment), runFragmentsArray.push(tempRunFragment), tempAttributes = lodash.cloneDeep(attributes), tempRunFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "r");
      } else if (isVnode(tempVNode)) {
        if (["strong", "b", "em", "i", "u", "ins", "strike", "del", "s", "sub", "sup", "mark", "code", "pre"].includes(tempVNode.tagName)) {
          switch (tempAttributes = {}, tempVNode.tagName) {
            case "strong":
            case "b":
              tempAttributes.strong = true;
              break;
            case "i":
              tempAttributes.i = true;
              break;
            case "u":
              tempAttributes.u = true;
              break;
            case "sub":
              tempAttributes.sub = true;
              break;
            case "sup":
              tempAttributes.sup = true;
          }
          const formattingFragment = buildFormatting(tempVNode);
          formattingFragment && runPropertiesFragment.import(formattingFragment);
        } else if ("span" === tempVNode.tagName) {
          const spanFragment = await buildRunOrRuns(tempVNode, { ...attributes, ...tempAttributes }, docxDocumentInstance);
          Array.isArray(spanFragment) ? (spanFragment.flat(1 / 0), runFragmentsArray.push(...spanFragment)) : runFragmentsArray.push(spanFragment);
          continue;
        }
      }
      tempVNode.children && tempVNode.children.length && (tempVNode.children.length > 1 && (attributes = { ...attributes, ...tempAttributes }), vNodes = tempVNode.children.slice().concat(vNodes));
    }
    if (runFragmentsArray.length) return runFragmentsArray;
  }
  if (runFragment.import(runPropertiesFragment), isVtext(vNode)) {
    const textFragment = buildTextElement(vNode.text);
    runFragment.import(textFragment);
  } else if (attributes && "picture" === attributes.type) {
    let response = null;
    const base64Uri = decodeURIComponent(vNode.properties.src);
    if (base64Uri && (response = docxDocumentInstance.createMediaFile(base64Uri)), response) {
      docxDocumentInstance.zip.folder("word").folder("media").file(response.fileNameWithExtension, Buffer.from(response.fileContent, "base64"), { createFolders: false });
      const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, "image", `media/${response.fileNameWithExtension}`, "Internal");
      attributes.inlineOrAnchored = true, attributes.relationshipId = documentRelsId, attributes.id = response.id, attributes.fileContent = response.fileContent, attributes.fileNameWithExtension = response.fileNameWithExtension;
    }
    const { type: type2, inlineOrAnchored, ...otherAttributes } = attributes, imageFragment = buildDrawing(inlineOrAnchored, type2, otherAttributes);
    runFragment.import(imageFragment);
  } else if (isVnode(vNode) && "br" === vNode.tagName) {
    const lineBreakFragment = ((type2 = "textWrapping") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "br").att("@w", "type", type2).up())();
    runFragment.import(lineBreakFragment);
  }
  return runFragment.up(), runFragment;
}, buildRunOrRuns = async (vNode, attributes, docxDocumentInstance) => {
  if (isVnode(vNode) && "span" === vNode.tagName) {
    let runFragments = [];
    for (let index = 0; index < vNode.children.length; index++) {
      const childVNode = vNode.children[index], modifiedAttributes = modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes), tempRunFragments = await buildRun(childVNode, modifiedAttributes, docxDocumentInstance);
      runFragments = runFragments.concat(Array.isArray(tempRunFragments) ? tempRunFragments : [tempRunFragments]);
    }
    return runFragments;
  }
  return await buildRun(vNode, attributes, docxDocumentInstance);
}, buildRunOrHyperLink = async (vNode, attributes, docxDocumentInstance) => {
  if (isVnode(vNode) && "a" === vNode.tagName) {
    const relationshipId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, "hyperlink", vNode.properties && vNode.properties.href ? vNode.properties.href : ""), hyperlinkFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w, r: namespaces_r } }).ele("@w", "hyperlink").att("@r", "id", `rId${relationshipId}`), modifiedAttributes = { ...attributes };
    modifiedAttributes.hyperlink = true;
    const runFragments = await buildRunOrRuns(vNode.children[0], modifiedAttributes, docxDocumentInstance);
    if (Array.isArray(runFragments)) for (let index = 0; index < runFragments.length; index++) {
      const runFragment = runFragments[index];
      hyperlinkFragment.import(runFragment);
    }
    else hyperlinkFragment.import(runFragments);
    return hyperlinkFragment.up(), hyperlinkFragment;
  }
  return await buildRunOrRuns(vNode, attributes, docxDocumentInstance);
}, buildHorizontalAlignment = (horizontalAlignment) => ("justify" === horizontalAlignment && (horizontalAlignment = "both"), libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "jc").att("@w", "val", horizontalAlignment).up()), buildParagraphProperties = (attributes) => {
  const paragraphPropertiesFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "pPr");
  if (attributes && attributes.constructor === Object) {
    Object.keys(attributes).forEach(((key) => {
      switch (key) {
        case "numbering":
          const { levelId, numberingId } = attributes[key], numberingPropertiesFragment = ((levelId2, numberingId2) => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "numPr").ele("@w", "ilvl").att("@w", "val", String(levelId2)).up().ele("@w", "numId").att("@w", "val", String(numberingId2)).up().up())(levelId, numberingId);
          paragraphPropertiesFragment.import(numberingPropertiesFragment), delete attributes.numbering;
          break;
        case "textAlign":
          const horizontalAlignmentFragment = buildHorizontalAlignment(attributes[key]);
          paragraphPropertiesFragment.import(horizontalAlignmentFragment), delete attributes.textAlign;
          break;
        case "backgroundColor":
          if ("block" === attributes.display) {
            const shadingFragment = buildShading(attributes[key]);
            paragraphPropertiesFragment.import(shadingFragment);
            const paragraphBorderFragment = (() => {
              const paragraphBorderFragment2 = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "pBdr"), bordersObject = lodash.cloneDeep(paragraphBordersObject);
              return Object.keys(bordersObject).forEach(((borderName) => {
                if (bordersObject[borderName]) {
                  const { size, spacing, color } = bordersObject[borderName], borderFragment = buildBorder(borderName, size, spacing, color);
                  paragraphBorderFragment2.import(borderFragment);
                }
              })), paragraphBorderFragment2.up(), paragraphBorderFragment2;
            })();
            paragraphPropertiesFragment.import(paragraphBorderFragment), delete attributes.backgroundColor;
          }
          break;
        case "paragraphStyle":
          const pStyleFragment = ((style = "Normal") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "pStyle").att("@w", "val", style).up())(attributes.paragraphStyle);
          paragraphPropertiesFragment.import(pStyleFragment), delete attributes.paragraphStyle;
          break;
        case "indentation":
          const indentationFragment = (({ left, right }) => {
            const indentationFragment2 = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "ind");
            return left && indentationFragment2.att("@w", "left", left), right && indentationFragment2.att("@w", "right", right), indentationFragment2.up(), indentationFragment2;
          })(attributes[key]);
          paragraphPropertiesFragment.import(indentationFragment), delete attributes.indentation;
      }
    }));
    const spacingFragment = ((lineSpacing, beforeSpacing, afterSpacing) => {
      const spacingFragment2 = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "spacing");
      return lineSpacing && spacingFragment2.att("@w", "line", lineSpacing), beforeSpacing && spacingFragment2.att("@w", "before", beforeSpacing), afterSpacing && spacingFragment2.att("@w", "after", afterSpacing), spacingFragment2.att("@w", "lineRule", "auto").up(), spacingFragment2;
    })(attributes.lineHeight, attributes.beforeSpacing, attributes.afterSpacing);
    delete attributes.lineHeight, delete attributes.beforeSpacing, delete attributes.afterSpacing, paragraphPropertiesFragment.import(spacingFragment);
  }
  return paragraphPropertiesFragment.up(), paragraphPropertiesFragment;
}, computeImageDimensions = (vNode, attributes) => {
  const { maximumWidth, originalWidth, originalHeight } = attributes, aspectRatio = originalWidth / originalHeight, maximumWidthInEMU = (TWIPValue = maximumWidth, Math.round(635 * TWIPValue));
  var TWIPValue;
  let modifiedHeight, modifiedWidth, originalWidthInEMU = pixelToEMU(originalWidth), originalHeightInEMU = pixelToEMU(originalHeight);
  if (originalWidthInEMU > maximumWidthInEMU && (originalWidthInEMU = maximumWidthInEMU, originalHeightInEMU = Math.round(originalWidthInEMU / aspectRatio)), vNode.properties && vNode.properties.style) {
    if (vNode.properties.style.width) if ("auto" !== vNode.properties.style.width) {
      if (pixelRegex.test(vNode.properties.style.width)) modifiedWidth = pixelToEMU(vNode.properties.style.width.match(pixelRegex)[1]);
      else if (percentageRegex.test(vNode.properties.style.width)) {
        const percentageValue = vNode.properties.style.width.match(percentageRegex)[1];
        modifiedWidth = Math.round(percentageValue / 100 * originalWidthInEMU);
      }
    } else vNode.properties.style.height && "auto" === vNode.properties.style.height && (modifiedWidth = originalWidthInEMU, modifiedHeight = originalHeightInEMU);
    if (vNode.properties.style.height) if ("auto" !== vNode.properties.style.height) {
      if (pixelRegex.test(vNode.properties.style.height)) modifiedHeight = pixelToEMU(vNode.properties.style.height.match(pixelRegex)[1]);
      else if (percentageRegex.test(vNode.properties.style.height)) {
        const percentageValue = vNode.properties.style.width.match(percentageRegex)[1];
        modifiedHeight = Math.round(percentageValue / 100 * originalHeightInEMU), modifiedWidth || (modifiedWidth = Math.round(modifiedHeight * aspectRatio));
      }
    } else modifiedWidth ? modifiedHeight || (modifiedHeight = Math.round(modifiedWidth / aspectRatio)) : (modifiedHeight = originalHeightInEMU, modifiedWidth = originalWidthInEMU);
    modifiedWidth && !modifiedHeight ? modifiedHeight = Math.round(modifiedWidth / aspectRatio) : modifiedHeight && !modifiedWidth && (modifiedWidth = Math.round(modifiedHeight * aspectRatio));
  } else modifiedWidth = originalWidthInEMU, modifiedHeight = originalHeightInEMU;
  attributes.width = modifiedWidth, attributes.height = modifiedHeight;
}, buildParagraph = async (vNode, attributes, docxDocumentInstance) => {
  const paragraphFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "p"), modifiedAttributes = modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes, { isParagraph: true }), paragraphPropertiesFragment = buildParagraphProperties(modifiedAttributes);
  if (paragraphFragment.import(paragraphPropertiesFragment), isVnode(vNode) && vNodeHasChildren(vNode)) if (["span", "strong", "b", "em", "i", "u", "ins", "strike", "del", "s", "sub", "sup", "mark", "a", "code", "pre"].includes(vNode.tagName)) {
    const runOrHyperlinkFragments = await buildRunOrHyperLink(vNode, modifiedAttributes, docxDocumentInstance);
    if (Array.isArray(runOrHyperlinkFragments)) for (let iteratorIndex = 0; iteratorIndex < runOrHyperlinkFragments.length; iteratorIndex++) {
      const runOrHyperlinkFragment = runOrHyperlinkFragments[iteratorIndex];
      paragraphFragment.import(runOrHyperlinkFragment);
    }
    else paragraphFragment.import(runOrHyperlinkFragments);
  } else if ("blockquote" === vNode.tagName) {
    const runFragmentOrFragments = await buildRun(vNode, attributes);
    if (Array.isArray(runFragmentOrFragments)) for (let index = 0; index < runFragmentOrFragments.length; index++) paragraphFragment.import(runFragmentOrFragments[index]);
    else paragraphFragment.import(runFragmentOrFragments);
  } else for (let index = 0; index < vNode.children.length; index++) {
    const childVNode = vNode.children[index];
    if ("img" === childVNode.tagName) {
      let base64String;
      const imageSource = childVNode.properties.src;
      if (isValidUrl(imageSource)) {
        if (base64String = await imageToBase64_min(imageSource).catch(((error) => {
          console.warning(`skipping image download and conversion due to ${error}`);
        })), !base64String || !mimeTypes.lookup(imageSource)) break;
        childVNode.properties.src = `data:${mimeTypes.lookup(imageSource)};base64, ${base64String}`;
      } else base64String = imageSource.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/)[2];
      const imageBuffer = Buffer.from(decodeURIComponent(base64String), "base64"), imageProperties = sizeOf(imageBuffer);
      modifiedAttributes.maximumWidth = modifiedAttributes.maximumWidth || docxDocumentInstance.availableDocumentSpace, modifiedAttributes.originalWidth = imageProperties.width, modifiedAttributes.originalHeight = imageProperties.height, computeImageDimensions(childVNode, modifiedAttributes);
    }
    const runOrHyperlinkFragments = await buildRunOrHyperLink(childVNode, isVnode(childVNode) && "img" === childVNode.tagName ? { ...modifiedAttributes, type: "picture", description: childVNode.properties.alt } : modifiedAttributes, docxDocumentInstance);
    if (Array.isArray(runOrHyperlinkFragments)) for (let iteratorIndex = 0; iteratorIndex < runOrHyperlinkFragments.length; iteratorIndex++) {
      const runOrHyperlinkFragment = runOrHyperlinkFragments[iteratorIndex];
      paragraphFragment.import(runOrHyperlinkFragment);
    }
    else paragraphFragment.import(runOrHyperlinkFragments);
  }
  else {
    if (isVnode(vNode) && "img" === vNode.tagName) {
      const imageSource = vNode.properties.src;
      let base64String = imageSource;
      if (isValidUrl(imageSource)) {
        if (base64String = await imageToBase64_min(imageSource).catch(((error) => {
          console.warning(`skipping image download and conversion due to ${error}`);
        })), !base64String || !mimeTypes.lookup(imageSource)) return paragraphFragment.up(), paragraphFragment;
        vNode.properties.src = `data:${mimeTypes.lookup(imageSource)};base64, ${base64String}`;
      } else base64String = base64String.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/)[2];
      const imageBuffer = Buffer.from(decodeURIComponent(base64String), "base64"), imageProperties = sizeOf(imageBuffer);
      modifiedAttributes.maximumWidth = modifiedAttributes.maximumWidth || docxDocumentInstance.availableDocumentSpace, modifiedAttributes.originalWidth = imageProperties.width, modifiedAttributes.originalHeight = imageProperties.height, computeImageDimensions(vNode, modifiedAttributes);
    }
    const runFragments = await buildRunOrRuns(vNode, modifiedAttributes, docxDocumentInstance);
    if (Array.isArray(runFragments)) for (let index = 0; index < runFragments.length; index++) {
      const runFragment = runFragments[index];
      paragraphFragment.import(runFragment);
    }
    else paragraphFragment.import(runFragments);
  }
  return paragraphFragment.up(), paragraphFragment;
}, buildTableCellWidth = (tableCellWidth) => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tcW").att("@w", "w", ((columnWidthString) => {
  if (pointRegex.test(columnWidthString)) {
    const matchedParts = columnWidthString.match(pointRegex);
    return pointToTWIP(matchedParts[1]);
  }
  if (pixelRegex.test(columnWidthString)) {
    const matchedParts = columnWidthString.match(pixelRegex);
    return pixelToTWIP(matchedParts[1]);
  }
  if (cmRegex.test(columnWidthString)) {
    const matchedParts = columnWidthString.match(cmRegex);
    return cmToTWIP(matchedParts[1]);
  }
  if (inchRegex.test(columnWidthString)) {
    const matchedParts = columnWidthString.match(inchRegex);
    return inchToTWIP(matchedParts[1]);
  }
})(tableCellWidth)).att("@w", "type", "dxa").up(), buildTableCellProperties = (attributes) => {
  const tableCellPropertiesFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tcPr");
  return attributes && attributes.constructor === Object && Object.keys(attributes).forEach(((key) => {
    switch (key) {
      case "backgroundColor":
        const shadingFragment = buildShading(attributes[key]);
        tableCellPropertiesFragment.import(shadingFragment), delete attributes.backgroundColor;
        break;
      case "verticalAlign":
        const verticalAlignmentFragment = ("middle" === (verticalAlignment = attributes[key]).toLowerCase() && (verticalAlignment = "center"), libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "vAlign").att("@w", "val", verticalAlignment).up());
        tableCellPropertiesFragment.import(verticalAlignmentFragment), delete attributes.verticalAlign;
        break;
      case "colSpan":
        const gridSpanFragment = (spanValue = attributes[key], libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "gridSpan").att("@w", "val", spanValue).up());
        tableCellPropertiesFragment.import(gridSpanFragment), delete attributes.colSpan;
        break;
      case "tableCellBorder":
        const tableCellBorderFragment = ((tableCellBorder) => {
          const tableCellBordersFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tcBorders"), { color, stroke, ...borders } = tableCellBorder;
          return Object.keys(borders).forEach(((border) => {
            if (tableCellBorder[border]) {
              const borderFragment = buildBorder(border, tableCellBorder[border], 0, color, stroke);
              tableCellBordersFragment.import(borderFragment);
            }
          })), tableCellBordersFragment.up(), tableCellBordersFragment;
        })(attributes[key]);
        tableCellPropertiesFragment.import(tableCellBorderFragment), delete attributes.tableCellBorder;
        break;
      case "rowSpan":
        const verticalMergeFragment = ((verticalMerge = "continue") => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "vMerge").att("@w", "val", verticalMerge).up())(attributes[key]);
        tableCellPropertiesFragment.import(verticalMergeFragment), delete attributes.rowSpan;
        break;
      case "width":
        const widthFragment = buildTableCellWidth(attributes[key]);
        tableCellPropertiesFragment.import(widthFragment), delete attributes.width;
    }
    var spanValue, verticalAlignment;
  })), tableCellPropertiesFragment.up(), tableCellPropertiesFragment;
}, fixupTableCellBorder = (vNode, attributes) => {
  if (Object.prototype.hasOwnProperty.call(vNode.properties.style, "border")) if ("none" === vNode.properties.style.border || 0 === vNode.properties.style.border) attributes.tableCellBorder = {};
  else {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style.border);
    attributes.tableCellBorder = { top: borderSize, left: borderSize, bottom: borderSize, right: borderSize, color: borderColor, stroke: borderStroke };
  }
  if (vNode.properties.style["border-top"] && "0" === vNode.properties.style["border-top"]) attributes.tableCellBorder = { ...attributes.tableCellBorder, top: 0 };
  else if (vNode.properties.style["border-top"] && "0" !== vNode.properties.style["border-top"]) {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-top"]);
    attributes.tableCellBorder = { ...attributes.tableCellBorder, top: borderSize, color: borderColor, stroke: borderStroke };
  }
  if (vNode.properties.style["border-left"] && "0" === vNode.properties.style["border-left"]) attributes.tableCellBorder = { ...attributes.tableCellBorder, left: 0 };
  else if (vNode.properties.style["border-left"] && "0" !== vNode.properties.style["border-left"]) {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-left"]);
    attributes.tableCellBorder = { ...attributes.tableCellBorder, left: borderSize, color: borderColor, stroke: borderStroke };
  }
  if (vNode.properties.style["border-bottom"] && "0" === vNode.properties.style["border-bottom"]) attributes.tableCellBorder = { ...attributes.tableCellBorder, bottom: 0 };
  else if (vNode.properties.style["border-bottom"] && "0" !== vNode.properties.style["border-bottom"]) {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-bottom"]);
    attributes.tableCellBorder = { ...attributes.tableCellBorder, bottom: borderSize, color: borderColor, stroke: borderStroke };
  }
  if (vNode.properties.style["border-right"] && "0" === vNode.properties.style["border-right"]) attributes.tableCellBorder = { ...attributes.tableCellBorder, right: 0 };
  else if (vNode.properties.style["border-right"] && "0" !== vNode.properties.style["border-right"]) {
    const [borderSize, borderStroke, borderColor] = cssBorderParser(vNode.properties.style["border-right"]);
    attributes.tableCellBorder = { ...attributes.tableCellBorder, right: borderSize, color: borderColor, stroke: borderStroke };
  }
}, buildTableCell = async (vNode, attributes, rowSpanMap, columnIndex, docxDocumentInstance) => {
  const tableCellFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tc");
  let modifiedAttributes = { ...attributes };
  if (isVnode(vNode) && vNode.properties) {
    if (vNode.properties.rowSpan) rowSpanMap.set(columnIndex.index, { rowSpan: vNode.properties.rowSpan - 1, colSpan: 0 }), modifiedAttributes.rowSpan = "restart";
    else {
      const previousSpanObject = rowSpanMap.get(columnIndex.index);
      rowSpanMap.set(columnIndex.index, Object.assign({}, previousSpanObject, { rowSpan: 0, colSpan: previousSpanObject && previousSpanObject.colSpan || 0 }));
    }
    if (vNode.properties.colSpan || vNode.properties.style && vNode.properties.style["column-span"]) {
      modifiedAttributes.colSpan = vNode.properties.colSpan || vNode.properties.style && vNode.properties.style["column-span"];
      const previousSpanObject = rowSpanMap.get(columnIndex.index);
      rowSpanMap.set(columnIndex.index, Object.assign({}, previousSpanObject, { colSpan: parseInt(modifiedAttributes.colSpan) || 0 })), columnIndex.index += parseInt(modifiedAttributes.colSpan) - 1;
    }
    vNode.properties.style && (modifiedAttributes = { ...modifiedAttributes, ...modifiedStyleAttributesBuilder(docxDocumentInstance, vNode, attributes) }, fixupTableCellBorder(vNode, modifiedAttributes));
  }
  const tableCellPropertiesFragment = buildTableCellProperties(modifiedAttributes);
  if (tableCellFragment.import(tableCellPropertiesFragment), vNodeHasChildren(vNode)) for (let index = 0; index < vNode.children.length; index++) {
    const childVNode = vNode.children[index];
    if (isVnode(childVNode) && "img" === childVNode.tagName) {
      const imageFragment = await buildImage(docxDocumentInstance, childVNode, modifiedAttributes.maximumWidth);
      imageFragment && tableCellFragment.import(imageFragment);
    } else if (isVnode(childVNode) && "figure" === childVNode.tagName) {
      if (vNodeHasChildren(childVNode)) for (let iteratorIndex = 0; iteratorIndex < childVNode.children.length; iteratorIndex++) {
        const grandChildVNode = childVNode.children[iteratorIndex];
        if ("img" === grandChildVNode.tagName) {
          const imageFragment = await buildImage(docxDocumentInstance, grandChildVNode, modifiedAttributes.maximumWidth);
          imageFragment && tableCellFragment.import(imageFragment);
        }
      }
    } else if (isVnode(childVNode) && ["ul", "ol"].includes(childVNode.tagName)) vNodeHasChildren(childVNode) && await buildList(childVNode, docxDocumentInstance, tableCellFragment);
    else {
      const paragraphFragment = await buildParagraph(childVNode, modifiedAttributes, docxDocumentInstance);
      tableCellFragment.import(paragraphFragment);
    }
  }
  else {
    const paragraphFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "p").up();
    tableCellFragment.import(paragraphFragment);
  }
  return tableCellFragment.up(), tableCellFragment;
}, buildRowSpanCell = (rowSpanMap, columnIndex, attributes) => {
  const rowSpanCellFragments = [];
  let spanObject = rowSpanMap.get(columnIndex.index);
  for (; spanObject && spanObject.rowSpan; ) {
    const rowSpanCellFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tc"), tableCellPropertiesFragment = buildTableCellProperties({ ...attributes, rowSpan: "continue", colSpan: spanObject.colSpan ? spanObject.colSpan : 0 });
    rowSpanCellFragment.import(tableCellPropertiesFragment);
    const paragraphFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "p").up();
    rowSpanCellFragment.import(paragraphFragment), rowSpanCellFragment.up(), rowSpanCellFragments.push(rowSpanCellFragment), spanObject.rowSpan - 1 == 0 ? rowSpanMap.delete(columnIndex.index) : rowSpanMap.set(columnIndex.index, { rowSpan: spanObject.rowSpan - 1, colSpan: spanObject.colSpan || 0 }), columnIndex.index += spanObject.colSpan || 1, spanObject = rowSpanMap.get(columnIndex.index);
  }
  return rowSpanCellFragments;
}, buildTableRowProperties = (attributes) => {
  const tableRowPropertiesFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "trPr");
  return attributes && attributes.constructor === Object && Object.keys(attributes).forEach(((key) => {
    switch (key) {
      case "tableRowHeight":
        const tableRowHeightFragment = (tableRowHeight = attributes[key], libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "trHeight").att("@w", "val", tableRowHeight).att("@w", "hRule", "atLeast").up());
        tableRowPropertiesFragment.import(tableRowHeightFragment), delete attributes.tableRowHeight;
        break;
      case "rowCantSplit":
        if (attributes.rowCantSplit) {
          const cantSplitFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "cantSplit").up();
          tableRowPropertiesFragment.import(cantSplitFragment), delete attributes.rowCantSplit;
        }
    }
    var tableRowHeight;
  })), tableRowPropertiesFragment.up(), tableRowPropertiesFragment;
}, buildTableRow = async (vNode, attributes, rowSpanMap, docxDocumentInstance) => {
  const tableRowFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tr"), modifiedAttributes = { ...attributes };
  isVnode(vNode) && vNode.properties && ((vNode.properties.style && vNode.properties.style.height || vNode.children[0] && isVnode(vNode.children[0]) && vNode.children[0].properties.style && vNode.children[0].properties.style.height) && (modifiedAttributes.tableRowHeight = ((rowHeightString) => {
    if (pointRegex.test(rowHeightString)) {
      const matchedParts = rowHeightString.match(pointRegex);
      return pointToTWIP(matchedParts[1]);
    }
    if (pixelRegex.test(rowHeightString)) {
      const matchedParts = rowHeightString.match(pixelRegex);
      return pixelToTWIP(matchedParts[1]);
    }
    if (cmRegex.test(rowHeightString)) {
      const matchedParts = rowHeightString.match(cmRegex);
      return cmToTWIP(matchedParts[1]);
    }
    if (inchRegex.test(rowHeightString)) {
      const matchedParts = rowHeightString.match(inchRegex);
      return inchToTWIP(matchedParts[1]);
    }
  })(vNode.properties.style && vNode.properties.style.height || (vNode.children[0] && isVnode(vNode.children[0]) && vNode.children[0].properties.style && vNode.children[0].properties.style.height ? vNode.children[0].properties.style.height : void 0))), vNode.properties.style && fixupTableCellBorder(vNode, modifiedAttributes));
  const tableRowPropertiesFragment = buildTableRowProperties(modifiedAttributes);
  tableRowFragment.import(tableRowPropertiesFragment);
  const columnIndex = { index: 0 };
  if (vNodeHasChildren(vNode)) {
    const tableColumns = vNode.children.filter(((childVNode) => ["td", "th"].includes(childVNode.tagName))), maximumColumnWidth = docxDocumentInstance.availableDocumentSpace / tableColumns.length;
    for (const column of tableColumns) {
      const rowSpanCellFragments = buildRowSpanCell(rowSpanMap, columnIndex, modifiedAttributes);
      if (Array.isArray(rowSpanCellFragments)) for (let iteratorIndex = 0; iteratorIndex < rowSpanCellFragments.length; iteratorIndex++) {
        const rowSpanCellFragment = rowSpanCellFragments[iteratorIndex];
        tableRowFragment.import(rowSpanCellFragment);
      }
      const tableCellFragment = await buildTableCell(column, { ...modifiedAttributes, maximumWidth: maximumColumnWidth }, rowSpanMap, columnIndex, docxDocumentInstance);
      columnIndex.index++, tableRowFragment.import(tableCellFragment);
    }
  }
  if (columnIndex.index < rowSpanMap.size) {
    const rowSpanCellFragments = buildRowSpanCell(rowSpanMap, columnIndex, modifiedAttributes);
    if (Array.isArray(rowSpanCellFragments)) for (let iteratorIndex = 0; iteratorIndex < rowSpanCellFragments.length; iteratorIndex++) {
      const rowSpanCellFragment = rowSpanCellFragments[iteratorIndex];
      tableRowFragment.import(rowSpanCellFragment);
    }
  }
  return tableRowFragment.up(), tableRowFragment;
}, buildTableGridCol = (gridWidth) => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "gridCol").att("@w", "w", String(gridWidth)), buildTableGrid = (vNode, attributes) => {
  const tableGridFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tblGrid");
  if (vNodeHasChildren(vNode)) {
    const gridColumns = vNode.children.filter(((childVNode) => "col" === childVNode.tagName)), gridWidth = attributes.maximumWidth / gridColumns.length;
    for (let index = 0; index < gridColumns.length; index++) {
      const tableGridColFragment = buildTableGridCol(gridWidth);
      tableGridFragment.import(tableGridColFragment);
    }
  }
  return tableGridFragment.up(), tableGridFragment;
}, buildTableGridFromTableRow = (vNode, attributes) => {
  const tableGridFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tblGrid");
  if (vNodeHasChildren(vNode)) {
    const numberOfGridColumns = vNode.children.reduce(((accumulator, childVNode) => {
      const colSpan = childVNode.properties.colSpan || childVNode.properties.style && childVNode.properties.style["column-span"];
      return accumulator + (colSpan ? parseInt(colSpan) : 1);
    }), 0), gridWidth = attributes.maximumWidth / numberOfGridColumns;
    for (let index = 0; index < numberOfGridColumns; index++) {
      const tableGridColFragment = buildTableGridCol(gridWidth);
      tableGridFragment.import(tableGridColFragment);
    }
  }
  return tableGridFragment.up(), tableGridFragment;
}, buildCellMargin = (side, margin) => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", side).att("@w", "type", "dxa").att("@w", "w", String(margin)).up(), buildTableProperties = (attributes) => {
  const tablePropertiesFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tblPr");
  attributes && attributes.constructor === Object && Object.keys(attributes).forEach(((key) => {
    switch (key) {
      case "tableBorder":
        const tableBordersFragment = ((tableBorder) => {
          const tableBordersFragment2 = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tblBorders"), { color, stroke, ...borders } = tableBorder;
          return Object.keys(borders).forEach(((border) => {
            if (borders[border]) {
              const borderFragment = buildBorder(border, borders[border], 0, color, stroke);
              tableBordersFragment2.import(borderFragment);
            }
          })), tableBordersFragment2.up(), tableBordersFragment2;
        })(attributes[key]);
        tablePropertiesFragment.import(tableBordersFragment), delete attributes.tableBorder;
        break;
      case "tableCellSpacing":
        const tableCellSpacingFragment = ((cellSpacing = 0) => libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tblCellSpacing").att("@w", "w", cellSpacing).att("@w", "type", "dxa").up())(attributes[key]);
        tablePropertiesFragment.import(tableCellSpacingFragment), delete attributes.tableCellSpacing;
        break;
      case "width":
        if (attributes[key]) {
          const tableWidthFragment = (tableWidth = attributes[key], libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tblW").att("@w", "type", "dxa").att("@w", "w", String(tableWidth)).up());
          tablePropertiesFragment.import(tableWidthFragment);
        }
        delete attributes.width;
    }
    var tableWidth;
  }));
  const tableCellMarginFragment = ((margin) => {
    const tableCellMarFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tblCellMar");
    return ["top", "bottom"].forEach(((side) => {
      const marginFragment = buildCellMargin(side, margin / 2);
      tableCellMarFragment.import(marginFragment);
    })), ["left", "right"].forEach(((side) => {
      const marginFragment = buildCellMargin(side, margin);
      tableCellMarFragment.import(marginFragment);
    })), tableCellMarFragment;
  })(160);
  tablePropertiesFragment.import(tableCellMarginFragment);
  const alignmentFragment = buildHorizontalAlignment("center");
  return tablePropertiesFragment.import(alignmentFragment), tablePropertiesFragment.up(), tablePropertiesFragment;
}, cssBorderParser = (borderString) => {
  let [size, stroke, color] = borderString.split(" ");
  if (pointRegex.test(size)) {
    const matchedParts = size.match(pointRegex);
    size = pointToEIP(matchedParts[1]);
  } else if (pixelRegex.test(size)) {
    const matchedParts = size.match(pixelRegex);
    pixelValue = matchedParts[1], size = pointToEIP(pixelToPoint(pixelValue));
  }
  var pixelValue;
  return stroke = stroke && ["dashed", "dotted", "double"].includes(stroke) ? stroke : "single", color = color && fixupColorCode(color).toUpperCase(), [size, stroke, color];
}, buildTable = async (vNode, attributes, docxDocumentInstance) => {
  const tableFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "tbl"), modifiedAttributes = { ...attributes };
  if (isVnode(vNode) && vNode.properties) {
    const tableAttributes = vNode.properties.attributes || {}, tableStyles = vNode.properties.style || {}, tableBorders = {}, tableCellBorders = {};
    let minimumWidth, maximumWidth, width, [borderSize, borderStrike, borderColor] = [2, "single", "000000"];
    if (isNaN(tableAttributes.border) || (borderSize = parseInt(tableAttributes.border, 10)), tableStyles.border) {
      const [cssSize, cssStroke, cssColor] = cssBorderParser(tableStyles.border);
      borderSize = cssSize || borderSize, borderColor = cssColor || borderColor, borderStrike = cssStroke || borderStrike;
    }
    if (tableBorders.top = borderSize, tableBorders.bottom = borderSize, tableBorders.left = borderSize, tableBorders.right = borderSize, tableBorders.stroke = borderStrike, tableBorders.color = borderColor, "collapse" === tableStyles["border-collapse"] ? (tableBorders.insideV = borderSize, tableBorders.insideH = borderSize) : (tableBorders.insideV = 0, tableBorders.insideH = 0, tableCellBorders.top = 1, tableCellBorders.bottom = 1, tableCellBorders.left = 1, tableCellBorders.right = 1), modifiedAttributes.tableBorder = tableBorders, modifiedAttributes.tableCellSpacing = 0, Object.keys(tableCellBorders).length && (modifiedAttributes.tableCellBorder = tableCellBorders), pixelRegex.test(tableStyles["min-width"])) minimumWidth = pixelToTWIP(tableStyles["min-width"].match(pixelRegex)[1]);
    else if (percentageRegex.test(tableStyles["min-width"])) {
      const percentageValue = tableStyles["min-width"].match(percentageRegex)[1];
      minimumWidth = Math.round(percentageValue / 100 * attributes.maximumWidth);
    }
    if (pixelRegex.test(tableStyles["max-width"])) pixelRegex.lastIndex = 0, maximumWidth = pixelToTWIP(tableStyles["max-width"].match(pixelRegex)[1]);
    else if (percentageRegex.test(tableStyles["max-width"])) {
      percentageRegex.lastIndex = 0;
      const percentageValue = tableStyles["max-width"].match(percentageRegex)[1];
      maximumWidth = Math.round(percentageValue / 100 * attributes.maximumWidth);
    }
    if (pixelRegex.test(tableStyles.width)) pixelRegex.lastIndex = 0, width = pixelToTWIP(tableStyles.width.match(pixelRegex)[1]);
    else if (percentageRegex.test(tableStyles.width)) {
      percentageRegex.lastIndex = 0;
      const percentageValue = tableStyles.width.match(percentageRegex)[1];
      width = Math.round(percentageValue / 100 * attributes.maximumWidth);
    }
    width ? (modifiedAttributes.width = width, maximumWidth && (modifiedAttributes.width = Math.min(modifiedAttributes.width, maximumWidth)), minimumWidth && (modifiedAttributes.width = Math.max(modifiedAttributes.width, minimumWidth))) : minimumWidth && (modifiedAttributes.width = minimumWidth), modifiedAttributes.width && (modifiedAttributes.width = Math.min(modifiedAttributes.width, attributes.maximumWidth));
  }
  const tablePropertiesFragment = buildTableProperties(modifiedAttributes);
  tableFragment.import(tablePropertiesFragment);
  const rowSpanMap = /* @__PURE__ */ new Map();
  if (vNodeHasChildren(vNode)) for (let index = 0; index < vNode.children.length; index++) {
    const childVNode = vNode.children[index];
    if ("colgroup" === childVNode.tagName) {
      const tableGridFragment = buildTableGrid(childVNode, modifiedAttributes);
      tableFragment.import(tableGridFragment);
    } else if ("thead" === childVNode.tagName) for (let iteratorIndex = 0; iteratorIndex < childVNode.children.length; iteratorIndex++) {
      const grandChildVNode = childVNode.children[iteratorIndex];
      if ("tr" === grandChildVNode.tagName) {
        if (0 === iteratorIndex) {
          const tableGridFragment = buildTableGridFromTableRow(grandChildVNode, modifiedAttributes);
          tableFragment.import(tableGridFragment);
        }
        const tableRowFragment = await buildTableRow(grandChildVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
        tableFragment.import(tableRowFragment);
      }
    }
    else if ("tbody" === childVNode.tagName) for (let iteratorIndex = 0; iteratorIndex < childVNode.children.length; iteratorIndex++) {
      const grandChildVNode = childVNode.children[iteratorIndex];
      if ("tr" === grandChildVNode.tagName) {
        if (0 === iteratorIndex) {
          const tableGridFragment = buildTableGridFromTableRow(grandChildVNode, modifiedAttributes);
          tableFragment.import(tableGridFragment);
        }
        const tableRowFragment = await buildTableRow(grandChildVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
        tableFragment.import(tableRowFragment);
      }
    }
    else if ("tr" === childVNode.tagName) {
      if (0 === index) {
        const tableGridFragment = buildTableGridFromTableRow(childVNode, modifiedAttributes);
        tableFragment.import(tableGridFragment);
      }
      const tableRowFragment = await buildTableRow(childVNode, modifiedAttributes, rowSpanMap, docxDocumentInstance);
      tableFragment.import(tableRowFragment);
    }
  }
  return tableFragment.up(), tableFragment;
}, buildGraphicFrameTransform = (attributes) => {
  const graphicFrameTransformFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "xfrm"), offsetFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "off").att("x", "0").att("y", "0").up();
  graphicFrameTransformFragment.import(offsetFragment);
  const extentsFragment = (({ width, height }) => libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "ext").att("cx", width).att("cy", height).up())(attributes);
  return graphicFrameTransformFragment.import(extentsFragment), graphicFrameTransformFragment.up(), graphicFrameTransformFragment;
}, buildShapeProperties = (attributes) => {
  const shapeProperties = libExports.fragment({ namespaceAlias: { pic: namespaces_pic } }).ele("@pic", "spPr"), graphicFrameTransformFragment = buildGraphicFrameTransform(attributes);
  shapeProperties.import(graphicFrameTransformFragment);
  const presetGeometryFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "prstGeom").att("prst", "rect").up();
  return shapeProperties.import(presetGeometryFragment), shapeProperties.up(), shapeProperties;
}, buildStretch = () => {
  const stretchFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "stretch"), fillRectFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "fillRect").up();
  return stretchFragment.import(fillRectFragment), stretchFragment.up(), stretchFragment;
}, buildBinaryLargeImageOrPictureFill = (relationshipId) => {
  const binaryLargeImageOrPictureFillFragment = libExports.fragment({ namespaceAlias: { pic: namespaces_pic } }).ele("@pic", "blipFill"), binaryLargeImageOrPictureFragment = ((relationshipId2) => libExports.fragment({ namespaceAlias: { a: namespaces_a, r: namespaces_r } }).ele("@a", "blip").att("@r", "embed", `rId${relationshipId2}`).att("cstate", "print").up())(relationshipId);
  binaryLargeImageOrPictureFillFragment.import(binaryLargeImageOrPictureFragment);
  const srcRectFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "srcRect").att("b", "0").att("l", "0").att("r", "0").att("t", "0").up();
  binaryLargeImageOrPictureFillFragment.import(srcRectFragment);
  const stretchFragment = buildStretch();
  return binaryLargeImageOrPictureFillFragment.import(stretchFragment), binaryLargeImageOrPictureFillFragment.up(), binaryLargeImageOrPictureFillFragment;
}, buildNonVisualPictureProperties = (pictureId, pictureNameWithExtension, pictureDescription) => {
  const nonVisualPicturePropertiesFragment = libExports.fragment({ namespaceAlias: { pic: namespaces_pic } }).ele("@pic", "nvPicPr"), nonVisualDrawingPropertiesFragment = ((pictureId2, pictureNameWithExtension2, pictureDescription2 = "") => libExports.fragment({ namespaceAlias: { pic: namespaces_pic } }).ele("@pic", "cNvPr").att("id", pictureId2).att("name", pictureNameWithExtension2).att("descr", pictureDescription2).up())(pictureId, pictureNameWithExtension, pictureDescription);
  nonVisualPicturePropertiesFragment.import(nonVisualDrawingPropertiesFragment);
  const nonVisualPictureDrawingPropertiesFragment = libExports.fragment({ namespaceAlias: { pic: namespaces_pic } }).ele("@pic", "cNvPicPr").up();
  return nonVisualPicturePropertiesFragment.import(nonVisualPictureDrawingPropertiesFragment), nonVisualPicturePropertiesFragment.up(), nonVisualPicturePropertiesFragment;
}, buildGraphicData = (graphicType, attributes) => {
  const graphicDataFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "graphicData").att("uri", "http://schemas.openxmlformats.org/drawingml/2006/picture");
  if ("picture" === graphicType) {
    const pictureFragment = (({ id, fileNameWithExtension, description, relationshipId, width, height }) => {
      const pictureFragment2 = libExports.fragment({ namespaceAlias: { pic: namespaces_pic } }).ele("@pic", "pic"), nonVisualPicturePropertiesFragment = buildNonVisualPictureProperties(id, fileNameWithExtension, description);
      pictureFragment2.import(nonVisualPicturePropertiesFragment);
      const binaryLargeImageOrPictureFill = buildBinaryLargeImageOrPictureFill(relationshipId);
      pictureFragment2.import(binaryLargeImageOrPictureFill);
      const shapeProperties = buildShapeProperties({ width, height });
      return pictureFragment2.import(shapeProperties), pictureFragment2.up(), pictureFragment2;
    })(attributes);
    graphicDataFragment.import(pictureFragment);
  }
  return graphicDataFragment.up(), graphicDataFragment;
}, buildGraphic = (graphicType, attributes) => {
  const graphicFragment = libExports.fragment({ namespaceAlias: { a: namespaces_a } }).ele("@a", "graphic"), graphicDataFragment = buildGraphicData(graphicType, attributes);
  return graphicFragment.import(graphicDataFragment), graphicFragment.up(), graphicFragment;
}, buildDrawingObjectNonVisualProperties = (pictureId, pictureName) => libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "docPr").att("id", pictureId).att("name", pictureName).up(), buildEffectExtentFragment = () => libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "effectExtent").att("b", "0").att("l", "0").att("r", "0").att("t", "0").up(), buildExtent = ({ width, height }) => libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "extent").att("cx", width).att("cy", height).up(), buildAnchoredDrawing = (graphicType, attributes) => {
  const anchoredDrawingFragment = libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "anchor").att("distB", "0").att("distL", "0").att("distR", "0").att("distT", "0").att("relativeHeight", "0").att("behindDoc", "false").att("locked", "true").att("layoutInCell", "true").att("allowOverlap", "false").att("simplePos", "false"), simplePosFragment = libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "simplePos").att("x", "0").att("y", "0").up();
  anchoredDrawingFragment.import(simplePosFragment);
  const positionHFragment = libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "positionH").att("relativeFrom", "column").ele("@wp", "posOffset").txt("19050").up().up();
  anchoredDrawingFragment.import(positionHFragment);
  const positionVFragment = libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "positionV").att("relativeFrom", "paragraph").ele("@wp", "posOffset").txt("19050").up().up();
  anchoredDrawingFragment.import(positionVFragment);
  const extentFragment = buildExtent({ width: attributes.width, height: attributes.height });
  anchoredDrawingFragment.import(extentFragment);
  const effectExtentFragment = buildEffectExtentFragment();
  anchoredDrawingFragment.import(effectExtentFragment);
  const wrapSquareFragment = libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "wrapSquare").att("wrapText", "bothSides").att("distB", "228600").att("distT", "228600").att("distL", "228600").att("distR", "228600").up();
  anchoredDrawingFragment.import(wrapSquareFragment);
  const drawingObjectNonVisualPropertiesFragment = buildDrawingObjectNonVisualProperties(attributes.id, attributes.fileNameWithExtension);
  anchoredDrawingFragment.import(drawingObjectNonVisualPropertiesFragment);
  const graphicFragment = buildGraphic(graphicType, attributes);
  return anchoredDrawingFragment.import(graphicFragment), anchoredDrawingFragment.up(), anchoredDrawingFragment;
}, buildDrawing = (inlineOrAnchored = false, graphicType, attributes) => {
  const drawingFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "drawing"), inlineOrAnchoredDrawingFragment = inlineOrAnchored ? ((graphicType2, attributes2) => {
    const inlineDrawingFragment = libExports.fragment({ namespaceAlias: { wp: namespaces_wp } }).ele("@wp", "inline").att("distB", "0").att("distL", "0").att("distR", "0").att("distT", "0"), extentFragment = buildExtent({ width: attributes2.width, height: attributes2.height });
    inlineDrawingFragment.import(extentFragment);
    const effectExtentFragment = buildEffectExtentFragment();
    inlineDrawingFragment.import(effectExtentFragment);
    const drawingObjectNonVisualPropertiesFragment = buildDrawingObjectNonVisualProperties(attributes2.id, attributes2.fileNameWithExtension);
    inlineDrawingFragment.import(drawingObjectNonVisualPropertiesFragment);
    const graphicFragment = buildGraphic(graphicType2, attributes2);
    return inlineDrawingFragment.import(graphicFragment), inlineDrawingFragment.up(), inlineDrawingFragment;
  })(graphicType, attributes) : buildAnchoredDrawing(graphicType, attributes);
  return drawingFragment.import(inlineOrAnchoredDrawingFragment), drawingFragment.up(), drawingFragment;
}, convertHTML$1 = HTMLToVDOM({ VNode: vnode, VText: vtext }), buildImage = async (docxDocumentInstance, vNode, maximumWidth = null) => {
  let response = null, base64Uri = null;
  try {
    const imageSource = vNode.properties.src;
    if (isValidUrl(imageSource)) {
      const base64String = await imageToBase64_min(imageSource).catch(((error) => {
        console.warning(`skipping image download and conversion due to ${error}`);
      }));
      base64String && (base64Uri = `data:${mimeTypes.lookup(imageSource)};base64, ${base64String}`);
    } else base64Uri = decodeURIComponent(vNode.properties.src);
    base64Uri && (response = docxDocumentInstance.createMediaFile(base64Uri));
  } catch (error) {
  }
  if (response) {
    docxDocumentInstance.zip.folder("word").folder("media").file(response.fileNameWithExtension, Buffer.from(response.fileContent, "base64"), { createFolders: false });
    const documentRelsId = docxDocumentInstance.createDocumentRelationships(docxDocumentInstance.relationshipFilename, "image", `media/${response.fileNameWithExtension}`, "Internal"), imageBuffer = Buffer.from(response.fileContent, "base64"), imageProperties = sizeOf(imageBuffer);
    return await buildParagraph(vNode, { type: "picture", inlineOrAnchored: true, relationshipId: documentRelsId, ...response, description: vNode.properties.alt, maximumWidth: maximumWidth || docxDocumentInstance.availableDocumentSpace, originalWidth: imageProperties.width, originalHeight: imageProperties.height }, docxDocumentInstance);
  }
}, buildList = async (vNode, docxDocumentInstance, xmlFragment) => {
  let vNodeObjects = [{ node: vNode, level: 0, type: vNode.tagName, numberingId: docxDocumentInstance.createNumbering(vNode.tagName, vNode.properties) }];
  for (; vNodeObjects.length; ) {
    const tempVNodeObject = vNodeObjects.shift();
    if (isVtext(tempVNodeObject.node) || isVnode(tempVNodeObject.node) && !["ul", "ol", "li"].includes(tempVNodeObject.node.tagName)) {
      const paragraphFragment = await buildParagraph(tempVNodeObject.node, { numbering: { levelId: tempVNodeObject.level, numberingId: tempVNodeObject.numberingId } }, docxDocumentInstance);
      xmlFragment.import(paragraphFragment);
    }
    if (tempVNodeObject.node.children && tempVNodeObject.node.children.length && ["ul", "ol", "li"].includes(tempVNodeObject.node.tagName)) {
      vNodeObjects = tempVNodeObject.node.children.reduce(((accumulator, childVNode) => {
        if (["ul", "ol"].includes(childVNode.tagName)) accumulator.push({ node: childVNode, level: tempVNodeObject.level + 1, type: childVNode.tagName, numberingId: docxDocumentInstance.createNumbering(childVNode.tagName, childVNode.properties) });
        else if (accumulator.length > 0 && isVnode(accumulator[accumulator.length - 1].node) && "p" === accumulator[accumulator.length - 1].node.tagName.toLowerCase()) accumulator[accumulator.length - 1].node.children.push(childVNode);
        else {
          const paragraphVNode = new vnode("p", null, isVtext(childVNode) ? [childVNode] : isVnode(childVNode) ? "li" === childVNode.tagName.toLowerCase() ? [...childVNode.children] : [childVNode] : []);
          accumulator.push({ node: isVnode(childVNode) ? "li" === childVNode.tagName.toLowerCase() ? childVNode : "p" !== childVNode.tagName.toLowerCase() ? paragraphVNode : childVNode : paragraphVNode, level: tempVNodeObject.level, type: tempVNodeObject.type, numberingId: tempVNodeObject.numberingId });
        }
        return accumulator;
      }), []).concat(vNodeObjects);
    }
  }
  return [];
};
async function convertVTreeToXML(docxDocumentInstance, vTree, xmlFragment) {
  if (!vTree) return "";
  if (Array.isArray(vTree) && vTree.length) for (let index = 0; index < vTree.length; index++) {
    const vNode = vTree[index];
    await convertVTreeToXML(docxDocumentInstance, vNode, xmlFragment);
  }
  else if (isVnode(vTree)) await (async function(docxDocumentInstance2, vNode, xmlFragment2) {
    if ("div" === vNode.tagName && ("page-break" === vNode.properties.attributes.class || vNode.properties.style && vNode.properties.style["page-break-after"])) {
      const paragraphFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "p").ele("@w", "r").ele("@w", "br").att("@w", "type", "page").up().up().up();
      xmlFragment2.import(paragraphFragment);
    } else {
      switch (vNode.tagName) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          const headingFragment = await buildParagraph(vNode, { paragraphStyle: `Heading${vNode.tagName[1]}` }, docxDocumentInstance2);
          return void xmlFragment2.import(headingFragment);
        case "span":
        case "strong":
        case "b":
        case "em":
        case "i":
        case "u":
        case "ins":
        case "strike":
        case "del":
        case "s":
        case "sub":
        case "sup":
        case "mark":
        case "p":
        case "a":
        case "blockquote":
        case "code":
        case "pre":
          const paragraphFragment = await buildParagraph(vNode, {}, docxDocumentInstance2);
          return void xmlFragment2.import(paragraphFragment);
        case "figure":
          if (vNodeHasChildren(vNode)) for (let index = 0; index < vNode.children.length; index++) {
            const childVNode = vNode.children[index];
            if ("table" === childVNode.tagName) {
              const tableFragment2 = await buildTable(childVNode, { maximumWidth: docxDocumentInstance2.availableDocumentSpace, rowCantSplit: docxDocumentInstance2.tableRowCantSplit }, docxDocumentInstance2);
              xmlFragment2.import(tableFragment2);
              const emptyParagraphFragment2 = await buildParagraph(null, {});
              xmlFragment2.import(emptyParagraphFragment2);
            } else if ("img" === childVNode.tagName) {
              const imageFragment2 = await buildImage(docxDocumentInstance2, childVNode);
              imageFragment2 && xmlFragment2.import(imageFragment2);
            }
          }
          return;
        case "table":
          const tableFragment = await buildTable(vNode, { maximumWidth: docxDocumentInstance2.availableDocumentSpace, rowCantSplit: docxDocumentInstance2.tableRowCantSplit }, docxDocumentInstance2);
          xmlFragment2.import(tableFragment);
          const emptyParagraphFragment = await buildParagraph(null, {});
          return void xmlFragment2.import(emptyParagraphFragment);
        case "ol":
        case "ul":
          return void await buildList(vNode, docxDocumentInstance2, xmlFragment2);
        case "img":
          const imageFragment = await buildImage(docxDocumentInstance2, vNode);
          return void (imageFragment && xmlFragment2.import(imageFragment));
        case "br":
          const linebreakFragment = await buildParagraph(null, {});
          return void xmlFragment2.import(linebreakFragment);
        case "head":
          return;
      }
      if (vNodeHasChildren(vNode)) for (let index = 0; index < vNode.children.length; index++) {
        const childVNode = vNode.children[index];
        await convertVTreeToXML(docxDocumentInstance2, childVNode, xmlFragment2);
      }
    }
  })(docxDocumentInstance, vTree, xmlFragment);
  else if (isVtext(vTree)) {
    const paragraphFragment = await buildParagraph(vTree, {}, docxDocumentInstance);
    xmlFragment.import(paragraphFragment);
  }
  return xmlFragment;
}
class ListStyleBuilder {
  constructor(defaults2) {
    this.defaults = defaults2 || { defaultOrderedListStyleType: "decimal" };
  }
  getListStyleType(listType) {
    switch (listType) {
      case "upper-roman":
        return "upperRoman";
      case "lower-roman":
        return "lowerRoman";
      case "upper-alpha":
      case "upper-alpha-bracket-end":
        return "upperLetter";
      case "lower-alpha":
      case "lower-alpha-bracket-end":
        return "lowerLetter";
      case "decimal":
      case "decimal-bracket":
        return "decimal";
      default:
        return this.defaults.defaultOrderedListStyleType;
    }
  }
  getListPrefixSuffix(style, lvl) {
    let listType = this.defaults.defaultOrderedListStyleType;
    switch (style && style["list-style-type"] && (listType = style["list-style-type"]), listType) {
      case "upper-roman":
      case "lower-roman":
      case "upper-alpha":
      case "lower-alpha":
      case "decimal":
      default:
        return `%${lvl + 1}.`;
      case "upper-alpha-bracket-end":
      case "lower-alpha-bracket-end":
      case "decimal-bracket-end":
        return `%${lvl + 1})`;
      case "decimal-bracket":
        return `(%${lvl + 1})`;
    }
  }
}
const removeSimpleOrDoubleQuotes = /(["'])(.*?)\1/;
function generateContentTypesFragments(contentTypesXML, type2, objects) {
  objects && Array.isArray(objects) && objects.forEach(((object2) => {
    const contentTypesFragment = libExports.fragment({ defaultNamespace: { ele: namespaces_contentTypes } }).ele("Override").att("PartName", `/word/${type2}${object2[`${type2}Id`]}.xml`).att("ContentType", `application/vnd.openxmlformats-officedocument.wordprocessingml.${type2}+xml`).up();
    contentTypesXML.root().import(contentTypesFragment);
  }));
}
function generateSectionReferenceXML(documentXML, documentSectionType, objects, isEnabled) {
  if (isEnabled && objects && Array.isArray(objects) && objects.length) {
    const xmlFragment = libExports.fragment();
    objects.forEach((({ relationshipId, type: type2 }) => {
      const objectFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w, r: namespaces_r } }).ele("@w", `${documentSectionType}Reference`).att("@r", "id", `rId${relationshipId}`).att("@w", "type", type2).up();
      xmlFragment.import(objectFragment);
    })), documentXML.root().first().first().import(xmlFragment);
  }
}
function generateXMLString(xmlString) {
  return libExports.create({ encoding: "UTF-8", standalone: true }, xmlString).toString({ prettyPrint: true });
}
async function generateSectionXML(vTree, type2 = "header") {
  const sectionXML = libExports.create({ encoding: "UTF-8", standalone: true, namespaceAlias: { w: namespaces_w, ve: namespaces_ve, o: namespaces_o, r: namespaces_r, v: namespaces_v, wp: namespaces_wp, w10: namespaces_w10 } }).ele("@w", "header" === type2 ? "hdr" : "ftr"), XMLFragment = libExports.fragment();
  await convertVTreeToXML(this, vTree, XMLFragment), "footer" === type2 && "p" === XMLFragment.first().node.tagName && this.pageNumber && XMLFragment.first().import(libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "fldSimple").att("@w", "instr", "PAGE").ele("@w", "r").up().up()), sectionXML.root().import(XMLFragment);
  const referenceName = "header" === type2 ? "Header" : "Footer";
  return this[`last${referenceName}Id`] += 1, { [`${type2}Id`]: this[`last${referenceName}Id`], [`${type2}XML`]: sectionXML };
}
class DocxDocument {
  constructor(properties) {
    this.zip = properties.zip, this.htmlString = properties.htmlString, this.orientation = properties.orientation, this.pageSize = properties.pageSize || defaultDocumentOptions.pageSize;
    const isPortraitOrientation = "portrait" === this.orientation, height = this.pageSize.height ? this.pageSize.height : 12240, width = this.pageSize.width ? this.pageSize.width : 15840;
    this.width = isPortraitOrientation ? width : height, this.height = isPortraitOrientation ? height : width;
    const marginsObject = properties.margins;
    this.margins = marginsObject && Object.keys(marginsObject).length ? marginsObject : isPortraitOrientation ? portraitMargins : landscapeMargins, this.availableDocumentSpace = this.width - this.margins.left - this.margins.right, this.title = properties.title || "", this.subject = properties.subject || "", this.creator = properties.creator || "html-to-docx", this.keywords = properties.keywords || ["html-to-docx"], this.description = properties.description || "", this.lastModifiedBy = properties.lastModifiedBy || "html-to-docx", this.revision = properties.revision || 1, this.createdAt = properties.createdAt || /* @__PURE__ */ new Date(), this.modifiedAt = properties.modifiedAt || /* @__PURE__ */ new Date(), this.headerType = properties.headerType || "default", this.header = properties.header || false, this.footerType = properties.footerType || "default", this.footer = properties.footer || false, this.font = properties.font || "Times New Roman", this.fontSize = properties.fontSize || 22, this.complexScriptFontSize = properties.complexScriptFontSize || 22, this.lang = properties.lang || "en-US", this.tableRowCantSplit = properties.table && properties.table.row && properties.table.row.cantSplit || false, this.pageNumber = properties.pageNumber || false, this.skipFirstHeaderFooter = properties.skipFirstHeaderFooter || false, this.lineNumber = properties.lineNumber ? properties.lineNumberOptions : null, this.lastNumberingId = 0, this.lastMediaId = 0, this.lastHeaderId = 0, this.lastFooterId = 0, this.stylesObjects = [], this.numberingObjects = [], this.fontTableObjects = [], this.relationshipFilename = "document", this.relationships = [{ fileName: "document", lastRelsId: 5, rels: [] }], this.mediaFiles = [], this.headerObjects = [], this.footerObjects = [], this.documentXML = null, this.generateContentTypesXML = this.generateContentTypesXML.bind(this), this.generateDocumentXML = this.generateDocumentXML.bind(this), this.generateCoreXML = this.generateCoreXML.bind(this), this.generateSettingsXML = this.generateSettingsXML.bind(this), this.generateWebSettingsXML = this.generateWebSettingsXML.bind(this), this.generateStylesXML = this.generateStylesXML.bind(this), this.generateFontTableXML = this.generateFontTableXML.bind(this), this.generateThemeXML = this.generateThemeXML.bind(this), this.generateNumberingXML = this.generateNumberingXML.bind(this), this.generateRelsXML = this.generateRelsXML.bind(this), this.createMediaFile = this.createMediaFile.bind(this), this.createDocumentRelationships = this.createDocumentRelationships.bind(this), this.generateHeaderXML = this.generateHeaderXML.bind(this), this.generateFooterXML = this.generateFooterXML.bind(this), this.generateSectionXML = generateSectionXML.bind(this), this.ListStyleBuilder = new ListStyleBuilder(properties.numbering);
  }
  generateContentTypesXML() {
    const contentTypesXML$1 = libExports.create({ encoding: "UTF-8", standalone: true }, '\n    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n\n    <Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">\n        <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />\n        <Default Extension="jpeg" ContentType="image/jpeg"/>\n        <Default Extension="png" ContentType="image/png"/>\n        <Default Extension="xml" ContentType="application/xml"/>\n        <Override PartName="/_rels/.rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>\n        <Override PartName="/word/_rels/document.xml.rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>\n        <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>\n        <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>\n        <Override PartName="/word/numbering.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"/>\n        <Override PartName="/word/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>\n        <Override PartName="/word/fontTable.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/>\n        <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>\n        <Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>\n        <Override PartName="/word/webSettings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"/>\n    </Types>\n');
    return generateContentTypesFragments(contentTypesXML$1, "header", this.headerObjects), generateContentTypesFragments(contentTypesXML$1, "footer", this.footerObjects), contentTypesXML$1.toString({ prettyPrint: true });
  }
  generateDocumentXML() {
    const documentXML = libExports.create({ encoding: "UTF-8", standalone: true }, (width = this.width, height = this.height, orientation = this.orientation, margins = this.margins, `
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <w:document
        xmlns:a="${namespaces_a}"
        xmlns:cdr="${namespaces_cdr}"
        xmlns:o="${namespaces_o}"
        xmlns:pic="${namespaces_pic}"
        xmlns:r="${namespaces_r}"
        xmlns:v="${namespaces_v}"
        xmlns:ve="${namespaces_ve}"
        xmlns:vt="${namespaces_vt}"
        xmlns:w="${namespaces_w}"
        xmlns:w10="${namespaces_w10}"
        xmlns:wp="${namespaces_wp}"
        xmlns:wne="${namespaces_wne}"
        >
        <w:body>
            <w:sectPr>
                <w:pgSz w:w="${width}" w:h="${height}" w:orient="${orientation}" />
                <w:pgMar w:top="${margins.top}"
                        w:right="${margins.right}"
                        w:bottom="${margins.bottom}"
                        w:left="${margins.left}"
                        w:header="${margins.header}"
                        w:footer="${margins.footer}"
                        w:gutter="${margins.gutter}"/>
            </w:sectPr>
        </w:body>
    </w:document>
  `));
    var width, height, orientation, margins;
    if (documentXML.root().first().import(this.documentXML), generateSectionReferenceXML(documentXML, "header", this.headerObjects, this.header), generateSectionReferenceXML(documentXML, "footer", this.footerObjects, this.footer), (this.header || this.footer) && this.skipFirstHeaderFooter && documentXML.root().first().first().import(libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "titlePg")), this.lineNumber) {
      const { countBy, start, restart } = this.lineNumber;
      documentXML.root().first().first().import(libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "lnNumType").att("@w", "countBy", countBy).att("@w", "start", start).att("@w", "restart", restart));
    }
    return documentXML.toString({ prettyPrint: true });
  }
  generateCoreXML() {
    return generateXMLString(((title = "", subject = "", creator = "html-to-docx", keywords = ["html-to-docx"], description = "", lastModifiedBy = "html-to-docx", revision = 1, createdAt = /* @__PURE__ */ new Date(), modifiedAt = /* @__PURE__ */ new Date()) => `
        <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

        <cp:coreProperties
          xmlns:cp="${namespaces_coreProperties}"
          xmlns:dc="${namespaces_dc}"
          xmlns:dcterms="${namespaces_dcterms}"
          xmlns:dcmitype="${namespaces_dcmitype}"
          xmlns:xsi="${namespaces_xsi}"
          >
            <dc:title>${title}</dc:title>
            <dc:subject>${subject}</dc:subject>
            <dc:creator>${creator}</dc:creator>
            ${keywords && Array.isArray(keywords) ? `<cp:keywords>${keywords.join(", ")}</cp:keywords>` : ""}
            <dc:description>${description}</dc:description>
            <cp:lastModifiedBy>${lastModifiedBy}</cp:lastModifiedBy>
            <cp:revision>${revision}</cp:revision>
            <dcterms:created xsi:type="dcterms:W3CDTF">${createdAt instanceof Date ? createdAt.toISOString() : (/* @__PURE__ */ new Date()).toISOString()}</dcterms:created>
            <dcterms:modified xsi:type="dcterms:W3CDTF">${modifiedAt instanceof Date ? modifiedAt.toISOString() : (/* @__PURE__ */ new Date()).toISOString()}</dcterms:modified>
        </cp:coreProperties>
    `)(this.title, this.subject, this.creator, this.keywords, this.description, this.lastModifiedBy, this.revision, this.createdAt, this.modifiedAt));
  }
  generateSettingsXML() {
    return generateXMLString(settingsXML);
  }
  generateWebSettingsXML() {
    return generateXMLString(webSettingsXML);
  }
  generateStylesXML() {
    return generateXMLString(((font = "Times New Roman", fontSize = 22, complexScriptFontSize = 22, lang2 = "en-US") => `
  <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

  <w:styles xmlns:w="${namespaces_w}" xmlns:r="${namespaces_r}">
	<w:docDefaults>
	  <w:rPrDefault>
		<w:rPr>
		  <w:rFonts w:ascii="${font}" w:eastAsiaTheme="minorHAnsi" w:hAnsiTheme="minorHAnsi" w:cstheme="minorBidi" />
		  <w:sz w:val="${fontSize}" />
		  <w:szCs w:val="${complexScriptFontSize}" />
		  <w:lang w:val="${lang2}" w:eastAsia="${lang2}" w:bidi="ar-SA" />
		</w:rPr>
	  </w:rPrDefault>
	  <w:pPrDefault>
		<w:pPr>
		  <w:spacing w:after="120" w:line="240" w:lineRule="atLeast" />
		</w:pPr>
	  </w:pPrDefault>
	</w:docDefaults>
	<w:style w:type="character" w:styleId="Hyperlink">
	  <w:name w:val="Hyperlink" />
	  <w:rPr>
		<w:color w:val="0000FF" />
		<w:u w:val="single" />
	  </w:rPr>
	</w:style>
	<w:style w:type="paragraph" w:styleId="Heading1">
	  <w:name w:val="heading 1" />
	  <w:basedOn w:val="Normal" />
	  <w:next w:val="Normal" />
	  <w:uiPriority w:val="9" />
	  <w:qFormat />
	  <w:pPr>
		<w:keepNext />
		<w:keepLines />
		<w:spacing w:before="480" />
		<w:outlineLvl w:val="0" />
	  </w:pPr>
	  <w:rPr>
		<w:b />
		<w:sz w:val="48" />
		<w:szCs w:val="48" />
	  </w:rPr>
	</w:style>
	<w:style w:type="paragraph" w:styleId="Heading2">
	  <w:name w:val="heading 2" />
	  <w:basedOn w:val="Normal" />
	  <w:next w:val="Normal" />
	  <w:uiPriority w:val="9" />
	  <w:unhideWhenUsed />
	  <w:qFormat />
	  <w:pPr>
		<w:keepNext />
		<w:keepLines />
		<w:spacing w:before="360" w:after="80" />
		<w:outlineLvl w:val="1" />
	  </w:pPr>
	  <w:rPr>
		<w:b />
		<w:sz w:val="36" />
		<w:szCs w:val="36" />
	  </w:rPr>
	</w:style>
	<w:style w:type="paragraph" w:styleId="Heading3">
	  <w:name w:val="heading 3" />
	  <w:basedOn w:val="Normal" />
	  <w:next w:val="Normal" />
	  <w:uiPriority w:val="9" />
	  <w:semiHidden />
	  <w:unhideWhenUsed />
	  <w:qFormat />
	  <w:pPr>
		<w:keepNext />
		<w:keepLines />
		<w:spacing w:before="280" w:after="80" />
		<w:outlineLvl w:val="2" />
	  </w:pPr>
	  <w:rPr>
		<w:b />
		<w:sz w:val="28" />
		<w:szCs w:val="28" />
	  </w:rPr>
	</w:style>
	<w:style w:type="paragraph" w:styleId="Heading4">
	  <w:name w:val="heading 4" />
	  <w:basedOn w:val="Normal" />
	  <w:next w:val="Normal" />
	  <w:uiPriority w:val="9" />
	  <w:semiHidden />
	  <w:unhideWhenUsed />
	  <w:qFormat />
	  <w:pPr>
		<w:keepNext />
		<w:keepLines />
		<w:spacing w:before="240" w:after="40" />
		<w:outlineLvl w:val="3" />
	  </w:pPr>
	  <w:rPr>
		<w:b />
		<w:sz w:val="24" />
		<w:szCs w:val="24" />
	  </w:rPr>
	</w:style>
	<w:style w:type="paragraph" w:styleId="Heading5">
	  <w:name w:val="heading 5" />
	  <w:basedOn w:val="Normal" />
	  <w:next w:val="Normal" />
	  <w:uiPriority w:val="9" />
	  <w:semiHidden />
	  <w:unhideWhenUsed />
	  <w:qFormat />
	  <w:pPr>
		<w:keepNext />
		<w:keepLines />
		<w:spacing w:before="220" w:after="40" />
		<w:outlineLvl w:val="4" />
	  </w:pPr>
	  <w:rPr>
		<w:b />
	  </w:rPr>
	</w:style>
	<w:style w:type="paragraph" w:styleId="Heading6">
	  <w:name w:val="heading 6" />
	  <w:basedOn w:val="Normal" />
	  <w:next w:val="Normal" />
	  <w:uiPriority w:val="9" />
	  <w:semiHidden />
	  <w:unhideWhenUsed />
	  <w:qFormat />
	  <w:pPr>
		<w:keepNext />
		<w:keepLines />
		<w:spacing w:before="200" w:after="40" />
		<w:outlineLvl w:val="5" />
	  </w:pPr>
	  <w:rPr>
		<w:b />
		<w:sz w:val="20" />
		<w:szCs w:val="20" />
	  </w:rPr>
	</w:style>
  </w:styles>
  `)(this.font, this.fontSize, this.complexScriptFontSize, this.lang));
  }
  generateFontTableXML() {
    const fontTableXML$1 = libExports.create({ encoding: "UTF-8", standalone: true }, fontTableXML), fontNames = ["Arial", "Calibri", "Calibri Light", "Courier New", "Symbol", "Times New Roman"];
    return this.fontTableObjects.forEach((({ fontName, genericFontName }) => {
      if (!fontNames.includes(fontName)) {
        fontNames.push(fontName);
        const fontFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "font").att("@w", "name", fontName);
        switch (genericFontName) {
          case "serif":
            fontFragment.ele("@w", "altName").att("@w", "val", "Times New Roman"), fontFragment.ele("@w", "family").att("@w", "val", "roman"), fontFragment.ele("@w", "pitch").att("@w", "val", "variable");
            break;
          case "sans-serif":
            fontFragment.ele("@w", "altName").att("@w", "val", "Arial"), fontFragment.ele("@w", "family").att("@w", "val", "swiss"), fontFragment.ele("@w", "pitch").att("@w", "val", "variable");
            break;
          case "monospace":
            fontFragment.ele("@w", "altName").att("@w", "val", "Courier New"), fontFragment.ele("@w", "family").att("@w", "val", "modern"), fontFragment.ele("@w", "pitch").att("@w", "val", "fixed");
        }
        fontTableXML$1.root().import(fontFragment);
      }
    })), fontTableXML$1.toString({ prettyPrint: true });
  }
  generateThemeXML() {
    return generateXMLString(((font = "Times New Roman") => `
    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

    <a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">
    <a:themeElements>
      <a:clrScheme name="Office">
        <a:dk1>
          <a:sysClr val="windowText" lastClr="000000"/>
        </a:dk1>
        <a:lt1>
          <a:sysClr val="window" lastClr="FFFFFF"/>
        </a:lt1>
        <a:dk2>
          <a:srgbClr val="44546A"/>
        </a:dk2>
        <a:lt2>
          <a:srgbClr val="E7E6E6"/>
        </a:lt2>
        <a:accent1>
          <a:srgbClr val="4472C4"/>
        </a:accent1>
        <a:accent2>
          <a:srgbClr val="ED7D31"/>
        </a:accent2>
        <a:accent3>
          <a:srgbClr val="A5A5A5"/>
        </a:accent3>
        <a:accent4>
          <a:srgbClr val="FFC000"/>
        </a:accent4>
        <a:accent5>
          <a:srgbClr val="5B9BD5"/>
        </a:accent5>
        <a:accent6>
          <a:srgbClr val="70AD47"/>
        </a:accent6>
        <a:hlink>
          <a:srgbClr val="0563C1"/>
        </a:hlink>
        <a:folHlink>
          <a:srgbClr val="954F72"/>
        </a:folHlink>
      </a:clrScheme>
      <a:fontScheme name="Office">
        <a:majorFont>
          <a:latin typeface="${font}"/>
          <a:ea typeface="${font}"/>
          <a:cs typeface=""/>
        </a:majorFont>
        <a:minorFont>
          <a:latin typeface="${font}"/>
          <a:ea typeface="${font}"/>
          <a:cs typeface=""/>
        </a:minorFont>
      </a:fontScheme>
      <a:fmtScheme name="Office">
        <a:fillStyleLst>
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:lumMod val="110000"/>
                  <a:satMod val="105000"/>
                  <a:tint val="67000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="105000"/>
                  <a:satMod val="103000"/>
                  <a:tint val="73000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="105000"/>
                  <a:satMod val="109000"/>
                  <a:tint val="81000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:satMod val="103000"/>
                  <a:lumMod val="102000"/>
                  <a:tint val="94000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:satMod val="110000"/>
                  <a:lumMod val="100000"/>
                  <a:shade val="100000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:lumMod val="99000"/>
                  <a:satMod val="120000"/>
                  <a:shade val="78000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
        </a:fillStyleLst>
        <a:lnStyleLst>
          <a:ln w="6350" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
          <a:ln w="12700" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
          <a:ln w="19050" cap="flat" cmpd="sng" algn="ctr">
            <a:solidFill>
              <a:schemeClr val="phClr"/>
            </a:solidFill>
            <a:prstDash val="solid"/>
            <a:miter lim="800000"/>
          </a:ln>
        </a:lnStyleLst>
        <a:effectStyleLst>
          <a:effectStyle>
            <a:effectLst/>
          </a:effectStyle>
          <a:effectStyle>
            <a:effectLst/>
          </a:effectStyle>
          <a:effectStyle>
            <a:effectLst>
              <a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0">
                <a:srgbClr val="000000">
                  <a:alpha val="63000"/>
                </a:srgbClr>
              </a:outerShdw>
            </a:effectLst>
          </a:effectStyle>
        </a:effectStyleLst>
        <a:bgFillStyleLst>
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:solidFill>
            <a:schemeClr val="phClr">
              <a:tint val="95000"/>
              <a:satMod val="170000"/>
            </a:schemeClr>
          </a:solidFill>
          <a:gradFill rotWithShape="1">
            <a:gsLst>
              <a:gs pos="0">
                <a:schemeClr val="phClr">
                  <a:tint val="93000"/>
                  <a:satMod val="150000"/>
                  <a:shade val="98000"/>
                  <a:lumMod val="102000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="50000">
                <a:schemeClr val="phClr">
                  <a:tint val="98000"/>
                  <a:satMod val="130000"/>
                  <a:shade val="90000"/>
                  <a:lumMod val="103000"/>
                </a:schemeClr>
              </a:gs>
              <a:gs pos="100000">
                <a:schemeClr val="phClr">
                  <a:shade val="63000"/>
                  <a:satMod val="120000"/>
                </a:schemeClr>
              </a:gs>
            </a:gsLst>
            <a:lin ang="5400000" scaled="0"/>
          </a:gradFill>
        </a:bgFillStyleLst>
      </a:fmtScheme>
    </a:themeElements>
  </a:theme>
`)(this.font));
  }
  generateNumberingXML() {
    const numberingXML = libExports.create({ encoding: "UTF-8", standalone: true }, `
        <?xml version="1.0" encoding="UTF-8" standalone="yes"?>

        <w:numbering
        xmlns:w="${namespaces_w}"
        xmlns:ve="${namespaces_ve}"
        xmlns:o="${namespaces_o}"
        xmlns:r="${namespaces_r}"
        xmlns:v="${namespaces_v}"
        xmlns:wp="${namespaces_wp}"
        xmlns:w10="${namespaces_w10}"
        xmlns:wne="${namespaces_wne}">
        </w:numbering>
    `), abstractNumberingFragments = libExports.fragment(), numberingFragments = libExports.fragment();
    return this.numberingObjects.forEach((({ numberingId, type: type2, properties }) => {
      const abstractNumberingFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "abstractNum").att("@w", "abstractNumId", String(numberingId));
      [...Array(8).keys()].forEach(((level) => {
        const levelFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "lvl").att("@w", "ilvl", level).ele("@w", "start").att("@w", "val", "ol" === type2 ? properties.attributes && properties.attributes["data-start"] || 1 : "1").up().ele("@w", "numFmt").att("@w", "val", "ol" === type2 ? this.ListStyleBuilder.getListStyleType(properties.style && properties.style["list-style-type"]) : "bullet").up().ele("@w", "lvlText").att("@w", "val", "ol" === type2 ? this.ListStyleBuilder.getListPrefixSuffix(properties.style, level) : "ï‚·").up().ele("@w", "lvlJc").att("@w", "val", "left").up().ele("@w", "pPr").ele("@w", "tabs").ele("@w", "tab").att("@w", "val", "num").att("@w", "pos", 720 * (level + 1)).up().up().ele("@w", "ind").att("@w", "left", 720 * (level + 1)).att("@w", "hanging", 360).up().up().up();
        "ul" === type2 && levelFragment.last().import(libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "rPr").ele("@w", "rFonts").att("@w", "ascii", "Symbol").att("@w", "hAnsi", "Symbol").att("@w", "hint", "default").up().up()), abstractNumberingFragment.import(levelFragment);
      })), abstractNumberingFragment.up(), abstractNumberingFragments.import(abstractNumberingFragment), numberingFragments.import(libExports.fragment({ namespaceAlias: { w: namespaces_w } }).ele("@w", "num").att("@w", "numId", String(numberingId)).ele("@w", "abstractNumId").att("@w", "val", String(numberingId)).up().up());
    })), numberingXML.root().import(abstractNumberingFragments), numberingXML.root().import(numberingFragments), numberingXML.toString({ prettyPrint: true });
  }
  appendRelationships(xmlFragment, relationships) {
    relationships.forEach((({ relationshipId, type: type2, target: target2, targetMode }) => {
      xmlFragment.import(libExports.fragment({ defaultNamespace: { ele: namespaces_relationship } }).ele("Relationship").att("Id", `rId${relationshipId}`).att("Type", type2).att("Target", target2).att("TargetMode", targetMode).up());
    }));
  }
  generateRelsXML() {
    return this.relationships.map((({ fileName, rels }) => {
      const xmlFragment = libExports.create({ encoding: "UTF-8", standalone: true }, "document" === fileName ? documentRelsXML : '\n    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n\n    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n    </Relationships>\n');
      return this.appendRelationships(xmlFragment.root(), rels), { fileName, xmlString: xmlFragment.toString({ prettyPrint: true }) };
    }));
  }
  createNumbering(type2, properties) {
    return this.lastNumberingId += 1, this.numberingObjects.push({ numberingId: this.lastNumberingId, type: type2, properties }), this.lastNumberingId;
  }
  createFont(fontFamily) {
    const fontTableObject = ((fontFamilyString, fallbackFont) => {
      const fontFamilyElements = fontFamilyString ? fontFamilyString.split(",").map(((fontName) => {
        const trimmedFontName = fontName.trim();
        return removeSimpleOrDoubleQuotes.test(trimmedFontName) ? trimmedFontName.match(removeSimpleOrDoubleQuotes)[2] : trimmedFontName;
      })) : [fallbackFont];
      return { fontName: fontFamilyElements[0], genericFontName: fontFamilyElements[fontFamilyElements.length - 1] };
    })(fontFamily, this.font);
    return this.fontTableObjects.push(fontTableObject), fontTableObject.fontName;
  }
  createMediaFile(base64String) {
    const matches = base64String.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
    if (3 !== matches.length) throw new Error("Invalid base64 string");
    const base64FileContent = matches[2], fileExtension = "octet-stream" === matches[1].match(/\/(.*?)$/)[1] ? "png" : matches[1].match(/\/(.*?)$/)[1], fileNameWithExtension = `image-${nanoid()}.${fileExtension}`;
    return this.lastMediaId += 1, { id: this.lastMediaId, fileContent: base64FileContent, fileNameWithExtension };
  }
  createDocumentRelationships(fileName = "document", type2, target2, targetMode = "External") {
    let relationshipType, relationshipObject = this.relationships.find(((relationship) => relationship.fileName === fileName)), lastRelsId = 1;
    switch (relationshipObject ? (lastRelsId = relationshipObject.lastRelsId + 1, relationshipObject.lastRelsId = lastRelsId) : (relationshipObject = { fileName, lastRelsId, rels: [] }, this.relationships.push(relationshipObject)), type2) {
      case "hyperlink":
        relationshipType = namespaces_hyperlinks;
        break;
      case "image":
        relationshipType = namespaces_images;
        break;
      case "header":
        relationshipType = namespaces_headers;
        break;
      case "footer":
        relationshipType = namespaces_footers;
        break;
      case "theme":
        relationshipType = namespaces_themes;
    }
    return relationshipObject.rels.push({ relationshipId: lastRelsId, type: relationshipType, target: target2, targetMode }), lastRelsId;
  }
  generateHeaderXML(vTree) {
    return this.generateSectionXML(vTree, "header");
  }
  generateFooterXML(vTree) {
    return this.generateSectionXML(vTree, "footer");
  }
}
const convertHTML = HTMLToVDOM({ VNode: vnode, VText: vtext }), normalizeDocumentOptions = (documentOptions) => {
  const normalizedDocumentOptions = { ...documentOptions };
  return Object.keys(documentOptions).forEach(((key) => {
    switch (key) {
      case "pageSize":
      case "margins":
        normalizedDocumentOptions[key] = ((dimensioningObject, defaultDimensionsProperty) => {
          let normalizedUnitResult = {};
          return "object" == typeof dimensioningObject && null !== dimensioningObject ? Object.keys(dimensioningObject).forEach(((key2) => {
            if (pixelRegex.test(dimensioningObject[key2])) {
              const matchedParts = dimensioningObject[key2].match(pixelRegex);
              normalizedUnitResult[key2] = pixelToTWIP(matchedParts[1]);
            } else if (cmRegex.test(dimensioningObject[key2])) {
              const matchedParts = dimensioningObject[key2].match(cmRegex);
              normalizedUnitResult[key2] = cmToTWIP(matchedParts[1]);
            } else if (inchRegex.test(dimensioningObject[key2])) {
              const matchedParts = dimensioningObject[key2].match(inchRegex);
              normalizedUnitResult[key2] = inchToTWIP(matchedParts[1]);
            } else dimensioningObject[key2] ? normalizedUnitResult[key2] = dimensioningObject[key2] : normalizedUnitResult[key2] = defaultDimensionsProperty[key2];
          })) : normalizedUnitResult = null, normalizedUnitResult;
        })(documentOptions[key], defaultDocumentOptions[key]);
        break;
      case "fontSize":
      case "complexScriptFontSize":
        normalizedDocumentOptions[key] = ((fontSize) => {
          let normalizedFontSize;
          if (pointRegex.test(fontSize)) {
            const matchedParts = fontSize.match(pointRegex);
            normalizedFontSize = pointToHIP(matchedParts[1]);
          } else normalizedFontSize = fontSize || null;
          return normalizedFontSize;
        })(documentOptions[key]);
    }
  })), normalizedDocumentOptions;
};
async function addFilesToContainer(zip, htmlString, suppliedDocumentOptions, headerHTMLString, footerHTMLString) {
  const normalizedDocumentOptions = normalizeDocumentOptions(suppliedDocumentOptions), documentOptions = (options = defaultDocumentOptions, patch = normalizedDocumentOptions, { ...options, ...patch });
  var options, patch;
  documentOptions.header && !headerHTMLString && (headerHTMLString = "<p></p>"), documentOptions.footer && !footerHTMLString && (footerHTMLString = "<p></p>"), documentOptions.decodeUnicode && (headerHTMLString = decode(headerHTMLString), htmlString = decode(htmlString), footerHTMLString = decode(footerHTMLString));
  const docxDocument = new DocxDocument({ zip, htmlString, ...documentOptions });
  if (docxDocument.documentXML = await (async function(docxDocumentInstance) {
    const vTree = convertHTML$1(docxDocumentInstance.htmlString), xmlFragment = libExports.fragment({ namespaceAlias: { w: namespaces_w } });
    return await convertVTreeToXML(docxDocumentInstance, vTree, xmlFragment);
  })(docxDocument), zip.folder("_rels").file(".rels", libExports.create({ encoding: "UTF-8", standalone: true }, relsXML).toString({ prettyPrint: true }), { createFolders: false }), zip.folder("docProps").file("core.xml", docxDocument.generateCoreXML(), { createFolders: false }), docxDocument.header && headerHTMLString) {
    const vTree = convertHTML(headerHTMLString);
    docxDocument.relationshipFilename = "header1";
    const { headerId, headerXML } = await docxDocument.generateHeaderXML(vTree);
    docxDocument.relationshipFilename = "document";
    const fileNameWithExt = `header${headerId}.xml`, relationshipId = docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, "header", fileNameWithExt, "Internal");
    zip.folder("word").file(fileNameWithExt, headerXML.toString({ prettyPrint: true }), { createFolders: false }), docxDocument.headerObjects.push({ headerId, relationshipId, type: docxDocument.headerType });
  }
  if (docxDocument.footer && footerHTMLString) {
    const vTree = convertHTML(footerHTMLString);
    docxDocument.relationshipFilename = "footer1";
    const { footerId, footerXML } = await docxDocument.generateFooterXML(vTree);
    docxDocument.relationshipFilename = "document";
    const fileNameWithExt = `footer${footerId}.xml`, relationshipId = docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, "footer", fileNameWithExt, "Internal");
    zip.folder("word").file(fileNameWithExt, footerXML.toString({ prettyPrint: true }), { createFolders: false }), docxDocument.footerObjects.push({ footerId, relationshipId, type: docxDocument.footerType });
  }
  docxDocument.createDocumentRelationships(docxDocument.relationshipFilename, "theme", "theme/theme1.xml", "Internal"), zip.folder("word").folder("theme").file("theme1.xml", docxDocument.generateThemeXML(), { createFolders: false }), zip.folder("word").file("document.xml", docxDocument.generateDocumentXML(), { createFolders: false }).file("fontTable.xml", docxDocument.generateFontTableXML(), { createFolders: false }).file("styles.xml", docxDocument.generateStylesXML(), { createFolders: false }).file("numbering.xml", docxDocument.generateNumberingXML(), { createFolders: false }).file("settings.xml", docxDocument.generateSettingsXML(), { createFolders: false }).file("webSettings.xml", docxDocument.generateWebSettingsXML(), { createFolders: false });
  const relationshipXMLs = docxDocument.generateRelsXML();
  return relationshipXMLs && Array.isArray(relationshipXMLs) && relationshipXMLs.forEach((({ fileName, xmlString }) => {
    zip.folder("word").folder("_rels").file(`${fileName}.xml.rels`, xmlString, { createFolders: false });
  })), zip.file("[Content_Types].xml", docxDocument.generateContentTypesXML(), { createFolders: false }), zip;
}
const minifyHTMLString = (htmlString) => {
  try {
    if ("string" == typeof htmlString || htmlString instanceof String) {
      return htmlString.replace(/\n/g, " ").replace(/\r/g, " ").replace(/\r\n/g, " ").replace(/[\t]+\</g, "<").replace(/\>[\t ]+\</g, "><").replace(/\>[\t ]+$/g, ">");
    }
    throw new Error("invalid html string");
  } catch (error) {
    return null;
  }
};
async function generateContainer(htmlString, headerHTMLString, documentOptions = {}, footerHTMLString) {
  const zip = new JSZip();
  let contentHTML = htmlString, headerHTML = headerHTMLString, footerHTML = footerHTMLString;
  htmlString && (contentHTML = minifyHTMLString(contentHTML)), await addFilesToContainer(zip, contentHTML, documentOptions, headerHTML, footerHTML);
  const buffer = await zip.generateAsync({ type: "arraybuffer" });
  if (Object.prototype.hasOwnProperty.call(global, "Buffer")) return Buffer.from(new Uint8Array(buffer));
  if (Object.prototype.hasOwnProperty.call(global, "Blob")) return new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
  throw new Error("Add blob support using a polyfill eg https://github.com/bjornstar/blob-polyfill");
}
process.env.DIST = path$1.join(__dirname, "../dist");
process.env.VITE_PUBLIC = electron.app.isPackaged ? process.env.DIST : path$1.join(__dirname, "../public");
let win;
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
function createWindow() {
  win = new electron.BrowserWindow({
    icon: path$1.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    backgroundColor: "#0f172a",
    webPreferences: {
      preload: path$1.join(__dirname, "preload.js"),
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: false
    }
  });
  win.webContents.on("did-finish-load", () => {
    win?.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$1.join(process.env.DIST, "index.html"));
  }
}
electron.ipcMain.handle("dialog:openFile", async () => {
  const { canceled, filePaths } = await electron.dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [{ name: "All Files", extensions: ["*"] }]
  });
  if (canceled) return null;
  const filePath = filePaths[0];
  return {
    path: filePath,
    name: path$1.basename(filePath),
    ext: path$1.extname(filePath).toLowerCase().replace(".", "")
  };
});
electron.ipcMain.handle("file:readFile", async (_, filePath) => {
  if (!filePath) return { error: "No path provided" };
  const ext = path$1.extname(filePath).toLowerCase().replace(".", "");
  const imageExts = ["png", "jpg", "jpeg", "webp", "gif", "svg", "bmp", "ico"];
  const textExts = [
    "txt",
    "md",
    "json",
    "js",
    "ts",
    "tsx",
    "jsx",
    "css",
    "html",
    "xml",
    "yaml",
    "yml",
    "ini",
    "env",
    "log",
    "csv",
    "py",
    "java",
    "c",
    "cpp",
    "h",
    "cs",
    "go",
    "rs",
    "php",
    "rb",
    "sh",
    "bat",
    "ps1",
    "sql",
    "gitignore",
    "editorconfig",
    "package",
    "lock"
  ];
  try {
    if (imageExts.includes(ext)) {
      const buffer = await fs$1.readFile(filePath);
      return {
        content: `data:image/${ext === "svg" ? "svg+xml" : ext};base64,${buffer.toString("base64")}`,
        type: "image",
        ext
      };
    }
    if (ext === "pdf") {
      const buffer = await fs$1.readFile(filePath);
      return {
        content: `data:application/pdf;base64,${buffer.toString("base64")}`,
        type: "pdf",
        ext
      };
    }
    if (ext === "docx") {
      const buffer = await fs$1.readFile(filePath);
      const result = await mammoth.convertToHtml({ buffer });
      return {
        content: result.value,
        type: "html",
        ext
      };
    }
    if (textExts.includes(ext) || ext === "") {
      const content = await fs$1.readFile(filePath, "utf-8");
      return { content, type: "text", ext };
    }
    try {
      const stat = await fs$1.stat(filePath);
      if (stat.size < 2 * 1024 * 1024) {
        const raw = await fs$1.readFile(filePath, "utf-8");
        if (raw.includes("\0")) {
          return { content: "Binary content detected.", type: "binary", ext };
        }
        return { content: raw, type: "text", ext };
      }
    } catch {
    }
    return {
      content: "File too large or format not supported.",
      type: "binary",
      ext
    };
  } catch (err) {
    console.error("Read Error:", err);
    return { error: String(err), type: "error", ext };
  }
});
electron.ipcMain.handle("file:saveFile", async (_, { path: filePath, content }) => {
  try {
    const ext = path$1.extname(filePath).toLowerCase().replace(".", "");
    if (ext === "docx") {
      const buffer = await generateContainer(content, null, {
        table: { row: { cantSplit: true } },
        footer: true,
        pageNumber: true
      });
      await fs$1.writeFile(filePath, buffer);
    } else {
      await fs$1.writeFile(filePath, content, "utf-8");
    }
    return { success: true };
  } catch (err) {
    console.error("Save Error:", err);
    return { success: false, error: String(err) };
  }
});
electron.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") electron.app.quit();
});
electron.app.on("activate", () => {
  if (electron.BrowserWindow.getAllWindows().length === 0) createWindow();
});
electron.app.whenReady().then(createWindow);
